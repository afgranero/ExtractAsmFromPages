<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="TRS-80 Revived Site by Ira Goldklang's is an archive of everything related to the Tandy Radio Shack TRS-80 microcomputer lines. Site contains emulators, programs, manuals, books, patches, games, hints, discussions, and tons more.">
	<meta name="author" content="Ira Goldklang">
	<meta name="robots" content="index, follow">
	<link rel="icon" href="https://www.trs-80.com/icon.ico" type="image/x-icon">
	<link rel="canonical" href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm">
	<meta property="og:title" content="TRS-80 Revived Site - Ira Goldklang's TRS-80 Archive">
	<meta property="og:description" content="Complete archive of TRS-80 emulators, programs, manuals, books, and games for Tandy Radio Shack TRS-80 computers.">
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm">
	<meta name="twitter:card" content="summary">
	<meta name="twitter:title" content="TRS-80 Revived Site">
	<meta name="twitter:description" content="Complete archive of TRS-80 emulators, programs, and resources.">
	<title>Model I ROM Explained - Part 2</title>
	<!-- Load your existing CSS file -->
	<link rel="stylesheet" href="Model%20I%20ROM%20Explained%20-%20Part%202_files/trs80-css.css">
	<link rel="stylesheet" href="Model%20I%20ROM%20Explained%20-%20Part%202_files/trs80-hamburger.css">
	<!-- Fancybox CSS -->
	<link rel="stylesheet" href="Model%20I%20ROM%20Explained%20-%20Part%202_files/fancybox.css">
	<!-- Load the component loader -->
	<script src="Model%20I%20ROM%20Explained%20-%20Part%202_files/trs80-loader.js"></script>
	<script src="Model%20I%20ROM%20Explained%20-%20Part%202_files/trs80-hamburger.js"></script>
</head>
<body class="trs80-loaded"><button id="hamburger-btn" class="hamburger-menu" aria-label="Toggle menu">
            <span></span>
            <span></span>
            <span></span>
        </button>
	<div class="site-container">
		<!-- Header will be loaded here -->
		<div id="header"><style>
    .trs80-header-grid {
        display: grid;
        /* 'auto' lets the images take only needed space, '1fr' gives the rest to the text */
        grid-template-columns: auto 1fr auto;
        grid-template-rows: 1fr;
        grid-column-gap: 20px;
        grid-row-gap: 0;
        background-color: #003399;
        margin-top: 10px;
        padding: 10px;
        /* This ensures all items in the grid (images and text) are aligned to the top */
        align-items: start;
    }

    .trs80-header-left { grid-area: 1 / 1 / 2 / 2; display: flex; align-items: start; }
    .trs80-header-center { grid-area: 1 / 2 / 2 / 3; text-align: center; }
    .trs80-header-right { grid-area: 1 / 3 / 2 / 4; display: flex; align-items: start; justify-content: flex-end; }

    .trs80-title { color: white !important; font-size: 170%; text-align: center; margin: 0 0 10px 0; font-weight: bold; }

    .trs80-description {
        color: white !important;
        font-size: 120%;
        text-align: center;
        margin: 0 auto 15px auto;
        padding: 0 10px;
        line-height: 1.4;
    }

    .trs80-header-grid img { border: 0 !important; margin: 0 2px; }
    .trs80-img-60 { width: 60px; }
    .trs80-img-80 { width: 80px; }
    .trs80-img-90 { width: 90px; }
    .trs80-img-100 { width: 100px; }

    /* Search Button Styling */
    .header-search-container {
        margin-bottom: 10px;
    }

    .header-search-link {
        display: inline-block;
        background: #ffcc00; /* Retro TRS-80 Amber */
        color: #003399 !important;
        padding: 6px 15px;
        border-radius: 4px;
        font-weight: bold;
        font-size: 0.9em;
        text-decoration: none;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        transition: transform 0.2s, background 0.2s;
    }

    .header-search-link:hover {
        background: #ffe066;
        transform: scale(1.05);
        text-decoration: none;
    }

    @media screen and (max-width: 768px) {
        .trs80-header-grid {
            grid-template-columns: 1fr;
            grid-template-rows: auto auto auto;
            text-align: center;
            justify-items: center;
        }
        .trs80-header-left { grid-area: 1 / 1 / 2 / 2; justify-content: center; }
        .trs80-header-center { grid-area: 2 / 1 / 3 / 2; }
        .trs80-header-right { grid-area: 3 / 1 / 4 / 2; justify-content: center; }
        .trs80-title { font-size: 130%; }
        .trs80-description { font-size: 100%; text-align: center; }
        .trs80-img-60 { width: 50px; }
        .trs80-img-80 { width: 65px; }
        .trs80-img-90 { width: 75px; }
        .trs80-img-100 { width: 80px; }
    }
</style>

<div class="trs80-header-grid">
    <div class="trs80-header-left">
        <img src="Model%20I%20ROM%20Explained%20-%20Part%202_files/computer-model1-keyboardandscreen-100.png" alt="[Model I]" class="trs80-img-60">
        <img src="Model%20I%20ROM%20Explained%20-%20Part%202_files/computer-model3-rsc05-blur-x100.png" alt="[Model III]" class="trs80-img-60">
        <img src="Model%20I%20ROM%20Explained%20-%20Part%202_files/computer-model4-rsc10-x100.png" alt="[Model 4]" class="trs80-img-90">
    </div>

    <div class="trs80-header-center">
        <p class="trs80-title">Welcome To Ira Goldklang's TRS-80 Revived Site</p>

        <p class="trs80-description">
            TRS-80 Revived Site is an archive of everything related to 
the Tandy Radio Shack TRS-80 home microcomputer lines. Site contains 
emulators, programs, manuals, books, patches, games, hints, discussions,
 and tons more.
        </p>

        <div class="header-search-container">
            <a href="https://www.trs-80.com/main-search-site.htm" class="header-search-link">
                <span class="search-icon">üîç</span> SEARCH THIS SITE
            </a>
        </div>
    </div>

    <div class="trs80-header-right">
        <img src="Model%20I%20ROM%20Explained%20-%20Part%202_files/computer-model-4p-sideways-view-x100.png" alt="[Model 4P]" class="trs80-img-90">
        <img src="Model%20I%20ROM%20Explained%20-%20Part%202_files/computer-model100-ccf836-x100.png" alt="[Model 100]" class="trs80-img-80">
        <img src="Model%20I%20ROM%20Explained%20-%20Part%202_files/computer-pc2-rsc07-x100.png" alt="[Pocket Computer]" class="trs80-img-100">
    </div>
</div>
</div>
		<!-- Content wrapper with sidebar and main content -->
		<div class="content-wrapper">
			<!-- Left Navigation will be loaded here -->
			<aside class="sidebar" id="navbar"><div class="navigationpanelv2">
	<div class="nav-entry-block">
		<h2>FIRST TIME VISITORS</h2>
		<p style="font-size:150%; margin-top:0; text-align:center; color:red;"><a href="https://www.trs-80.com/main-welcome.htm">Visit the WELCOME page</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>Services</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-faq-reading-disks.htm" style="color:red !important;">Do you have TRS-80 Disks?  Send them in for Preservation and Conversion for use in an Emulator</a></li>
			<li><a href="https://www.trs-80.com/main-disketterequest.htm">Request Real DOS Disks</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>General</h2>
		<ul>
			<li><a href="https://www.trs-80.com/index.html">Site News</a></li>
			<li><a href="https://www.trs-80.com/main-introduction-to-emulators.htm">Intro to Emulation</a></li>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-interviews.htm">Interviews</a></span>
				<ul>
					<li><a href="https://americanhistory.si.edu/comphist/gates.htm">Bill Gates</a></li>
					<li><a href="http://www.trs-80.org/interview-bill-hogue/">Bill Hogue</a></li>
					<li><a href="http://www.trs-80.org/interview-dan-gookin/">Dan Gookin</a></li>
					<li><a href="https://www.trs-80.com/sub-interview-don-french.htm">Don French</a></li>
					<li><a href="https://bluebilby.com/dubois-mcnamara/">Dubouis &amp; McNamara</a></li>
					<li><a href="http://www.trs-80.org/interview-j-weaver/">J. Weaver Jr.</a></li>
					<li><a href="http://www.trs-80.org/interview-jack-crenshaw/">Jack Crenshaw</a></li>
					<li><a href="http://www.trs-80.org/interview-jim-stutsman/">Jim Stutsman</a></li>
					<li><a href="http://www.48k.ca/JoshLavinsky.html">Josh Lavinsky</a></li>
					<li><a href="http://www.trs-80.org/interview-kevin-tschudi/">Kevin Tschudi</a></li>
					<li><a href="http://www.trs-80.org/interview-paul-andreasen/">Paul Andreasen</a></li>
					<li><a href="https://www.trs-80.com/sub-interview-steve-leininger.htm">Steven W. Leininger</a></li>
					<li><a href="https://www.trs-80.com/sub-interview-bill-demas.htm">William Demas</a></li>
				</ul>
			</li>
			<li><a href="https://www.trs-80.com/main-shipping.htm">Shipping a TRS-80</a></li>
			<li><a href="https://www.trs-80.com/main-lore.htm">Radio Shack Lore</a></li>
			<li><a href="https://www.trs-80.com/main-fun-stuff.htm">Fun Stuff</a></li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>Help The Site!</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-missing-software.htm">Missing Software</a></li>
			<li><a href="https://www.trs-80.com/main-missing-magazines.htm">Missing Magazines</a></li>
			<li><a href="https://www.trs-80.com/main-faq-reading-disks.htm">Send in Your Disks for Archiving</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Searches</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-search-site.htm">Site-Wide Search</a></li>
			<li><a href="https://www.trs-80.com/main-search-software.htm">Software Search</a></li>
			<li><a href="https://www.trs-80.com/main-search-magazines.htm">Magazine Search</a></li>
			<li><a href="https://www.trs-80.com/main-search-rs-catalogs.htm">Catalog Search</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Emulation and Virtual Media</h2>
		<span>Info and Downloads:</span>
		<ul>
			<li><a href="https://www.trs-80.com/main-emulators.htm">Emulators</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-tape-utilities.htm">Virtual Tape Utilities</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-disk-utilities.htm">Virtual Disk Utilities</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-misc-utilities.htm">Misc TRS-80 Utilities</a></li>
		</ul>
		<span>How To Convert:</span>
		<ul>
			<li><a href="https://www.trs-80.com/main-emulation-conversion-tapes.htm">Tapes to Virtual</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-conversion-disks.htm">Disks to Virtual</a></li>
			<li><a href="https://www.classic-computers.org.nz/system-80/software_esf_archive-imaging.htm">Stringy Floppy to Virtual</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Advanced</h2>
		<span>Internal Operations</span>
		<ul>
			<li>
				<span class="submenu-toggle">ROM/Z-80 Info</span>
				<ul>
					<li><a href="https://www.trs-80.com/main-internal-rom-related.htm#compared">ROMs Compared</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-level-1.htm">Model I Level 1 ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm">Model I Level II ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm">Model III Level II ROM</a></li>
					<li><a href="https://github.com/kiwisincebirth/TRS-80">Model III Level II Compilable Source</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4.htm">Model 4 ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4-xdrom-main.htm">Model 4 XDROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4p.htm">Model 4P Boot ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-network-4.htm">Network 4 ROM</a></li>
					<li><a href="https://www.gatesnotes.com/microsoft-original-source-code">Orig Source Code</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-bugs.htm">Bugs</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-rom-addresses.htm">Memory map and address reference</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-entry-points.htm">Entry Points to routines</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-io-and-misc-routines.htm">I/O and Misc ROM routines</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-math-calls.htm">Math Routines</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-rst-vectors.htm">RST vectors and Disk BASIC entry points</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-z80-info.htm">Reference for Z-80 opcodes and undocumented command</a></li>
				</ul>
			</li>
			<li><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm">RAM Addresses/Routines</a></li>
			<li><a href="https://www.trs-80.com/main-internal-ports-and-i-o.htm">Ports and I/O Devices</a></li>
			<li><a href="https://www.trs-80.com/sub-rom-dcbs.htm">Device Control Blocks (DCB's)</a></li>
			<li><a href="https://www.trs-80.com/main-internal-keyboard-map.htm">Keyboard Map</a></li>
		</ul>

		<span>Disassemblies</span>
		<ul>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-disassemblies.htm">Disassemblies</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-level-1.htm">Level I ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm">Level II ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm">Model III ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-4-durda.htm">Frank Durda Modified C-ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4.htm">Model 4 ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4p.htm">Model 4P Bootstrap ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4-xdrom-main.htm">XDROM - Frank Durda's Model 4 ROM C replacement</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-dos-nd80-m1-main.htm">NEWDOS/80 v2.0</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-dos-td13-main.htm">TRSDOS v1.3</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-dos-td23-main.htm">TRSDOS v2.3</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-network-4.htm">Network 4 Transporter ROM code analysis</a></li>
				</ul>
			</li>
		</ul>

		<span>Zaps/Patches/Fixes</span>
		<ul>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-zaps-and-patches.htm">Zaps and Patches</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/main-zaps-and-patches.htm#dos">DOS</a></li>
					<li><a href="https://www.trs-80.com/sub-zaps-sw-electric-pencil.htm">Electric Pencil</a></li>
					<li><a href="https://www.trs-80.com/sub-zaps-sw-general.htm">Other Software</a></li>
					<li><a href="https://www.trs-80.com/main-zaps-and-patches.htm#software-zaps-and">ZIPs of Patches</a></li>
				</ul>
			</li>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-tips-and-tricks.htm">Tips and Tricks</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/sub-tips-hard-drive.htm">Hard Drive Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-packing.htm">String Packing and USR Routines</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-level2.htm">Level II Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-reference-dos-newdos80-main.htm#tips">NEWDOS/80 Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-dos.htm">Other DOS Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-graphics.htm">TRS-80 Graphics</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-file-formats.htm">Tape and File Formats/Structures</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-easter-eggs.htm">Bugs and Easter Eggs</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-misc.htm">Misc Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-model-3.htm">Model III Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-model-4.htm">Model 4 Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-model-4p.htm">Model 4P Tips and Tricks</a></li>
				</ul>
			</li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>TRS-80 Models</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-models.htm">Timeline</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model1.htm">Model I</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model2.htm">Model II</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model3.htm">Model III</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model4.htm">Model 4/4P/4D</a></li>
			<li><a href="https://www.trs-80.com/sub-models-coco.htm">Color (Coco 1-3, MC-10)</a></li>
			<li><a href="https://www.trs-80.com/sub-models-laptops.htm">Laptops (100/200/600)</a></li>
			<li><a href="https://www.trs-80.com/sub-models-pocket.htm">Pocket (PC-1 to PC-8)</a></li>
			<li><a href="https://www.trs-80.com/sub-models-clones.htm">Clones</a></li>
			<li><a href="https://www.trs-80.com/sub-models-printers.htm">Printers</a></li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>Reference</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-reference-dos-trsdos-main.htm">TRSDOS</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-dos-dosplus.htm">DOSPlus</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-dos-newdos80-main.htm">NEWDOS/80</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-multidos.htm">MULTIDOS</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-dos-cpm.htm">CP/M</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-level-2-basic.htm">Level II BASIC Ref</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Detailed Products</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-details-orchestra.htm">ORCH-80/85/90</a></li>
			<li><a href="https://www.trs-80.com/sub-details-speed-up-boards.htm">Speed-Up Boards</a></li>
			<li><a href="https://www.trs-80.com/sub-details-scott-adams.htm">Scott Adams Adventures</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Tandy Publications</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-rs-csbs.htm">Customer Service Bulletins</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-memos.htm">Memos / Bulletins / Releases</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-cc-answers.htm">Comp Center Answers</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-catalogs.htm">Catalogs</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-comics.htm">Comic Books</a></li>
		</ul>
		<span>Microcomputer News</span>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-rs-micronewsletter-usa.htm">USA Edition</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-micronewsletter-aus.htm">Australian Edition</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-micronewsletter-other.htm">Other Editions</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Publications</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-books.htm">Books</a></li>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-magazine-main-menu.htm">Magazines (Non-Tandy)</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/sub-mag-80micro-main.htm">80 Microcomputing</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-80-notebook.htm">80 Notebook</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-80us-detail.htm">80 U.S. Journal</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-alternatesource-detail.htm">The Alternate Source</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-baron.htm">Baron's Microcomputing</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-cie.htm">C.I.E.</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-cload.htm">CLOAD</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-codeworks.htm">CodeWorks</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-computernews80.htm">Computer News 80</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-computer-user.htm">Computer User</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-creative.htm">Creative Computing</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-hecomputronics-detail.htm">H&amp;E Computronics</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-lsi-journal.htm">LDOS / LSI</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-micro80.htm">Micro-80</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-misosys-notes.htm">Misosys Notes</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-misosys-quarterly.htm">Misosys Quarterly</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-softside-detail.htm">Softside</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-the8ighty.htm">The 8ighty</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-trace.htm">Trace</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-trs8bit.htm">TRS8Bit</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-trstimes.htm">TRSTimes</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-other.htm">Other Magazines</a></li>
				</ul>
			</li>
			<li><a href="https://www.trs-80.com/sub-publications-manuals-software-1.htm">Software Manuals</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-user-groups-1.htm">User's Group Newsletters</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-catalogs.htm">Catalogs (Non-Tandy)</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-flyers.htm">Product Flyers</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-company-news.htm">Company Newsletters</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>This Section for TRS-80 Hardware Owners</h2>
		<span>TRS-80 Upgrades/Parts:</span>
		<ul>
			<li><a href="https://www.trs-80.com/main-upgrades.htm">Upgrades and Parts</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-parts-thingverse.htm">Schematics/3-D Printable Parts</a></li>
		</ul>
		<span>TRS-80 Repairs:</span>
		<ul>
			<li class="navbumpv2"><a href="https://www.trs-80.com/main-repairs.htm">Main Repair Page</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-repair-people.htm">Repair People</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-how-to-open.htm">Opening a TRS-80</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-eprom.htm">Using an EPROM</a></li>
		</ul>
		<span>Hardware Mods and Hacks:</span>
		<ul>
			<li><a href="https://www.trs-80.com/sub-tips-modifications-model-1.htm">Model I</a></li>
			<li><a href="https://www.trs-80.com/sub-tips-modifications-model-3.htm">Model III</a></li>
			<li><a href="https://www.trs-80.com/sub-tips-modifications-model-4.htm">Model 4</a></li>
		</ul>
		<span>Other Items ...</span>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-manuals-hardware-1.htm">Hardware Manuals</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-manuals-service.htm">Service Manuals</a></li>
			<li><a href="https://voidstar.blog/tandy-radio-shack-computer-cassette-recorder-trs-ccr-usage/">Using a Computer / Tablet / Smartphone for Cassette I/O</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Misc</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-emailme.htm">Send Me Email</a></li>
			<li><a href="https://www.trs-80.com/main-old-news.htm">Archived News and Guestbook</a></li>
			<li><a href="https://www.trs-80.com/main-personalstories.htm">Personal Stories Submitted</a></li>
			<li><a href="https://www.trs-80.com/main-emaillinks.htm">Email and other TRS-80 Sites</a></li>
			<li><a href="https://www.trs-80.com/main-copyrights.htm">Copyrights</a></li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>
</div></aside>
			<!-- Main Content -->
			<main class="main-content">
				<div class="main-page-container" id="top">
					<h1>Model I ROM Explained - Part 2</h1>
					<div class="section-wrapper">
						<h2 id="page-customization">Page Customization<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
						<div class="section-content">
							<div class="toggle-container">
								<label class="toggle-label">
									<input type="checkbox" id="OpCodeToggle">
									Display OPCodes
								</label>
							</div>
							<div class="toggle-container">
								<label class="toggle-label">
									<input type="checkbox" id="LabelsToggle" checked="checked">
									Display Labels
								</label>
							</div>
						</div>
					</div>

					<div class="section-wrapper">
						<h2 id="pagenav">Disassembly Navigation<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
						<div class="section-content">
							<div class="top-menu-shorter">
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0000H">0000</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0100H">0100</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0200H">0200</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0300H">0300</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0400H">0400</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0500H">0500</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0600H">0600</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0700H">0700</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0800H">0800</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0900H">0900</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A00H">0A00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0B00H">0B00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0C00H">0C00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0D00H">0D00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0E00H">0E00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0F00H">0F00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1000H">1000</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1100H">1100</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1200H">1200</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1300H">1300</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1400H">1400</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1500H">1500</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1600H">1600</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1608H">Reserved Words</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#18C9H">Error Messages</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1900H">1900</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1A00H">1A00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1B00H">1B00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C00H">1C00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D00H">1D00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E00H">1E00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1F00H">1F00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2000H">2000</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2100H">2100</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2200H">2200</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2300H">2300</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2400H">2400</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2500H">2500</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2600H">2600</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2700H">2700</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2800H">2800</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2900H">2900</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2A00H">2A00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2B00H">2B00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2C00H">2C00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2D00H">2D00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2E00H">2E00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2F00H">2F00</a>
							</div>
						</div>
					</div>

					<div class="section-wrapper">
						<h2 id="continuing">... continuing<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
						<div class="section-content">
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1000H"><div>1001-1002</div><div><a href="#100AH" class="memory-link">JR Z,100AH<span class="origrom2">JR Z,FOTZS1</span></a><span class="opcode2">28 07</span></div><div>If we do NOT need to do an asterisk fill in the ASCII string, JUMP to FOTZS1.</div></div>
									<div class="assembly-row-combined"><div>1003</div><div>LD A,B<span class="opcode2">78</span></div><div>If
 we're here, then we do need to do the asterisk fill, so first lets see 
what the sign was.  Load Register A with the character at the location 
of the input buffer pointer in Register B</div></div>
									<div class="assembly-row-combined"><div>1004</div><div>CP C<span class="opcode2">B9</span></div><div>Check to see if the character at the location of the input buffer pointer in Register A is a <span class="code">SPACE</span>.  The Z FLAG will be set if it was a <span class="code">SPACE</span></div></div>
									<div class="assembly-row-combined"><div>1005-1006</div><div>LD C,2AH<span class="origrom2">LD C,"*"</span><span class="opcode2">0E 2A</span></div><div>Load Register C with a the fill character, which, in this case, will be a <span class="code">*</span></div></div>
									<div class="assembly-row-combined"><div>1007-1008</div><div><a href="#100AH" class="memory-link">JR NZ,100AH<span class="origrom2">JR NZ,FOTZS1</span></a><span class="opcode2">20 01</span></div><div>If the character at the location of the input buffer pointer in Register A isn't <span class="code">SPACE</span> then JUMP to FOTS1 to change the <span class="code">SPACE</span> where the sign would be into a <span class="code">*</span>.</div></div>
									<div class="assembly-row-combined" id="1009H"><div>1009</div><div>LD B,C<span class="opcode2">41</span></div><div>Load Register B with the <span class="code">*</span> character in Register C</div></div>
									<div class="assembly-row-combined" id="100AH"><div>100A<span class="origrom2">FOTZS1</span></div><div>LD (HL),C<span class="opcode2">71</span></div><div>Fill
 the zero or the sign with the filler character held in Register C at 
the location of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>100B</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H">RST 10H<span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character from the buffer.  Using CHRGET is, however, a RAM saving method since there is no <span class="code">SPACE</span> to skip, so the RST 10H really just does INC HL and LD A,(HL)</div></div>
									<div class="assembly-row-combined"><div>100C-100D</div><div><a href="#1022H" class="memory-link">JR Z,1022H<span class="origrom2">JR Z,FOTZS4</span></a><span class="opcode2">28 14</span></div><div>If
 the character at the location of the input buffer pointer in Register 
Pair HL is the end of the input buffer character (00H) then we are done 
with the number.  In this casse, we need to back up and put in a ZERO, 
so JUMP to FOTZS4.  CHRGET would have set the ZERO FLAG on any 00H or <span class="code">:</span>, but there are no <span class="code">:</span> going to be found.  </div></div>
									<div class="assembly-row-combined"><div>100E-100F</div><div>CP 45H<span class="origrom2">CP "E"</span><span class="opcode2">FE 45</span></div><div>Check to see if the character at the location of the input buffer pointer in Register A is an <span class="code">E</span></div></div>
									<div class="assembly-row-combined"><div>1010-1011</div><div><a href="#1022H" class="memory-link">JR Z,1022H<span class="origrom2">JR Z,FOTZS4</span></a><span class="opcode2">28 10</span></div><div>If the character is an <span class="code">E</span> we need to put a <span class="code">0</span> in the floating point nontation with the C format 0, so JUMP to FOTZS4 to put into that ZERO.</div></div>
									<div class="assembly-row-combined"><div>1012-1013</div><div>CP 44H<span class="origrom2">CP "D"</span><span class="opcode2">FE 44</span></div><div>Check to see if the character at the location of the input buffer pointer in Register A is a <span class="code">D</span></div></div>
									<div class="assembly-row-combined"><div>1014-1015</div><div><a href="#1022H" class="memory-link">JR Z,1022H<span class="origrom2">JR Z,FOTZS4</span></a><span class="opcode2">28 0C</span></div><div>If the character is an <span class="code">D</span> we need to put a <span class="code">0</span> in the floating point nontation with the C format 0, so JUMP to FOTZS4 to put into that ZERO.</div></div>
									<div class="assembly-row-combined"><div>1016-1017</div><div>CP 30H<span class="origrom2">CP "0"</span><span class="opcode2">FE 30</span></div><div>Check to see if the character at the location of the input buffer pointer in Register A is a <span class="code">0</span></div></div>
									<div class="assembly-row-combined"><div>1018-1019</div><div><a href="#100AH" class="memory-link">JR Z,100AH<span class="origrom2">JR Z,FOTZS1</span></a><span class="opcode2">28 F0</span></div><div>If the character is a <span class="code">0</span> then we need to suppress it, so JUMP to FOTZS1.</div></div>
									<div class="assembly-row-combined"><div>101A-101B</div><div>CP 2CH<span class="origrom2">CP ","</span><span class="opcode2">FE 2C</span></div><div>Check to see if the character at the location of the input buffer pointer in Register A is a <span class="code">,</span></div></div>
									<div class="assembly-row-combined"><div>101C-101D</div><div><a href="#100AH" class="memory-link">JR Z,100AH<span class="origrom2">JR Z,FOTZS1</span></a><span class="opcode2">28 EC</span></div><div>If the character is a <span class="code">,</span> then we need to suppress it, so JUMP to FOTZS1.</div></div>
									<div class="assembly-row-combined"><div>101E-101F</div><div>CP 2EH<span class="origrom2">CP "."</span><span class="opcode2">FE 2E</span></div><div>Check to see if the character at the location of the input buffer pointer in Register A is a <span class="code">.</span></div></div>
									<div class="assembly-row-combined"><div>1020-1021</div><div><a href="#1025H" class="memory-link">JR NZ,1025H<span class="origrom2">JR NZ,FOTZS2</span></a><span class="opcode2">20 03</span></div><div>If we do not have a <span class="code">.</span>, then JUMP to FOTZS2</div></div>
									<div class="assembly-row-combined" id="1022H"><div>1022<span class="origrom2">FOTZS4</span></div><div>DEC HL<span class="opcode2">2B</span></div><div>If we are here then we need to back up the string and put a <span class="code">0</span> before it.  First, step back one location in the string</div></div>
									<div class="assembly-row-combined"><div>1023-1024</div><div>LD (HL),30H<span class="origrom2">LD (HL),"0"</span><span class="opcode2">36 30</span></div><div>Save a <span class="code">0</span> at the location of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined" id="1025H"><div>1025<span class="origrom2">FOTZS2</span></div><div>LD A,E<span class="opcode2">7B</span></div><div>Next we need to check to see if we need a floating dollar sign.  First, load the format specs into Register A</div></div>
									<div class="assembly-row-combined"><div>1026-1027</div><div>AND 10H<span class="origrom2">AND 0001 0000</span><span class="opcode2">E6 10</span></div><div>Check to see if a <span class="code">$</span> is to be included in the ASCII string</div></div>
									<div class="assembly-row-combined"><div>1028-1029</div><div><a href="#102DH" class="memory-link">JR Z,102DH<span class="origrom2">JR Z,FOTZS3</span></a><span class="opcode2">28 03</span></div><div>If the Z FLAG is set, then we don't have a dollar sign, so skip the next 2 instructions (which puts in a <span class="code">$</span>) if a <span class="code">$</span> isn't to be included in the ASCII string</div></div>
									<div class="assembly-row-combined"><div>102A</div><div>DEC HL<span class="opcode2">2B</span></div><div>Need to add a <span class="code">$</span>, so first we decrement the value of the input buffer pointer in Register Pair HL ...</div></div>
									<div class="assembly-row-combined"><div>102B-102C</div><div>LD (HL),24H<span class="origrom2">LD (HL),"$"</span><span class="opcode2">36 24</span></div><div>... and then put a <span class="code">$</span> there</div></div>
									<div class="assembly-row-combined" id="102DH"><div>102D<span class="origrom2">FOTZS3</span></div><div>LD A,E<span class="opcode2">7B</span></div><div>Next we need to check to see if we need a trailing sign.  First, load the format specs into Register A</div></div>
									<div class="assembly-row-combined"><div>102E-102F</div><div>AND 04H<span class="origrom2">AND 0000 0100</span><span class="opcode2">E6 04</span></div><div>Turn
 off every bit except Bit 2 (by ANDing against 00000100).  If Bit 2 was 
on, then NZ will be set.  If Bit 2 was off, then Z will be set.  So this
 checks to see if the sign is to follow the ASCII string</div></div>
									<div class="assembly-row-combined"><div>1030</div><div>RET NZ<span class="opcode2">C0</span></div><div>If the sign isn't to follow the ASCII string, then we are done so RETurn</div></div>
									<div class="assembly-row-combined"><div>1031</div><div>DEC HL<span class="opcode2">2B</span></div><div>Decrement the value of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1032</div><div>LD (HL),B<span class="opcode2">70</span></div><div>Save the sign (in Register B) to the location of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1033</div><div>RET<span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1034H">1034 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUINI"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Initially set up the format specs and put in a <span class="code">SPACE</span>
 for the sign of a positive number.  This routine gets called by the 
FLOATING to ASCII Conversion Routine (at 0FBEH) and by the BINARY to 
ASCII Conversion Routine (at 0FAFH)</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1034H"><div>1034-1036<span class="origrom2">FOUINI</span></div><div>LD (40D8H),A<span class="origrom2">LD (TEMP3),A</span><span class="opcode2">32 D8 40</span></div><div>Save the format specification (in Register A) to 40D8H.<br>Note: 40D8H-40D9H holds the temporary storage location</div></div>
									<div class="assembly-row-combined"><div>1037-1039</div><div>LD HL,4130H<span class="origrom2">LD HL,FBUFFR+1</span><span class="opcode2">21 30 41</span></div><div>Set
 up a pointer into FBUFFR, starting at FBUFFR+1 just in case the number 
will overflow its field, in which case there is still room in FBUFFR for
 the <span class="code">%</span> character.</div></div>
									<div class="assembly-row-combined"><div>103A-103B</div><div>LD (HL)," "<span class="opcode2">36 20</span></div><div>Save a <span class="code">SPACE</span> at the location of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>103C</div><div>RET<span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="103DH">103D - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUFRV"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine gets called by the FLOATING to ASCII Conversion 
Routine (0FBEH-0FC0H) if the value being converted is either Single 
Precision or Double Precision.  This will print a single or double 
precision number in free format</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="103DH"><div>103D-103E<span class="origrom2">FOUFRV</span></div><div>CP 05H<span class="opcode2">FE 05</span></div><div>Company
 Register A against 05H and if A &lt; 05H, set the C FLAG.  With this, 
the CARRY FLAG will be set if we are dealing with a double precision 
number.</div></div>
									<div class="assembly-row-combined"><div>103F</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the pointer to the buffer (held in Register Pair HL) to the STACK</div></div>
									<p class="debug-note">OK, this is fun.  The next instructions 
are supposed to set Register D to be the counter for the number of 
digits to display.  There is no agreement on what the next two 
instructions do:<br><br> "Microsoft BASIC Decoded &amp; Other Mysteries"
 says it turns 04 (SP) and 08 (SP) into 08 (SP) and 10 (DP) into 09 (SP)
 and 0B (DP)<br><br> "Model III ROM Commented" says it turns D into 07 (SP) and 17 (DP)<br><br> The original ROM Source Code comment says it turns D into 04 to 06 (SP) and 10 to 20 (DP)</p>
									<div class="assembly-row-combined"><div>1040-1041</div><div>SBC A,00H<span class="opcode2">DE 00</span></div><div>Adjust the value of the number type in Register A.  It will be 04H if SINGLE PRECISION and it will be 08H if DOUBLE precision</div></div>
									<div class="assembly-row-combined"><div>1042</div><div>RLA<span class="opcode2">17</span></div><div>Multiply the value of the number type in Register A by two, so now A will be 08H if SINGLE precision and 0AH if DOUBLE precision</div></div>
									<div class="assembly-row-combined"><div>1043</div><div>LD D,A<span class="opcode2">57</span></div><div>Load Register D with the adjusted value of the number type in Register A</div></div>
									<div class="assembly-row-combined"><div>1044</div><div>INC D<span class="opcode2">14</span></div><div>Bump the value of the number type in Register D (so D will be 09H if SINGLE precision and 0BH if DOUBLE precision)</div></div>
									<div class="assembly-row-combined"><div>1045-1047</div><div><a href="#1201H" class="memory-link">CALL 1201H<span class="origrom2">CALL FOUTNV</span></a><span class="opcode2">CD 01 12</span></div><div>Go
 scale (normalize) the current value in ACCumulator so that all the 
significant digits will be in the integer portion (i.e., 99,999 &lt;= X 
&lt;= 999,999).  Returns wihth A being the number of times the DOUBLE 
precision value was scaled up or down</div></div>
									<div class="assembly-row-combined"><div>1048-104A</div><div>LD BC,0300H<span class="opcode2">01 00 03</span></div><div>Load
 Register B to be the decimal point count of 3 (as we will assume it 
will come in E Notation), and Register C to be the comma count 
(currently 0).</div></div>
									<div class="assembly-row-combined"><div>104B</div><div>ADD A,D<span class="opcode2">82</span></div><div>Test to see if we are going to actually need E Notation by first adding the value in Register D to the value in Register A</div></div>
									<div class="assembly-row-combined"><div>104C-104E</div><div><a href="#1057H" class="memory-link">JP M,1057H<span class="origrom2">JP M,FOFRS1</span></a><span class="opcode2">FA 57 10</span></div><div>If D is less than .01 then we will need E Notation, so JUMP to FOFRS1</div></div>
									<div class="assembly-row-combined"><div>104F</div><div>INC D<span class="opcode2">14</span></div><div>Now we need to see if the number is too big.  Bump the value in Register D</div></div>
									<div class="assembly-row-combined"><div>1050</div><div>CP D<span class="opcode2">BA</span></div><div>Compare the bumped Register D to Register A</div></div>
									<div class="assembly-row-combined"><div>1051-1052</div><div><a href="#1057H" class="memory-link">JR NC,1057H<span class="origrom2">JR NC,FOFRS1</span></a><span class="opcode2">30 04</span></div><div>If the number is too big (i.e., greater than 10^D-1), JUMP to FOFRS1 </div></div>
									<div class="assembly-row-combined"><div>1053</div><div>INC A<span class="opcode2">3C</span></div><div>If
 we are here, then we are able to display the number in fixed point 
notation, so we must bump the number of decimal point count</div></div>
									<div class="assembly-row-combined"><div>1054</div><div>LD B,A<span class="opcode2">47</span></div><div>Load Register B with the decimal point count (stored in Register A)</div></div>
									<div class="assembly-row-combined"><div>1055-1056</div><div>LD A,02H<span class="opcode2">3E 02</span></div><div>Set
 up for fixed point output.  Fixed point notation has no exponent, so 
loading Register A with a two so that the next instruction will turn A 
(which is tracking the exponent) to 0. </div></div>
									<div class="assembly-row-combined" id="1057H"><div>1057-1058<span class="origrom2">FOFRS1</span></div><div>SUB A,02H<span class="opcode2">D6 02</span></div><div>Compute the exponent value (which will be a zero if we were passing through), so now D-2 will be added to it</div></div>
									<div class="assembly-row-combined"><div>1059</div><div>POP HL<span class="opcode2">E1</span></div><div>Get the pointer to the string buffer from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>105A</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the exponent value (currently in Register A) to the STACK</div></div>
									<div class="assembly-row-combined"><div>105B-105D</div><div><a href="#1291H" class="memory-link">CALL 1291H<span class="origrom2">CALL FOUTED</span></a><span class="opcode2">CD 91 12</span></div><div>GOSUB
 to FOUTED to test to see if the number is .01 &lt; number &lt; .1 for 
purposes of putting a comma or decimal point in the input buffer if 
necessary</div></div>
									<div class="assembly-row-combined"><div>105E-105F</div><div>LD (HL),30H<span class="origrom2">LD (HL),"0"</span><span class="opcode2">36 30</span></div><div>If the number is within that range, then add a <span class="code">0</span> at the location of the buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1060-1062</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09C9H">CALL Z,09C9H<span class="origrom2">CALL Z,INXHRT</span></a><span class="opcode2">CC C9 09</span></div><div>If there was no scaling, GOSUB to 09C9H to bump HL and return</div></div>
									<div class="assembly-row-combined"><div>1063-1065</div><div><a href="#12A4H" class="memory-link">CALL 12A4H<span class="origrom2">CALL FOUTCV</span></a><span class="opcode2">CD A4 12</span></div><div>Next
 we need to convert the number to decimal digits by a GOSUB to FOUTCV 
which will convert the binary value in ACCumulator to ASCII, the result 
being stored in the input buffer pointer</div></div>
									<p class="debug-note">The FOFRS2 routine will suppress trailing zeroes.</p>
									<div class="assembly-row-combined" id="1066H"><div>1066<span class="origrom2">FOFRS2</span></div><div>DEC HL<span class="opcode2">2B</span></div><div>Backspace to the last character by decrementing the value of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1067</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Fetch the last character (at the location of the input buffer pointer in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>1068-1069</div><div>CP 30H<span class="origrom2">CP "0"</span><span class="opcode2">FE 30</span></div><div>Check to see if the value in Register A is a <span class="code">0</span></div></div>
									<div class="assembly-row-combined"><div>106A-106B</div><div><a href="#1066H" class="memory-link">JR Z,1066H<span class="origrom2">JR Z,FOFRS2</span></a><span class="opcode2">28 FA</span></div><div>If it is a zero, then we want to suppress it, so loop back to FOFRS2 to decrement again and keep suppressing ending zeroes.</div></div>
									<p class="debug-note">At this point, all trailing zeroes are now gone and HL points to the last non-zero character.</p>
									<div class="assembly-row-combined"><div>106C-106D</div><div>CP 2EH<span class="origrom2">CP "."</span><span class="opcode2">FE 2E</span></div><div>Check to see if the last character in the buffer (now that all ending zeroes have been supressed) is is a <span class="code">.</span></div></div>
									<div class="assembly-row-combined"><div>106E-1070</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09C9H">CALL NZ,09C9H<span class="origrom2">CALL NZ,INXHRT</span></a><span class="opcode2">C4 C9 09</span></div><div>If
 its NOT a decimal point, GOSUB to bump the value of the input buffer 
pointer in Register Pair HL.  Otherwise, HL is now sitting at the 
decimal point to suppress that character too.</div></div>
									<div class="assembly-row-combined"><div>1071</div><div>POP AF<span class="opcode2">F1</span></div><div>Restore the exponent from the STACK into Register A</div></div>
									<div class="assembly-row-combined"><div>1072-10731</div><div><a href="#1093H" class="memory-link">JR Z,1093H<span class="origrom2">JR Z,FOUTDN</span></a><span class="opcode2">28 1F</span></div><div>If the exponent is zero then we are done, so jump to 1093H.  Otherwise, pass down to FOFLDN.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1074H">1074 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOFLDN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will put the exponent and a <span class="code">D</span> or <span class="code">E</span> into the buffer.  On entry, Register A holds the exponent and it is assumed that all FLAGs are set correctly.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1074<span class="origrom2">FOFLDN</span></div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the exponent (stored in A) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1075</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H">RST 20H<span class="origrom2">GETYPE</span></a><span class="opcode2">E7</span></div><div>Determine
 the precision by checking the value of the current number type flag.  
In this case, this is a really cool trick.  The purpose is to load a bit
 into the CARRY flag if we are going to display an <span class="code">E</span>
 instead of a D.  We start off with 1/2 of the ascii value for the "D", 
then, in 1 instruction, multiply it by 2 and add in the carry bit.  So 
if the CARRY FLAG is off, then it is a "D" and if the CARRY FLAG is on, 
then it is an "E"</div></div>
									<div class="assembly-row-combined"><div>1076-1077</div><div>LD A,22H<span class="opcode2">3E 22</span></div><div>Load Register A with the starting value for a D or E character.  In this case, A is set for 1/2 of the ASCII code for <span class="code">D</span></div></div>
									<div class="assembly-row-combined"><div>1078</div><div>ADC A,A<span class="opcode2">8F</span></div><div>Multiply
 the value of the character in Register A by two and add in the value of
 the Carry flag from the number type flag test.  This will result with A
 it being a <span class="code">D</span> if the value is SINGLE precision and an <span class="code">E</span> if the value is DOUBLE precision</div></div>
									<div class="assembly-row-combined"><div>1079</div><div>LD (HL),A<span class="opcode2">77</span></div><div>Save the exponent designation (the <span class="code">D</span> or <span class="code">E</span> in Register A) at the location of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>107A</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the buffer pointer in Register Pair HL, which is the first position of the exponent in the buffer</div></div>
									<div class="assembly-row-combined"><div>107B</div><div>POP AF<span class="opcode2">F1</span></div><div>Get the value of the exponent from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>107C-107D</div><div>LD (HL),2BH<span class="origrom2">LD (HL),"+"</span><span class="opcode2">36 2B</span></div><div>Save a <span class="code">+</span>
 at the location of the input buffer pointer in Register Pair HL.  This 
is done to save bytes.  Instead of testing for + or - and then putting 
in the appropriate character, a <span class="code">+</span> is put in, and then it is overwritten if a <span class="code">-</span> should be there.</div></div>
									<div class="assembly-row-combined"><div>107E-1080</div><div><a href="#1085H" class="memory-link">JP P,1085H<span class="origrom2">JP P,FOUCE1</span></a><span class="opcode2">F2 85 10</span></div><div>If the exponent is positive, then the <span class="code">+</span>
 we just put into the buffer (and HL is still pointing to that location)
 is good, so skip the next 3 instructions (by jumping to 1085H) if the 
exponent is positive</div></div>
									<div class="assembly-row-combined"><div>1081-1082</div><div>LD (HL),2DH<span class="origrom2">LD (HL),"-"</span><span class="opcode2">36 2D</span></div><div>Save a <span class="code">-</span> (which is 2DH) at the location of the input buffer pointer in Register Pair HL, thus overwriting the initially placed <span class="code">+</span> in that same location</div></div>
									<div class="assembly-row-combined"><div>1083</div><div>CPL<span class="opcode2">2F</span></div><div>If
 we are here then we have a negative exponent (or we would have jumped 
to 1085H back in 107EH), so convert the negative exponent to positive by
 reversing the value of the exponent in Register A</div></div>
									<div class="assembly-row-combined"><div>1084</div><div>INC A<span class="opcode2">3C</span></div><div>We
 also need to bump the value of the exponent in Register A by 1 when 
switching from negative to positive.  We then pass through and rejoin 
where we would have jumped if the number had been positive.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1085H">1085 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUCE1" and "FOUCE2"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will calculate the two digit exponent.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1085-1086<span class="origrom2">FOUCE1</span></div><div>LD B,2FH<span class="origrom2">LD B,"0"-1</span><span class="opcode2">06 2F</span></div><div>At this point, the exponent is positive.  Next step is to load Register B with a <span class="code">0</span> minus one.  This is because the next instruction, which is the top of a loop, bumps it by one.</div></div>
									<div class="assembly-row-combined" id="1087H"><div>1087<span class="origrom2">FOUCE2</span></div><div>INC B<span class="opcode2">04</span></div><div>Top
 of a loop.  Bump the value of the ASCII character in Register B.  This 
is the start of a 3 Opcode routine to divide by 10 using compound 
subtraction</div></div>
									<div class="assembly-row-combined"><div>1088-1089</div><div>SUB A,0AH<span class="opcode2">D6 0A</span></div><div>Subtract ten from the value of the exponent in Register A</div></div>
									<div class="assembly-row-combined"><div>108A-108B</div><div><a href="#1087H" class="memory-link">JR NC,1087H<span class="origrom2">JR NC,FOUCE2</span></a><span class="opcode2">30 FB</span></div><div>Loop
 until the value of the exponent in Register A is less than ten.  B 
holds the quotient (e.g., the number of times the subtraction had to 
occur to get to a remainder less than 10)</div></div>
									<div class="assembly-row-combined"><div>108C-108D</div><div>ADD A,3AH<span class="opcode2">C6 3A</span></div><div>Since A is holding the remainder of the 'divide-by-10' routine above, add 3AH to it so that it will be an ASCII digit + 10</div></div>
									<div class="assembly-row-combined"><div>108E</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>108F</div><div>LD (HL),B<span class="opcode2">70</span></div><div>Save
 the ASCII character in Register B (which is the first digit of the 
exponent in ASCII - the 10's digit) at the location of the input buffer 
pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1090</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1091</div><div>LD (HL),A<span class="opcode2">77</span></div><div>Save
 the value of the ASCII character in Register A (which is the second 
digit of the exponent in ASCII - the 1's digit) at the location of the 
input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined" id="1092H"><div>1092<span class="origrom2">FOUTZR</span></div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the buffer pointer in Register Pair HL</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1093H">1093 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUTDN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will print a free format zero.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1093-1094<span class="origrom2">FOUTDN</span></div><div>LD (HL),00H<span class="opcode2">36 00</span></div><div>Save an end of the ASCII string character (designated as 00H) at the location of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1095</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Since the FFXFLV routine will need the buffer pointer in DE instead of HL, swap those registers</div></div>
									<div class="assembly-row-combined"><div>1096-1098</div><div>LD HL,4130H<span class="origrom2">LD HL,FBUFFR+1</span><span class="opcode2">21 30 41</span></div><div>Load Register Pair HL with the starting address of the buffer pointer.<br>Note: 4130H-4149H holds an internal print buffer</div></div>
									<div class="assembly-row-combined"><div>1099</div><div>RET<span class="opcode2">C9</span></div><div>DONE!  RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="109AH">109A- LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUTFX"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will print a number in fixed format.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>109A<span class="origrom2">FOUTFX</span></div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>109B</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the field length specifiers (B has the number of <span class="code">#</span>'s before the current vale of the input buffer pointer and C has the number of #'s after) to the STACK</div></div>
									<div class="assembly-row-combined"><div>109C-109D</div><div>CP 04H<span class="opcode2">FE 04</span></div><div>Check to see if the current number type in ACCumulator is single or double precision </div></div>
									<div class="assembly-row-combined"><div>109E</div><div>LD A,D<span class="opcode2">7A</span></div><div>Load Register A with the format specifiers (held in Register D)</div></div>
									<div class="assembly-row-combined"><div>109F-10A1</div><div><a href="#1109H" class="memory-link">JP NC,1109H<span class="origrom2">P NC,FOUFXV</span></a><span class="opcode2">D2 09 11</span></div><div>If
 the current value in ACCumulator is either single precision or double 
precision then JUMP away to FOUFXV.  If its an integer we will pass 
through.</div></div>
									<div class="assembly-row-combined"><div>10A2</div><div>RRA<span class="opcode2">1F</span></div><div>Rotate
 Register A so that we can check to see if this has to be printed in 
floating format or not.  RRA rotates Register A right one bit, with Bit 0
 going to CARRY and CARRY going to Bit 7.</div></div>
									<div class="assembly-row-combined"><div>10A3-10A5</div><div><a href="#11A3H" class="memory-link">JP C,11A3H<span class="origrom2">JP C,FFXIFL</span></a><span class="opcode2">DA A3 11</span></div><div>If we need to print it in floating point (exponential) notation, JUMP TO FFXIFL.</div></div>
									<p class="debug-note">If we are here then we are going to print an integer in fixed format/fixed point notation.</p>
									<div class="assembly-row-combined"><div>10A6-10A8</div><div>LD BC,0603H<span class="opcode2">01 03 06</span></div><div>Load Register B to a decimal counte of 6 and Load Register C with a comma count of 3</div></div>
									<div class="assembly-row-combined"><div>10A9-10AB</div><div><a href="#1289H" class="memory-link">CALL 1289H<span class="origrom2">CALL FOUICC</span></a><span class="opcode2">CD 89 12</span></div><div>Go check to see if commas are needed.  If no comma is needed, set C to zero</div></div>
									<div class="assembly-row-combined"><div>10AC</div><div>POP DE<span class="opcode2">D1</span></div><div>Restore the field lengths (the number of #'s to the left and right of the decimal point) from the STACK into Register DE</div></div>
									<div class="assembly-row-combined"><div>10AD</div><div>LD A,D<span class="opcode2">7A</span></div><div>Load Register A with the number of digits requested to the left of the decimal point in Register D</div></div>
									<div class="assembly-row-combined"><div>10AE-10AF</div><div>SUB A,05H<span class="opcode2">D6 05</span></div><div>Since
 the maximim number of digits allowed for an integer to the left of the 
decimal point is 5, subtract 5 from the number of digits to the left of 
the decimal point requested.  This will test to see if we have to print 
extra spaces because the field is too big.</div></div>
									<div class="assembly-row-combined"><div>10B0-10B2</div><div><a href="#1269H" class="memory-link">CALL P,1269H<span class="origrom2">CALL P,FOTZER</span></a><span class="opcode2">F4 69 12</span></div><div>If
 the field is too big, and we have to print extra spaces, we GOSUB to 
FOTZER to put in zeroes which will later be converted to either <span class="code">SPACE</span> or <span class="code">*</span> by FOUTZS</div></div>
									<div class="assembly-row-combined"><div>10B3-10B5</div><div><a href="#132FH" class="memory-link">CALL 132FH<span class="origrom2">CALL FOUTCI</span></a><span class="opcode2">CD 2F 13</span></div><div>Convert
 the number to decimal digits by GOSUBing to the INTEGER TO ASCII 
routine at 1232F (which converts the integer in ACCumulator to ASCII and
 stores the ASCII string in the buffer pointed to in HL)</div></div>
									<div class="assembly-row-combined" id="10B6H"><div>10B6<span class="origrom2">FOUTTD</span></div><div>LD A,E<span class="opcode2">7B</span></div><div>Next
 we need to test to see if we need a decimal point.  First, load 
Register A with the number of digits to the right of the decimal point 
requested (which is stored in Register E)</div></div>
									<div class="assembly-row-combined"><div>10B7</div><div>OR A<span class="opcode2">B7</span></div><div>Check to see if there are any digits to the right of the decimal point requested and set the status flags accordingly</div></div>
									<div class="assembly-row-combined"><div>10B8-10BA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#092FH">CALL Z,092FH<span class="origrom2">CALL Z,DCXHRT</span></a><span class="opcode2">CC 2F 09</span></div><div>If
 the Z FLAG is set, then we do NOT need a decimal point, and need to 
backspace over it, so GOSUB to DCXHRT to decrement the value of the 
buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>10BB</div><div>DEC A<span class="opcode2">3D</span></div><div>Next
 we need to test to see how many trailing zeroes we need to print.  
Decrement the number of digits to the right of the decimal point in 
Register A.</div></div>
									<div class="assembly-row-combined"><div>10BC-10BE</div><div><a href="#1269H" class="memory-link">CALL P,1269H<span class="origrom2">CALL P,FOTZER</span></a><span class="opcode2">F4 69 12</span></div><div>If the POSITIVE flag is set, then print the trailing zeroes via  GOSUB to 1269H</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="10BFH">10BF - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUTTS"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will finish up the printing of a fixed format number.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>10BF<span class="origrom2">FOUTTS</span></div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save
 the current buffer pointer (stored in Register Pair HL) to the STACK.  
We then pss through to the FOUTTS routine to finish up the number.</div></div>
									<div class="assembly-row-combined"><div>10C0-10C2</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0FF5H">CALL 0FF5H<span class="origrom2">CALL FOUTZS</span></a><span class="opcode2">CD F5 0F</span></div><div>Go edit the ASCII string in the input buffer to suppress any zeroes, if needed.</div></div>
									<div class="assembly-row-combined"><div>10C3</div><div>POP HL<span class="opcode2">E1</span></div><div>Get the saved buffer pointer value from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>10C4-10C5</div><div><a href="#10C8H" class="memory-link">JR Z,10C8H<span class="origrom2">JR Z,FFXIX1</span></a><span class="opcode2">28 02</span></div><div>If the Z FLAG is set, then we do NOT have a trailing sign, so we JUMP away to 10C8H</div></div>
									<div class="assembly-row-combined"><div>10C6</div><div>LD (HL),B<span class="opcode2">70</span></div><div>So
 now we know a sign does follow the value so we save sign (held in 
Register B) at the location of the buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>10C7</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined" id="10C8H"><div>10C8-10C9<span class="origrom2">FFXIX1</span></div><div>LD (HL),00H<span class="opcode2">36 00</span></div><div>Terminate
 the buffer by saving an end of the ASCII string character (=00H) at the
 location of the input buffer pointer in Register Pair HL</div></div>
									<p class="debug-note">Now we need to check to see if the fixed 
format/fixed point number overflowed its field length.  The location if 
the decimal point needs to be in TEMP2.</p>
									<div class="assembly-row-combined"><div>10CA-10CC</div><div>LD HL,412FH<span class="origrom2">LD HL,FBUFFR</span><span class="opcode2">21 2F 41</span></div><div>Load
 Register Pair HL with the starting address of the input buffer pointer 
(which is 412FH) minus 1 (because the first instruction of the following
 common code is add 1 to HL)</div></div>
									<div class="assembly-row-combined" id="10CDH"><div>10CD<span class="origrom2">FOUBE1</span></div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined" id="10CEH"><div>10CE-10D0<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;FOUBE5</span></div><div>LD A,(40F3H)<span class="origrom2">LD A,(TEMP2)</span><span class="opcode2">3A F3 40</span></div><div>Load
 Register A with the LSB of the address of the decimal point for the 
ASCII string.  Why just the LSB?  FBUFFR is only 35 bytes long, so we 
only need to check the LSB to see if the field is big enough.</div></div>
									<div class="assembly-row-combined"><div>10D1</div><div>SUB A,L<span class="opcode2">95</span></div><div>First,
 subtract the LSB of the input buffer pointer address in Register L from
 the value in Register A to see how much space we have taken up</div></div>
									<div class="assembly-row-combined"><div>10D2</div><div>SUB A,D<span class="opcode2">92</span></div><div>Next,
 set the flags by subtract the number of digits to the left of the 
decimal point in Register D from the adjusted value in Register A to 
determine if we have taken the right amount of space.  Z FLAG will mean 
we did!</div></div>
									<div class="assembly-row-combined"><div>10D3</div><div>RET Z<span class="opcode2">C8</span></div><div>If we have taken the right amount of space, then we are done, so we RETurn</div></div>
									<div class="assembly-row-combined"><div>10D4</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>If
 we are here, then we took too much space.  How do we know it is too 
much instead of just "different"?  Well, we started checking from the 
beginning of the buffer, and the field must be small enough to fit into 
the buffer.  With this, we need to fetch the next character from the 
buffer into Register A</div></div>
									<div class="assembly-row-combined"><div>10D5-10D6</div><div>CP 20H<span class="origrom2">CP " "</span><span class="opcode2">FE 20</span></div><div>Check
 to see if the character at the location of the buffer pointer in 
Register A is a space, meaning we can just ignore the character to make 
the field shorter</div></div>
									<div class="assembly-row-combined"><div>10D7-10D8</div><div><a href="#10CDH" class="memory-link">JR Z,10CDH<span class="origrom2">JR Z,FOUBE1</span></a><span class="opcode2">28 F4</span></div><div>If it is a space, then LOOP back to FOUBE1 to ignore it</div></div>
									<div class="assembly-row-combined"><div>10D9-10DA</div><div>CP 2AH<span class="origrom2">CP "*"</span><span class="opcode2">FE 2A</span></div><div>Check to see if the character at the location of the input buffer pointer in Register A is a <span class="code">*</span>, meaning we can just ignore the character to make the field shorter</div></div>
									<div class="assembly-row-combined"><div>10DD</div><div>DEC HL<span class="opcode2">2B</span></div><div>Since we want to ignore <span class="code">*</span>'s we decrement the value of the input buffer pointer in Register Pair HL so it will get re-tested</div></div>
									<div class="assembly-row-combined"><div>10DE</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value of the buffer pointer in Register Pair HL to the STACK</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="10DFH">10DF - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUBE2"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>In this routine, we check to see if we can ignore the leading
 zero before a decimal point.  We can do this if if we see the 
following: (in order)<br>
								</p><table class="data-table indent05">
									<tbody>
										<tr><td>+,-</td><td>a sign (either "-" or "+")</td><td>[optional]</td></tr>
										<tr><td>$</td><td>a dollar sign</td><td>[optional]</td></tr>
										<tr><td>0</td><td>a zero</td><td>[mandatory]</td></tr>
										<tr><td>.</td><td>a decimal point</td><td>[mandatory]</td></tr>
										<tr><td>0-9</td><td>another digit</td><td>[mandatory]</td></tr>
									</tbody>
								</table>
								<br>If we see a leading zero, it must be the one before a 
decimal point or else FOUTZS would have akready suppressed it.  In that 
case, we just <span class="code">INC HL</span> over the character following the zero, and not have to check for the decimal point explicitly. <p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>10DF<span class="origrom2">FOUBE2</span></div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the the current character (which is the value in Register Pair AF) to the STACK.  This also saves the ZERO FLAG.</div></div>
									<div class="assembly-row-combined"><div>10E0-10E2</div><div>LD BC,10DFH<span class="origrom2">LD BC,FOUBE2</span><span class="opcode2">01 DF 10</span></div><div>Load Register Pair BC with the return address for use in case we have a <span class="code">-</span>, a <span class="code">+</span>, or a <span class="code">$</span></div></div>
									<div class="assembly-row-combined"><div>10E3</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the return address in Register Pair BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>10E4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H">RST 10H<span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>Since
 we need to bump the current input buffer pointer in Register Pair HL 
until it points to the next character, call the EXAMINE NEXT SYMBOL 
routine at RST 10H.<br><br>The RST 10H routine parses the characters 
starting at HL+1 for the first non-SPACE,non-09H,non-0BH character it 
finds.  On exit, Register A will hold that character, and the C FLAG is 
set if its alphabetic, and NC FLAG if its alphanumeric.  All strings 
must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>10E5-10E6</div><div>CP 2DH<span class="origrom2">CP "-"</span><span class="opcode2">FE 2D</span></div><div>Check to see if the character at the location of the input buffer pointer in Register A is a <span class="code">-</span></div></div>
									<div class="assembly-row-combined"><div>10E7</div><div>RET Z<span class="opcode2">C8</span></div><div>Return (to 10DFH) if the character at the location of the input buffer pointer in Register A is a <span class="code">-</span></div></div>
									<div class="assembly-row-combined"><div>10E8-10E9</div><div>CP 2BH<span class="origrom2">CP "+"</span><span class="opcode2">FE 2B</span></div><div>Check to see if the character at the location of the input buffer pointer in Register A is a <span class="code">+</span></div></div>
									<div class="assembly-row-combined"><div>10EA</div><div>RET Z<span class="opcode2">C8</span></div><div>Return (to 10DFH) if the character at the location of the input buffer pointer in Register A is a <span class="code">+</span></div></div>
									<div class="assembly-row-combined" id="10EBH"><div>10EB-10EC</div><div>CP 24H<span class="origrom2">CP "$"</span><span class="opcode2">FE 24</span></div><div>Check to see if the character at the location of the input buffer pointer in Register A is a <span class="code">$</span></div></div>
									<div class="assembly-row-combined"><div>10ED</div><div>RET Z<span class="opcode2">C8</span></div><div>Return (to 10DFH) if the character at the location of the input buffer pointer in Register A is a <span class="code">$</span></div></div>
									<div class="assembly-row-combined" id="10EEH"><div>10EE</div><div>POP BC<span class="opcode2">C1</span></div><div>We don't need a shortcut to jump to 10DFH anymore, so let's get rid of the now unneeded return address from the STACK</div></div>
									<div class="assembly-row-combined"><div>10EF-10F0</div><div>CP 30H<span class="origrom2">CP "0"</span><span class="opcode2">FE 30</span></div><div>Check to see if the character at the location of the input buffer pointer in Register A is a <span class="code">0</span></div></div>
									<div class="assembly-row-combined"><div>10F1-10F2</div><div><a href="#1102H" class="memory-link">JR NZ,1102H<span class="origrom2">JR NZ,FOUBE4</span></a><span class="opcode2">20 0F</span></div><div>If the character at the location of the input buffer pointer in Register A isn't a <span class="code">0</span> then we can no longer just get rid of the characters, so JUMP to FOUBE4 to continue</div></div>
									<div class="assembly-row-combined"><div>10F3</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the input buffer pointer in Register Pair HL so that we skip over the decimal point to the next character</div></div>
									<div class="assembly-row-combined"><div>10F4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H">RST 10H<span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>Since
 we need to bump the current input buffer pointer in Register Pair HL 
until it points to the next character, call the EXAMINE NEXT SYMBOL 
routine at RST 10H.<br><br>The RST 10H routine parses the characters 
starting at HL+1 for the first non-SPACE,non-09H,non-0BH character it 
finds.  On exit, Register A will hold that character, and the C FLAG is 
set if its alphabetic, and NC FLAG if its alphanumeric.  All strings 
must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>10F5-10F6</div><div><a href="#1102H" class="memory-link">JR NC,1102H<span class="origrom2">JR NC,FOUBE4</span></a><span class="opcode2">30 0B</span></div><div>If the character after the decimal point is not a digit then we can't shorten the field anymore, so JUMP to FOUBE4</div></div>
									<div class="assembly-row-combined"><div>10F7</div><div>DEC HL<span class="opcode2">2B</span></div><div>If
 we didn't jump away, then we can shorten the field by one, so DECrement
 the value of the buffer pointer in Register Pair HL to backspace</div></div>
									<div class="assembly-row-combined" id="10F8H"><div>10F8</div><div>LD BC,772BH<span class="opcode2">01 2B 77</span></div><div>Z-80
 Trick! The byte at this memory location, 01H, is there to turn the real
 instruction that follows in 10F9H into a harmless LD BC,xxxx.  This 
way, if you are processing straight down in order, it skips the next 
command at 10F9H (in this case a <span class="code">DEC HL</span>) 
because it wasn't a command, it was a hex number to be loaded into BC!  
Instead, if you jump to 10F9H, you skip this byte and it is an <span class="code">DEC HL</span></div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="10F9H">10F9 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUBE3"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>If we can get rid of the zero, we put the characters on the 
STACK back into the buffer one position in front of where they 
originally were.<br><br> Note that the maximum number of STACK levels 
this uses is three -- one for the last entry flag, one for a possible 
sign, and one for a possible dollar sign.<br><br> We don't have to worry
 about the first character being in the buffer twice because the pointer
 when FOUT exits will be pointing to the second occurance.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>10F9<span class="origrom2">FOUBE3</span></div><div>DEC HL<span class="opcode2">2B</span></div><div>If
 passing through, this instruction won't get executed.  If JUMPed to, 
decrement the value of the buffer pointer in Register Pair HL (we needed
 that Z-80 trick to avoid a double backspace if passing through)</div></div>
									<div class="assembly-row-combined"><div>10FA</div><div>LD (HL),A<span class="opcode2">77</span></div><div>If
 passing through, this instruction won't get executed.  If JUMPed to, 
save the character in Register A at the location of the input buffer 
pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>10FB</div><div>POP AF<span class="opcode2">F1</span></div><div>Get the character from the STACK and put it in Register Pair AF</div></div>
									<div class="assembly-row-combined"><div>10FC-10FD</div><div><a href="#10F9H" class="memory-link">JR Z,10F9H<span class="origrom2">JR Z,FOUBE3</span></a><span class="opcode2">28 FB</span></div><div>If the Z FLAG is set, then we LOOP back to FOUBE3 to put the character back into the buffer</div></div>
									<div class="assembly-row-combined"><div>10FE</div><div>POP BC<span class="opcode2">C1</span></div><div>Restore the buffer pointer from the top of the STACK into Register Pair BC</div></div>
									<div class="assembly-row-combined" id="1100H"><div>10FF-1101</div><div><a href="#10CEH" class="memory-link">JP 10CEH<span class="origrom2">JP FOUBE5</span></a><span class="opcode2">C3 CE 10</span></div><div>LOOP back to 10CEH to see if the field is NOW small enough.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1102H">1102 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUBE4"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>If the number is too big for the field, we wind up here to deal with that.</p> 				<div class="assembly-row-combined" id="1102H"><div>1102<span class="origrom2">FOUBE4</span></div><div>POP AF<span class="opcode2">F1</span></div><div>Restore the character from the STACK and put it in Register Pair AF</div></div>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1103-1104</div><div><a href="#1102H" class="memory-link">JR Z,1102H<span class="origrom2">JR Z,FOUBE4</span></a><span class="opcode2">28 FD</span></div><div>If the Z FLAG is set, then LOOP back 1 instruction to leave the number in the buffer alone</div></div>
									<div class="assembly-row-combined"><div>1105</div><div>POP HL<span class="opcode2">E1</span></div><div>Get
 the starting address of the field from the STACK and put it in Register
 Pair HL.  This will be the pointer to the beginning of the number - 1</div></div>
									<div class="assembly-row-combined"><div>1106-1107</div><div>LD (HL),25H<span class="origrom2">LD (HL),"%"</span><span class="opcode2">36 25</span></div><div>Show that we have overflowed the field by putting a <span class="code">%</span> character at the front.</div></div>
									<div class="assembly-row-combined"><div>1108</div><div>RET<span class="opcode2">C9</span></div><div>All done!  RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1109H">1109 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUFXV"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is where the PRINT USING routine will print a single or double precision number in a fixed format</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1109<span class="origrom2">FOUFXV</span></div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the buffer pointer in Register Pair HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>110A</div><div>RRA<span class="opcode2">1F</span></div><div>Rotate
 Register A so that the "fixed notation" or "floating notation" flag bit
 moves into the CARRY FLAG for testing.  RRA rotates Register A right 
one bit, with Bit 0 going to CARRY and CARRY going to Bit 7.</div></div>
									<div class="assembly-row-combined"><div>110B-110D</div><div><a href="#11AAH" class="memory-link">JP C,11AAH<span class="origrom2">JP C,FFXFLV</span></a><span class="opcode2">DA AA 11</span></div><div>If the CARRY FLAG was set, then we know we are printing the number in "E" notation, so JUMP to FFXFLV</div></div>
									<div class="assembly-row-combined"><div>110E-110F</div><div><a href="#1124H" class="memory-link">JR Z,1124H<span class="origrom2">JR Z,FFXSFX</span></a><span class="opcode2">28 14</span></div><div>If the Z FLAG was set, the we have a SINGLE PRECISION number to print, so JUMP to FFXSFC to do that</div></div>
									<p class="debug-note">If we are here, then we are printing a DOUBLE PRECISION number in fixed format/fixed point notation</p>
									<div class="assembly-row-combined"><div>1110-1112</div><div>LD DE,1384H<span class="origrom2">LD DE,FFXDXM</span><span class="opcode2">11 84 13</span></div><div>Load
 Register Pair DE with the address of the DOUBLE PRECISION value to be 
compared to the current value in ACCumulator.  Register Pair DE points 
to a double precision constant equal to 1D16</div></div>
									<div class="assembly-row-combined"><div>1113-1115</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A49H">CALL 0A49H<span class="origrom2">CALL DCOMPD</span></a><span class="opcode2">CD 49 0A</span></div><div>Since
 we can't print a number which is greater than 10^16 in fixed format, 
GOSUB to compare the double precision constant pointed to by Register 
Pair DE (which is 1Dl6) to the double precision value in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>1116-1117</div><div>LD D,10H<span class="opcode2">16 10</span></div><div>Load Register D with the maximum length of a double precision value (which is 16 in decimal)</div></div>
									<div class="assembly-row-combined"><div>1118-111A</div><div><a href="#1132H" class="memory-link">JP M,1132H<span class="origrom2">JP M,FFXSDC</span></a><span class="opcode2">FA 32 11</span></div><div>If
 the M FLAG is set, then the number in the ACCumulator is small enough 
to print (i.e., less than or equal to 1Dl6), so JUMP to 1132H</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="111BH">111B - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FFXSDO"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will print a number which is greaster than 10^16 in free format with a percent sign</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>111B<span class="origrom2">FFXSDO</span></div><div>POP HL<span class="opcode2">E1</span></div><div>Get the current buffer pointer from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>111C</div><div>POP BC<span class="opcode2">C1</span></div><div>Get the field specifier from the STACK and put it in Register Pair BC, resulting in B containing the number of <span class="code">#</span>'s before and C containing the number of <span class="code">#</span>'s after</div></div>
									<div class="assembly-row-combined"><div>111D-111F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0FBDH">CALL 0FBDH<span class="origrom2">CALL FOUT</span></a><span class="opcode2">CD BD 0F</span></div><div>Print
 the number in free format via a GOSUB to FOUT (which will convert a 
double precision value in ACCumulator to an ASCII string)</div></div>
									<div class="assembly-row-combined"><div>1120</div><div>DEC HL<span class="opcode2">2B</span></div><div>Decrement the input buffer pointer in Register Pair HL to point in front of the number</div></div>
									<div class="assembly-row-combined"><div>1121-1122</div><div>LD (HL),25H<span class="origrom2">LD (HL),"%"</span><span class="opcode2">36 25</span></div><div>Save a <span class="code">%</span> character at the location of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1123</div><div>RET<span class="opcode2">C9</span></div><div>All done!  RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1124H">1124 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FFXSFX"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will print a SINGLE PRECISION number in fixed format/fixed point notation</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1124H"><div>1124-1126<span class="origrom2">FFXSFX</span></div><div>LD BC,B60EH<span class="opcode2">01 0E B6</span></div><div>Load Register Pair BC/DE with 1E16</div></div>
									<div class="assembly-row-combined"><div>1127-1129</div><div>LD DE,1BCAH<span class="opcode2">11 CA 1B</span></div><div>Register Pairs BC and DE now hold a single precision constant equal to 1x10^16</div></div>
									<div class="assembly-row-combined"><div>112A-112C</div><div><a href="#0A0CH" class="memory-link">CALL 0A0CH<span class="origrom2">CALL FCOMP</span></a><span class="opcode2">CD 0C 0A</span></div><div>Call
 the SINGLE PRECISION COMPARISON routine at routine at 0A0CH which 
algebraically compares the single precision value in BC/DE to the single
 precision value ACCumulator.<br>The results are stored in A as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Register A</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator = BCDE</td><td style="border: 1px solid black; padding: 8px;">00</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator &gt; BCDE</td><td style="border: 1px solid black; padding: 8px;">01</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator &lt; BCDE</td><td style="border: 1px solid black; padding: 8px;">FF</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>112D-112F</div><div><a href="#111BH" class="memory-link">JP P,111BH<span class="origrom2">JP P,FFXSDO</span></a><span class="opcode2">F2 1B 11</span></div><div>If the P FLAG is set then the number is too big, so we need to JUMP to FFXSDO to print it in free format with a <span class="code">%</span> overflow symbol</div></div>
									<div class="assembly-row-combined"><div>1130-1131</div><div>LD D,06H<span class="opcode2">16 06</span></div><div>Now
 we know that the SINGLE precision value in ACCumulator is less than 
1x10^16.  Load Register D with the maximum length of a single precision 
value (which is 6) and then fall through to the FFXSDC routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1132H">1124 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FFXSDC"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will print a SINGLE PRECISION or DOUBLE PRECISION number in fixed format/fixed point notation</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1132H"><div>1132-1134<span class="origrom2">FFXSDC</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0955H">CALL 0955H<span class="origrom2">CALL SIGN</span></a><span class="opcode2">CD 55 09</span></div><div>GOSUB to SIGN to see if we have a ZERO in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>1135-1137</div><div><a href="#1201H" class="memory-link">CALL NZ,1201H<span class="origrom2">CALL NZ,FOUTNV</span></a><span class="opcode2">C4 01 12</span></div><div>If
 we do NOT have a ZERO, then GOSUB to FOUTNV to normalize the number so 
that all digits to be printed are located in the initeger part</div></div>
									<div class="assembly-row-combined"><div>1138</div><div>POP HL<span class="opcode2">E1</span></div><div>Get the buffer pointer from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1139</div><div>POP BC<span class="opcode2">C1</span></div><div>Get the value from the STACK and put it in Register Pair BC, resulting in B containing the number of <span class="code">#</span>'s before and C containing the number of <span class="code">#</span>'s after</div></div>
									<div class="assembly-row-combined"><div>113A-113C</div><div><a href="#1157H" class="memory-link">JP M,1157H<span class="origrom2">JP M,FFXXVS</span></a><span class="opcode2">FA 57 11</span></div><div>If the exponent is negative, JUMP to FFXXVS to handle that</div></div>
									<p class="debug-note">This routine will print a number that has no fractional digits</p>
									<div class="assembly-row-combined"><div>113D</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the value in Register Pair BC (B was the number of <span class="code">#</span>'s before and C is the number of <span class="code">#</span>'s after) to the STACK</div></div>
									<div class="assembly-row-combined"><div>113E</div><div>LD E,A<span class="opcode2">5F</span></div><div>Load Register E with the exponent</div></div>
									<p class="debug-note">If the field length is higher than the 
number of characters we actually have, we are going to need to put in 
that number of leading zeroes.</p>
									<div class="assembly-row-combined"><div>113F</div><div>LD A,B<span class="opcode2">78</span></div><div>Load Register A with the number of digits before the decimal point requested</div></div>
									<div class="assembly-row-combined"><div>1140</div><div>SUB A,D<span class="opcode2">92</span></div><div>Subtract
 the maximum length for the current number type in Register D (which is 
6) from the number of digits requested in Register A</div></div>
									<div class="assembly-row-combined"><div>1141</div><div>SUB A,E<span class="opcode2">93</span></div><div>Subtract the number of times the current value in ACCumulator was divided in Register E from the adjusted value in Register A</div></div>
									<div class="assembly-row-combined"><div>1142-1144</div><div><a href="#1269H" class="memory-link">CALL P,1269H<span class="origrom2">CALL P,FOTZER</span></a><span class="opcode2">F4 69 12</span></div><div>If
 B-D-E is still POSITIVE, then we have to fill with some zeroes so GOSUB
 to 1269H to put leading zeros into the input buffer if necessary</div></div>
									<div class="assembly-row-combined"><div>1145-1147</div><div><a href="#127DH" class="memory-link">CALL 127DH<span class="origrom2">CALL FOUTCD</span></a><span class="opcode2">CD 7D 12</span></div><div>Next, set up the decimal point and comma counts via a GOSUB to DOUTCD</div></div>
									<div class="assembly-row-combined"><div>1148-114A</div><div><a href="#12A4H" class="memory-link">CALL 12A4H<span class="origrom2">CALL FOUTCV</span></a><span class="opcode2">CD A4 12</span></div><div>Then,
 convert the number to decimal digits via a GOSUB to FOUTCV to convert 
the integer portion of the current value in ACCumulator to an ASCII 
string</div></div>
									<div class="assembly-row-combined"><div>114B</div><div>OR E<span class="opcode2">B3</span></div><div>Merge in the number of digits after the number, if the field is big enough of course.</div></div>
									<div class="assembly-row-combined"><div>114C-114E</div><div><a href="#1277H" class="memory-link">CALL NZ,1277H<span class="origrom2">CALL NZ,FOTZEC</span></a><span class="opcode2">C4 77 12</span></div><div>If
 there are number to be put there (i.e., merging in E leaves a number 
greater than Zero), then GOSUB to FOTZEC to put trailing zeros into the 
input buffer if necessary</div></div>
									<div class="assembly-row-combined"><div>114F</div><div>OR E<span class="opcode2">B3</span></div><div>Check to see if commas or the decimal point is needed</div></div>
									<div class="assembly-row-combined"><div>1150-1152</div><div><a href="#1291H" class="memory-link">CALL NZ,1291H<span class="origrom2">CALL NZ,FOUTED</span></a><span class="opcode2">C4 91 12</span></div><div>Go put commas and the decimal point into the input buffer if necessary</div></div>
									<div class="assembly-row-combined"><div>1153</div><div>POP DE<span class="opcode2">D1</span></div><div>Retrieve the field length specs from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1154-1156</div><div><a href="#10B6H" class="memory-link">JP 10B6H<span class="origrom2">JP FOUTTD</span></a><span class="opcode2">C3 B6 10</span></div><div>Jump to 10B6H to check the size, run zero suppression, and convert the fractional portion of the number to ASCII to finish up</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1157H">1157 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FFXXVS"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will print a SINGLE PRECISION or DOUBLE PREVISION number that has fractional digits</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1157<span class="origrom2">FFXXVS</span></div><div>LD E,A<span class="opcode2">5F</span></div><div>Preserve the exponent into Register E</div></div>
									<div class="assembly-row-combined"><div>1158</div><div>LD A,C<span class="opcode2">79</span></div><div>Prepare
 to divide by 10 the right number of times so that the result will be 
rounded correctly and have the correct number of significant digits.  
First, load Register A with the number of digits requested to the right 
of the decimal point</div></div>
									<div class="assembly-row-combined"><div>1159</div><div>OR A<span class="opcode2">B7</span></div><div>Check to see if any digits to the right of the decimal point was requested</div></div>
									<div class="assembly-row-combined"><div>115A-115C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0F16H">CALL NZ,0F16H<span class="origrom2">CALL NZ,DCRART</span></a><span class="opcode2">C4 16 0F</span></div><div>Go decrement the number of digits requested to the right of the decimal point if necessary</div></div>
									<div class="assembly-row-combined"><div>115D</div><div>ADD A,E<span class="opcode2">83</span></div><div>Add
 the number of times the current value was multiplied in Register E to 
the number of digits to the right of the decimal point requested in 
Register A</div></div>
									<div class="assembly-row-combined"><div>115E-1160</div><div><a href="#1162H" class="memory-link">JP M,1162H<span class="origrom2">JP M,FFXXV8</span></a><span class="opcode2">FA 62 11</span></div><div>If
 the value in ACCumulator must be scaled down then skip the next 
instruction, as we want a ZERO FLAG only if the result was not negative</div></div>
									<div class="assembly-row-combined"><div>1161</div><div>XOR A<span class="opcode2">AF</span></div><div>Zero Register A</div></div>
									<div class="assembly-row-combined" id="1162H"><div>1162<span class="origrom2">FFXXV8</span></div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the field specifications held in Register Pair BC (B was the number of <span class="code">#</span>'s before and C is the number of <span class="code">#</span>'s after) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1163</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the the scale count (held in Register Pair AF) to the STACK</div></div>
									<div class="assembly-row-combined" id="1164H"><div>1164-1166<span class="origrom2">FFXXV2</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0F18H">CALL M,0F18H<span class="origrom2">CALL M,FINDIV</span></a><span class="opcode2">FC 18 0F</span></div><div>Top of a divide loop.  GOSUB to 0F18H to divide the value in ACCumulator by ten, A times, if necessary</div></div>
									<div class="assembly-row-combined"><div>1167-1169</div><div><a href="#1164H" class="memory-link">JP M,1164H<span class="origrom2">JP M,FFXXV2</span></a><span class="opcode2">FA 64 11</span></div><div>Loop
 until the value in ACCumulator is properly adjusted. When this is done,
 A will hold the number of times it was divided by 10</div></div>
									<div class="assembly-row-combined"><div>116A</div><div>POP BC<span class="opcode2">C1</span></div><div>Get the original scale count from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>116B</div><div>LD A,E<span class="opcode2">7B</span></div><div>We
 now need to test as to whether the number has integer digits or not.  
First, load Register A with the number of times the value in ACCumulator
 was multiplied in Register E</div></div>
									<div class="assembly-row-combined"><div>116C</div><div>SUB A,B<span class="opcode2">90</span></div><div>Subtract the value in Register B from the value in Register A</div></div>
									<div class="assembly-row-combined"><div>116D</div><div>POP BC<span class="opcode2">C1</span></div><div>Get the value from the STACK and put it in Register Pair BC, resulting in B containing the number of <span class="code">#</span>'s before and C containing the number of <span class="code">#</span>'s after</div></div>
									<div class="assembly-row-combined"><div>116E</div><div>LD E,A<span class="opcode2">5F</span></div><div>Calculate
 the number of decimal places before the number ends by first loading 
Register E with the adjusted scale factor value in Register A ...</div></div>
									<div class="assembly-row-combined"><div>116F</div><div>ADD A,D<span class="opcode2">82</span></div><div>...
 and then adding the length of the maximum size for the current value in
 Register D to the adjusted scale factor value in Register A.  This will
 set the sign flag</div></div>
									<div class="assembly-row-combined"><div>1170</div><div>LD A,B<span class="opcode2">78</span></div><div>Load Register A with the number of <span class="code">#</span>'s before (stored in B)</div></div>
									<div class="assembly-row-combined"><div>1171-1173</div><div><a href="#117FH" class="memory-link">JP M,117FH<span class="origrom2">JP M,FFXXV3</span></a><span class="opcode2">FA 7F 11</span></div><div>Jump to 117FH if there are no digits to the left of the decimal point</div></div>
									<p class="debug-note">This routine will print numbers with 
integer digits, and will print some leading zeroes if the field is 
bigger than the number of digits we need to print.</p>
									<div class="assembly-row-combined"><div>1174</div><div>SUB A,D<span class="opcode2">92</span></div><div>We
 now know there are leading digits so, subtract the maximum length for 
the current value in Register D (6 for SINGLE precision and 10 for 
DOUBLE precision) from the adjusted value in Register A</div></div>
									<div class="assembly-row-combined"><div>1175</div><div>SUB A,E<span class="opcode2">93</span></div><div>Then, subtract the adjusted scale value in Register E from the adjusted value in Register A</div></div>
									<div class="assembly-row-combined"><div>1176-1178</div><div><a href="#1269H" class="memory-link">CALL P,1269H<span class="origrom2">CALL P,FOTZER</span></a><span class="opcode2">F4 69 12</span></div><div>If that subtraction leads to a positive number, go put leading zeros into the input buffer</div></div>
									<div class="assembly-row-combined"><div>1179</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the field specs held in Register Pair BC (B was the number of <span class="code">#</span>'s before and C is the number of <span class="code">#</span>'s after) to the STACK</div></div>
									<div class="assembly-row-combined"><div>117A-117C</div><div><a href="#127DH" class="memory-link">CALL 127DH<span class="origrom2">CALL FOUTCD</span></a><span class="opcode2">CD 7D 12</span></div><div>GOSUB to set up BC for decimal point and comma counters</div></div>
									<div class="assembly-row-combined"><div>117D-117E</div><div><a href="#1190H" class="memory-link">JR 1190H<span class="origrom2">JR FFXXV6</span></a><span class="opcode2">18 11</span></div><div>Jump to 1190H to convert the digits before the decimal point and trim the number</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="117FH">117F - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FFXXV3"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will print a number without integer digits.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>117F-1181<span class="origrom2">FFXXV3</span></div><div><a href="#1269H" class="memory-link">CALL 1269H<span class="origrom2">CALL FOTZER</span></a><span class="opcode2">CD 69 12</span></div><div>Go put leading zeros (as needed) into the input buffer</div></div>
									<div class="assembly-row-combined"><div>1182</div><div>LD A,C<span class="opcode2">79</span></div><div>Load
 Register A with the number of bytes requested to the right of the 
decimal point (in Register C) because C is about to get wiped</div></div>
									<div class="assembly-row-combined"><div>1183-1185</div><div><a href="#1294H" class="memory-link">CALL 1294H<span class="origrom2">CALL FOUTDP</span></a><span class="opcode2">CD 94 12</span></div><div>GOSUB to 1294H to put a decimal point into the input buffer</div></div>
									<div class="assembly-row-combined"><div>1186</div><div>LD C,A<span class="opcode2">4F</span></div><div>Reload Register C with the number of digits requested to the right of the decimal point in Register A</div></div>
									<div class="assembly-row-combined"><div>1187</div><div>XOR A<span class="opcode2">AF</span></div><div>Next we need to calculate how many zeroes to put between the decimal point and the first digit, so start by zeroing Register A</div></div>
									<div class="assembly-row-combined"><div>1188</div><div>SUB A,D<span class="opcode2">92</span></div><div>Then - subtract the maximum length for the current value in Register D from the value in Register A</div></div>
									<div class="assembly-row-combined"><div>1189</div><div>SUB A,E<span class="opcode2">93</span></div><div>Then - subtract the value in Register E from the adjusted value in Register A</div></div>
									<div class="assembly-row-combined"><div>118A-118C</div><div><a href="#1269H" class="memory-link">CALL 1269H<span class="origrom2">CALL FOTZER</span></a><span class="opcode2">CD 69 12</span></div><div>GOSUB to put that many zeroes into the buffer</div></div>
									<div class="assembly-row-combined"><div>118D</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the value in Register Pair BC (B is the exponent and C is the number of <span class="code">#</span>'s after) to the STACK</div></div>
									<div class="assembly-row-combined"><div>118E</div><div>LD B,A<span class="opcode2">47</span></div><div>Load Register B (i.e., the decimal place count) with the value in Register A (which is 0)</div></div>
									<div class="assembly-row-combined"><div>118F</div><div>LD C,A<span class="opcode2">4F</span></div><div>Load Register C (i..e, the comma count) with the value in Register A (which is 0)</div></div>
									<div class="assembly-row-combined" id="1190H"><div>1190-1192<span class="origrom2">FFXXV6</span></div><div><a href="#12A4H" class="memory-link">CALL 12A4H<span class="origrom2">CALL FOUTCV</span></a><span class="opcode2">CD A4 12</span></div><div>GOSUB
 to 12A4H to convert the integer portion of the SINGLE precision value 
in ACCumulator to an ASCII string.  These will be the decimal digits.</div></div>
									<div class="assembly-row-combined"><div>1193</div><div>POP BC<span class="opcode2">C1</span></div><div>Get the number of <span class="code">#</span>'s before and number of <span class="code">#</span>'s after and put it back in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>1194</div><div>OR C<span class="opcode2">B1</span></div><div>Check
 to see if we need to print any zeroes after the last digit (i.e., if 
there are any digits to the right of the decimal point requested) and 
set the status accordingly</div></div>
									<div class="assembly-row-combined"><div>1195-1196</div><div><a href="#119AH" class="memory-link">JR NZ,119AH<span class="origrom2">JR NZ,FFXXV7</span></a><span class="opcode2">20 03</span></div><div>If the NZ FLAG is set, then there are digits to the right of the decimal point to fill, so JUMP to 119AH to do that</div></div>
									<div class="assembly-row-combined"><div>1197-1199</div><div>LD HL,(40F3H)<span class="origrom2">LD HL,(TEMP2)</span><span class="opcode2">2A F3 40</span></div><div>Now
 we know that there are no digits to the right of the decimal point.  
Load Register Pair HL with the position of the decimal point (which is 
stored in 40F3H).<br>Note: 40F3H-40F4H is a temporary storage location</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="119AH">119A - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FFXXV7"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will print trailing zeroes.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>119A<span class="origrom2">FFXXV7</span></div><div>ADD A,E<span class="opcode2">83</span></div><div>Add the value in Register E to the value in Register A to get the number of digits before the decimal point</div></div>
									<div class="assembly-row-combined"><div>119B</div><div>DEC A<span class="opcode2">3D</span></div><div>Decrement the adjusted value in Register A</div></div>
									<div class="assembly-row-combined"><div>119C-119E</div><div><a href="#1269H" class="memory-link">CALL P,1269H<span class="origrom2">CALL P,FOTZER</span></a><span class="opcode2">F4 69 12</span></div><div>If dropping A by 1 still results in a positive number, GOSUB 1269H to put that number of zeros into the input buffer</div></div>
									<div class="assembly-row-combined"><div>119F</div><div>LD D,B<span class="opcode2">50</span></div><div>Load Register D with the number of digits to the left of the decimal point requested (from Register B)</div></div>
									<div class="assembly-row-combined"><div>11A0-11A2</div><div><a href="#10BFH" class="memory-link">JP 10BFH<span class="origrom2">JP FOUTTS</span></a><span class="opcode2">C3 BF 10</span></div><div>Jump to 10BFH to finish up</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="11A3H">11A3 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FFXIFL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will print an integer in fixed format/floating point notation.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>11A3<span class="origrom2">FFXIFL</span></div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the current position of the buffer (in Register Pair HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>11A4</div><div>PUSH DE<span class="opcode2">D5</span></div><div>Generally save Register Pair DE to be POPped after the CALL.  DE currently holds the format specs</div></div>
									<div class="assembly-row-combined"><div>11A5-11A7</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0ACCH">CALL 0ACCH<span class="origrom2">CALL CONSI</span></a><span class="opcode2">CD CC 0A</span></div><div>GOSUB 0ACCH to convert the integer value in ACCumulator to a SINGLE precision value</div></div>
									<div class="assembly-row-combined"><div>11A8</div><div>POP DE<span class="opcode2">D1</span></div><div>Restore DE from the STACK</div></div>
									<div class="assembly-row-combined"><div>11A9</div><div>XOR A<span class="opcode2">AF</span></div><div>Zero
 Register A, clear the status flags.  This will denote to the next 
routine that we are printing a number as a SINGLE PRECISION number, and 
then fall into the FFXFLV routine</div></div>

								</div>
							</div>

							<h2 class="assembly-section-title" id="11AAH">11AA - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FFXFLV"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will print a SINGLE or DOUBLE PRECISION number in fixed format/floating point notation.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>11AA-11AC<span class="origrom2">FFXFLV</span></div><div><a href="#11B0H" class="memory-link">JP Z,11B0H<span class="origrom2">JP Z,FFXSFL</span></a><span class="opcode2">CA B0 11</span></div><div>If we have a SINGLE PRECISION number (because the Z FLAG is set), Jump to 11B0H to set the flags appropriately</div></div>
									<div class="assembly-row-combined"><div>11AD-11AE</div><div>LD E,10H<span class="opcode2">1E 10</span></div><div>We know we have a DOUBLE PRECISION so load Register E with the maximum length of a double precision value (which is 16)</div></div>
									<div class="assembly-row-combined"><div>11AF-11B2</div><div>LD BC,1E06H<span class="opcode2">01 1E 06</span></div><div>Z-80
 Trick!  If passing through then this just modifies the Register Pair 
BC.  However, if JUMPing to 11B0, a LD E,06H occurs, changing E</div></div>
									<div class="assembly-row-combined" id="11B0H"><div>11B0-11B1<span class="origrom2">FFXSFL</span></div><div>LD E,06H<span class="opcode2">1E 06</span></div><div>Load Register E with the maximum length of a single precision value (which is 6)</div></div>
									<div class="assembly-row-combined"><div>11B2-11B4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0955H">CALL 0955H<span class="origrom2">CALL SIGN</span></a><span class="opcode2">CD 55 09</span></div><div>GOSUB 0955H to check to see if we have a zero in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>11B5</div><div>SCF<span class="opcode2">37</span></div><div>Set the Carry flag to determine if we are printing a zero or not.  This works because FOUTNV exits with the NC FLAG set</div></div>
									<div class="assembly-row-combined"><div>11B6-11B8</div><div><a href="#1201H" class="memory-link">CALL NZ,1201H<span class="origrom2">CALL NZ,FOUTNV</span></a><span class="opcode2">C4 01 12</span></div><div>If
 we do not have a zero, then we need to normalize the number so that all
 digits to be printed are in the integer portion, so GOSUB to 1201H to 
scale the current value in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>11B9</div><div>POP HL<span class="opcode2">E1</span></div><div>Get the buffer position from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>11BA</div><div>POP BC<span class="opcode2">C1</span></div><div>Get the number of <span class="code">#</span>'s before and the number of <span class="code">#</span>'s after from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>11BB</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the exponent in Register Pair AF to the STACK</div></div>
									<div class="assembly-row-combined"><div>11BC</div><div>LD A,C<span class="opcode2">79</span></div><div>We
 need to calculate how many significant digits we must print, so load 
Register A with the number of digits to the right of the decimal point 
requested (stored in Register C)</div></div>
									<div class="assembly-row-combined"><div>11BD</div><div>OR A<span class="opcode2">B7</span></div><div>Set the status so we can see if there are any digits to the right of the decimal point requested through a zero register</div></div>
									<div class="assembly-row-combined"><div>11BE</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the original trailing digit count (in Register Pair AF) to the STACK</div></div>
									<div class="assembly-row-combined"><div>11BF-11C1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0F16H">CALL NZ,0F16H<span class="origrom2">CALL NZ,DCRART</span></a><span class="opcode2">C4 16 0F</span></div><div>If
 the trail count is not zero, then GOSUB to 0F16H to decrement the 
number of digits requested to the right of the decimal point in Register
 A</div></div>
									<div class="assembly-row-combined"><div>11C2</div><div>ADD A,B<span class="opcode2">80</span></div><div>Add
 the number of digits requested for the left of the decimal point in 
Register B to the number of digits requested to the right of the decimal
 point in Register A</div></div>
									<div class="assembly-row-combined"><div>11C3</div><div>LD C,A<span class="opcode2">4F</span></div><div>Load Register C with the total digit count (held in Register A)</div></div>
									<div class="assembly-row-combined"><div>11C4</div><div>LD A,D<span class="opcode2">7A</span></div><div>Load Register A with the value of the edit flag in Register D</div></div>
									<div class="assembly-row-combined"><div>11C5-11C6</div><div>AND 04H<span class="origrom2">AND 0000 0100</span><span class="opcode2">E6 04</span></div><div>Check to see if the sign follows the ASCII string (i.e., is a "trailing" sign)</div></div>
									<div class="assembly-row-combined"><div>11C7-11C8</div><div>CP 01H<span class="opcode2">FE 01</span></div><div>Set
 the Carry flag according to the sign following the ASCII string test 
(it will be No Carry if a sign follows, and will be CARRY if A=0)</div></div>
									<div class="assembly-row-combined"><div>11C9</div><div>SBC A,A<span class="opcode2">9F</span></div><div>If we have a trailing sign, this will set Register D to 0.  Otherwise, D will be FFH if we don't have a trailing sign.</div></div>
									<div class="assembly-row-combined"><div>11CA</div><div>LD D,A<span class="opcode2">57</span></div><div>Load Register D with those results</div></div>
									<div class="assembly-row-combined"><div>11CB</div><div>ADD A,C<span class="opcode2">81</span></div><div>Add the value in Register C to the value in Register A so as to set the number of significant digits to print</div></div>
									<div class="assembly-row-combined"><div>11CC</div><div>LD C,A<span class="opcode2">4F</span></div><div>Load Register C with the adjusted value in Register A</div></div>
									<div class="assembly-row-combined"><div>11CD</div><div>SUB A,E<span class="opcode2">93</span></div><div>If
 the number of significant digits to print is less than E, then we have 
to get rid of some numbers!  Subtract the value in Register E from the 
adjusted value in Register A so that A will now contain the number of 
times to divide by 10</div></div>
									<div class="assembly-row-combined"><div>11CE</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save
 the divisor count (from Register Pair AF) to the STACK.  This is the 
result of the comparison of the number of significant digits and the 
number of digits we will actually print.</div></div>
									<div class="assembly-row-combined"><div>11CF</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the "B" field spec and the number of significant digits (from Register Pair BC) to the STACK</div></div>
									<div class="assembly-row-combined" id="11D0H"><div>11D0-11D2<span class="origrom2">FFXLV1</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0F18H">CALL M,0F18H<span class="origrom2">CALL M,FINDIV</span></a><span class="opcode2">FC 18 0F</span></div><div>GOSUB 0F18H to divide the current value in ACCumulator by ten, Register A number of times</div></div>
									<div class="assembly-row-combined"><div>11D3-11D5</div><div><a href="#11D0H" class="memory-link">JP M,11D0H<span class="origrom2">JP M,FFXLV1</span></a><span class="opcode2">FA D0 11</span></div><div>Loop back 1 instruction (divide by 10) until the division has been completed</div></div>
									<div class="assembly-row-combined"><div>11D6</div><div>POP BC<span class="opcode2">C1</span></div><div>Retrieve the "B" field spec and the number of significant digits from the STACK back into Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>11D7</div><div>POP AF<span class="opcode2">F1</span></div><div>Get the number of trailing zeroes to print from the STACK and put it in Register Pair A</div></div>
									<div class="assembly-row-combined"><div>11D8</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the "B" field spec and the number of significant digits (from Register Pair BC) to the STACK</div></div>
									<div class="assembly-row-combined"><div>11D9</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the number of trailing zeroes to print to the STACK</div></div>
									<div class="assembly-row-combined"><div>11DA-11DC</div><div><a href="#11DEH" class="memory-link">JP M,11DEH<span class="origrom2">JP M,FFXLV3</span></a><span class="opcode2">FA DE 11</span></div><div>Skip the next instruction (i.e., jump to 11DEH) if there are any trailing zeroes</div></div>
									<div class="assembly-row-combined"><div>11DD</div><div>XOR A<span class="opcode2">AF</span></div><div>Zero Register A and all status flags</div></div>
									<div class="assembly-row-combined" id="11DEH"><div>11DE<span class="origrom2">FFXLV3</span></div><div>CPL<span class="opcode2">2F</span></div><div>Make the trailing zero count posivite by inverting the value in Register A</div></div>
									<div class="assembly-row-combined"><div>11DF</div><div>INC A<span class="opcode2">3C</span></div><div>Bump the value in Register A so that it will be positive</div></div>
									<div class="assembly-row-combined"><div>11E0</div><div>ADD A,B<span class="opcode2">80</span></div><div>Set
 the decimal place count by adding the number of digits requested to the
 left of the decimal point in Register B to the adjusted value in 
Register A</div></div>
									<div class="assembly-row-combined"><div>11E1</div><div>INC A<span class="opcode2">3C</span></div><div>Bump the adjusted value in Register A</div></div>
									<div class="assembly-row-combined"><div>11E2</div><div>ADD A,D<span class="opcode2">82</span></div><div>Take
 into account if the sign is trailing by adding the value of the maximum
 length for the current number type in Register D (6 for single 
precision, 16 fo double precision) to the adjusted value in Register A</div></div>
									<div class="assembly-row-combined"><div>11E3</div><div>LD B,A<span class="opcode2">47</span></div><div>Copy Register A into Register B so that B holds the number of digits before the decimal point</div></div>
									<div class="assembly-row-combined"><div>11E4-11E5</div><div>LD C,00H<span class="opcode2">0E 00</span></div><div>Set the comma count to zero by loading Register C with zero (so that there are no commas)</div></div>
									<div class="assembly-row-combined"><div>11E6-11E8</div><div><a href="#12A4H" class="memory-link">CALL 12A4H<span class="origrom2">CALL FOUTCV</span></a><span class="opcode2">CD A4 12</span></div><div>GOSUB to 12A4H to convert the current value in ACCumulator to decimal digits</div></div>
									<div class="assembly-row-combined"><div>11E9</div><div>POP AF<span class="opcode2">F1</span></div><div>Get the number of #'s before from the STACK and put it in Register Pair AF</div></div>
									<div class="assembly-row-combined"><div>11EA-11EC</div><div><a href="#1271H" class="memory-link">CALL P,1271H<span class="origrom2">CALL P,FOTZNC</span></a><span class="opcode2">F4 71 12</span></div><div>GOSUB 1271H to put zeros into the trailing input buffer</div></div>
									<div class="assembly-row-combined"><div>11ED</div><div>POP BC<span class="opcode2">C1</span></div><div>Get the number of #'s before and the number of <span class="code">#</span>'s after from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>11EE</div><div>POP AF<span class="opcode2">F1</span></div><div>Get the C count (numbers before the decimal point) from the STACK and put it in Register Pair A and restore the FLAGS</div></div>
									<div class="assembly-row-combined"><div>11EF-11F1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#092FH">CALL Z,092FH<span class="origrom2">CALL Z,DCXHRT</span></a><span class="opcode2">CC 2F 09</span></div><div>If
 C = 0 then the last character was a decimal point, so ignore it via a 
GOSUB to 092FH to decrement the input buffer pointer in Register Pair HL
 if there are none</div></div>
									<div class="assembly-row-combined"><div>11F2</div><div>POP AF<span class="opcode2">F1</span></div><div>Get the exponent back from from the STACK and put it in Register Pair AF</div></div>
									<div class="assembly-row-combined"><div>11F3-11F4</div><div><a href="#11F8H" class="memory-link">JR C,11F8H<span class="origrom2">JR C,FFXLV2</span></a><span class="opcode2">38 03</span></div><div>If the number is zero, then the exponent is zero, so JUMP to 11F8H (to add the exponent) if the carry flag was set</div></div>
									<div class="assembly-row-combined"><div>11F5</div><div>ADD A,E<span class="opcode2">83</span></div><div>Otherwise, we need to scale the number - so first add the value in Register E to the value in Register A</div></div>
									<div class="assembly-row-combined"><div>11F6</div><div>SUB A,B<span class="opcode2">90</span></div><div>Subtract the number of digits to the left of the decimal point requested in Register B from the adjusted value in Register A</div></div>
									<div class="assembly-row-combined"><div>11F7</div><div>SUB A,D<span class="opcode2">92</span></div><div>Subtract the value in Register D from the value in Register A to get the size of the exponent</div></div>
									<div class="assembly-row-combined" id="11F8H"><div>11F8<span class="origrom2">FFXLV2</span></div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the "B" field spec to the STACK</div></div>
									<div class="assembly-row-combined"><div>11F9-11FB</div><div><a href="#1074H" class="memory-link">CALL 1074H<span class="origrom2">CALL FOFLDN</span></a><span class="opcode2">CD 74 10</span></div><div>Put the exponent into the buffer via a GOSUB to 1074H to figure the value of the exponent for the current value in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>11FC</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Swap
 DE and HL so that the pointer to the end of the buffer is put into 
Register Pair HL just in case we have a trailing sign we need to add.</div></div>
									<div class="assembly-row-combined"><div>11FD</div><div>POP DE<span class="opcode2">D1</span></div><div>Restore the "B" field spec into Register D in case we need to put on a trailing sign.</div></div>
									<div class="assembly-row-combined" id="1200H"><div>11FE-1200</div><div><a href="#10BFH" class="memory-link">JP 10BFH<span class="origrom2">JP FOUTTS</span></a><span class="opcode2">C3 BF 10</span></div><div>Jump to 10BFH to put on the trailing sign and finish up</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1201H">1201 - Test the magnitude of SP and DP numbers, and clear the times the value was scaled<span class="origrom"> - "FOUTNV"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will scale (normalize) the number in the 
accumulator so that all the digits are in the integer part (i.e., 
between 99,999 and 999,999).  The signed base 10 exponent is returned in
 Register A.  Registers D and E are unchanged.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1201H"><div>1201<span class="origrom2">FOUTNV</span></div><div>PUSH DE<span class="opcode2">D5</span></div><div>Save the value in Register Pair DE to the STACK.  We are going to pop this back at the end of the routine.</div></div>
									<div class="assembly-row-combined"><div>1202</div><div>XOR A<span class="opcode2">AF</span></div><div>Zero Register A, which will be the exponent</div></div>
									<div class="assembly-row-combined"><div>1203</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the exponent in Register Pair A to the STACK</div></div>
									<div class="assembly-row-combined"><div>1204</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H">RST 20H<span class="origrom2">GETYPE</span></a><span class="opcode2">E7</span></div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in 
ACCumulator and returns a combination of STATUS flags and unique numeric
 values in the A Register according to the data mode flag (40AFH).  The 
results are returned as follows:<br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>1205-1207</div><div><a href="#1222H" class="memory-link">JP PO,1222H<span class="origrom2">JP PO,FOUNDB</span></a><span class="opcode2">E2 22 12</span></div><div>If
 that test shows we have a SINGLE PRECISION number (through getting a 
Parity-Odd flag), jump to 1222H to handle.  Otherwise, pass through</div></div>
									<div class="assembly-row-combined" id="1208H"><div>1208-120A<span class="origrom2">FORBIG</span></div><div>LD A,(4124H)<span class="origrom2">LD A,(FAC)</span><span class="opcode2">3A 24 41</span></div><div>At
 this point we know we have a DOUBLE precision value.  Load Register A 
with the value of the exponent for the double precision value in 
ACCumulator</div></div>
									<div class="assembly-row-combined"><div>120B-120C</div><div>CP 91H<span class="opcode2">FE 91</span></div><div>Check
 to see if the double precision value in ACCumulator uses is less than 
1D5 (i.e., the integer portion of the double precision value)</div></div>
									<div class="assembly-row-combined"><div>120D-120F</div><div><a href="#1222H" class="memory-link">JP NC,1222H<span class="origrom2">P NC,FOUNDB</span></a><span class="opcode2">D2 22 12</span></div><div>If
 the double precision value in ACCumulator is not less than 1D5, then 
ship over the following multiplcation code and go to FOUNDB.</div></div>
									<div class="assembly-row-combined"><div>1210-1212</div><div>LD DE,1364H<span class="origrom2">LD DE,TENTEN</span><span class="opcode2">11 64 13</span></div><div>Load Register Pair DE with 1D10</div></div>
									<div class="assembly-row-combined"><div>1213-1215</div><div>LD HL,4127H<span class="origrom2">LD HL,ARGLO</span><span class="opcode2">21 27 41</span></div><div>In praration for VMOVE and DMULT, point HL to REG2</div></div>
									<div class="assembly-row-combined"><div>1216-1218</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09D3H">CALL 09D3H<span class="origrom2">CALL VMOVE</span></a><span class="opcode2">CD D3 09</span></div><div>GOSUB to 09D3H to move the double precision constant into REG2</div></div>
									<div class="assembly-row-combined"><div>1219-121B</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0DA1H">CALL 0DA1H<span class="origrom2">CALL DMULT</span></a><span class="opcode2">CD A1 0D</span></div><div>GOSUB
 to 0DA1H to call the DOUBLE PRECISION MULTIPLY routine at 0DA1H (which 
multiplies the double precision value in ACCumulator by the value in REG
 2. The product is left in ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>121C</div><div>POP AF<span class="opcode2">F1</span></div><div>Retrieve the original exponent from the STACK into Register A</div></div>
									<div class="assembly-row-combined"><div>121D-121E</div><div>SUB A,0AH<span class="opcode2">D6 0A</span></div><div>Subtract ten from the value in Register A to do a proper offset for an exponent</div></div>
									<div class="assembly-row-combined"><div>121F</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the adjusted exponent (held in Register A) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1220-1221</div><div><a href="#1208H" class="memory-link">JR 1208H<span class="origrom2">JR FORBIG</span></a><span class="opcode2">18 E6</span></div><div>Force it to be bigger via a JUMP to 1208H so as to loop until the integer portion exceeds 2e16</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1222H">1222 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUNDB"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>There is a big bug in this routine which was fixed in v1.2 of
 the ROM.  The fixing of that bug caused a renumbering from 1228H-124CH.
  The numbering here will show both.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1222H"><div>1222-1224<span class="origrom2">FOUNDB</span></div><div><a href="#124FH" class="memory-link">CALL 124FH<span class="origrom2">CALL FOUNVC</span></a><span class="opcode2">CD 4F 12</span></div><div>Check
 to see if the number in the ACCumulator is too big or too small via a 
GOSUB to 124FH to compare the current value in ACCumulator to 999999.5</div></div>
									<div class="assembly-row-combined" id="1225H"><div>1225<span class="origrom2">FOUNV1</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H">RST 20H<span class="origrom2">GETYPE</span></a><span class="opcode2">E7</span></div><div>In
 order to determine if the ACCumulator is big enough, we need to know 
what kind of value we have in the ACCumulator so call the TEST DATA MODE
 routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>  
The RST 20H routine determines the type of the current value in 
ACCumulator and returns a combination of STATUS flags and unique numeric
 values in the A Register according to the data mode flag (40AFH).  The 
results are returned as follows:<br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>1226-1228</div><div><a href="#1234H" class="memory-link">JP PE,1234H<span class="origrom2">JP PE,FOUNV4</span></a><span class="opcode2">EA 34 12</span></div><div>If that test shows we have a DOUBLE PRECISION or a STRING, jump to 1234H</div></div>
									<div class="assembly-row-combined"><div>*1226-1228</div><div><a href="#1233H" class="memory-link">JR NC,1233H</a></div><div>In ROM 1.2 this is a big bug fix.  Now if the shows we do NOT have a STRING, jump to 1233H</div></div>
									<p class="debug-note">The next two instructions load BCDE with 99999.95 so as to check to see if the number in FAC is too big.</p>
									<div class="assembly-row-combined"><div>1229-122B<br>*1228-122A</div><div>LD BC,9143H<span class="opcode2">01 43 91</span></div><div>Load Register Pair BC with the exponent and the MSB of a single precision constant</div></div>
									<div class="assembly-row-combined"><div>122C-122E<br>*122B-122D</div><div>LD DE,4FF9H<span class="opcode2">11 F9 4F</span></div><div>Load
 Register Pair DE with the NMSB and the LSB of a single precision 
constant. Register Pairs BC and DE are now equal to a single precision 
constant of 99,999.945</div></div>
									<div class="assembly-row-combined"><div>122F-1231<br>*122E-1230</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A0CH">CALL 0A0CH<span class="origrom2">CALL FCOMP</span></a><span class="opcode2">CD 0C 0A</span></div><div>GOSUB
 to routine at 0A0CH which algebraically compares the single precision 
value in BC/DE to the single precision value ACCumulator.<br>The results are stored in A as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Register A</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator = BCDE</td><td style="border: 1px solid black; padding: 8px;">00</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator &gt; BCDE</td><td style="border: 1px solid black; padding: 8px;">01</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator &lt; BCDE</td><td style="border: 1px solid black; padding: 8px;">FF</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>1232-1233</div><div><a href="#123AH" class="memory-link">JR 123AH<span class="origrom2">JR FOUNV5</span></a><span class="opcode2">18 06</span></div><div>Jump down two instructions to 123AH to test the results of the comparison</div></div>
									<div class="assembly-row-combined"><div>*1231-1232</div><div><a href="#123AH" class="memory-link">JR 1239H<span class="origrom2">JR FOUNV5</span></a></div><div>Jump down two instructions to 123AH to test the results of the comparison</div></div>
									<div class="assembly-row-combined" id="1234H"><div>1234-1236<span class="origrom2">FOUNV4</span><br>*1233-1235</div><div>LD DE,136CH<span class="origrom2">LD DE,FOUTDL</span><span class="opcode2">11 6C 13</span></div><div>Load Register Pair DE with the starting address of a double precision constant equal to 999,999,999,999,999.95</div></div>
									<div class="assembly-row-combined"><div>1237-1239<br>*1236-1238</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A49H">CALL 0A49H<span class="origrom2">CALL DCOMPD</span></a><span class="opcode2">CD 49 0A</span></div><div>Go
 compare the double precision constant pointed to by Register Pair DE to
 the double precision value in ACCumulator to see if the number is still
 too small</div></div>
									<div class="assembly-row-combined" id="123AH"><div>123A-123C<span class="origrom2">FOUNV5</span><br>1239-123B</div><div><a href="#124CH" class="memory-link">JP P,124CH<span class="origrom2">JP P,FOUNV3</span></a><span class="opcode2">F2 4C 12</span></div><div>If the number isn't too small anymore then we are done so JUMP to 124CH</div></div>
									<div class="assembly-row-combined" id="123AH"><div>*1239-123B<span class="origrom2">FOUNV5</span></div><div>JP P,124BH</div><div>If the number isn't too small anymore then we are done so JUMP to 124BH</div></div>
									<div class="assembly-row-combined"><div>123D<br>*123C</div><div>POP AF<span class="opcode2">F1</span></div><div>If
 we are here then the number is still too small so we will need to 
multiply it by 10.  Get the value of the scaled counter from the STACK 
and put it in Register Pair AF</div></div>
									<div class="assembly-row-combined"><div>123E-1240<br>*123D-123F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0F0BH">CALL 0F0BH<span class="origrom2">CALL FINMLT</span></a><span class="opcode2">CD 0B 0F</span></div><div>GOSUB to 0F0BH to multiply the current value in ACCumulator by ten</div></div>
									<div class="assembly-row-combined"><div>1241<br>*1240</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the exponent value (the negative of the number of times the value was multiplied) in Register Pair AF to the STACK.</div></div>
									<div class="assembly-row-combined"><div>1242-1243<br>1241-1242</div><div><a href="#1225H" class="memory-link">JR 1225H<span class="origrom2">JR FOUNV1</span></a><span class="opcode2">18 E1</span></div><div>Keep looping back to see if the number is big enough (i.e., between 999,999 and 99,999)</div></div>
									<div class="assembly-row-combined" id="1244H"><div>1244<br>*1243</div><div>POP AF<span class="opcode2">F1</span></div><div>At
 this point, the ACCumulator is too big.  First, fetch the exponent 
(i.e., the scaled count) from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>1245-1247<br>1244-1246</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0F18H">CALL 0F18H<span class="origrom2">CALL FINDIV</span></a><span class="opcode2">CD 18 0F</span></div><div>GOSUB to 0F18H to divide the current value in ACCumulator by ten</div></div>
									<div class="assembly-row-combined"><div>1248<br>1247</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the exponent to the STACK.  A is the count of the number of times it was divided</div></div>
									<div class="assembly-row-combined"><div>1249-124B<br>*1248-124A</div><div><a href="#124FH" class="memory-link">CALL 124FH<span class="origrom2">CALL FOUNVC</span></a><span class="opcode2">CD 4F 12</span></div><div>We need to see if the ACCumulator is small enough so GOSUB to 124FH to loop until the value in ACCumulator is &lt; 999,999</div></div>
									<div class="assembly-row-combined" id="124CH"><div>124C<span class="origrom2">FOUNV3</span><br>*124B</div><div>POP AF<span class="opcode2">F1</span></div><div>At this point, we are done scaling, so restore the exponent into Register A.  A = + times divided or - times multiplied</div></div>
									<div class="assembly-row-combined"><div>124D<br>124C</div><div>POP DE<span class="opcode2">D1</span></div><div>Restore DE from where it was preserved at the top of this routine</div></div>
									<div class="assembly-row-combined"><div>N/A<br>*124D</div><div>OR A</div><div>In ROM v1.2 sets the status flags.  This also realigns the memory addresses from changes to v1.2 ROM</div></div>
									<div class="assembly-row-combined"><div>124E</div><div>RET<span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="124FH">124F - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUNVC"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will see if the number in the ACCumulator is small enough yet</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>124F<span class="origrom2">FOUNVC</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H">RST 20H<span class="origrom2">GETYPE</span></a><span class="opcode2">E7</span></div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in 
ACCumulator and returns a combination of STATUS flags and unique numeric
 values in the A Register according to the data mode flag (40AFH).  The 
results are returned as follows:<br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>1250-1252</div><div><a href="#125EH" class="memory-link">JP PE,125EH<span class="origrom2">JP PE,FONVC1</span></a><span class="opcode2">EA 5E 12</span></div><div>If that test shows we have a DOUBLE PRECISION number, jump to 125EH</div></div>
									<p class="debug-note">The next two instructions load BCDE with 999999.5 to see if the number in the FAC is too large.</p>
									<div class="assembly-row-combined"><div>1253-1255</div><div>LD BC,9474H<span class="opcode2">01 74 94</span></div><div>Now
 that we know we have a single precision number, load Register Pair BC 
with the exponent and the MSB of a single precision constant</div></div>
									<div class="assembly-row-combined"><div>1256-1258</div><div>LD DE,23F8H<span class="opcode2">11 F8 23</span></div><div>Load
 Register Pair DE with the NMSB and the LSB of a single precision 
constant. Register Pairs BC and DE are now equal to a single precision 
constant of 999,999.5</div></div>
									<div class="assembly-row-combined"><div>1259-125B</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A0CH">CALL 0A0CH<span class="origrom2">CALL FCOMP</span></a><span class="opcode2">CD 0C 0A</span></div><div>Call
 the SINGLE PRECISION COMPARISON routine at routine at 0A0CH which 
algebraically compares the single precision value in BC/DE to the single
 precision value ACCumulator.<br>The results are stored in A as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Register A</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator = BCDE</td><td style="border: 1px solid black; padding: 8px;">00</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator &gt; BCDE</td><td style="border: 1px solid black; padding: 8px;">01</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator &lt; BCDE</td><td style="border: 1px solid black; padding: 8px;">FF</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>125C-125D</div><div><a href="#1264H" class="memory-link">JR 1264H<span class="origrom2">JR FONVC2</span></a><span class="opcode2">18 06</span></div><div>Jump to 1264H to test the result of the comparison</div></div>

									<div class="assembly-row-combined" id="125EH"><div>125E-1260<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;FONVC1</span></div><div>LD DE,1374H<span class="origrom2">LD DE,FOUTDU</span><span class="opcode2">11 74 13</span></div><div>If
 we are here, then we have a DOUBLE PRECISION number to deal with, so 
start by loading Register Pair DE with the starting address of a double 
precision constant equal to 9,999,999,999,999,999.5</div></div>
									<div class="assembly-row-combined"><div>1261-1263</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A49H">CALL 0A49H<span class="origrom2">CALL DCOMPD</span></a><span class="opcode2">CD 49 0A</span></div><div>Check
 to see if the number is too big via a GOSUB to 0A49H to compare the 
double precision constant pointed to by Register Pair DE to the double 
precision value in ACCumulator</div></div>
									<div class="assembly-row-combined" id="1264H"><div>1264<span class="origrom2">FONVC2</span></div><div>POP HL<span class="opcode2">E1</span></div><div>Get the return address from the STACK and put it in Register Pair HL so we can go to 1244H</div></div>
									<div class="assembly-row-combined"><div>1265-1267</div><div><a href="#1244H" class="memory-link">JP P,1244H<span class="origrom2">JP P,FOUNV2</span></a><span class="opcode2">F2 44 12</span></div><div>If
 the P FLAG is set, then the number is still too big (i.e., the number 
in the ACCumulator has more than 6 digits in the integer portion), so 
JUMP to 1244H</div></div>
									<div class="assembly-row-combined"><div>*1265-1267</div><div><a href="#1243H" class="memory-link">JP P,1243H</a></div><div>In ROM v1.2 the ROM addresses had moved 1 byte</div></div>
									<div class="assembly-row-combined"><div>1268</div><div>JP (HL)<span class="opcode2">E9</span></div><div>If the number isn't too big, then just RETurn by JUMPing to (HL)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1269H">1269H - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOTZER"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine puts leading zeroes into the input buffer.  The 
count is held in Register A and it can be zero, but the Z FLAG needs to 
be set in that case.  Only (HL) and Register A are affected.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1269H"><div>1269<span class="origrom2">FOTZER</span></div><div>OR A<span class="opcode2">B7</span></div><div>This is the entry point from FFXXV3 where the flags have not yet been set, so set the flags, particularly the Z FLAG</div></div>
									<div class="assembly-row-combined" id="126AH"><div>126A<span class="origrom2">FOTZR1</span></div><div>RET Z<span class="opcode2">C8</span></div><div>Top of a loop.  If the number of 0's we need to display is zero, then just RETurn</div></div>
									<div class="assembly-row-combined"><div>126B</div><div>DEC A<span class="opcode2">3D</span></div><div>Decrement the value in Register A to show that an ASCII zero was moved to the print buffer</div></div>
									<div class="assembly-row-combined"><div>126C-126D</div><div>LD (HL),30H<span class="origrom2">LD (HL),"0"</span><span class="opcode2">36 30</span></div><div>Save a <span class="code">0</span> at the location of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>126E</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>126F-1270</div><div><a href="#126AH" class="memory-link">JR 126AH<span class="origrom2">JR FOTZR1</span></a><span class="opcode2">18 F9</span></div><div>Jump back to 126AH until the number in Register A of ASCII zeroes were moved</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1271H">1271 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOTZNC"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will put zeroes in the buffer along with commans
 or a decimal point in the middle.  The count is held in Register A and 
it can be zero, but the Z FLAG needs to be set in that case.  Registers B
 (decimal point count) and C (comma count) are updated accordingly.  
Everything but DE is affected.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1271H"><div>1271-1272<span class="origrom2">FOTZNC</span></div><div><a href="#1277H" class="memory-link">JR NZ,1277H<span class="origrom2">JR NZ,FOTZEC</span></a><span class="opcode2">20 04</span></div><div>So long as we are adding zeroes, Jump to 1277H</div></div>
									<div class="assembly-row-combined" id="1273H"><div>1273<span class="origrom2">FOTZRC</span></div><div>RET Z<span class="opcode2">C8</span></div><div>Top of a loop.  If there are no more zeroes to add, RETurn</div></div>
									<div class="assembly-row-combined"><div>1274-1276</div><div><a href="#1291H" class="memory-link">CALL 1291H<span class="origrom2">CALL FOUTED</span></a><span class="opcode2">CD 91 12</span></div><div>Check to see if we need to insert a comma or a decimal prior to the zero at the current positiuon via a GOSUB to FOUTED</div></div>
									<div class="assembly-row-combined" id="1277H"><div>1277-1278<span class="origrom2">FOTZEC</span></div><div>LD (HL),30H<span class="origrom2">LD (HL),"0"</span><span class="opcode2">36 30</span></div><div>Save a <span class="code">0</span> at the location of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1279</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>127A</div><div>DEC A<span class="opcode2">3D</span></div><div>Decrement the counter of trailing zeroes to add in Register A</div></div>
									<div class="assembly-row-combined"><div>127B-127C</div><div><a href="#1273H" class="memory-link">JR 1273H<span class="origrom2">JR FOTZRC</span></a><span class="opcode2">18 F6</span></div><div>Loop back and keep looping until the number of zeroes to add is 0.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="127DH">127D - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUTCD"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will put a possible comma count into Register C 
and will zero Register C if we are not using commas in the 
specification.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>127D<span class="origrom2">FOUTCD</span></div><div>LD A,E<span class="opcode2">7B</span></div><div>The
 next bunch of math is to set up the decimal point count.  First, load 
Register A with the value in Register E so that A holds the decimal 
point countcount of the times the value was scaled up or down</div></div>
									<div class="assembly-row-combined"><div>127E</div><div>ADD A,D<span class="opcode2">82</span></div><div>Add the number of digits to print (from Register D) to the value in Register A</div></div>
									<div class="assembly-row-combined"><div>127F</div><div>INC A<span class="opcode2">3C</span></div><div>Bump the adjusted value in Register A so now A holds the number of digits before the decimal point</div></div>
									<div class="assembly-row-combined"><div>1280</div><div>LD B,A<span class="opcode2">47</span></div><div>Load Register B with the leading digit count (from Register A)</div></div>
									<div class="assembly-row-combined"><div>1281</div><div>INC A<span class="opcode2">3C</span></div><div>Next, we are going to set up the comma count.  First bump the value in Register A so not A holds the leading digits + 2</div></div>
									<div class="assembly-row-combined" id="1282H"><div>1282-1283<span class="origrom2">FOTCD1</span></div><div>SUB A,03H<span class="opcode2">D6 03</span></div><div>Subtract three from the adjusted value in Register A which, when combined with the next instruction as a loop, divides modulo 3</div></div>
									<div class="assembly-row-combined"><div>1284-1285</div><div><a href="#1282H" class="memory-link">JR NC,1282H<span class="origrom2">JR NC,FOTCD1</span></a><span class="opcode2">30 FC</span></div><div>Loop back 1 instruction until the value in Register A is -1, -2, or -3</div></div>
									<div class="assembly-row-combined"><div>1286-1287</div><div>ADD A,05H<span class="opcode2">C6 05</span></div><div>Add 5 (which is 3 back plus 2 more for scaling) to A to get a positive remainder.  This will give 4, 3, or 2 as the comma count</div></div>
									<div class="assembly-row-combined"><div>1288</div><div>LD C,A<span class="opcode2">4F</span></div><div>Save the possible comma count into Register A</div></div>
									<div class="assembly-row-combined" id="1289H"><div>1289-128B<span class="origrom2">FOUICC</span></div><div>LD A,(40D8H)<span class="origrom2">LD A,(TEMP3)</span><span class="opcode2">3A D8 40</span></div><div>Load Register A with the format specs from the temporary storage location</div></div>
									<div class="assembly-row-combined"><div>128C-128D</div><div>AND 40H<span class="origrom2">AND 0100 0000</span><span class="opcode2">E6 40</span></div><div>Mask against 0100 0000 to isolate the comma bit to see if commas are requested</div></div>
									<div class="assembly-row-combined"><div>128E</div><div>RET NZ<span class="opcode2">C0</span></div><div>If the NZ FLAG is set then we are using commas, so just RETurn</div></div>
									<div class="assembly-row-combined" id="128FH"><div>128F</div><div>LD C,A<span class="opcode2">4F</span></div><div>If we are here, then we aren't using commas, so Zero the comma counter in Register C</div></div>
									<div class="assembly-row-combined" id="1290H"><div>1290</div><div>RET<span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1291H">1291 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUTED"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will put decimal points and commas in their 
correct places.  This subroutine should be called before the next digit 
is put in the buffer.  Register B = the decimal point count and Register
 C = the comma count.<br><br> The counts tell how many more digits have to go in before the comma ;or decimal point go in.  <br><br>
 The comma or decimal point then goes before the last digit in the 
count.  For example, if the decimal point should come after the first 
digit, the decimal point count should be 2.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1291H"><div>1291<span class="origrom2">FOUTED</span></div><div>DEC B<span class="opcode2">05</span></div><div>First
 we need to test to see if it is time to put in a decimal point.  To do 
this, we DECrement the decimal point counter in Register B to see if the
 zero flag sets or not</div></div>
									<div class="assembly-row-combined"><div>1292-1293</div><div><a href="#129CH" class="memory-link">JR NZ,129CH<span class="origrom2">JR NZ,FOUED1</span></a><span class="opcode2">20 08</span></div><div>If the decimal point position hasn't been reached then JUMP to FOUED1 to see if a comma needs to go there.</div></div>
									<div class="assembly-row-combined" id="1294H"><div>1294-1295<span class="origrom2">FOUTDP</span></div><div>LD (HL),2EH<span class="origrom2">LD (HL),"."</span><span class="opcode2">36 2E</span></div><div>If
 we are here, then the decimal point time has come.  Save a decimal 
point at the location of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1296-1298</div><div>LD (40F3H),HL<span class="origrom2">LD (TEMP2),HL</span><span class="opcode2">22 F3 40</span></div><div>Save the address of the decimal point position (held in Register Pair HL).<br>Note: 40F3H-40F4H is a temporary storage location</div></div>
									<div class="assembly-row-combined"><div>1299</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>129A</div><div>LD C,B<span class="opcode2">48</span></div><div>We just put in a decimal point, so we KNOW we don't need to put a comma here, so ZERO out the comma counter</div></div>
									<div class="assembly-row-combined"><div>129B</div><div>RET<span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="129CH">129C - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUED1"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Part of the above routine, jumped here to test to see if a comma needs to be placed at (HL).</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>129C<span class="origrom2">FOUED1</span></div><div>DEC C<span class="opcode2">0D</span></div><div>First, we need to test to see if it is time to put in a comma by DECrementing the comma counter in Register C</div></div>
									<div class="assembly-row-combined"><div>129D</div><div>RET NZ<span class="opcode2">C0</span></div><div>If the NZ FLAG is set, then we are not putting in a comma, so RETurn</div></div>
									<div class="assembly-row-combined"><div>129E-129F</div><div>LD (HL),2CH<span class="origrom2">LD (HL),","</span><span class="opcode2">36 2C</span></div><div>If
 didn't jump out, then we need a comma here so put a comma (which is 
ASCII code 2CH) at the location of the input buffer pointer in Register 
Pair HL</div></div>
									<div class="assembly-row-combined"><div>12A0</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the input buffer pointer (to account for the new comma) in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>12A1-12A2</div><div>LD C,03H<span class="opcode2">0E 03</span></div><div>Reset the comma counter by setting it to 3 (since commas come after units of 3 numbers)</div></div>
									<div class="assembly-row-combined"><div>12A3</div><div>RET<span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="12A4H">12A4 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUTCV"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will convert a SINGLE PRECISION or a DOUBLE 
PRECISION number that has been normalized to decimal digits.  The 
decimal point count is in Register B and the comma count is in Register 
C.  (HL) points to where the first digit will go.  Routine will exit 
with A=0.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>12A4<span class="origrom2">FOUTCV</span></div><div>PUSH DE<span class="opcode2">D5</span></div><div>Generally preserve Register Pair DE.  This will get POPped when the subroutine is done.</div></div>
									<div class="assembly-row-combined"><div>12A5</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H">RST 20H<span class="origrom2">GETYPE</span></a><span class="opcode2">E7</span></div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in 
ACCumulator and returns a combination of STATUS flags and unique numeric
 values in the A Register according to the data mode flag (40AFH).  The 
results are returned as follows:<br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>12A6-12A8</div><div><a href="#12EAH" class="memory-link">JP PO,12EAH<span class="origrom2">JP PO,FOUTCS</span></a><span class="opcode2">E2 EA 12</span></div><div>If
 we have a single precision number (by the Parity Odd flag being set) 
JUMP to 12EAH to convert a SINGLE precision number into its INTEGER 
equivalent)</div></div>
									<div class="assembly-row-combined"><div>12A9</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Now that we know we have a DOUBLE PRECISION number, save decimal/comma count (in Register Pair BC) to the STACK</div></div>
									<div class="assembly-row-combined"><div>12AA</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the buffer address (in Register Pair HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>12AB-12AD</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09FCH">CALL 09FCH<span class="origrom2">CALL VMOVAF</span></a><span class="opcode2">CD FC 09</span></div><div>GOSUB to 09FCH to mmove the double precision value in ACCumulator to REG2</div></div>
									<div class="assembly-row-combined"><div>12AE-12B0</div><div>LD HL,137CH<span class="origrom2">LD HL,DHALF</span><span class="opcode2">21 7C 13</span></div><div>Load Register Pair HL with the starting address of a double precision constant equal to 0.5D0</div></div>
									<div class="assembly-row-combined"><div>12B1-12B3</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09F7H">CALL 09F7H<span class="origrom2">CALL VMOVFM</span></a><span class="opcode2">CD F7 09</span></div><div>GOSUB to 09F7H to move 0.5D0 to the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>12B4-12B6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0C77H">CALL 0C77H<span class="origrom2">CALL DADD</span></a><span class="opcode2">CD 77 0C</span></div><div>Call
 the DOUBLE PRECISION ADD function (which adds the double precision 
value in REG 2 to the value in ACCumulator (which is the constant 
0.5D0).  Result is left in ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>12B7</div><div>XOR A<span class="opcode2">AF</span></div><div>Zero Register A and clear the status flags; particularly the CARRY FLAG</div></div>
									<div class="assembly-row-combined"><div>12B8-12BA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0B7BH">CALL 0B7BH<span class="origrom2">CALL DINTFO</span></a><span class="opcode2">CD 7B 0B</span></div><div>Isolate the integer part of the double precision number via a GOSUB to 0B7BH</div></div>
									<div class="assembly-row-combined"><div>12BB</div><div>POP HL<span class="opcode2">E1</span></div><div>Restore the buffer address from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>12BC</div><div>POP BC<span class="opcode2">C1</span></div><div>Restore the decimal and comma counters from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>12BD-12BF</div><div>LD DE,138CH<span class="origrom2">LD DE,FODTBL</span><span class="opcode2">11 8C 13</span></div><div>Load
 Register Pair DE with the starting address of a series of double 
precision constants (i.e., a table of powers of 10 from 1.0x10E15 - 
1.0x10E6) for the binary to ASCII conversion</div></div>
									<div class="assembly-row-combined"><div>12C0-12C1</div><div>LD A,0AH<span class="opcode2">3E 0A</span></div><div>We
 are going to want to convert ten digits, so load Register A with the 
number of times to divide the double precision value in ACCumulator by a
 power of 10</div></div>
									<p class="debug-note">Top of a loop to convert the next digit.  It is executed "A" times.</p>
									<div class="assembly-row-combined" id="12C2H"><div>12C2-12C4<span class="origrom2">FOUCD1</span></div><div><a href="#1291H" class="memory-link">CALL 1291H<span class="origrom2">CALL FOUTED</span></a><span class="opcode2">CD 91 12</span></div><div>Check to see if we need to put in a decimal point or a comma at the location pointed to by HL via a GOSUB to 1291H</div></div>
									<div class="assembly-row-combined"><div>12C5</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save
 the count of digits before the decimal point and the count of digts 
after the decimal point (stored in Register Pair BC) to the STACK</div></div>
									<div class="assembly-row-combined"><div>12C6</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the number of digits to process / division count (stored in Register Pair A) to the STACK</div></div>
									<div class="assembly-row-combined"><div>12C7</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the current buffer address (stored in Register Pair HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>12C8</div><div>PUSH DE<span class="opcode2">D5</span></div><div>Save the address of the power of 10 table (stored in Register Pair DE) to the STACK</div></div>
									<div class="assembly-row-combined"><div>12C9-12CA</div><div>LD B,2FH<span class="origrom2">LD B,"0"-1</span><span class="opcode2">06 2F</span></div><div>Load
 Register B (which will be the quotient in ASCII for each division) with
 the ASCII value for a zero character minus one since the loop which 
follows starts by INCrementing the value</div></div>
									<div class="assembly-row-combined" id="12CBH"><div>12CB<span class="origrom2">FOUCD2</span></div><div>INC B<span class="opcode2">04</span></div><div>Top of a loop.  Bump the ASCII value for the digit in Register B so as to start with ASCII "0"</div></div>
									<div class="assembly-row-combined"><div>12CC</div><div>POP HL<span class="opcode2">E1</span></div><div>Get the address of the power of 10 table (i.e., the divisor) from the STACK and put it in Register Pair HL and </div></div>
									<div class="assembly-row-combined"><div>12CD</div><div>PUSH HL<span class="opcode2">E5</span></div><div>.... put it right back into the STACK so that it can be restored during the loop</div></div>
									<div class="assembly-row-combined"><div>12CE-12D0</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0D48H">CALL 0D48H<span class="origrom2">CALL DADDFS</span></a><span class="opcode2">CD 48 0D</span></div><div>GOSUB
 to 0D48H to subtract the double precision value pointed to by Register 
Pair HL from the double precision value in REG l.  This is to divide the
 current integer value by of a power of 10 starting at 10e15 working its
 way down to 10e6 in a loop until the remainder is less than the current
 power)</div></div>
									<div class="assembly-row-combined"><div>12D1-12D2</div><div><a href="#12CBH" class="memory-link">JR NC,12CBH<span class="origrom2">JR NC,FOUCD2</span></a><span class="opcode2">30 F8</span></div><div>Jump
 back to do another subtraction and keep looping until the Carry flag 
gets set by the subtraction (meaning that the remainder is now less than
 the current power)</div></div>
									<div class="assembly-row-combined"><div>12D3</div><div>POP HL<span class="opcode2">E1</span></div><div>If
 we are here because the C FLAG fired, then we have subtracted once too 
many times.  So we need to un-subtract once.  To do that we first need 
to get the address of the power table from the STACK and put it in 
Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>12D4-12D6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0D36H">CALL 0D36H<span class="origrom2">CALL DADDFO</span></a><span class="opcode2">CD 36 0D</span></div><div>GOSUB
 to 0D36H to add the double precision value pointed to by Register Pair 
HL (which is the table of powers of 10) to the double precision 
remainder in ACCumulator to make it a positive value. Return with the 
correct remainder in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>12D7</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Swap DE and HL so that th eopoert of ten pointer is now in DE.</div></div>
									<div class="assembly-row-combined"><div>12D8</div><div>POP HL<span class="opcode2">E1</span></div><div>Get the current buffer address from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>12D9</div><div>LD (HL),B<span class="opcode2">70</span></div><div>Save the ASCII value for the digit in Register B at the location of the input buffer pointer (stored in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>12DA</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the buffer pointer in Register Pair HL since we have just put a digit there</div></div>
									<div class="assembly-row-combined"><div>12DB</div><div>POP AF<span class="opcode2">F1</span></div><div>Get the loop counter back into Register A</div></div>
									<div class="assembly-row-combined"><div>12DC</div><div>POP BC<span class="opcode2">C1</span></div><div>Get the decimal point and comma counter from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>12DD</div><div>DEC A<span class="opcode2">3D</span></div><div>Decrement the loop counter value in Register A (we are going to loop 10 times)</div></div>
									<div class="assembly-row-combined"><div>12DE-12DF</div><div><a href="#12C2H" class="memory-link">JR NZ,12C2H<span class="origrom2">JR NZ,FOUCD1</span></a><span class="opcode2">20 E2</span></div><div>Loop 10 times until the ASCII string has been figured</div></div>
									<div class="assembly-row-combined"><div>12E0</div><div>PUSH BC<span class="opcode2">C5</span></div><div>At
 this point, we have finished printing the last digit, so now we want to
 convert the remaining digits using single precision routines (which are
 faster).  First, save the decimal and comma counters (stored in 
Register Pair BC) to the STACK</div></div>
									<div class="assembly-row-combined"><div>12E1</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the input buffer pointer (stored in Register Pair HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>12E2-12E4</div><div>LD HL,411DH<span class="origrom2">LD HL,DFACLO</span><span class="opcode2">21 1D 41</span></div><div>Point HL to the remaining digits for processing as a single precision number</div></div>
									<div class="assembly-row-combined"><div>12E5-12E7</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09B1H">CALL 09B1H<span class="origrom2">CALL MOVRM</span></a><span class="opcode2">CD B1 09</span></div><div>Move the numbers that are left to ACCumulator via a GOSUB to MOVRM</div></div>
									<div class="assembly-row-combined"><div>12E8-12E9</div><div><a href="#12F6H" class="memory-link">JR 12F6H<span class="origrom2">JR FOUCDC</span></a><span class="opcode2">18 0C</span></div><div>Jump to 12F6H to convert that last half to ASCII</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="12EAH">12EA - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUTCS"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine is to convert a SINGLE precision value to an 
INTEGER which will be the decimal digits.  Divide the integer equivalent
 by 100,000 and 10,000.  Use the code at 1335H to convert the last 1000 
to ASCII.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="12EAH"><div>12EA<span class="origrom2">FOUTCS</span></div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the decimal/comma count (in Register Pair BC) to the STACK</div></div>
									<div class="assembly-row-combined"><div>12EB</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the buffer pointer (stored in Register Pair HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>12EC-12EE</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0708H">CALL 0708H<span class="origrom2">CALL FADDH</span></a><span class="opcode2">CD 08 07</span></div><div>Round
 the number to the nearest integer via a GOSUB to 0708H which will add a
 single precision value of 0.5 to the single precision value in 
ACCumulator.  The result is stored in BC/DE</div></div>
									<div class="assembly-row-combined"><div>12EF</div><div>INC A<span class="opcode2">3C</span></div><div>When
 a number is positive and non-zero, a FADDH call to round will always 
exit with the HIGH ORDER of 0 in Register A.  So we add 1 to force A to 
be non-zero.</div></div>
									<div class="assembly-row-combined"><div>12F0-12F2</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0AFBH">CALL 0AFBH<span class="origrom2">CALL QINT</span></a><span class="opcode2">CD FB 0A</span></div><div>GOSUB to 0AFBH to convert the positive single precision value in ACCumulator to an integer.  The result is stored in C/D/E</div></div>
									<div class="assembly-row-combined"><div>12F3-12F5</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09B4H">CALL 09B4H<span class="origrom2">CALL MOVFR</span></a><span class="opcode2">CD B4 09</span></div><div>Save the C/D/E number into the ACCumulator via a GOSUB to MOVFR</div></div>
									<div class="assembly-row-combined" id="12F6H"><div>12F6<span class="origrom2">FOUCDC</span></div><div>POP HL<span class="opcode2">E1</span></div><div>Get the current buffer pointer value from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>12F7</div><div>POP BC<span class="opcode2">C1</span></div><div>Get the decimal/comma count value from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>12F8</div><div>XOR A<span class="opcode2">AF</span></div><div>Clear the CARRY FLAG, which is our flag to calculate two digits</div></div>
									<div class="assembly-row-combined"><div>12F9-12FB</div><div>LD DE,13D2H<span class="origrom2">LD DE,FOSTBL</span><span class="opcode2">11 D2 13</span></div><div>Load
 Register Pair DE with the starting address for a series of integer 
values (in this case, 100,000) and then fall through to FOUCS1</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="12FCH">12FC - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUCS1"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine is to calculate the next digit of the number.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>12FC<span class="origrom2">FOUCS1</span></div><div>CCF<span class="opcode2">3F</span></div><div>Complement the Carry flag, which tracks when we are done with the division loop of 12FC-1327H</div></div>
									<div class="assembly-row-combined"><div>12FD-12FF</div><div><a href="#1291H" class="memory-link">CALL 1291H<span class="origrom2">CALL FOUTED</span></a><span class="opcode2">CD 91 12</span></div><div>Check to see if we need to put a decimal point or a comma before the current number via GOSUB to FOUTED</div></div>
									<div class="assembly-row-combined" id="1300H"><div>1300</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the decimal and comma counter (stored in Register Pair BC) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1301</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the carry flag (which acts as our digit count for the count of the number of times through this loop) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1302</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the current buffer pointer value (stored in Register Pair HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1303</div><div>PUSH DE<span class="opcode2">D5</span></div><div>Save the power of 10 table pointer (stored in Register Pair DE) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1304-1306</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09BFH">CALL 09BFH<span class="origrom2">CALL MOVRF</span></a><span class="opcode2">CD BF 09</span></div><div>Loads the SINGLE PRECISION value in ACCumulator into Register Pair BC/DE via A GOSUB to MOVRF.</div></div>
									<div class="assembly-row-combined"><div>1307</div><div>POP HL<span class="opcode2">E1</span></div><div>Get the power of 10 table address (the integer value for 100,000) from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1308-1309</div><div>LD B,2FH<span class="origrom2">LD B,"0"-1</span><span class="opcode2">06 2F</span></div><div>Set B to be the next digit to print.  Since the next step INCremenets B, we need to start off with B one too low.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="130AH">130A - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUCS2"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine divides the integer portion of the current value
 by 100,000 using compound subtraction.  The quotient is kept in 
Register B as an ASCII value.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>130A<span class="origrom2">FOUCS2</span></div><div>INC B<span class="opcode2">04</span></div><div>Bump the ASCII value from the digit in Register B to increase the ASCII value from 0 and upward</div></div>
									<div class="assembly-row-combined"><div>130B</div><div>LD A,E<span class="opcode2">7B</span></div><div>Load Register A with the Low Order/LSB of the single precision value in Register E</div></div>
									<div class="assembly-row-combined"><div>130C</div><div>SUB (HL)<span class="opcode2">96</span></div><div>Subtract
 the value at the location of the memory pointer in Register Pair HL 
(the LSB of 100,000) from the value of the LSB of the single precision 
value in Register A</div></div>
									<div class="assembly-row-combined"><div>130D</div><div>LD E,A<span class="opcode2">5F</span></div><div>Load Register E with the adjusted LSB of the single precision value in Register A</div></div>
									<div class="assembly-row-combined"><div>130E</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL to the next digit of 100,000</div></div>
									<div class="assembly-row-combined"><div>130F</div><div>LD A,D<span class="opcode2">7A</span></div><div>Load Register A with the Middle Order/NMSB of the single precision value in Register D</div></div>
									<div class="assembly-row-combined"><div>1310</div><div>SBC A,(HL)<span class="opcode2">9E</span></div><div>Subtract
 the value at the location of the memory pointer in Register Pair HL 
(the middle byte of 100,000) from the value of the NMSB of the single 
precision value in Register A</div></div>
									<div class="assembly-row-combined"><div>1311</div><div>LD D,A<span class="opcode2">57</span></div><div>Load Register D with the adjusted NMSB of the single precision value in Register A</div></div>
									<div class="assembly-row-combined"><div>1312</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL to the MSB of 100,000</div></div>
									<div class="assembly-row-combined"><div>1313</div><div>LD A,C<span class="opcode2">79</span></div><div>Load Register A with the High Order/MSB of the single precision value in Register C</div></div>
									<div class="assembly-row-combined"><div>1314</div><div>SBC A,(HL)<span class="opcode2">9E</span></div><div>Subtract
 the value at the location of the memory pointer in Register Pair HL 
from the value of the MSB of 100,000 (a single precision value in 
Register A)</div></div>
									<div class="assembly-row-combined"><div>1315</div><div>LD C,A<span class="opcode2">4F</span></div><div>Load Register C with the adjusted MSB of the single precision value in Register A</div></div>
									<div class="assembly-row-combined"><div>1316</div><div>DEC HL<span class="opcode2">2B</span></div><div>Decrement the value of the memory pointer in Register Pair HL to the NMSB of 100,000</div></div>
									<div class="assembly-row-combined"><div>1317</div><div>DEC HL<span class="opcode2">2B</span></div><div>Decrement the value of the memory pointer in Register Pair HL again, now to the LSB of 100,000</div></div>
									<div class="assembly-row-combined"><div>1318-1319</div><div><a href="#130AH" class="memory-link">JR NC,130AH<span class="origrom2">JR NC,FOUCS2</span></a><span class="opcode2">30 F0</span></div><div>Loop until the ASCII value for the digit under 100,000 has been figured</div></div>
									<div class="assembly-row-combined"><div>131A-131C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#07B7H">CALL 07B7H<span class="origrom2">CALL FADDA</span></a><span class="opcode2">CD B7 07</span></div><div>We
 need to add 100,000 to C/D/E and make it positive so we GOSUB to 07B7H 
to add the value at the location of the memory pointer in Register Pair 
HL to the value in Register Pairs BC and DE</div></div>
									<div class="assembly-row-combined"><div>131D</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL to now point to the 10,000 constant</div></div>
									<div class="assembly-row-combined"><div>131E-1320</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09B4H">CALL 09B4H<span class="origrom2">CALL MOVFR</span></a><span class="opcode2">CD B4 09</span></div><div>Save the remainder as a current value by GOSUB to 09B4H (which moves the SINGLE PRECISION value in DC/DE into ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>1321</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Load
 Register Pair DE with the address of the next value to divide the 
current value in ACCumulator by (which is the constant of 10,000)</div></div>
									<div class="assembly-row-combined"><div>1322</div><div>POP HL<span class="opcode2">E1</span></div><div>Get the value of the memory pointer from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1323</div><div>LD (HL),B<span class="opcode2">70</span></div><div>Save the ASCII value for the digit in Register B at the location of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1324</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1325</div><div>POP AF<span class="opcode2">F1</span></div><div>Get the carry flag from the STACK and put it in Register Pair AF</div></div>
									<div class="assembly-row-combined"><div>1326</div><div>POP BC<span class="opcode2">C1</span></div><div>Get the value from the STACK and put it in Register Pair BC so it can be saved later</div></div>
									<div class="assembly-row-combined"><div>1327-1328</div><div><a href="#12FCH" class="memory-link">JR C,12FCH<span class="origrom2">JR C,FOUCS1</span></a><span class="opcode2">38 D3</span></div><div>If the carry flag is set, then reset it and loop the dividing by 10,000 until the integer portion is found</div></div>
									<div class="assembly-row-combined"><div>1329</div><div>INC DE<span class="opcode2">13</span></div><div>If
 we fall through to here, we have divided the integer part of the single
 precision variable by 100,000 and then by 10,000 with the remainder 
being positive and saved as the current value.  With this we bump the 
value of the memory pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>132A</div><div>INC DE<span class="opcode2">13</span></div><div>and again bump the value of the memory pointer in Register Pair DE, so now DE points to the constant 1,000</div></div>
									<div class="assembly-row-combined"><div>132B-132C</div><div>LD A,04H<span class="opcode2">3E 04</span></div><div>Load Register A with the number of digits for the ASCII string to be figured</div></div>
									<div class="assembly-row-combined"><div>132D-132E</div><div><a href="#1335H" class="memory-link">JR 1335H<span class="origrom2">JR FOUCI1</span></a><span class="opcode2">18 06</span></div><div>Jump to 1335H to convert the remainder to 4 ASCII digits.  Note that the CARRY FLAG will be off.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="132FH">132F - This routine will convert an INTEGER to ASCII<span class="origrom"> - "FOUTCI"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine converts an integer into decimal digits by 
dividing the integer portion of the current value by 100,000 using 
compound subtraction.  The quotient is kept in Register B as an ASCII 
value and A=0 on exit.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="132FH"><div>132F<span class="origrom2">FOUTCI</span></div><div>PUSH DE<span class="opcode2">D5</span></div><div>Generally preserve DE.  This will be POPped just before the RETurn</div></div>
									<div class="assembly-row-combined"><div>1330-1332</div><div>LD DE,13D8H<span class="origrom2">LD DE,FOITBL</span><span class="opcode2">11 D8 13</span></div><div>Load Register Pair DE with the starting address of the descending powers of 10 starting at 10,000</div></div>
									<div class="assembly-row-combined"><div>1333-1334</div><div>LD A,05H<span class="opcode2">3E 05</span></div><div>Load Register A with the number of digits for the ASCII string to be built (i.e., 5 since the maximum positive integer is 32768)</div></div>
									<div class="assembly-row-combined" id="1335H"><div>1335-1337<span class="origrom2">FOUCI1</span></div><div><a href="#1291H" class="memory-link">CALL 1291H<span class="origrom2">CALL FOUTED</span></a><span class="opcode2">CD 91 12</span></div><div>Top
 of the big loop.  Check to see if a decimal point or comma needs to be 
placed before the digit being processed via a GOSUB to FOUTED</div></div>
									<div class="assembly-row-combined"><div>1338</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the decimal and comma counter (stored in Register Pair BC) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1339</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the number of digits-to-process counter (stored in Register A) to the STACK</div></div>
									<div class="assembly-row-combined"><div>133A</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the address of the power table (stored in Register Pair HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>133B</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Load Register Pair HL with the starting address of the descending powers of 10 starting at 10,000 (stored in Register Pair DE)</div></div>
									<div class="assembly-row-combined"><div>133C</div><div>LD C,(HL)<span class="opcode2">4E</span></div><div>Load Register C with the LSB for the power of 10 stored in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>133D</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL to be the MDB of the power of 10</div></div>
									<div class="assembly-row-combined"><div>133E</div><div>LD B,(HL)<span class="opcode2">46</span></div><div>Load Register B with the MSB for the integer value at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>133F</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the integer value of the power of 10 in Register Pair BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>1340</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL to the next value in the power of 10 table</div></div>
									<div class="assembly-row-combined"><div>1341</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Swap (SP) and HL so that the pointer to the power of 10 table is in the STACK and the power of ten is in HL</div></div>
									<div class="assembly-row-combined"><div>1342</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Put the power of ten into DE</div></div>
									<div class="assembly-row-combined"><div>1343-1345</div><div>LD HL,(4121H)<span class="origrom2">LD HL,(FACLO)</span><span class="opcode2">2A 21 41</span></div><div>Load Register Pair HL with the integer value in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>1346-1347</div><div>LD B,2FH<span class="origrom2">LD B,"0" - 1</span><span class="opcode2">06 2F</span></div><div>Since
 we are about to start a loop which starts with an INC, compensate by 
loading Register B with the ASCII value for a zero character minus one</div></div>
									<p class="debug-note">This loop divides the current value by a 
power of 10 starting at 10,000 and working down to 10.  The remainder 
frome ach division is added to the division and the sum becomes the 
dividend for the next division until done.  The quotient is +2FH (which 
is the ASCII equivalent of a quotient).</p>
									<div class="assembly-row-combined" id="1348H"><div>1348<span class="origrom2">FOUCI2</span></div><div>INC B<span class="opcode2">04</span></div><div>Bump the ASCII value for the digit in Register B (so it starts at 0 and moves up each loop)</div></div>
									<div class="assembly-row-combined"><div>1349</div><div>LD A,L<span class="opcode2">7D</span></div><div>Load Register A with the LSB of the integer value in Register L</div></div>
									<div class="assembly-row-combined"><div>134A</div><div>SUB E<span class="opcode2">93</span></div><div>Subtract the value of the LSB of the integer value in Register E from the value of the LSB of the integer value in Register A</div></div>
									<div class="assembly-row-combined"><div>134B</div><div>LD L,A<span class="opcode2">6F</span></div><div>Load Register L with the adjusted value of the LSB of the integer value in Register A</div></div>
									<div class="assembly-row-combined"><div>134C</div><div>LD A,H<span class="opcode2">7C</span></div><div>Load Register A with the value of the MSB of the integer value in Register H</div></div>
									<div class="assembly-row-combined"><div>134D</div><div>SBC A,D<span class="opcode2">9A</span></div><div>Subtract the MSB of the integer value in Register D from the value of the MSB of the integer value in Register A</div></div>
									<div class="assembly-row-combined"><div>134E</div><div>LD H,A<span class="opcode2">67</span></div><div>Load Register H with the adjusted value of the MSB of the integer value in Register A</div></div>
									<div class="assembly-row-combined"><div>134F-1350</div><div><a href="#1348H" class="memory-link">JR NC,1348H<span class="origrom2">JR NC,FOUCI2</span></a><span class="opcode2">30 F7</span></div><div>If the quotient (stored in HL) &gt;= the current power of 10 (stored in DE) then we need to loop back to 1348H</div></div>
									<div class="assembly-row-combined"><div>1351</div><div>ADD HL,DE<span class="opcode2">19</span></div><div>The
 problem with using the CARRY FLAG as a trigger is that it triggers once
 you have already gone too far.  So we need to go back 1.  To do this, 
add the remainder (stored as an integer in Register Pair DE) to the 
quotient (stored in Register Pair HL as an integer)</div></div>
									<div class="assembly-row-combined"><div>1352-1354</div><div>LD (4121H),HL<span class="origrom2">LD (FACLO),HL</span><span class="opcode2">22 21 41</span></div><div>Save the integer remainder (stored in Register Pair HL) in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>1355</div><div>POP DE<span class="opcode2">D1</span></div><div>Get the address of the next power of 10 from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1356</div><div>POP HL<span class="opcode2">E1</span></div><div>Get the memory pointer for the buffer from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1357</div><div>LD (HL),B<span class="opcode2">70</span></div><div>Save
 the ASCII value for the digit (from Register B that tracked the number 
of divisions) to the location of the output buffer pointer (stored in 
Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>1358</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the buffer pointer in Register Pair HL since we just filled that spot with an ASCII value</div></div>
									<div class="assembly-row-combined"><div>1359</div><div>POP AF<span class="opcode2">F1</span></div><div>Get the number of digits to convert (i.e., the digit counter) from the STACK and put it in A</div></div>
									<div class="assembly-row-combined"><div>135A</div><div>POP BC<span class="opcode2">C1</span></div><div>Get the decimal/comma counts from the STACK and put it into Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>135B</div><div>DEC A<span class="opcode2">3D</span></div><div>Decrement the value of the counter in Register A (which is a countdown from 5)</div></div>
									<div class="assembly-row-combined"><div>135C-135D</div><div><a href="#1335H" class="memory-link">JR NZ,1335H<span class="origrom2">JR NZ,FOUCI1</span></a><span class="opcode2">20 D7</span></div><div>If the counter of the number of digits (from 5) is still not zero, jump back to 1335H until all of the digits have been figured</div></div>
									<div class="assembly-row-combined"><div>135E-1360</div><div><a href="#1291H" class="memory-link">CALL 1291H<span class="origrom2">CALL FOUTED</span></a><span class="opcode2">CD 91 12</span></div><div>So
 now all the digits have been calculated in ASCII, so GOSUB 1291H to put
 a decimal point or comma into the input buffer if necessary</div></div>
									<div class="assembly-row-combined"><div>1361</div><div>LD (HL),A<span class="opcode2">77</span></div><div>Save
 a zero (the value in Register A which hit zero when the loop from 5 
finished) to the input buffer, pointed to by Register Pair HL.  Note 
that we do not advance HL, so we can overwrite this trailing zero if 
necessary.</div></div>
									<div class="assembly-row-combined"><div>1362</div><div>POP DE<span class="opcode2">D1</span></div><div>Get the value from the STACK (which was whatever value was in DE when this routine started) and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1363</div><div>RET<span class="opcode2">C9</span></div><div>RETurn to CALLer with A=0</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1364H">1364-136B - DOUBLE PRECISION CONSTANT STORAGE LOCATION<span class="origrom"> - "TENTEN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1364-136B<span class="origrom2">TENTEN</span></div><div>00 00 00 00 F9 02 15 A2</div><div>A double precision constant equal to 10000000000 is stored here</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="136CH">136C-1373 - DOUBLE PRECISION CONSTANT STORAGE LOCATION<span class="origrom"> - "FOUTDL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>136C-1373<span class="origrom2">FOUTDL</span></div><div>FD FF 9F 31 A9 5F 63 B2</div><div>A double precision constant equal to 999,999,999,999,999.95 is stored here</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1374H">1374-137B - DOUBLE PRECISION CONSTANT STORAGE LOCATION<span class="origrom"> - "FOUTDU"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1374-137B<span class="origrom2">FOUTDU</span></div><div>FE FF 03 BF C9 1B 0E B6</div><div>A double precision constant equal to 9,999,999,999,999,999.5 is stored here</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="137CH">137C-1383 - DOUBLE PRECISION CONSTANT STORAGE LOCATION<span class="origrom"> - "DHALF"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>137C-137F<span class="origrom2">DHALF</span></div><div>00 00 00 00</div><div>A double precision constant equal to 0.5D0 is stored here.<br>BYTE
 SAVING NOTE: Referencing 1380H, which is half-way through this double 
precision value of .5, results in a single precision value of 0.5</div></div>
									<div class="assembly-row-combined"><div>1380-1383<span class="origrom2">FHALF</span></div><div>00 00 00 80</div><div>A double precision constant equal to 0.5E0 is stored here.<br>BYTE
 SAVING NOTE: Referencing 1380H, which is half-way through this double 
precision value of .5, results in a single precision value of 0.5</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1384H">1384-138B - DOUBLE PRECISION CONSTANT STORAGE LOCATION<span class="origrom"> - "FFXDXM"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1384-138B<span class="origrom2">FFXDXM</span></div><div>00 00 04 BF C9 1B 0E B6</div><div>A double precision constant equal to 1D16</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="138CH">138C-13D1 - DOUBLE PRECISION INTEGER CONSTANT STORAGE LOCATION<span class="origrom"> - "FODTBL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>138C-1392<span class="origrom2">FODTBL</span></div><div>00 80 C6 A5 7E 8D 03</div><div>1D15</div></div>
									<div class="assembly-row-combined"><div>1393-1399</div><div>00 40 7A 10 F3 5A 00</div><div>1D14</div></div>
									<div class="assembly-row-combined"><div>139A-13A0</div><div>00 A0 72 4E 18 09 00</div><div>1D13</div></div>
									<div class="assembly-row-combined"><div>13A1-13A7</div><div>00 10 A5 D5 E8 00 00</div><div>1D12</div></div>
									<div class="assembly-row-combined"><div>13A1-13A7</div><div>00 10 A5 D5 E8 00 00</div><div>1D11</div></div>
									<div class="assembly-row-combined"><div>13A8-13AE</div><div>00 E8 76 48 17 00 00</div><div>1D10</div></div>
									<div class="assembly-row-combined"><div>13AF-13B5</div><div>00 E4 0B 54 02 00 00</div><div>1D9</div></div>
									<div class="assembly-row-combined"><div>13B6-13BC</div><div>00 CA 9A 3B 00 00 00</div><div>1D8</div></div>
									<div class="assembly-row-combined"><div>13BD-13C3</div><div>00 E1 F4 05 00 00 00</div><div>1D7</div></div>
									<div class="assembly-row-combined"><div>13C4-13CA</div><div>80 96 98 00 00 00 00</div><div>1D6</div></div>
									<div class="assembly-row-combined"><div>13CB-13D1</div><div>40 42 0F 00 00 00 00</div><div>1D5</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="13D2H">13D2-13D9 - SINGLE PRECISION POWER OF TEN TABLE LOCATION<span class="origrom"> - "FOSTBL</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>13D2-13D4<span class="origrom2">FOSTBL</span></div><div>A0 86 01</div><div>1E5</div></div>
									<div class="assembly-row-combined"><div>13D5-13D7</div><div>10 27 00</div><div>1E4</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="13D2H">13D8 - SINGLE PRECISION POWER OF TEN TABLE LOCATION<span class="origrom"> - "FOITBL</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>13D8-13D9<span class="origrom2">FOITBL</span></div><div>10 27</div><div>10,000</div></div>
									<div class="assembly-row-combined"><div>13DA-13DB</div><div>E8 03</div><div>1,000</div></div>
									<div class="assembly-row-combined"><div>13DC-13DD</div><div>64 00</div><div>100</div></div>
									<div class="assembly-row-combined"><div>13DE-13DF</div><div>0A 00</div><div>10</div></div>
									<div class="assembly-row-combined"><div>13E0-13E1</div><div>01 00</div><div>1</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="13E2H">13E2-13E6 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "PSHNEG"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="13E2H"><div>13E2-13E4<span class="origrom2">PSHNEG</span></div><div>LD HL,0982H<span class="origrom2">LD HL,NEG</span><span class="opcode2">21 82 09</span></div><div>Load Register Pair HL with the address of the routine for conversion of floating point numbers from negative to positive</div></div>
									<div class="assembly-row-combined"><div>13E5</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Exchange the value of that routines jump address to the STACK with the value of the return address in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>135E-1360</div><div><a href="#1291H" class="memory-link">CALL 1291H<span class="origrom2">CALL FOUTED</span></a><span class="opcode2">CD 91 12</span></div><div>So
 now all the digits have been calculated in ASCII, so GOSUB 1291H to put
 a decimal point or comma into the input buffer if necessary</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="13E7H">13E7-13F1 - LEVEL II BASIC <span class="code">SQR(n)</span><span class="origrom"> - "SQR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine computes the square root of any value in 
ACCumulator.  It processes it by raising n to the power of 0.5. The root
 is left in ACCumulator as a single precision value.  Single-precision 
values only should be used</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>13E7-13F1<span class="origrom2">SQR</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09A4H">CALL 09A4H<span class="origrom2">CALL PUSHF</span></a><span class="opcode2">CD A4 09</span></div><div>GOSUB 09A4 which moves the SINGLE PRECISION value in ACCumulator to the STACK (stored in LSB/MSB/Exponent order)</div></div>
									<div class="assembly-row-combined"><div>13EA-13EC</div><div>LD HL,1380H<span class="origrom2">LD HL,FHALF</span><span class="opcode2">21 80 13</span></div><div>Load Register Pair HL with the starting address of a single precision constant equal to 0.5 (which will be the exponent)</div></div>
									<div class="assembly-row-combined"><div>13ED-13EF</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09B1H">CALL 09B1H<span class="origrom2">CALL MOVRM</span></a><span class="opcode2">CD B1 09</span></div><div>GOSUB 09B1H (which moves a SINGLE PRECISION number pointed to by HL to ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>13F0-13F1</div><div><a href="#13F5H" class="memory-link">JR 13F5H<span class="origrom2">JR FPWRT</span></a><span class="opcode2">18 03</span></div><div>Jump to the <span class="code">EXP(n)</span>
 routine at 13F5H (which will be using a .5 exponent to do the square 
root) skipping 13F2H since the exponent is already single precision</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="13F2H">13F2-1478H LEVEL II BASIC X to the Y Power (X^Y) ROUTINE<span class="origrom"> - "FPWRQ"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>A call to 13F2H raises the single precision value which has 
been saved to the STACK to the power specified in ACCumulator. The 
result will be returned in ACCumulator. The method of computation is e 
** (y ln x).</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>13F2-13F4<span class="origrom2">FPWRQ</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0AB1H">CALL 0AB1H<span class="origrom2">CALL FRCSNG</span></a><span class="opcode2">CD B1 0A</span></div><div>Make
 sure that the exponent is single precision by GOSUB to 0AB1H which is 
the CONVERT TO SINGLE PRECISION routine at 0AB1H (which converts the 
contents of ACCumulator from integer or double precision into single 
precision)</div></div>
									<div class="assembly-row-combined" id="13F5H"><div>13F5<span class="origrom2">FPWRT</span></div><div>POP BC<span class="opcode2">C1</span></div><div>Get the MSB of the single precision value from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>13F6</div><div>POP DE<span class="opcode2">D1</span></div><div>Get the NMSB and the LSB of the single precision value from the STACK and put it in Register Pair DE</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="13F7H">13F7 - LEVEL II BASIC Exponentiation routine<span class="origrom"> - "FPWR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine handles the exponentiation routine of X^Y.  To 
do so, first Y is checked for 0 and, if so, then the answer is simply 1.
  Then we check X for 0 and, if so, then the answer is simply 0.<br><br>
 If neither of those scenarios is the case, then must check to see if X 
is positive and, if not, check to see if Y is negative and if it is even
 or odd.<br><br> If Y is negative, the we negate it to avoid the LOG routine giving a ?FC ERROR when we call it.<br><br> If X is negative and Y is odd, the NEG routine is pushed to the STACK as the exit rouine so that the result will be negative.<br><br> The actual math here is X^Y = EXP(Y*LOG(X)).</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>13F7-13F9<span class="origrom2">FPWR</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0955H">CALL 0955H<span class="origrom2">CALL SIGN</span></a><span class="opcode2">CD 55 09</span></div><div>First,
 check Y to see if Y is zero via a GOSUB 0955H to check the sign for the
 single precision value in ACCumulator (the exponent)</div></div>
									<div class="assembly-row-combined"><div>13FA</div><div>LD A,B<span class="opcode2">78</span></div><div>Next,
 check to see if X is zero by first loading Register A with the MSB of 
the number to be raised (stored as a single precision value in Register 
B)</div></div>
									<div class="assembly-row-combined"><div>13FB-13FC</div><div><a href="#1439H" class="memory-link">JR Z,1439H<span class="origrom2">JR Z,EXP</span></a><span class="opcode2">28 3C</span></div><div>If it is zero then we already know our ansder which is, mathematically, a 1 so JUMP to the <span class="code">EXP(n)</span> routine at 1439H</div></div>
									<div class="assembly-row-combined"><div>13FD-13FF</div><div><a href="#1404H" class="memory-link">JP P,1404H<span class="origrom2">JP P,POSEXP</span></a><span class="opcode2">F2 04 14</span></div><div>After
 knowing that X isn't 0, we must check the sign of Y.  If it is 
positive, then JUMP to POSEXP to skip the next 2 opcodes (which check to
 see if zero is involved) if the exponent (the single precision value in
 ACCumulator) is positive</div></div>
									<div class="assembly-row-combined" id="1400H"><div>1400</div><div>OR A<span class="opcode2">B7</span></div><div>Check to see if this is a ZERO raised to the minus power.</div></div>
									<div class="assembly-row-combined"><div>1401-1403</div><div><a href="#199AH" class="memory-link">JP Z,199AH<span class="origrom2">JP Z,DV0ERR</span></a><span class="opcode2">CA 9A 19</span></div><div>If it is 0 raised to a minus power, display a <span class="code">?/0 ERROR</span>
 message since the single precision value in ACCumulator is negative and
 the single precision value in Register Pairs BC and DE is equal to 
zero.<br>/0 ERROR entry point</div></div>
									<div class="assembly-row-combined" id="1404H"><div>1404<span class="origrom2">POSEXP</span></div><div>OR A<span class="opcode2">B7</span></div><div>ANOTHER check to see if the value to be raised (i.e., the single precision value in Register Pairs BC and DE) is equal to zero</div></div>
									<div class="assembly-row-combined"><div>1405-1407</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0779H">JP Z,0779H<span class="origrom2">JP Z,DV0ERR</span></a><span class="opcode2">CA 79 07</span></div><div>If
 the value to be raised (i.e., the single precision value in Register 
Pairs BC and DE) is equal to zero, then we already know the result will 
be zero, so JUMP to ZERO0.</div></div>
									<div class="assembly-row-combined"><div>1408</div><div>PUSH DE<span class="opcode2">D5</span></div><div>At
 this point we know that none of the values are zero, and we are raising
 the number to a positive power.  Save the value to be raised (the NMSB 
and the LSB of the single precision value in Register Pair DE) to the 
STACK</div></div>
									<div class="assembly-row-combined"><div>1409</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the exponent and the MSB of the single precision value in Register Pair BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>140A</div><div>LD A,C<span class="opcode2">79</span></div><div>Now
 we want to check the sign of X.  First, load Register A with the value 
of the MSB of the single precision value to be raised (which is stored 
in Register C)</div></div>
									<div class="assembly-row-combined"><div>140B-140C</div><div>OR 7FH<span class="opcode2">F6 7F</span></div><div>Turn the Z FLAG off by ORing against 7FH (0111 1111) in Register A</div></div>
									<div class="assembly-row-combined"><div>140D-140F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09BFH">CALL 09BFH<span class="origrom2">CALL MOVRF</span></a><span class="opcode2">CD BF 09</span></div><div>Load
 the Y (the power) into BC/DE by GOSUB to 09BF which loads the SINGLE 
PRECISION value in ACCumulator (the exponent) into Register Pair BC/DE</div></div>
									<div class="assembly-row-combined"><div>1410-1412</div><div><a href="#1421H" class="memory-link">JP P,1421H<span class="origrom2">JP P,FPWR1</span></a><span class="opcode2">F2 21 14</span></div><div>If X is positive, then jump down to FPWR1 as we have nothing advanced to process</div></div>
									<div class="assembly-row-combined"><div>1413</div><div>PUSH DE<span class="opcode2">D5</span></div><div>Otherwise,
 we need to do some more math.  Save the Y value to the STACK first by 
saving the NMSB and the LSB of the exponent (the single precision value 
in Register Pair DE) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1414</div><div>PUSH BC<span class="opcode2">C5</span></div><div>and then Save the exponent and the LSB of the single precision value in Register Pair BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>1415-1417</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0B40H">CALL 0B40H<span class="origrom2">CALL INT</span></a><span class="opcode2">CD 40 0B</span></div><div>Check
 to see if the Y is an integer via a GOSUB to 0B40H to figure the 
integer portion of the exponent (i.e., the single precision value in 
ACCumulator) into A with the truncated floating point portion into 
ACCumulator</div></div>
									<div class="assembly-row-combined"><div>1418</div><div>POP BC<span class="opcode2">C1</span></div><div>Restore the exponent and the MSB of the Y value from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>1419</div><div>POP DE<span class="opcode2">D1</span></div><div>Restore the NMSB and the LSB of the Y value from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>141A</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the LSB of the integer to the STACK for even and odd information</div></div>
									<div class="assembly-row-combined"><div>141B-141D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A0CH">CALL 0A0CH<span class="origrom2">CALL FCOMP</span></a><span class="opcode2">CD 0C 0A</span></div><div>Make
 sure we have an integer by GOSUBing to FCOMP which will compare the 
original exponent to the truncated one by GOSUB to routine at 0A0CH 
which algebraically compares the single precision value in BC/DE to the 
single precision value ACCumulator.<br>The results are stored in A as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Register A</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator = BCDE</td><td style="border: 1px solid black; padding: 8px;">00</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator &gt; BCDE</td><td style="border: 1px solid black; padding: 8px;">01</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator &lt; BCDE</td><td style="border: 1px solid black; padding: 8px;">FF</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>141E</div><div>POP HL<span class="opcode2">E1</span></div><div>Get the exponent as an integer from the STACK and put it in Register H.  This will help us determine if it is even or odd.</div></div>
									<div class="assembly-row-combined"><div>141F</div><div>LD A,H<span class="opcode2">7C</span></div><div>Load Register A with the exponent as an integer (as stored in Register H)</div></div>
									<div class="assembly-row-combined"><div>1420</div><div>RRA<span class="opcode2">1F</span></div><div>Rotate
 that exponent right by one, so we can tell if it is even or odd.  If 
the exponent (as an integer) is odd, set the CARRY FLAG.  RRA rotates 
Register A right one bit, with Bit 0 going to CARRY and CARRY going to 
Bit 7.</div></div>
									<div class="assembly-row-combined" id="1421H"><div>1421<span class="origrom2">FPWR1</span></div><div>POP HL<span class="opcode2">E1</span></div><div>Prepare to get the X back into the ACCumulator by fetching the number from the top of the STACK into Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1422-1424</div><div>LD (4123H),HL<span class="origrom2">LD (FAC-1),HL</span><span class="opcode2">22 23 41</span></div><div>Save the HIGH ORDERs of X to the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>1425</div><div>POP HL<span class="opcode2">E1</span></div><div>Get the LOW ORDERS of X from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1426-1428</div><div>LD (4121H),HL<span class="origrom2">LD (FACLO),HL</span><span class="opcode2">22 21 41</span></div><div>Save
 the rest of the exponent (i.e., as stored in Register Pair HL as the 
NMSB and the LSB of the single precision value) in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>1429-142B</div><div><a href="#13E2H" class="memory-link">CALL C,13E2H<span class="origrom2">CALL C,PSHNEG</span></a><span class="opcode2">DC E2 13</span></div><div>If
 the exponent is odd then we need to negate the final result, so GOSUB 
to 13E2H to PUSH the address of the NEG routine into the STACK</div></div>
									<div class="assembly-row-combined"><div>142C-142E</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0982H">CALL Z,0982H<span class="origrom2">CALL Z,NEG</span></a><span class="opcode2">CC 82 09</span></div><div>If the exponent is an integer and the base is negative, GOSUB to 0983H to invert the value of the exponent</div></div>
									<div class="assembly-row-combined"><div>142F</div><div>PUSH DE<span class="opcode2">D5</span></div><div>Save the NMSB and the LSB of the Y/exponent (i.e., the single precision value in Register Pair DE) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1430</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the MSB of the Y/exponent (i.e., the single precision value in Register Pair BC) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1431-1433</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0809H">CALL 0809H<span class="origrom2">CALL LOG</span></a><span class="opcode2">CD 09 08</span></div><div>Now
 we want to compute EXP(Y*LOG(X)) so we CALL the LOG(N) routine at 0809H
 (which computes the natural log (base E) of the single precision value 
in ACCumulator. The result is returned as a single precision value in 
ACCumulator.  Can give an ILLEGAL FUNCTION CALL erro if a negative base 
is raised to a power with a fraction)</div></div>
									<div class="assembly-row-combined"><div>1434</div><div>POP BC<span class="opcode2">C1</span></div><div>Get the exponent and the MSB of the single precision value from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>1435</div><div>POP DE<span class="opcode2">D1</span></div><div>Get the NMSB and the LSB of the single precision from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1436-1438</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0847H">CALL 0847H<span class="origrom2">CALL FMULT</span></a><span class="opcode2">CD 47 08</span></div><div>We
 need to multiply the ln(value) * the exponent so we have to GOSUB to 
0847H to SINGLE PRECISION MULTIPLY routine (which multiplies the current
 value in ACCumulator by the value in (BC/DE). The product is left in 
ACCumulator</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1439H">1439 - LEVEL II ROM <span class="code">EXP</span> ROUTINE.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p> Single-precision only. (ACCumulator = EXP(REG1)).<br><br> To
 process this function we first save the original argument and multiply 
the ACCumulator by log2(e).  The result of that is then used to 
determine if we will get overflow, since exp(x)=2^(x*log2(e)) where 
log2(e)=log(e) base 2.<br><br> We then save the integer part of this to 
scale the answer at the end, since 2^y=2^int(y)*2^(y-int(y)) and 
2^int(y) is easy to compute.  <br><br> So in the end we compute 2^(x*log2(e)-int(x*log2(e))) by p(ln(2)*(int(x*log2(e))+1)-x) where p is an approximation polynomial.<br><br> The result is then scaled by the power of 2 we previously saved.<br><br>
 A call to 1439H raises E (natural base) to the value in ACCumulator 
which must be a single precision value. The result will be returned in 
ACCumulator as a single precision number.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>&lt;1439-143B<span class="origrom2">EXP</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09A4H">CALL 09A4H<span class="origrom2">CALL PUSHF</span></a><span class="opcode2">CD A4 09</span></div><div>Save
 the argument  via a GOSUB to 09A4 to move the SINGLE PRECISION value in
 ACCumulator (the exponent) to the STACK (stored in LSB/MSB/Exponent 
order)</div></div>
									<div class="assembly-row-combined"><div>143C-143E</div><div>LD BC,8138H<span class="opcode2">01 38 81</span></div><div>Next we want to do a LOG(E) in base 2, so load Register Pair BC with the exponent and MSB of a single precision constant</div></div>
									<div class="assembly-row-combined"><div>143F-1441</div><div>LD DE,AA3BH<span class="opcode2">11 3B AA</span></div><div>Load
 Register Pair DE with the NMSB and the LSB of a single precision 
constant. Register Pairs BC and DE are now equal to a single precision 
constant of 1.442695 (which is approximately 2 + ln 2)</div></div>
									<div class="assembly-row-combined"><div>1442-1444</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0847H">CALL 0847H<span class="origrom2">CALL FMULT</span></a><span class="opcode2">CD 47 08</span></div><div>We
 next want to calculate INT(ARG/LN(2)) = INT(ARG*LOG2(E)).  So we will 
need to multiply the exponent value by 2 ln 2 so we call the SINGLE 
PRECISION MULTIPLY routine at 0847H (which multiplies the current value 
in ACCumulator by the value in (BC/DE). The product is left in 
ACCumulator</div></div>
									<div class="assembly-row-combined"><div>1445-1447</div><div>LD A,(4124H)<span class="origrom2">LD A,(FAC)</span><span class="opcode2">3A 24 41</span></div><div>Load
 Register A with the result of the math just done (i.e., which was 
multiplying the exponent value by 2 ln 2) which was stored in 
ACCumulator.</div></div>
									<div class="assembly-row-combined"><div>1448-1449</div><div>CP 88H<span class="opcode2">FE 88</span></div><div>Next
 we want to see if ABS(ACCumulator) is &gt;= 128 (i.e., if the integer 
portion of the single precision value in ACCumulator uses more than 7 
bits of precision) by comparing it against a mask of 1000 1000</div></div>
									<div class="assembly-row-combined"><div>144A-144C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0931H">JP NC,0931H<span class="origrom2">P NC,MLDVEX</span></a><span class="opcode2">D2 31 09</span></div><div>If
 the single precision value in ACCumulator uses more than 7 bits of 
precision for its integer portion then it is too big and we need to JUMP
 to MLDVEX to deal with that.</div></div>
									<div class="assembly-row-combined"><div>144D-144F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0B40H">CALL 0B40H<span class="origrom2">CALL INT</span></a><span class="opcode2">CD 40 0B</span></div><div>So
 now that we know the integer portion is not too big, but we need to see
 if the argument is too big as well so we GOSUB to 0B40H to get the 
integer portion of the value in ACCumulator and return with it in 
Register A</div></div>
									<div class="assembly-row-combined"><div>1450-1451</div><div>ADD A,80H<span class="opcode2">C6 80</span></div><div>Adjust the value in Register A by masking it against 1000 0000</div></div>
									<div class="assembly-row-combined"><div>1452-1453</div><div>ADD A,02H<span class="opcode2">C6 02</span></div><div>Adjust the value in Register A by adding 2 more.  We will either get an overflow (C FLAG) or we wont (NC FLAG)</div></div>
									<div class="assembly-row-combined"><div>1454-1456</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0931H">JP C,0931H<span class="origrom2">JP C,MLDVEX</span></a><span class="opcode2">DA 31 09</span></div><div>If (exponent * 2 ln 2) is =&gt; 126 (meaning when 2 was added it it, it overflowed with a 128), jump to 0931H</div></div>
									<div class="assembly-row-combined"><div>1457</div><div>PUSH AF<span class="opcode2">F5</span></div><div>So now neither has overflowed, so save the scale factor +82H (as stored in Register Pair AF) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1458-145A</div><div>LD HL,07F8H<span class="origrom2">LD HL,FONE</span><span class="opcode2">21 F8 07</span></div><div>Load Register Pair HL with a single precision constant equal to 1.0 (as found at 1458H)</div></div>
									<div class="assembly-row-combined"><div>145B-145D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#070BH">CALL 070BH<span class="origrom2">CALL FADDS</span></a><span class="opcode2">CD 0B 07</span></div><div>Go
 add the single precision constant 1.0 (as pointed to by Register Pair 
HL) to the current value in ACCumulator which is EXP * 2 ln 2</div></div>
									<div class="assembly-row-combined"><div>145E-1460</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0841H">CALL 0841H<span class="origrom2">CALL MULLN2</span></a><span class="opcode2">CD 41 08</span></div><div>Need to multiply that by ln 2, so GOSUB to 0841H to multiply (1 + [EXP * 2 ln 2]) (as stored in ACCumulator) by 0.693147</div></div>
									<div class="assembly-row-combined"><div>1461</div><div>POP AF<span class="opcode2">F1</span></div><div>Get the scale factor (as stored in the STACK) and put it in Register Pair AF</div></div>
									<div class="assembly-row-combined"><div>1462</div><div>POP BC<span class="opcode2">C1</span></div><div>Get
 the original exponent into BC/DE in 2 steps fist get the exponent and 
the MSB of the single precision value from the STACK and put it in 
Register Pair BC </div></div>
									<div class="assembly-row-combined"><div>1463</div><div>POP DE<span class="opcode2">D1</span></div><div>and then get the NMSB and the LSB of the single precision value from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1464</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Put the scale factor (the integerized EXP * 2 ln 2) as stored in Register Pair AF onto the STACK</div></div>
									<div class="assembly-row-combined"><div>1465-1467</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0713H">CALL 0713H<span class="origrom2">CALL FSUB</span></a><span class="opcode2">CD 13 07</span></div><div>Now
 we need to subtract the original exponent from the integerized exponent
 so we GOSUB to 0713H which is the SINGLE PRECISION SUBTRACT routine 
(which subtracts the single precision value in BC/DE from the single 
precision value in ACCumulator.  The difference is left in ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>1468-146A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0982H">CALL 0982H<span class="origrom2">CALL NEG</span></a><span class="opcode2">CD 82 09</span></div><div>To
 force that difference to be a positive number we GOSUB to 0982H which 
makes the current single precision value in ACCumulator positive</div></div>
									<div class="assembly-row-combined"><div>146B-146D</div><div>LD HL,1479H<span class="origrom2">LD HL,EXPCON</span><span class="opcode2">21 79 14</span></div><div>Load
 Register Pair HL with the starting address for a series of 8 
coefficients so as to enable us to evaluate the approximation polynomial
 in the next instruction</div></div>
									<div class="assembly-row-combined"><div>146E-1470</div><div><a href="#14A9H" class="memory-link">CALL 14A9H<span class="origrom2">CALL POLY</span></a><span class="opcode2">CD A9 14</span></div><div>GOSUB to 14A9H to do that series of computations</div></div>
									<div class="assembly-row-combined"><div>1471-1473</div><div>LD DE,0000H<span class="opcode2">11 00 00</span></div><div>We
 want to make sure that FMULT will check for an exponent overflow at the
 end of this routine, so we can't just add it to the exponent.  Rather, 
we will multiply it by 2^(B-1) so that FMULT will check.  So first, load
 the integerized equivalent of EXP * 2 lnt 2 into BC/DE so first we load
 Register Pair DE with zero ...</div></div>
									<div class="assembly-row-combined"><div>1474</div><div>POP BC<span class="opcode2">C1</span></div><div>... and then get the value from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>1475</div><div>LD C,D<span class="opcode2">4A</span></div><div>Load Register C with zero (since Register D was filled with a zero in 1471H)</div></div>
									<div class="assembly-row-combined"><div>1476-1478</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0847H">JP 0847H<span class="origrom2">JP FMULT</span></a><span class="opcode2">C3 47 08</span></div><div>We
 need to multiply by the sum from the series and return so we jump to 
0847H which is the the SINGLE PRECISION MULTIPLY routine at 0847H (which
 multiplies the current value in ACCumulator by the value in (BC/DE). 
The product is left in ACCumulator</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1479H">1479-1499 - SINGLE PRECISION CONSTANT STORAGE LOCATION<br>This represents 1/6, -1/5, 1/4, -1/3, 1/2, -1, and 1<span class="origrom"> - "EXPCON"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1479<span class="origrom2">EXPCON</span></div><div>09</div><div>The number of single precision constants (9) which follow are stored here</div></div>
									<div class="assembly-row-combined"><div>147A-147D</div><div>40 2E 94 74</div><div>A single precision constant equal to -0.00014171607 (-1.413165 * 10e-4) is stored here</div></div>
									<div class="assembly-row-combined"><div>147E-1481</div><div>70 4F 2E 77</div><div>A single precision constant equal to 0.00132988204 (1.32988 * 10e-3, roughly -1/6) is stored here</div></div>
									<div class="assembly-row-combined"><div>1482-1485</div><div>6E 02 88 7A</div><div>A single precision constant equal to -0.00830136052 (-8.30136 * 10e-3, roughly -1/5) is stored here</div></div>
									<div class="assembly-row-combined"><div>1486-1489</div><div>E7 A0 2A 7C</div><div>A single precision constant equal to 0.04165735095 (roughly 1/4) is stored here</div></div>
									<div class="assembly-row-combined"><div>148A-148D</div><div>50 AA AA 7E</div><div>A single precision constant equal to -0.16666531543 (roughly -1/3) is stored here</div></div>
									<div class="assembly-row-combined"><div>148E-1491</div><div>FF FF 7F 7F</div><div>A single precision constant equal to 0.49999996981 (roughly 1/2) is stored here</div></div>
									<div class="assembly-row-combined"><div>1492-1495</div><div>00 00 80 81</div><div>A single precision constant equal to -1.0 is stored here</div></div>
									<div class="assembly-row-combined"><div>1496-1499</div><div>00 00 00 81</div><div>A single precision constant equal to 1.0 is stored here</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="149AH">149A-14C8 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "POLYX"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is a general purpose summation routine which computes 
the series C0*X+C1*X^3+C2*X^5+C3*X^7+...+C(N)*X^(2*N+1) for I=0 to N 
when entered at 149AH  If entered at 14A9H the series changes to SUM 
((((x*c0+c1)x*c2)x+c3)x+.cN.  On entry, the x is held in BC/DE and HL 
points to a list containing the number of terms followed by the 
coefficients.<br><br> The pointer to degree+1 is in (HL) and the 
constants should follow the egree, stored in reverse order.  X is in the
 ACCumulator.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="149AH"><div>149A-149C<span class="origrom2">POLYX</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09A4H">CALL 09A4H<span class="origrom2">CALL PUSHF</span></a><span class="opcode2">CD A4 09</span></div><div>Save
 X to the STACK via a GOSUB to 09A4 to which move the SINGLE PRECISION 
value in ACCumulator to the STACK (stored in LSB/MSB/Exponent order)</div></div>
									<div class="assembly-row-combined"><div>149D-149F</div><div>LD DE,0C32H<span class="origrom2">LD DE,FMULTT</span><span class="opcode2">11 32 0C</span></div><div>Load Register Pair DE with the return address of the FMULTT routine ...</div></div>
									<div class="assembly-row-combined"><div>14A0</div><div>PUSH DE<span class="opcode2">D5</span></div><div>... and push it to the STACK, so that once this routine ends, it will be multiplied by X</div></div>
									<div class="assembly-row-combined"><div>14A1</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save pointer to the constant (as stored in Register Pair HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>14A2-14A4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09BFH">CALL 09BFH<span class="origrom2">CALL MOVRF</span></a><span class="opcode2">CD BF 09</span></div><div>We
 need to square X, so we do that in the next two steps.  First, GOSUB to
 09BFH which loads the SINGLE PRECISION value in ACCumulator into 
Register Pair BC/DE</div></div>
									<div class="assembly-row-combined"><div>14A5-14A7</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0847H">CALL 0847H<span class="origrom2">CALL FMULT</span></a><span class="opcode2">CD 47 08</span></div><div>Since
 ACCumulator and BC/DE now hold the same number, you can square that by a
 GOSUB to 0847H which is the SINGLE PRECISION MULTIPLY routine (which 
multiplies the current value in ACCumulator by the value in (BC/DE). The
 product is left in ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>14A8</div><div>POP HL<span class="opcode2">E1</span></div><div>Restore the consatnt pointer from the STACK and put it in Register Pair HL, and then fall through into the POLY routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="14A9H">14A9 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "POLY"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>General polynomial evaluator routine.  Pointer to degree+1 is
 in (HL), and that gets updated through the computation.  The Constants 
follow the degree and should be stored in reverse order.  The 
ACCumulator has the X.  The formula is 
c0+c1*x+c2*x^2+c3*x^3+...+c(n-1)*x^(n-1)+c(n)*x^n</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id=""><div>14A9-14AB<span class="origrom2">POLY</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09A4H">CALL 09A4H<span class="origrom2">CALL PUSHF</span></a><span class="opcode2">CD A4 09</span></div><div>Save
 the "X" to the STACK.  We need to move either x or x**2 (depending on 
the routine entry point) to the STACK so we GOSUB to 09A4 which moves 
the SINGLE PRECISION value in ACCumulator to the STACK (stored in 
LSB/MSB/Exponent order)</div></div>
									<div class="assembly-row-combined"><div>14AC</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Fetch
 the degree (i.e., the number of values to be figured at the location of
 the memory pointer in Register Pair HL) into Register A</div></div>
									<div class="assembly-row-combined"><div>14AD</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL so that it points to the first constant/coefficient</div></div>
									<div class="assembly-row-combined"><div>14AE-14B0</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09B1H">CALL 09B1H<span class="origrom2">CALL MOVRM</span></a><span class="opcode2">CD B1 09</span></div><div>Now
 load that constant/coefficient (stored in HL) and move it to 
ACCumulator by GOSUB to 09B1H (which moves a SINGLE PRECISION number 
pointed to by HL to ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>14B1</div><div>LD B,0F1<span class="opcode2">06 F1</span></div><div>Z-80 Trick!  If passing through, this will simply alter Register B and the next instruction of POP AF will not be processed.</div></div>
									<div class="assembly-row-combined" id="14B2H"><div>14B2<span class="origrom2">POLY1</span></div><div>POP AF<span class="opcode2">F1</span></div><div>Get the degree (count of coefficients left) from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>14B3</div><div>POP BC<span class="opcode2">C1</span></div><div>Get the value of "X" from the STACK and put it in Register Pair BC/DE - Step 1 and ...</div></div>
									<div class="assembly-row-combined"><div>14B4</div><div>POP DE<span class="opcode2">D1</span></div><div>... Step 2</div></div>
									<div class="assembly-row-combined"><div>14B5</div><div>DEC A<span class="opcode2">3D</span></div><div>Count 1 of the terms as computed by decrementing the counter in Register A</div></div>
									<div class="assembly-row-combined"><div>14B6</div><div>RET Z<span class="opcode2">C8</span></div><div>If that decrement results in a zero (meaning the series of computations has been completed) return out of the subroutine</div></div>
									<div class="assembly-row-combined"><div>14B7-14B8</div><div>PUSH DE<br>PUSH BC<span class="opcode2">D5</span></div><div>Save the NMSB and the LSB of "X" from DE to the STACK and save the MSB of "X" from BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>14B9</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save counter of the remaining degrees (terms to compute) as tracked by Register A into the STACK</div></div>
									<div class="assembly-row-combined"><div>14BA</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value of the memory pointer to the next constant/coefficient (stored in Register Pair HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>14BB-14BD</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0847H">CALL 0847H<span class="origrom2">CALL FMULT</span></a><span class="opcode2">CD 47 08</span></div><div>Compute
 C(I)*x by GOSUB to 0847H which is the SINGLE PRECISION MULTIPLY routine
 (which multiplies the current value in ACCumulator by the value in 
(BC/DE). The product is left in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>14BE</div><div>POP HL<span class="opcode2">E1</span></div><div>Restore the coefficient table address (from the STACK) to Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>14BF-14C1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09C2H">CALL 09C2H<span class="origrom2">CALL MOVRM</span></a><span class="opcode2">CD C2 09</span></div><div>Get
 the next coefficient from HL into BC/DE by GOSUB to 09C2H (which loads a
 SINGLE PRECISION value pointed to by Register Pair HL into Register 
Pairs BC and DE)</div></div>
									<div class="assembly-row-combined"><div>14C2</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the next coefficient (stored in Register Pair HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>14C3-14C5</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0716H">CALL 0716H<span class="origrom2">CALL FADD</span></a><span class="opcode2">CD 16 07</span></div><div>Compute
 C(I)*x+C(I+1) by GOSUB to 0716H which is the SINGLE PRECISION ADD 
routine (which adds the single precision value in (BC/DE) to the single 
precision value in ACCumulator. The sum is left in ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>14C6</div><div>POP HL<span class="opcode2">E1</span></div><div>Restore the coefficient table address (from the STACK) to Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>14C7-14C8</div><div><a href="#14B2H" class="memory-link">JR 14B2H<span class="origrom2">JR POLY1</span></a><span class="opcode2">18 E9</span></div><div>Jump back to 14B2H to continue the series.  ACCumulator contains the current term</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="14C9H">14C9-1540 - LEVEL II BASIC <span class="code">RND(n)</span> ROUTINE<span class="origrom"> - "RND"</span>.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>If the passed argument is 0, the last random number generated
 is returned.  If the argument is &lt; 0, a new sequence of random 
numbers is started using the argument.<br><br> To form the next random 
number in the sequence, we multiply the previous random number by a 
random constant, and add in another random constant.  Then the HIGH 
ORDER and LOW ORDER bytes are switched, the exponent is put where it 
will be shifted in by normal, and the exponent in the ACCUMULATOR is set
 to 80H so the result will be less than 1.  This is then normalized and 
saved for the next time.<br><br> The reason we switch the HIGH ORDER and
 LOW ORDER bytes is so we have a random chance of getting a number less 
than or greater than .5</p><br>
								<div class="assembly-table">
									<p class="debug-note">Integer, single or double-precision. Output will be single-precision. (ACC=RND (ACC))<br><br>A
 call to 14C9H Generates a random number between 0 and 1, or 1 and n 
depending on the parameter passed in ACCumulator, The random value is 
returned in ACCumulator as an integer with the mode flag set. The 
parameter passed will determine the range of the random number returned.
 A parameter of 0 will return an interger between 0 and 1. A parameter 
greater than 0 will have any fraction portion truncated and will cause a
 value between 1 and the integer portion of the parameter to be 
returned.</p><br>
									<p class="debug-note">There is a bug in the operation of this 
command.  According to Vernon Hester RND(n) where n is an integer from 1
 to 32767 is supposed to return an integer from 1 to n. However, when n 
is a power of two raised to a positive integer exponent from 0 to 14 
sometimes returns n+1</p>
									<div class="assembly-row-combined"><div>14C9-14CB<span class="origrom2">RND</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A7FH">CALL 0A7FH<span class="origrom2">CALL FRCINT</span></a><span class="opcode2">CD 7F 0A</span></div><div>First
 convert the argument to an integer via a GOSUB to the CONVERT TO 
INTEGER routine at 0A7FH (where the contents of ACCumulator are 
converted from single or double precision to integer and deposited into 
HL)</div></div>
									<div class="assembly-row-combined" id="14CCH"><div>14CC</div><div>LD A,H<span class="opcode2">7C</span></div><div>Load Register A with the value of the MSB for the integer value in Register H</div></div>
									<div class="assembly-row-combined"><div>14CD</div><div>OR A<span class="opcode2">B7</span></div><div>Check to see if the integer value in Register Pair HL is negative</div></div>
									<div class="assembly-row-combined"><div>14CE-14D0</div><div><a href="#1E4AH" class="memory-link">JP M,1E4AH<span class="origrom2">JP M,FCERR</span></a><span class="opcode2">FA 4A 1E</span></div><div>Since we won't accept a negative number, display a <span class="code">?FC ERROR</span> message if the integer value in Register Pair HL is negative</div></div>
									<div class="assembly-row-combined"><div>14D1</div><div>OR L<span class="opcode2">B5</span></div><div>Combine the MSB and LSB and set status flags so we can see if the integer value in Register Pair HL is equal to zero</div></div>
									<div class="assembly-row-combined"><div>14D2-14D4</div><div><a href="#14F0H" class="memory-link">JP Z,14F0H<span class="origrom2">JP Z,RND0</span></a><span class="opcode2">CA F0 14</span></div><div>If it is zero, we don't need the rest of the below which functions to generate <span class="code">RND(n)</span> so we just jump to 14F0H (which generates RND(0), which is a number between 0 and 1)</div></div>
									<div class="assembly-row-combined"><div>14D5</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Since it wasn't zero, we need to save the argument (as stored in Register Pair HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>14D6-14D8</div><div><a href="#14F0H" class="memory-link">CALL 14F0H<span class="origrom2">CALL RND0</span></a><span class="opcode2">CD F0 14</span></div><div>Generate a random number between 0 and 1 via a call to GOSUB to 14F0H (which generates <span class="code">RND(0)</span>) and return with the single precision result in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>14D9-14DB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09BFH">CALL 09BFH<span class="origrom2">CALL MOVRF</span></a><span class="opcode2">CD BF 09</span></div><div>Move
 the random number we just generated into BC/DE via a GOSUB to 09BFH 
which loads the SINGLE PRECISION value in ACCumulator into Register Pair
 BC/DE</div></div>
									<div class="assembly-row-combined"><div>14DC</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Swap some registers so that the random number is now in B/C/H/L</div></div>
									<div class="assembly-row-combined"><div>14DD</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Swap
 (SP) and HL so that the LOW ORDER bytes of the random number are at the
 top of the STACK, and HL now holds the integer argument</div></div>
									<div class="assembly-row-combined"><div>14DE</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the HIGH ORDER bytes of the random number value to the STACK</div></div>
									<div class="assembly-row-combined"><div>14DF-14E1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0ACFH">CALL 0ACFH<span class="origrom2">CALL CONSIH</span></a><span class="opcode2">CD CF 0A</span></div><div>Convert
 the original x of RND(x) to single precision by GOSUB to 0ACFH which 
converts the integer value in Register Pair HL to single precision and 
return with the result in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>14E2-14E3</div><div>POP BC<br>POP DE<span class="opcode2">C1</span></div><div>Restore the RND(0) value from the STACK and put it into Register Pair BC/DE</div></div>
									<div class="assembly-row-combined"><div>14E4-14E6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0847H">CALL 0847H<span class="origrom2">CALL FMULT</span></a><span class="opcode2">CD 47 08</span></div><div>Multiply the RND(0) value (currently in BC/DE) by the n of <span class="code">RND(n)</span>
 (currently in ACCumulator) by GOSUB to 0847H which is the SINGLE 
PRECISION MULTIPLY routine (which multiplies the current value in 
ACCumulator by the value in (BC/DE). The product is left in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>14E7-14E9</div><div>LD HL,07F8H<span class="origrom2">LD HL,FONE</span><span class="opcode2">21 F8 07</span></div><div>Load Register Pair HL with the starting address of a single precision constant equal to 1.0</div></div>
									<div class="assembly-row-combined"><div>14EA-14EC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#070BH">CALL 070BH<span class="origrom2">CALL FADDS</span></a><span class="opcode2">CD 0B 07</span></div><div>Increase
 the random number by one by GOSUB to 070BH which adds the single 
precision constant pointed to by Register Pair HL (which is 1.0) to the 
single precision value in ACCumulator (which is the random number). 
Return with the single precision result in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>14ED-14EF</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0B40H">JP 0B40H<span class="origrom2">JP INT</span></a><span class="opcode2">C3 40 0B</span></div><div>With
 the random number now in ACCumulator, jump to 0B40H (which will convert
 it to an integer and RETurn to the subroutine caller, thus exiting out 
of this routine)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="14F0H">14F0 - This routine calculates <span class="code">RND(0)</span><span class="origrom"> - "RND0"</span>.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>14F0-14F2</div><div>LD HL,4090H<span class="origrom2">LD HL,MULTR</span><span class="opcode2">21 90 40</span></div><div>Load Register Pair HL with the starting address for a multiplier table used for figuring random numbers</div></div>
									<div class="assembly-row-combined"><div>14F3</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the starting address for the table used for figuring random numbers (stored in HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>14F4-14F6</div><div>LD DE,0000H<span class="opcode2">11 00 00</span></div><div>Load Register Pair DE with zero (which will be the NMLSB and LSB of the starting value)</div></div>
									<div class="assembly-row-combined"><div>14F7</div><div>LD C,E<span class="opcode2">4B</span></div><div>Load Register C with zero (C will be the MSB of the starting value).  Now C/D/E is zero.</div></div>
									<div class="assembly-row-combined"><div>14F8-14F9</div><div>LD H,03H<span class="opcode2">26 03</span></div><div>Load Register H with the counter value for the multiplication loop (which will be 3)</div></div>
									<div class="assembly-row-combined" id="14FAH"><div>14FA-14FB<span class="origrom2">RNDO0</span></div><div>LD L,08H<span class="opcode2">2E 08</span></div><div>Load Register L with a counter value of 8 bits</div></div>
									<div class="assembly-row-combined" id="14FCH"><div>14FC<span class="origrom2">RND1</span></div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Swap DE and HL so that the counters are now in DE and the NMSB and the LSB of the random number is in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>14FD</div><div>ADD HL,HL<span class="opcode2">29</span></div><div>Multiply the NMSB and the LSB of the random number in Register Pair HL by two</div></div>
									<div class="assembly-row-combined"><div>14FE</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange the newly doubled NMSB and the LSB of the random number to DE and the counters to Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>14FF</div><div>LD A,C<span class="opcode2">79</span></div><div>Next we want to shift the HIGH ORDER byte (Register C), so first load Register A with the MSB of the random number in Register C</div></div>
									<div class="assembly-row-combined" id="1500H"><div>1500</div><div>RLA<span class="opcode2">17</span></div><div>Multiply the HIGH ORDER byte of the random number in Register A by two</div></div>
									<div class="assembly-row-combined"><div>1501</div><div>LD C,A<span class="opcode2">4F</span></div><div>Load Register C with the adjusted MSB of the random number in Register A</div></div>
									<div class="assembly-row-combined"><div>1502</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Swap (SP) and HL so that the counters are now at the top of the STACK and the pointer to the multiplier is in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1503</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Fetch a multiplier from the the table value (held at the location of the memory pointer in Register Pair HL) into Register A</div></div>
									<div class="assembly-row-combined"><div>1504</div><div>RLCA<span class="opcode2">07</span></div><div>Rotate the bits of Register A</div></div>
									<div class="assembly-row-combined"><div>1505</div><div>LD (HL),A<span class="opcode2">77</span></div><div>Save the doubled value (stored in Register A) at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1506</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Swap (SP) and HL so that the counters are now in HL and the pointer to the multiplication table is at the top of the STACK</div></div>
									<div class="assembly-row-combined"><div>1507-1509</div><div><a href="#1516H" class="memory-link">JP NC,1516H<span class="origrom2">JP NC,RND2</span></a><span class="opcode2">D2 16 15</span></div><div>If that rotation set a NC FLAG, JUMP forward to 1516H</div></div>
									<div class="assembly-row-combined"><div>150A</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the counter values in Register Pair HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>150B-150D</div><div>LD HL,(40AAH)<span class="origrom2">LD HL,(RNDX)</span><span class="opcode2">2A AA 40</span></div><div>Load Register Pair HL with the NMSB and the LSB of the random number seed.<br>Note: 40AAH-40ADH holds the random number seed</div></div>
									<div class="assembly-row-combined"><div>150E</div><div>ADD HL,DE<span class="opcode2">19</span></div><div>Add
 the NMSB and the LSB of the random number in Register Pair DE to the 
NMSB and the LSB of the random number seed in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>150F</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Load Register Pair DE with the adjusted NMSB and LSB of the random number in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1510-1512</div><div>LD A,(40ACH)<span class="origrom2">LD A,(RNDX+2)</span><span class="opcode2">3A AC 40</span></div><div>Load Register A with the MSB of the random number seed</div></div>
									<div class="assembly-row-combined"><div>1513</div><div>ADC A,C<span class="opcode2">89</span></div><div>Add the MSB of the random number in Register C to the MSB of the random number seed in Register A</div></div>
									<div class="assembly-row-combined"><div>1514</div><div>LD C,A<span class="opcode2">4F</span></div><div>Load Register C with the adjusted MSB of the random number in Register A</div></div>
									<div class="assembly-row-combined"><div>1515</div><div>POP HL<span class="opcode2">E1</span></div><div>Get the counter values from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined" id="1516H"><div>1516<span class="origrom2">RND2</span></div><div>DEC L<span class="opcode2">2D</span></div><div>Decrement the loop counter in Register L</div></div>
									<div class="assembly-row-combined"><div>1517-1519</div><div><a href="#14FCH" class="memory-link">JP NZ,14FCH<span class="origrom2">JP NZ,RND1</span></a><span class="opcode2">C2 FC 14</span></div><div>Loop back to 14FCH until the above has been done eight times</div></div>
									<div class="assembly-row-combined"><div>151A</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Swap (SP) and HL so that HL will now point to the table of multipliers</div></div>
									<div class="assembly-row-combined"><div>151B</div><div>INC HL<span class="opcode2">23</span></div><div>Bump to the next table of multipliers value</div></div>
									<div class="assembly-row-combined"><div>151C</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Exchange the bumped pointer to the table value in Register Pair HL with the counter value to the STACK</div></div>
									<div class="assembly-row-combined"><div>151D</div><div>DEC H<span class="opcode2">25</span></div><div>Decrement the counter value of the outer loop (in Register H) to see if there are more bytes to deal with</div></div>
									<div class="assembly-row-combined"><div>151E-1520</div><div><a href="#14FAH" class="memory-link">JP NZ,14FAH<span class="origrom2">JP NZ,RNDO0</span></a><span class="opcode2">C2 FA 14</span></div><div>Loop back to 14FAH three times until the random number has been figured</div></div>
									<div class="assembly-row-combined"><div>1521</div><div>POP HL<span class="opcode2">E1</span></div><div>Clear the flag table address from the STACK.  The fact that it is going into HL is not important</div></div>
									<div class="assembly-row-combined"><div>1522-1524</div><div>LD HL,B065H<span class="opcode2">21 65 B0</span></div><div>Load Register Pair HL with the value to re-seed the random number seed</div></div>
									<div class="assembly-row-combined"><div>1525</div><div>ADD HL,DE<span class="opcode2">19</span></div><div>Add the seed (from Register Pair HL) to the NMSB and the LSB of the random number in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1526-1528</div><div>LD (40AAH),HL<span class="origrom2">LD (RNDX),HL</span><span class="opcode2">22 AA 40</span></div><div>Save the adjusted value in Register Pair HL as the NMSB and the LSB of the random number seed.<br>Note: 40AAH-40ADH holds the random number seed</div></div>
									<div class="assembly-row-combined"><div>1529-152B</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0AEFH">CALL 0AEFH<span class="origrom2">CALL VALSNG</span></a><span class="opcode2">CD EF 0A</span></div><div>Go set the current number type to single precision</div></div>
									<div class="assembly-row-combined"><div>152C-152D</div><div>LD A,05H<span class="opcode2">3E 05</span></div><div>Load Register A with a 5</div></div>
									<div class="assembly-row-combined"><div>152E</div><div>ADC A,C<span class="opcode2">89</span></div><div>Add 5 (the value held in A) and the MSB of the random number in Register C</div></div>
									<div class="assembly-row-combined"><div>152F-1531</div><div>LD (40ACH),A<span class="origrom2">LD (RNDX+2),A</span><span class="opcode2">32 AC 40</span></div><div>Save the adjusted value in Register A as the MSB of the random number seed, so now the result is in A/H/L</div></div>
									<div class="assembly-row-combined"><div>1532</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Swap DE and HL so that the result is now in A/D/E</div></div>
									<div class="assembly-row-combined"><div>1533-1534</div><div>LD B,80H<span class="opcode2">06 80</span></div><div>Load Register B with a value for the sign flag and the exponent (i.e, 1000 0000)</div></div>
									<div class="assembly-row-combined"><div>1535-1537</div><div>LD HL,4125H<span class="origrom2">LD HL,FAC+1</span><span class="opcode2">21 25 41</span></div><div>Load Register Pair HL with the address for the sign value storage location.<br>Note: 4125H-4126H is used by floating point routines</div></div>
									<div class="assembly-row-combined"><div>1538</div><div>LD (HL),B<span class="opcode2">70</span></div><div>Save the sign result (1000 0000) in Register B at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1539</div><div>DEC HL<span class="opcode2">2B</span></div><div>Decrement to exponent (held in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>153A</div><div>LD (HL),B<span class="opcode2">70</span></div><div>Set the exponent to (1000 0000) so that the value will be &lt; 1</div></div>
									<div class="assembly-row-combined"><div>153B</div><div>LD C,A<span class="opcode2">4F</span></div><div>Now
 we just want to normalize C/D/E.  First, load Register C with the value
 of the MSB for the single precision random number in Register A</div></div>
									<div class="assembly-row-combined"><div>153C-153D</div><div>LD B,00H<span class="opcode2">06 00</span></div><div>Zero the value of any overflow in Register B</div></div>
									<div class="assembly-row-combined"><div>153E-1540</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0765H">JP 0765H<span class="origrom2">JP NORMAL</span></a><span class="opcode2">C3 65 07</span></div><div>Jump to 0765H which will normalize the value and then jump to 14D9H unless <span class="code">RND(0)</span> was called in which case return to caller</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1541H">1541-1546 - LEVEL II BASIC <span class="code">COS</span> ROUTINE<span class="origrom"> - "COS"</span>.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Single-precision only.(ACCumulator = COS(ACCumulator)).  A 
call to 1541H computes the cosine for an angle given in radians. The 
angle must be a floating point value in ACCumulator; the cosine will be 
returned in ACCumulator as a floating point value.<br><br> The formula being used is COS(X) = SIN(X+PI/2)</p> 				<div class="assembly-row-combined" id="1541H"><div>1541-1543<span class="origrom2">COS</span></div><div>LD HL,158BH<span class="origrom2">LD HL,PI2</span><span class="opcode2">21 8B 15</span></div><div>Load Register Pair HL with the starting address of a single precision constant equal to 1.57079637029 (which is pi / 2)</div></div>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1544-1546</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#070BH">CALL 070BH<span class="origrom2">CALL FADDS</span></a><span class="opcode2">CD 0B 07</span></div><div>GOSUB
 to 070BH to add 1.57079637029 (stored in HL) to the single precision 
value in ACCumulator and then pass through to the SIN() routine which is
 next</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1547H">1547-158A - LEVEL II BASIC <span class="code">SIN</span> ROUTINE<span class="origrom"> - "SIN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p> Single-precision only.(ACCumulator = SIN(ACCumulator)).<br><br> A call to 1549H returns the sine as a single precision value in ACCumulator. The sine must be given in radians in ACCumulator.<br><br> The actual calculation routine is:</p><ol> <li>Assume X &lt;= 360 degrees.</li> <li>Recompute x as x=x/360 so that x=&lt; 1.</li> <li>If x &lt;= 90 degrees go to step 7.</li> <li>If x &lt;= 180 degrees then x=0.5-x and then go to step 7.</li> <li>If x &lt;= 270 degrees then x=0.5-x.</li> <li>Recompute x as x=x-1.0.</li> <li>Compute SIN using the power series.</li> </ol><p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1547H"><div>1547-1549H<span class="origrom2">"SIN"</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09A4H">CALL 09A4H<span class="origrom2">CALL PUSHF</span></a><span class="opcode2">CD A4 09</span></div><div>First
 we want to divide the ACCumulator by 2*PI.  First, GOSUB to 09A4 which 
moves the SINGLE PRECISION value in ACCumulator (the x in a SIN(x) call)
 to the STACK (stored in LSB/MSB/Exponent order)</div></div>
									<div class="assembly-row-combined"><div>154A-154C</div><div>LD BC,8349H<span class="opcode2">01 49 83</span></div><div>Load Register Pair BC with the exponent and the MSB of a single precision constant</div></div>
									<div class="assembly-row-combined"><div>154D-154F</div><div>LD DE,0FDBH<span class="opcode2">11 DB 0F</span></div><div>Load
 Register Pair DE with the NMSB and the LSB of a single precision 
constant. Register Pairs BC and DE now hold a single precision constant 
equal to 6.2831855 (which is pi * 2)</div></div>
									<div class="assembly-row-combined"><div>1550-1552</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09B4H">CALL 09B4H<span class="origrom2">CALL MOVFR</span></a><span class="opcode2">CD B4 09</span></div><div>Move
 2 x pi value (held in DC/BE) into ACCumulator by GOSUB to 09B4H (which 
moves the SINGLE PRECISION value in DC/DE into ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>1553-1554</div><div>POP BC<br>POP DE<span class="opcode2">C1</span></div><div>Put the x from a SIN(x) call into BC/DE</div></div>
									<div class="assembly-row-combined"><div>1555-1557</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#08A2H">CALL 08A2H<span class="origrom2">CALL FDIV</span></a><span class="opcode2">CD A2 08</span></div><div>To
 divide the x from a SIN(x) call (held in BC/DE) by pi*2 (held in 
ACCumulator) we must GOSUB 80A2H to divide the single precision value in
 Register Pairs BC and DE by the single precision value in ACCumulator. 
Return with the single precision result in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>1558-155A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09A4H">CALL 09A4H<span class="origrom2">CALL PUSHF</span></a><span class="opcode2">CD A4 09</span></div><div>Move
 that value (x / 2*pi) from ACCumulator to the STACK by GOSUB to 09A4H 
which moves the SINGLE PRECISION value in ACCumulator to the STACK 
(stored in LSB/MSB/Exponent order)</div></div>
									<div class="assembly-row-combined"><div>155B-155D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0B40H">CALL 0B40H<span class="origrom2">CALL INT</span></a><span class="opcode2">CD 40 0B</span></div><div>Go
 figure the integer portion for the single precision value in 
ACCumulator by calling 0B40H.  We need to do this so we can isolate the 
remainder</div></div>
									<div class="assembly-row-combined"><div>155E,155F</div><div>POP BC<br>POP DE<span class="opcode2">C1</span></div><div>Put the quotient and remainder of x/2*pi into BC/DE</div></div>
									<div class="assembly-row-combined"><div>1560-1562</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0713H">CALL 0713H<span class="origrom2">CALL FSUB</span></a><span class="opcode2">CD 13 07</span></div><div>To
 get the remainder we need to subtract the integer portion from the full
 portion so we GOSUB 0713H (the SINGLE PRECISION SUBTRACT routine) to 
subtract the single precision value in BC/DE (the entire result) from 
the single precision value in ACCumulator (the integer part of the 
result).  The difference is left in ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>1563-1564</div><div>LD HL,158FH<span class="origrom2">LD HL,FR4</span><span class="opcode2">21 8F 15</span></div><div>Load Register Pair HL with the starting address of a single precision constant equal to 0.25</div></div>
									<div class="assembly-row-combined"><div>1566-1568</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0710H">CALL 0710H<span class="origrom2">CALL FSUBS</span></a><span class="opcode2">CD 10 07</span></div><div>Next
 in calculating a SIN we would need to subtract .25 (held in HL) from 
the fractional part (held in ACCumulator) so as to see if it is &lt;= to
 90 degrees.  To do this we GOSUB 0710H to subtract the single precision
 value in ACCumulator from the single precision constant pointed to by 
Register Pair HL. Return with the result in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>1569-156B</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0955H">CALL 0955H<span class="origrom2">CALL SIGN</span></a><span class="opcode2">CD 55 09</span></div><div>Go check the sign of the result of that (.25 - fractional part) subtraction which is held in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>156C</div><div>SCF<span class="opcode2">37</span></div><div>Set the Carry flag</div></div>
									<div class="assembly-row-combined"><div>156D-156F</div><div><a href="#1577H" class="memory-link">JP P,1577H<span class="origrom2">JP P,SIN1</span></a><span class="opcode2">F2 77 15</span></div><div>Jump to 1577H if the single precision value in ACCumulator is positive (meaning it is &lt; than 90 degrees)</div></div>
									<div class="assembly-row-combined"><div>1570-1572</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0708H">CALL 0708H<span class="origrom2">CALL FADDH</span></a><span class="opcode2">CD 08 07</span></div><div>If
 we are here, it is =&gt; 90 degrees, so we need to add .5 to the single
 precision value in ACCumulator. Return with the result in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>1573-1575</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0955H">CALL 0955H<span class="origrom2">CALL SIGN</span></a><span class="opcode2">CD 55 09</span></div><div>Go
 check the sign for the single precision value in ACCumulator which 
basically checks to see if it is &gt; 0.75 (meaning &lt; 270 degrees)</div></div>
									<div class="assembly-row-combined"><div>1576</div><div>OR A<span class="opcode2">B7</span></div><div>Test the value of the sign test in Register A</div></div>
									<div class="assembly-row-combined" id="1577H"><div>1577<span class="origrom2">SIN1</span></div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the sign indicator (+ or -1) in Register Pair AF to the STACK</div></div>
									<div class="assembly-row-combined"><div>1578-157A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0982H">CALL P,0982H<span class="origrom2">CALL P,NEG</span></a><span class="opcode2">F4 82 09</span></div><div>If it is positive, make it negative by GOSUB to 0982H</div></div>
									<div class="assembly-row-combined"><div>157B-157D</div><div>LD HL,158FH<span class="origrom2">LD HL,FR4</span><span class="opcode2">21 8F 15</span></div><div>Load Register Pair HL with the starting address of a single precision constant equal to 0.25</div></div>
									<div class="assembly-row-combined"><div>157E-1580</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#070BH">CALL 070BH<span class="origrom2">CALL FADDS</span></a><span class="opcode2">CD 0B 07</span></div><div>Add .25 (stored in HL) to the current value in ACCumulator by GOSUB to 070BH (result is saved in ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>1581</div><div>POP AF<span class="opcode2">F1</span></div><div>Get the sign reversal flag from the STACK and put it in Register Pair AF</div></div>
									<div class="assembly-row-combined"><div>1582-1584</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0982H">CALL NC,0982H<span class="origrom2">CALL NC,NEG</span></a><span class="opcode2">D4 82 09</span></div><div>Set the sign of the x term according to the quadrant by GOSUB to 0982H if if the Carry flag wasn't set from above</div></div>
									<div class="assembly-row-combined"><div>1585-1587</div><div>LD HL,1593H<span class="origrom2">LD HL,SINCON</span><span class="opcode2">21 93 15</span></div><div>Load
 Register Pair HL with 1593H (which is the starting address for a series
 of single precision values for a set of computations)</div></div>
									<div class="assembly-row-combined"><div>1588-158A</div><div><a href="#149AH" class="memory-link">JP 149AH<span class="origrom2">JP POLYX</span></a><span class="opcode2">C3 9A 14</span></div><div>Go to 149AH to compute the series and then RETURN</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="158BH">158B-158E - SINGLE PRECISION CONSTANT STORAGE LOCATION<span class="origrom"> - "PI2"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>158B-158EH<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;PI2</span></div><div>DB 0F 49 81<span class="opcode2">DB 0F</span></div><div>A single precision constant equal to 1.57079637029 is stored here</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="158FH">158F-1592 - SINGLE PRECISION CONSTANT STORAGE LOCATION<span class="origrom"> - "FR4"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>158F-1592H<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;FR4</span></div><div>00 00 00 7F</div><div>A single precision constant equal to 0.25 is stored here</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1593H">1593-15A7 - SINGLE PRECISION CONSTANTS STORAGE LOCATION<span class="origrom"> - "SINCON"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1593<span class="origrom2">SINCON</span></div><div>05H</div><div>The
 number of single precision constants (05) which follows is stored here.
  These are the coefficients used in the power series to compute SIN(x)</div></div>
									<div class="assembly-row-combined"><div>1594-1597H</div><div>BAH D7H 1EH 86H</div><div>A single precision constant equal to 39.7106704708 is stored here</div></div>
									<div class="assembly-row-combined"><div>1598-159BH</div><div>64H 26H 99H 87H</div><div>A single precision constant equal to -76.5749816893 is stored here</div></div>
									<div class="assembly-row-combined"><div>159C-159FH</div><div>58H 34H 23H 87H</div><div>A single precision constant equal to 81.6022338865 is stored here</div></div>
									<div class="assembly-row-combined"><div>15A0-15A3H</div><div>E0H 6DH A5H 86H</div><div>A single precision constant equal to -41.3416748045 is stored here</div></div>
									<div class="assembly-row-combined"><div>15A4-15A7H</div><div>DAH 0FH 49H 83H</div><div>A single precision constant equal to 6.28318500497 is stored here</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="15A8H">15A8-15BC - LEVEL II BASIC <span class="code">TAN(n)</span> ROUTINE<span class="origrom"> - "TAN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Single-precision only.(ACCumulator = TAN(ACCumulator)).<br>A 
call to 15A8H computes the tangent of an angle in radians. The angle 
must be specified as a single precision value in ACCumulator. The 
tangent will be left in ACCumulator.<br>Uses the fact that TAN(x) = SIN(x) / COS(x)</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>15A8-15AA<span class="origrom2">TAN</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09A4H">CALL 09A4H<span class="origrom2">CALL PUSHF</span></a><span class="opcode2">CD A4 09</span></div><div>Save
 the argument via a GOSUB to 09A4 which moves the SINGLE PRECISION value
 in ACCumulator to the STACK (stored in LSB/MSB/Exponent order)</div></div>
									<div class="assembly-row-combined"><div>15AB-15AD</div><div><a href="#1547H" class="memory-link">CALL 1547H<span class="origrom2">CALL SIN</span></a><span class="opcode2">CD 47 15</span></div><div>Call the <span class="code">SIN(n)</span>
 routine at 1547H (which returns the sine as a single precision value in
 ACCumulator. The sine must be given in radians in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>15AE,15AF</div><div>POP BC<br>POP HL<span class="opcode2">C1</span></div><div>Get the original exponent and value from the STACK and put it in Register Pair BC/HL</div></div>
									<div class="assembly-row-combined"><div>15B0-15B2</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09A4H">CALL 09A4H<span class="origrom2">CALL PUSHF</span></a><span class="opcode2">CD A4 09</span></div><div>Call 09A4 which moves the SIN(x) single precision value (stored in REG) 1 to the STACK (stored in LSB/MSB/Exponent order)</div></div>
									<div class="assembly-row-combined"><div>15B3</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Load Register Pair DE with the NMSB and the LSB of the single precision value in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>15B4-15B6H&nbsp;</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09B4H">CALL 09B4H<span class="origrom2">CALL MOVFR</span></a><span class="opcode2">CD B4 09</span></div><div>Call 09B4H (which moves the original value in BC/DE into ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>15B7-15B9</div><div><a href="#1541H" class="memory-link">CALL 1541H<span class="origrom2">CALL COS</span></a><span class="opcode2">CD 41 15</span></div><div>Call
 the COSINE routine at 1541H (which computes the cosine for an angle 
given in radians. The angle must be a floating point value; the cosine 
will be returned in ACCumulator as a floating point value</div></div>
									<div class="assembly-row-combined"><div>15BA-15BC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#08A0H">JP 08A0H<span class="origrom2">JP FDIVT</span></a><span class="opcode2">C3 A0 08</span></div><div>Jump to 08A0H to compute <span class="code">SIN(n)</span> / <span class="code">COS(n)</span> and return the value as <span class="code">TAN(n)</span></div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="15BDH">15BD-15E2 - LEVEL II BASIC <span class="code">ATN(n)</span> ROUTINE<span class="origrom"> - "ATN"</span>.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Single-precision only.(ACCumulator = ATN(ACCumulator)).<br>A 
call to 15BD returns the angle in radians, for the floating point 
tangent value in ACCumulator. The angle will be left as a single 
precision value in ACCumulator.<br><br>The method of computation used in this routine is: </p><ol> <li>Test
 the sign of the tangent to see if a negative angle is in the 2nd or 4th
 quadrant.  Set the flag to force the result to positive on exit.  If 
the value is negative, invert the sign.</li> <li>Test magnitude of 
tangent.  If it is &lt; 1 go to step 3.  Otherwise, compute its 
reciprocal and put the return address on the STACK that will calculate 
pi/2 - series value.</li> <li>Evaluate the series:  (((x^2*c0+c1) x^2+c2) . c8)x</li> <li>If the flag from step 1 is not set, then invert the sign of the series result.</li> <li>If the original value is &lt; 1 then return to the caller.  Otherwise, compute pi/2-value from step 4 and then return.</li> </ol><p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>15BD-15BF<span class="origrom2">ATN</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0955H">CALL 0955H<span class="origrom2">CALL SIGN</span></a><span class="opcode2">CD 55 09</span></div><div>Go check the sign of argument (i.e., the single precision value in the ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>15C0-15C2</div><div><a href="#13E2H" class="memory-link">CALL M,13E2H<span class="origrom2">CALL M,PSHNEG</span></a><span class="opcode2">FC E2 13</span></div><div>If the single precision value in ACCumulator is negative then put a return address of 13E2H to the STACK</div></div>
									<div class="assembly-row-combined"><div>15C3-15C5</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0982H">CALL M,0982H<span class="origrom2">CALL M,NEG</span></a><span class="opcode2">FC 82 09</span></div><div>Go convert the negative number in ACCumulator to positive if necessary</div></div>
									<div class="assembly-row-combined"><div>15C6-15C8</div><div>LD A,(4124H)<span class="origrom2">LD A,(FAC)</span><span class="opcode2">3A 24 41</span></div><div>We
 next want to see if the ACCumulator is &gt; 1, so load Register A with 
the exponent of the tangent (which is a single precision value in 
ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>15C9-15CA</div><div>CP 81H<span class="opcode2">FE 81</span></div><div>Check to see if the the exponent of the tangent (which is a single precision value in ACCumulator) is less than one</div></div>
									<div class="assembly-row-combined"><div>15CB-15CC</div><div><a href="#15D9H" class="memory-link">JR C,15D9H<span class="origrom2">JR C,ATN2</span></a><span class="opcode2">38 0C</span></div><div>Jump to forward 15D9H if the carry flag is set (i.e., the single precision value in ACCumulator is less than one)</div></div>
									<div class="assembly-row-combined"><div>15CD-15CF</div><div>LD BC,8100H<span class="opcode2">01 00 81</span></div><div>Load Register Pair BC with an exponent and a MSB for a single precision value</div></div>
									<div class="assembly-row-combined"><div>15D0</div><div>LD D,C<span class="opcode2">51</span></div><div>Zero the NMSB of the single precision value in Register D</div></div>
									<div class="assembly-row-combined"><div>15D1</div><div>LD E,C<span class="opcode2">59</span></div><div>Zero the LSB of the single precision value in Register E</div></div>
									<div class="assembly-row-combined"><div>15D2-15D4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#08A2H">CALL 08A2H<span class="origrom2">CALL FDIV</span></a><span class="opcode2">CD A2 08</span></div><div>GOSUB
 082AH to get the reciprocal of the tangent.  This routine divides the 
single precision value in ACCumulator into the single precision constant
 in Register Pairs BC and DE</div></div>
									<div class="assembly-row-combined"><div>15D5-15D7</div><div>LD HL,0710H<span class="origrom2">LD HL,FSUBS</span><span class="opcode2">21 10 07</span></div><div>Load Register Pair HL with a return address of 0710H (which is the subtract routine to be called once the series is calculated)</div></div>
									<div class="assembly-row-combined"><div>15D8</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value of the return address in Register Pair HL to the STACK</div></div>
									<div class="assembly-row-combined" id="15D9H"><div>15D9-15DB<span class="origrom2">ATN2</span></div><div>LD HL,15E3H<span class="origrom2">LD HL,ATNCON</span><span class="opcode2">21 E3 15</span></div><div>Load Register Pair HL with the starting address for a series of single precision numbers for a set of computations</div></div>
									<div class="assembly-row-combined"><div>15DC-15DE</div><div><a href="#149AH" class="memory-link">CALL 149AH<span class="origrom2">CALL POLYX</span></a><span class="opcode2">CD 9A 14</span></div><div>Go do the set of computations</div></div>
									<div class="assembly-row-combined"><div>15DF-15E1</div><div>LD HL,158BH<span class="origrom2">LD HL,PI2</span><span class="opcode2">21 8B 15</span></div><div>Load Register Pair HL with the starting address of a single precision constant equal to 1.57079637029 (which is pi/2)</div></div>
									<div class="assembly-row-combined"><div>15E2</div><div>RET<span class="opcode2">C9</span></div><div>Return.  The return address was set to 0710H above, which will then subtract the last term from pi/2 and then return</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="15E3H">15E3-1607 - SINGLE PRECISION CONSTANTS STORAGE LOCATION<span class="origrom"> - "ATNCON"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>15E3<span class="origrom2">ATNCON</span></div><div>09</div><div>The number of single precision constants (9) which follows is stored here</div></div>
									<div class="assembly-row-combined"><div>15E4-15E7</div><div>4A D7 3B 78</div><div>A single precision constant equal to 0.00286622549 is stored here</div></div>
									<div class="assembly-row-combined"><div>15E8-15EB</div><div>02 6E 84 7B</div><div>A single precision constant equal to -0.01616573699 is stored here</div></div>
									<div class="assembly-row-combined"><div>15EC-15EF</div><div>FE C1 2F 7C</div><div>A single precision constant equal to 0.04290961441 is stored here</div></div>
									<div class="assembly-row-combined"><div>15F0-15F3</div><div>74 31 9A 3D</div><div>A single precision constant equal to 0.07528963666 is stored here</div></div>
									<div class="assembly-row-combined"><div>15F4-15F7</div><div>84 3D 5A 7D</div><div>A single precision constant equal to 0.10656264407 is stored here</div></div>
									<div class="assembly-row-combined"><div>15F8-15FB</div><div>C8 7F 91 7E</div><div>A single precision constant equal to -0.14208900905 is stored here</div></div>
									<div class="assembly-row-combined"><div>15FC-15FF</div><div>E4 BB 4C 7E</div><div>A single precision constant equal to 0.19993549561 is stored here</div></div>
									<div class="assembly-row-combined" id="1600H"><div>1600-1603</div><div>6C AA AA 7F</div><div>A single precision constant equal to -0.33333146561 is stored here</div></div>
									<div class="assembly-row-combined"><div>1604-1607</div><div>00 00 00 01</div><div>A single precision constant equal to 1.0 is stored here</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1608H">1608H-164FH - FUNCTION DISPATCH TABLE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This table stores entry locations (16-bit addresses) for function handlers (right-side expression routines).</p>
								<p>Structure: 36 entries, each a 2-byte word (little-endian) 
pointing to the ROM routine for the function.  Corresponds to tokens 
D7H‚ÄìFAH (215‚Äì250 decimal, 36 functions).</p>
								<p>Purpose: During expression evaluation, the token (minus D7H) 
is multiplied by 2 to index into this table. The fetched address is 
loaded into HL, and control jumps to it (e.g., via JP (HL) at 000CH).</p>
							</div>

							<h2 class="assembly-section-title" id="1650H">1650H-1821H - RESERVED WORD TABLE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This table contains all BASIC reserved words (keywords like 
END, FOR, SIN, etc.) in concatenated form.  Each word is stored as ASCII
 characters, with the high bit (bit 7) set on the last character (i.e., 
ORed with 80H) to mark the end of the word. There are no null 
terminators or separators between words.</p>
								<p>The order in the table determines the token value: the first 
word is token 80H (128 decimal), the second 81H, and so on up to the 
last (token FAH for MID$), for 466 bytes.</p>
								<p>Purpose: During input scanning (e.g., via ROM routine at 
1BC0H), the interpreter matches input strings against this table and 
replaces them with the corresponding 1-byte token for compact storage in
 the Program Statement Table (PST).</p>
								<p>Tokens 80H‚ÄìBBH are typically statements (e.g., END, FOR, IF).
 Tokens BCH‚ÄìD6H are operators/misc (e.g., AND, OR). Tokens D7H‚ÄìFAH are 
functions (e.g., SGN, INT, MID$).</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1650-1652</div><div>C5 4E 44</div><div>END (Token = 80H) [C5="E", 4E="N", 44="D"]</div></div>
									<div class="assembly-row-combined"><div>1653-1655</div><div>C6 4F 52</div><div>FOR (Token = 81H) [C6="F", 4F="O", 52="R"]</div></div>
									<div class="assembly-row-combined"><div>1656-165A</div><div>D2 45 53 45 54</div><div>RESET (Token = 82H) [D2="R", 45="E", 53="S", 45="E", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>165B-165D</div><div>D3 45 54</div><div>SET (Token = 83H) [D3="S", 45="E", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>165E-1660</div><div>C3 4C 53</div><div>CLS (Token = 84H) [C3="C", 4C="L", 53="S"]</div></div>
									<div class="assembly-row-combined"><div>1661-1663</div><div>C3 4D 44</div><div>CMD (Token = 85H) [C3="C", 4D="M", 44="D"]</div></div>
									<div class="assembly-row-combined"><div>1664-1669</div><div>D2 41 4E 44 4F 4D</div><div>RANDOM (Token = 86H) [D2="R", 41="A", 4E="N", 44="D", 4F="O", 4D="M"]</div></div>
									<div class="assembly-row-combined"><div>166A-166D</div><div>CE 45 58 54</div><div>NEXT (Token = 87H) [CE="N", 45="E", 58="X", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>166E-1671</div><div>C4 41 54 41</div><div>DATA (Token = 88H) [C4="D", 41="A", 54="T", 41="A"]</div></div>
									<div class="assembly-row-combined"><div>1672-1676</div><div>C9 4E 50 55 54</div><div>INPUT (Token = 89H) [C9="I", 4E="N", 50="P", 55="U", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>1677-1679</div><div>C4 49 4D</div><div>DIM (Token = 8AH) [C4="D", 49="I", 4D="M"]</div></div>
									<div class="assembly-row-combined"><div>167A-167D</div><div>D2 45 41 44</div><div>READ (Token = 8BH) [D2="R", 45="E", 41="A", 44="D"]</div></div>
									<div class="assembly-row-combined"><div>167E-1680</div><div>CC 45 54</div><div>LET (Token = 8CH) [CC="L", 45="E", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>1681-1684</div><div>C7 4F 54 4F</div><div>GOTO (Token = 8DH) [C7="G", 4F="O", 54="T", 4F="O"]</div></div>
									<div class="assembly-row-combined"><div>1685-1687</div><div>D2 55 4E</div><div>RUN (Token = 8EH) [D2="R", 55="U", 4E="N"]</div></div>
									<div class="assembly-row-combined"><div>1688-1689</div><div>C9 46</div><div>IF (Token = 8FH) [C9="I", 46="F"]</div></div>
									<div class="assembly-row-combined"><div>168A-1690</div><div>D2 45 53 54 4F 52 45</div><div>RESTORE (Token = 90H) [D2="R", 45="E", 53="S", 54="T", 4F="O", 52="R", 45="E"]</div></div>
									<div class="assembly-row-combined"><div>1691-1695</div><div>C7 4F 53 55 42</div><div>GOSUB (Token = 91H) [C7="G", 4F="O", 53="S", 55="U", 42="B"]</div></div>
									<div class="assembly-row-combined"><div>1696-169B</div><div>D2 45 54 55 52 4E</div><div>RETURN (Token = 92H) [D2="R", 45="E", 54="T", 55="U", 52="R", 4E="N"]</div></div>
									<div class="assembly-row-combined"><div>169C-169E</div><div>D2 45 4D</div><div>REM (Token = 93H) [D2="R", 45="E", 4D="M"]</div></div>
									<div class="assembly-row-combined"><div>169F-16A2</div><div>D3 54 4F 50</div><div>STOP (Token = 94H) [D3="S", 54="T", 4F="O", 50="P"]</div></div>
									<div class="assembly-row-combined"><div>16A3-16A6</div><div>C5 4C 53 45</div><div>ELSE (Token = 95H) [C5="E", 4C="L", 53="S", 45="E"]</div></div>
									<div class="assembly-row-combined"><div>16A7-16AA</div><div>D4 52 4F 4E</div><div>TRON (Token = 96H) [D4="T", 52="R", 4F="O", 4E="N"]</div></div>
									<div class="assembly-row-combined"><div>16AB-16AF</div><div>D4 52 4F 46 46</div><div>TROFF (Token = 97H) [D4="T", 52="R", 4F="O", 46="F", 46="F"]</div></div>
									<div class="assembly-row-combined"><div>16B0-16B5</div><div>C4 45 46 53 54 52</div><div>DEFSTR (Token = 98H) [C4="D", 45="E", 46="F", 53="S", 54="T", 52="R"]</div></div>
									<div class="assembly-row-combined"><div>16B6-16BB</div><div>C4 45 46 49 4E 54</div><div>DEFINT (Token = 99H) [C4="D", 45="E", 46="F", 49="I", 4E="N", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>16BC-16C1</div><div>C4 45 46 53 4E 47</div><div>DEFSNG (Token = 9AH) [C4="D", 45="E", 46="F", 53="S", 4E="N", 47="G"]</div></div>
									<div class="assembly-row-combined"><div>16C2-16C7</div><div>C4 45 46 44 42 4C</div><div>DEFDBL (Token = 9BH) [C4="D", 45="E", 46="F", 44="D", 42="B", 4C="L"]</div></div>
									<div class="assembly-row-combined"><div>16C8-16CB</div><div>CC 49 4E 45</div><div>LINE (Token = 9CH) [CC="L", 49="I", 4E="N", 45="E"]</div></div>
									<div class="assembly-row-combined"><div>16CC-16CF</div><div>C5 44 49 54</div><div>EDIT (Token = 9DH) [C5="E", 44="D", 49="I", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>16D0-16D4</div><div>C5 52 52 4F 52</div><div>ERROR (Token = 9EH) [C5="E", 52="R", 52="R", 4F="O", 52="R"]</div></div>
									<div class="assembly-row-combined"><div>16D5-16DA</div><div>D2 45 53 55 4D 45</div><div>RESUME (Token = 9FH) [D2="R", 45="E", 53="S", 55="U", 4D="M", 45="E"]</div></div>
									<div class="assembly-row-combined"><div>16DB-16DD</div><div>CF 55 54</div><div>OUT (Token = A0H) [CF="O", 55="U", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>16DE-16DF</div><div>CF 4E</div><div>ON (Token = A1H) [CF="O", 4E="N"]</div></div>
									<div class="assembly-row-combined"><div>16E0-16E3</div><div>CF 50 45 4E</div><div>OPEN (Token = A2H) [CF="O", 50="P", 45="E", 4E="N"]</div></div>
									<div class="assembly-row-combined"><div>16E4-16E8</div><div>C6 49 45 4C 44</div><div>FIELD (Token = A3H) [C6="F", 49="I", 45="E", 4C="L", 44="D"]</div></div>
									<div class="assembly-row-combined"><div>16E9-16EB</div><div>C7 45 54</div><div>GET (Token = A4H) [C7="G", 45="E", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>16EC-16EE</div><div>D0 55 54</div><div>PUT (Token = A5H) [D0="P", 55="U", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>16EF-16F3</div><div>C3 4C 4F 53 45</div><div>CLOSE (Token = A6H) [C3="C", 4C="L", 4F="O", 53="S", 45="E"]</div></div>
									<div class="assembly-row-combined"><div>16F4-16F7</div><div>CC 4F 41 44</div><div>LOAD (Token = A7H) [CC="L", 4F="O", 41="A", 44="D"]</div></div>
									<div class="assembly-row-combined"><div>16F8-16FC</div><div>CD 45 52 47 45</div><div>MERGE (Token = A8H) [CD="M", 45="E", 52="R", 47="G", 45="E"]</div></div>
									<div class="assembly-row-combined"><div>16FD-1700</div><div>CE 41 4D 45</div><div>NAME (Token = A9H) [CE="N", 41="A", 4D="M", 45="E"]</div></div>
									<div class="assembly-row-combined"><div>1701-1704</div><div>CB 49 4C 4C</div><div>KILL (Token = AAH) [CB="K", 49="I", 4C="L", 4C="L"]</div></div>
									<div class="assembly-row-combined"><div>1705-1708</div><div>CC 53 45 54</div><div>LSET (Token = ABH) [CC="L", 53="S", 45="E" 54="T"]</div></div>
									<div class="assembly-row-combined"><div>1709-170C</div><div>D2 53 45 54</div><div>RSET (Token = ACH) [D2="R", 53="S", 45="E" 54="T"]</div></div>
									<div class="assembly-row-combined"><div>170D-1710</div><div>D3 41 56 45</div><div>SAVE (Token = ADH) [D3="S", 41="A", 56="V", 45="E"]</div></div>
									<div class="assembly-row-combined"><div>1711-1716</div><div>D3 59 53 54 45  4D</div><div>SYSTEM (Token = AEH) [D3="S", 59="Y", 53="S", 54="T", 45="E", 4D="M"]</div></div>
									<div class="assembly-row-combined"><div>1717-171C</div><div>CC 50 52 49 4E 54</div><div>LPRINT (Token = AFH) [CC="L", 50="P", 52="R", 49="I", 4E="N", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>171D-171F</div><div>C4 45 46</div><div>DEF (Token = B0H) [C4="D", 45="E", 46="F"]</div></div>
									<div class="assembly-row-combined"><div>1720-1723</div><div>D0 4F 4B 45</div><div>POKE (Token = B1H) [D0="P", 4F="O", 4B="K", 45="E"]</div></div>
									<div class="assembly-row-combined"><div>1724-1728</div><div>D0 52 49 4E 54</div><div>PRINT (Token = B2H) [D0="P", 52="R", 49="I", 4E="N", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>1729-172C</div><div>C3 4F 4E 54</div><div>CONT (Token = B3H) [C3="C", 4F="O", 4E="N", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>172D-1730</div><div>CC 49 53 54</div><div>LIST (Token = B4H) [CC="L", 49="I", 53="S", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>1731-1735</div><div>CC 4C 49 53 54</div><div>LLIST (Token = B5H) [CC="L", 4C="L", 49="I", 53="S", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>1736-173B</div><div>C4 45 4C 45 54 45</div><div>DELETE (Token = B6H) [C4="D", 45="E", 4C="L", 45="E", 54="T", 45="E"]</div></div>
									<div class="assembly-row-combined"><div>173C-173F</div><div>C1 55 54 4F</div><div>AUTO (Token = B7H) [C1="A", 55="U", 54="T", 4F="O"]</div></div>
									<div class="assembly-row-combined"><div>1740-1744</div><div>C3 4C 45 41 52</div><div>CLEAR (Token = B8H) [C3="C", 4C="L", 45="E", 41="A", 52="R"]</div></div>
									<div class="assembly-row-combined"><div>1745-1749</div><div>C3 4C 4F 41 44</div><div>CLOAD (Token = B9H) [C3="C", 4C="L", 4F="O", 41="A", 44="D"]</div></div>
									<div class="assembly-row-combined"><div>174A-174E</div><div>C3 53 41 56 45</div><div>CSAVE (Token = BAH) [C3="C", 53="S", 41="A", 56="V", 45="E"]</div></div>
									<div class="assembly-row-combined"><div>174F-1751</div><div>CE 45 57</div><div>NEW (Token = BBH) [CE="N", 45="E", 57="W"]</div></div>
									<div class="assembly-row-combined"><div>1752-1755</div><div>D4 41 42 28</div><div>TAB( (Token = BCH) [D4="T", 41="A", 42="B", 28="("]</div></div>
									<div class="assembly-row-combined"><div>1756-1757</div><div>D4 4F</div><div>TO (Token = BDH) [D4="T", 4F="O"]</div></div>
									<div class="assembly-row-combined"><div>1758-1759</div><div>C6 4E</div><div>FN (Token = BEH) [C6="F", 4E="N"]</div></div>
									<div class="assembly-row-combined"><div>175A-175E</div><div>D5 53 49 4E 47</div><div>USING (Token = BFH) [D5="U", 53="S", 49="I", 4E="N", 47="G"]</div></div>
									<div class="assembly-row-combined"><div>175F-1764</div><div>D6 41 52 50 54 52</div><div>VARPTR (Token = C0H) [D6="V", 41="A", 52="R", 50="P", 54="T", 52="R"]</div></div>
									<div class="assembly-row-combined"><div>1765-1767</div><div>D5 53 52</div><div>USR (Token = C1H) [D5="U", 53="S", 52="R"]</div></div>
									<div class="assembly-row-combined"><div>1768-176A</div><div>C5 52 4C</div><div>ERL (Token = C2H) [C5="E", 52="R", 4C="L"]</div></div>
									<div class="assembly-row-combined"><div>176B-176D</div><div>C5 52 52</div><div>ERR (Token = C3H) [C5="E", 52="R", 52="R"]</div></div>
									<div class="assembly-row-combined"><div>176E-1774</div><div>D3 54 52 49 4E 47 24</div><div>STRING$ (Token = C4H) [D3="S", 54="T" 52="R", 49="I", 4E="N", 47="G", 24="$"]</div></div>
									<div class="assembly-row-combined"><div>1775-1779</div><div>C9 4E 53 54 52</div><div>INSTR (Token = C5H) [C9="I", 4E="N", 53="S", 54="T", 52="R"]</div></div>
									<div class="assembly-row-combined"><div>177A-177E</div><div>D0 4F 49 4E 54</div><div>POINT (Token = C6H) [D0="P", 4F="O", 49="I", 4E="N", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>177F-1783</div><div>D4 49 4D 45 24</div><div>TIME$ (Token = C7H) [D4="T", 49="I", 4D="M", 45="E", 24="$"]</div></div>
									<div class="assembly-row-combined"><div>1784-1786</div><div>CD 45 4D</div><div>MEM (Token = C8H) [CD="M", 45="E", 4D="M"]</div></div>
									<div class="assembly-row-combined"><div>1787-178C</div><div>C9 4E 4B 45 59 24</div><div>INKEY$ (Token = C9H) [C9="I", 4E="N", 4B="K", 45="E", 59="Y", 24="$"]</div></div>
									<div class="assembly-row-combined"><div>178D-1790</div><div>D4 48 45 4E</div><div>THEN (Token = CAH) [D4="T", 48="H", 45="E", 4E="N"]</div></div>
									<div class="assembly-row-combined"><div>1791-1793</div><div>CE 4F 54</div><div>NOT (Token = CBH) [CE="N", 4F="O", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>1794-1797</div><div>D3 54 45 50</div><div>STEP (Token = CCH) [D3="S", 54="T", 45="E", 50="P"]</div></div>
									<div class="assembly-row-combined"><div>1798-1798</div><div>AB</div><div>+ (Token = CDH) [AB="+"]</div></div>
									<div class="assembly-row-combined"><div>1799-1799</div><div>AD</div><div>- (Token = CEH) [AD="-"]</div></div>
									<div class="assembly-row-combined"><div>179A-179A</div><div>AA</div><div>* (Token = CFH) [AA="*"]</div></div>
									<div class="assembly-row-combined"><div>179B-179B</div><div>AF</div><div>/ (Token = D0H) [AF="/"]</div></div>
									<div class="assembly-row-combined"><div>179C-179C</div><div>DB</div><div>[ (Token = D1H) [DB="["]</div></div>
									<div class="assembly-row-combined"><div>179D-179F</div><div>C1 4E 44</div><div>AND (Token = D2H) [C1="A", 4E="N", 44="D"]</div></div>
									<div class="assembly-row-combined"><div>17A0-17A1</div><div>CF 52</div><div>OR (Token = D3H) [CF="O", 52="R"]</div></div>
									<div class="assembly-row-combined"><div>17A2-17A2</div><div>BE</div><div>&gt; (Token = D4H) [BE="&gt;"]</div></div>
									<div class="assembly-row-combined"><div>17A3-17A3</div><div>BD</div><div>= (Token = D5H) [BD="="]</div></div>
									<div class="assembly-row-combined"><div>17A4-17A4</div><div>BC</div><div>&lt; (Token = D6H) [BC="&lt;"]</div></div>
									<div class="assembly-row-combined"><div>17A5-17A7</div><div>D3 47 4E</div><div>SGN (Token = D7H) [D3="S", 47="G", 4E="N"]</div></div>
									<div class="assembly-row-combined"><div>17A8-17AA</div><div>C9 4E 54</div><div>INT (Token = D8H) [C9="I", 4E="N", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>17AB-17AD</div><div>C1 42 53</div><div>ABS (Token = D9H) [C1="A", 42="B", 53="S"]</div></div>
									<div class="assembly-row-combined"><div>17AE-17B0</div><div>C6 52 45</div><div>FRE (Token = DAH) [C6="F", 52="R", 45="E"]</div></div>
									<div class="assembly-row-combined"><div>17B1-17B3</div><div>C9 4E 50</div><div>INP (Token = DBH) [C9="I", 4E="N", 50="P"]</div></div>
									<div class="assembly-row-combined"><div>17B4-17B6</div><div>D0 4F 53</div><div>POS (Token = DCH) [D0="P", 4F="O", 53="S"]</div></div>
									<div class="assembly-row-combined"><div>17B7-17B9</div><div>D3 51 52</div><div>SQR (Token = DDH) [D3="S", 51="Q", 52="R"]</div></div>
									<div class="assembly-row-combined"><div>17BA-17BC</div><div>D2 4E 44</div><div>RND (Token = DEH) [D2="R", 4E="N", 44="D"]</div></div>
									<div class="assembly-row-combined"><div>17BD-17BF</div><div>CC 4F 47</div><div>LOG (Token = DFH) [CC="L", 4F="O", 47="G"]</div></div>
									<div class="assembly-row-combined"><div>17C0-17C2</div><div>C5 58 50</div><div>EXP (Token = E0H) [C5="E", 58="X", 50="P"]</div></div>
									<div class="assembly-row-combined"><div>17C3-17C5</div><div>C3 4F 53</div><div>COS (Token = E1H) [C3="C", 4F="O", 53="S"]</div></div>
									<div class="assembly-row-combined"><div>17C6-17C7</div><div>D3 49 4E</div><div>SIN (Token = E2H) [D3="S", 49="I", 4E="N"]</div></div>
									<div class="assembly-row-combined"><div>17C9-17CB</div><div>D4 41 4E</div><div>TAN (Token = E3H) [D4="T", 41="A", 4E="N"]</div></div>
									<div class="assembly-row-combined"><div>17CC-17CE</div><div>C1 54 4E</div><div>ATN (Token = E4H) [C1="A", 54="T", 4E="N"]</div></div>
									<div class="assembly-row-combined"><div>17CF-17D2</div><div>D0 45 45 4B</div><div>PEEK (Token = E5H) [D0="P", 45="E", 45="E", 4B="K"]</div></div>
									<div class="assembly-row-combined"><div>17D3-17D5</div><div>C3 56 49</div><div>CVI (Token = E6H) [C3="C", 56="V", 49="I"]</div></div>
									<div class="assembly-row-combined"><div>17D6-17D8</div><div>C3 56 53</div><div>CVS (Token = E7H) [C3="C", 56="V", 53="S"]</div></div>
									<div class="assembly-row-combined"><div>17D9-17DB</div><div>C3 56 44</div><div>CVD (Token = E8H) [C3="C", 56="V", 44="D"]</div></div>
									<div class="assembly-row-combined"><div>17DC-17DE</div><div>C5 4F 46</div><div>EOF (Token = E9H) [C5="E", 4F="O", 46="F"]</div></div>
									<div class="assembly-row-combined"><div>17DF-17E1</div><div>CC 4F 43</div><div>LOC (Token = EAH) [CC="L", 4F="O", 43="C"]</div></div>
									<div class="assembly-row-combined"><div>17E2-17E4</div><div>CC 4F 46</div><div>LOF (Token = EBH) [CC="L", 4F="O", 46="F"]</div></div>
									<div class="assembly-row-combined"><div>17E5-17E8</div><div>CD 4B 49 24</div><div>MKI$ (Token = ECH) [CD="M", 4B="K", 49="I", 24="$"]</div></div>
									<div class="assembly-row-combined"><div>17E9-17EC</div><div>CD 4B 53 24</div><div>MKS$ (Token = EDH) [CD="M", 4B="K", 53="S", 24="$"]</div></div>
									<div class="assembly-row-combined"><div>17ED-17F0</div><div>CD 4B 44 24</div><div>MKD$ (Token = EEH) [CD="M", 4B="K", 44="D", 24="$"]</div></div>
									<div class="assembly-row-combined"><div>17F1-17F4</div><div>C3 49 4E 54</div><div>CINT (Token = EFH) [C3="C", 49="I", 4E="N", 54="T"]</div></div>
									<div class="assembly-row-combined"><div>17F5-17F8</div><div>C3 53 4E 47</div><div>CSNG (Token = F0H) [C3="C", 53="S", 4E="N", 47="G"]</div></div>
									<div class="assembly-row-combined"><div>17F9-17FC</div><div>C3 44 42 4C</div><div>CDBL (Token = F1H) [C3="C", 44="D", 42="B", 4C="L"]</div></div>
									<div class="assembly-row-combined"><div>17FD-17FF</div><div>C6 49 58</div><div>FIX (Token = F2H) [C6="F", 49="I", 58="X"]</div></div>
									<div class="assembly-row-combined"><div>1800-1802</div><div>CC 45 4E</div><div>LEN (Token = F3H) [CC="L", 45="E", 4E="M"]</div></div>
									<div class="assembly-row-combined"><div>1803-1806</div><div>D3 54 52  24</div><div>STR$ (Token = F4H) [D3="S", 54="T", 52="R", 24="$"]</div></div>
									<div class="assembly-row-combined"><div>1807-1809</div><div>D6 41 4C</div><div>VAL (Token = F5H) [D6="V", 41="A", 4C="L"]</div></div>
									<div class="assembly-row-combined"><div>180A-180C</div><div>C1 53 43</div><div>ASC (Token = F6H) [C1="A", 53="S", 43="C"]</div></div>
									<div class="assembly-row-combined"><div>180D-1810</div><div>C3 48 52 24</div><div>CHR$ (Token = F7H) [C3="C", 48="H", 52="R", 24="$"]</div></div>
									<div class="assembly-row-combined"><div>1811-1815</div><div>CC 45 46 54 4</div><div>LEFT$ (Token = F8H) [CC="L", 45="E", 46="F", 54="T", 24="$"]</div></div>
									<div class="assembly-row-combined"><div>1816-181B</div><div>D2 49 47 48 54 24</div><div>RIGHT$ (Token = F9H) [D2="R", 49="I", 47="G", 48="H", 54="T", 24="$"]</div></div>
									<div class="assembly-row-combined"><div>181C-181F</div><div>CD 49 44 24</div><div>MID$ (Token = FAH) [CD="M", 49="I", 44="D", 24="$"]</div></div>
									<div class="assembly-row-combined"><div>1820</div><div>A7</div><div>' (Token = FBH) [A7="'"]</div></div>
									<div class="assembly-row-combined"><div>1821</div><div>80</div><div>[end marker]</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1822H">1822H-1899H - STATEMENT DISPATCH TABLE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This table stores entry locations for statement handlers (verb action routines).</p>
								<p>Structure: 60 entries, each a 2-byte word (little-endian) 
pointing to the ROM routine that executes the statement.  The entries 
correspond to tokens 80H‚ÄìBBH (128‚Äì187 decimal, 60 statements).</p>
								<p>Purpose: This table tells the interpreter where to jump to 
execute commands.  The execution driver (at 1D5AH) fetches a token from 
the current line. If it's 80H‚ÄìBBH, it subtracts 80H, multiplies by 2, 
indexes into this table, loads the address into HL, and jumps to the 
handler.</p>
								<p>Tokens BC‚ÄìF9H are invalid as line starters (except in 
specific contexts like IF...THEN) and are handled differently (e.g., 
within expressions).</p>
								<p>Example:</p>
								<ul>
									<li>Program line contains tokenized BASIC "10 GOTO 100" stored as [31 30 $88]</li>
									<li>Interpreter reads token $88 (GOTO)</li>
									<li>Calculate table offset (Index = Token - $80 = $88 - $80 = 8; and then Offset = Index √ó 2 = 16 bytes)</li>
									<li>Look up handler address (Table base: 1822H; Entry location: 1822H + 16 = 1832H; Read bytes: [A9 1D] at 1832H-1833H )</li>
									<li>Form handler address (little-endian) ( Low byte: A9, High byte: 1D; Address: (1D &lt;&lt; 8) | A9 = 1DA9H)</li>
									<li>Jump to handler at 1DA9H</li>
								</ul>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1822-1823</div><div>AE 1D</div><div>Token 80H (<span class="code">END</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1DAEH">1DAEH</a></div></div>
									<div class="assembly-row-combined"><div>1824-1825</div><div>A1 1C</div><div>Token 81H (<span class="code">FOR</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1CA1H">1CA1H</a></div></div>
									<div class="assembly-row-combined"><div>1826-1827</div><div>35 01</div><div>Token 82H (<span class="code">SET/RESET</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0135H">0135H</a></div></div>
									<div class="assembly-row-combined"><div>1828-1829</div><div>73 41</div><div>Token 83H (<span class="code">CMD</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">4173H</a></div></div>
									<div class="assembly-row-combined"><div>182A-182B</div><div>B6 22</div><div>Token 84H (<span class="code">NEXT</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#22B6H">22B6H</a></div></div>
									<div class="assembly-row-combined"><div>182C-182D</div><div>9A 21</div><div>Token 85H (<span class="code">INPUT</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#219AH">219AH</a></div></div>
									<div class="assembly-row-combined"><div>182E-182F</div><div>EF 21</div><div>Token 86H (<span class="code">READ</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#21EFH">21EFH</a></div></div>
									<div class="assembly-row-combined"><div>1830-1831</div><div>B1 1E</div><div>Token 87H (<span class="code">GOSUB</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1EB1H">1EB1H</a></div></div>
									<div class="assembly-row-combined"><div>1832-1833</div><div>A9 1D</div><div>Token 88H (<span class="code">STOP</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1DA9H">1DA9H</a></div></div>
									<div class="assembly-row-combined"><div>1834-1835</div><div>07 1F</div><div>Token 89H (<span class="code">REM</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1F07H">1F07H</a></div></div>
									<div class="assembly-row-combined"><div>1836-1837</div><div>F7 1D</div><div>Token 8AH (<span class="code">TRON</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1DF7H">1DF7H</a></div></div>
									<div class="assembly-row-combined"><div>1838-1839</div><div>F8 1D</div><div>Token 8BH (<span class="code">TROFF</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1DF8H">1DF8H</a></div></div>
									<div class="assembly-row-combined"><div>183A-183B</div><div>00 1E</div><div>Token 8CH (<span class="code">DEFSTR</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E00H">1E00H</a></div></div>
									<div class="assembly-row-combined"><div>183C-183D</div><div>60 2E</div><div>Token 8DH (<span class="code">EDIT</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2E60H">2E60H</a></div></div>
									<div class="assembly-row-combined"><div>183E-183F</div><div>AF 1F</div><div>Token 8EH (<span class="code">RESUME</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1FAFH">1FAFH</a></div></div>
									<div class="assembly-row-combined"><div>1840-1841</div><div>FB 2A</div><div>Token 8FH (<span class="code">OUT</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2AFBH">2AFBH</a></div></div>
									<div class="assembly-row-combined"><div>1842-1843</div><div>79 41</div><div>Token 90H (<span class="code">OPEN</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#4179H">4179H</a></div></div>
									<div class="assembly-row-combined"><div>1844-1845</div><div>7C 41</div><div>Token 91H (<span class="code">FIELD</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">417CH</a></div></div>
									<div class="assembly-row-combined"><div>1846-1847</div><div>7F 41</div><div>Token 92H (<span class="code">GET</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">417FH</a></div></div>
									<div class="assembly-row-combined"><div>1848-1849</div><div>82 41</div><div>Token 93H (<span class="code">PUT</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">4182H</a></div></div>
									<div class="assembly-row-combined"><div>184A-184B</div><div>85 41</div><div>Token 94H (<span class="code">CLOSE</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">4185H</a></div></div>
									<div class="assembly-row-combined"><div>184C-184D</div><div>88 41</div><div>Token 95H (<span class="code">LOAD</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">4188H</a></div></div>
									<div class="assembly-row-combined"><div>184E-184F</div><div>8B 41</div><div>Token 96H (<span class="code">MERGE</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">418BH</a></div></div>
									<div class="assembly-row-combined"><div>1850-1851</div><div>8E 41</div><div>Token 97H (<span class="code">NAME</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">418EH</a></div></div>
									<div class="assembly-row-combined"><div>1852-1853</div><div>91 41</div><div>Token 98H (<span class="code">KILL</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">4191H</a></div></div>
									<div class="assembly-row-combined"><div>1854-1855</div><div>97 41</div><div>Token 99H (<span class="code">LSET</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">4197H</a></div></div>
									<div class="assembly-row-combined"><div>1856-1857</div><div>9A 41</div><div>Token 9AH (<span class="code">RSET</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">419AH</a></div></div>
									<div class="assembly-row-combined"><div>1858-1859</div><div>A0 41</div><div>Token 9BH (<span class="code">SAVE</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">41A0H</a></div></div>
									<div class="assembly-row-combined"><div>185A-185B</div><div>B2 02</div><div>Token 9CH (<span class="code">LINE</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#02B2H">02B2H</a></div></div>
									<div class="assembly-row-combined"><div>185C-185D</div><div>67 20</div><div>Token 9DH (<span class="code">EDIT</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2067H">2067H</a></div></div>
									<div class="assembly-row-combined"><div>185E-185F</div><div>B1 2C</div><div>Token 9EH (<span class="code">ERROR</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2CB1H">2CB1H</a></div></div>
									<div class="assembly-row-combined"><div>1860-1861</div><div>6F 20</div><div>Token 9FH (<span class="code">RESUME</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#206FH">206FH</a></div></div>
									<div class="assembly-row-combined"><div>1862-1863</div><div>29 2B</div><div>Token A0H (<span class="code">LLIST</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2B29H">2B29H</a></div></div>
									<div class="assembly-row-combined"><div>1864-1865</div><div>08 20</div><div>Token A1H (<span class="code">AUTO</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2008H">2008H</a></div></div>
									<div class="assembly-row-combined"><div>1866-1867</div><div>F5 2B</div><div>Token A2H (<span class="code">CSAVE</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2BF5H">2BF5H</a></div></div>
									<div class="assembly-row-combined"><div>1868-1869</div><div>49 1B</div><div>Token A3H (<span class="code">NEW</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1B49H">1B49H</a></div></div>
									<div class="assembly-row-combined"><div>186A-186B</div><div>7F 41</div><div>Token A4H (<span class="code">GET</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">417FH</a></div></div>
									<div class="assembly-row-combined"><div>186C-186D</div><div>82 41</div><div>Token A5H (<span class="code">PUT</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">4182H</a></div></div>
									<div class="assembly-row-combined"><div>186E-186F</div><div>85 41</div><div>Token A6H (<span class="code">CLOSE</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">4185H</a></div></div>
									<div class="assembly-row-combined"><div>1870-1871</div><div>88 41</div><div>Token A7H (<span class="code">LOAD</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">4188H</a></div></div>
									<div class="assembly-row-combined"><div>1872-1873</div><div>8B 41</div><div>Token A8H (<span class="code">MERGE</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">418BH</a></div></div>
									<div class="assembly-row-combined"><div>1874-1875</div><div>8E 41</div><div>Token A9H (<span class="code">NAME</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">418EH</a></div></div>
									<div class="assembly-row-combined"><div>1876-1877</div><div>91 41</div><div>Token AAH (<span class="code">KILL</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">4191H</a></div></div>
									<div class="assembly-row-combined"><div>1878-1879</div><div>97 41</div><div>Token ABH (<span class="code">LSET</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">4197H</a></div></div>
									<div class="assembly-row-combined"><div>187A-187B</div><div>9A 41</div><div>Token ACH (<span class="code">RSET</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">419AH</a></div></div>
									<div class="assembly-row-combined"><div>187C-187D</div><div>A0 41</div><div>Token ADH (<span class="code">SAVE</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">41A0H</a></div></div>
									<div class="assembly-row-combined"><div>187E-187F</div><div>B2 02</div><div>Token AEH (<span class="code">SYSTEM</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#02B2H">02B2H</a></div></div>
									<div class="assembly-row-combined"><div>1880-1881</div><div>67 20</div><div>Token AFH (<span class="code">LPRINT</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2067H">2067H</a></div></div>
									<div class="assembly-row-combined"><div>1882-1883</div><div>5B 41</div><div>Token B0H (<span class="code">DEF</span>) jumps to <a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH">415BH</a></div></div>
									<div class="assembly-row-combined"><div>1884-1885</div><div>B1 2C</div><div>Token B1H (<span class="code">POKE</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2CB1H">2CB1H</a></div></div>
									<div class="assembly-row-combined"><div>1886-1887</div><div>6F 20</div><div>Token B2H (<span class="code">PRINT</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#206FH">206FH</a></div></div>
									<div class="assembly-row-combined"><div>1888-1889</div><div>E4 1D</div><div>Token B3H (<span class="code">CONT</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1DE4H">1DE4H</a></div></div>
									<div class="assembly-row-combined"><div>188A-188B</div><div>2E 2B</div><div>Token B4H (<span class="code">LIST</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2B2EH">2B2EH</a></div></div>
									<div class="assembly-row-combined"><div>188C-188D</div><div>29 2B</div><div>Token B5H (<span class="code">LLIST</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2B29H">2B29H</a></div></div>
									<div class="assembly-row-combined"><div>188E-188F</div><div>C6 2B</div><div>Token B6H (<span class="code">DELETE</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2BC6H">2BC6H</a></div></div>
									<div class="assembly-row-combined"><div>1890-1891</div><div>08 20</div><div>Token B7H (<span class="code">AUTO</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2008H">2008H</a></div></div>
									<div class="assembly-row-combined"><div>1892-1893</div><div>7A 1E</div><div>Token B8H (<span class="code">CLEAR</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E7AH">1E7AH</a></div></div>
									<div class="assembly-row-combined"><div>1894-1895</div><div>1F 2C</div><div>Token B9H (<span class="code">CLOAD</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2C1FH">2C1FH</a></div></div>
									<div class="assembly-row-combined"><div>1896-1897</div><div>F5 2B</div><div>Token BAH (<span class="code">CSAVE</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2BF5H">2BF5H</a></div></div>
									<div class="assembly-row-combined"><div>1898-1899</div><div>49 1B</div><div>Token BBH (<span class="code">NEW</span>) jumps to <a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1B49H">1B49H</a></div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="189AH">189AH-18A0H - OPERATOR PRECEDENCE TABLE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The Operator Precedence Table is a 7-byte lookup table that 
tells the BASIC interpreter the order in which to evaluate operators in 
mathematical and logical expressions. Each byte contains a precedence 
value (higher numbers = higher precedence = evaluated first).</p>
								<p>Structure: 7 entries (one byte each) for operators like ^ (7FH), * and / (7CH), + and - (79H), etc.</p>
								<p>Purpose: Used during expression parsing to handle operator priority (e.g., multiplication before addition).</p>
								<p>How it Works: When the interpreter encounters an expression like 3 + 4 * 5 ^ 2:</p>
								<ol>
									<li>Tokenize: Break into tokens: 3, +, 4, *, 5, ^, 2</li>
									<li>Look up precedence: For each operator token, read its precedence:
										<ul>
											<li>+ (token $99) ‚Üí precedence 79</li>
											<li>* (token $9B) ‚Üí precedence 7C</li>
											<li>^ (token ??)  ‚Üí precedence 7F</li>
										</ul>
									</li>
									<li>Build evaluation tree: Highest precedence first:
										<ul>
											<li>Step 1: 5 ^ 2 = 25        (^ has precedence 7F)</li>
											<li>Step 2: 4 * 25 = 100      (* has precedence 7C)</li>
											<li>Step 3: 3 + 100 = 103     (+ has precedence 79)</li>
										</ul>
									</li>
								</ol>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>189A</div><div>79H</div><div>Addition</div></div>
									<div class="assembly-row-combined"><div>189B</div><div>79H</div><div>Subtraction</div></div>
									<div class="assembly-row-combined"><div>189C</div><div>7CH</div><div>Multiplication</div></div>
									<div class="assembly-row-combined"><div>189D</div><div>7CH</div><div>Division</div></div>
									<div class="assembly-row-combined"><div>189E</div><div>7FH</div><div>Exponentiation</div></div>
									<div class="assembly-row-combined"><div>189F</div><div>50H</div><div>Relational Comparisons (=, &gt; &lt; ‚â• ‚â§ &gt;&lt;)</div></div>
									<div class="assembly-row-combined"><div>18A0</div><div>56H</div><div>Logical Operators (AND, OR NOT)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="18A1H">18A1H-18AAH - DATA CONVERSION ROUTINE TABLE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The Data Conversion Routine Table is a jump table containing 5
 two-byte addresses (pointers) to routines that convert between 
different data types in TRS-80 BASIC. It's used whenever the interpreter
 needs to convert numbers to strings for display, parse strings into 
numbers, or promote integers to floats for arithmetic.</p>
								<p>Structure: 5 entries, each a 2-byte word</p>
								<p>Examples: To string at 0AF4H, to integer at 0A7FH</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>18A1-18A2</div><div>DB 0A</div><div>Integer to String (for PRINT) to 0ADBH<br>Convert a 16-bit integer to its decimal ASCII representation.  Used by<ul><li>PRINT statement when displaying integers</li><li>STR$() function for integers</li><li>Error messages showing line numbers</li></ul></div></div>
									<div class="assembly-row-combined"><div>18A3-18A4</div><div>00 00</div><div>Unused/Reserved (NULL pointer)</div></div>
									<div class="assembly-row-combined"><div>18A5-18A6</div><div>7F 0A</div><div>Float to String (for PRINT) to 0A7FH<br>Convert floating point number to decimal ASCII representation.  Used by<ul><li>PRINT statement when displaying floats</li><li>STR$() function for floating point</li><li>Scientific notation output</li></ul></div></div>
									<div class="assembly-row-combined"><div>18A7-18A8</div><div>F4 0A</div><div>String to Float (for INPUT/VAL) to 0AF4H<br>Parse ASCII decimal string and convert to internal floating point format.  Used by<ul><li>INPUT statement when reading numeric values</li><li>VAL() function</li><li>Direct numeric assignment from string literals</li></ul></div></div>
									<div class="assembly-row-combined"><div>18A9-18AA</div><div>B1 0A</div><div>Integer to Float (type promotion) to 0AB1H<br>Promote 16-bit integer to floating point representation.  used by<ul><li>Mixed-type arithmetic (integer + float)</li><li>Functions expecting float arguments</li><li>Type coercion in expressions</li></ul></div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="18ABH">18ABH-18C8H - Arithmetic Operation Tables<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Three consecutive tables for arithmetic handlers (addition, subtraction, multiplication, division, comparison).
								</p><p>Structure: Each table has entries as 2-byte words pointing to operation-specific routines.</p>
								<p>Purpose: Called when precedence requires breaking expressions (e.g., integer addition at 0BD2H).</p>
							</div>


							<h2 class="assembly-section-title" id="1608H">1608-18C8 - LIST OF BASIC RESERVED WORDS, TOKENS, AND ENTRY LOCATIONS AS FOLLOWS:<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The original ROM source code makes an interesting note about 
the order of these reserved words. Some reserved words are contained in 
other reserved words, which will cause a problem. They given examples 
of:
									</p><ul>
										<li><span class="code">IF J=F OR T=5</span> will process a <span class="code">FOR</span></li>
										<li><span class="code">INP</span> is part of <span class="code">INPUT</span></li>
										<li><span class="code">IF T OR Q THEN</span> will process a <span class="code">TO</span></li>
									</ul>
									SO, the smaller word always has to appear later in the reserved word table.
								<p></p>
								<table class="data-table">
									<thead>
										<tr><th><strong>Word</strong></th><th><strong>Token</strong></th><th><strong>Address</strong></th><th><strong>Word</strong></th><th><strong>Token</strong></th><th><strong>Address</strong></th></tr>
									</thead>
									<tbody>
										<tr><td>ABS</td><td>D9</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0977H" class="memory-link">0977</a></td><td>AND</td><td>D2</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25FDH" class="memory-link">25FD</a></td></tr>
										<tr><td>ASC</td><td>F6</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2A0FH" class="memory-link">2A0F</a></td><td>ATN</td><td>E4</td><td><a href="#15BDH" class="memory-link">15BD</a></td></tr>
										<tr><td>AUTO</td><td>B7</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2008H" class="memory-link">2008</a></td><td>CDBL</td><td>F1</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0ADBH" class="memory-link">0ADB</a></td></tr>
										<tr><td>CHR$(</td><td>F7</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2A1FH" class="memory-link">2A1F</a></td><td>CINT</td><td>EF</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A7FH" class="memory-link">0A7F</a></td></tr>
										<tr><td>CLEAR</td><td>B8</td><td><a href="#1E7AH" class="memory-link">1E7A</a></td><td>CLOAD</td><td>B9</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2C1FH" class="memory-link">2C1F</a></td></tr>
										<tr><td>CLOSE</td><td>A6</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#4185H" class="memory-link">4185</a></td><td>CLS</td><td>84</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#01C9H" class="memory-link">01C9</a></td></tr>
										<tr><td>CMD</td><td>85</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#4173H" class="memory-link">4173</a></td><td>CONT</td><td>B3</td><td><a href="#1DE4H" class="memory-link">1DE4</a></td></tr>
										<tr><td>COS</td><td>El</td><td><a href="#1541H" class="memory-link">1541</a></td><td>CSAVE</td><td>BA</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2BF5H" class="memory-link">2BF5</a></td></tr>
										<tr><td>CSNG</td><td>F0</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0AB1H" class="memory-link">0AB1</a></td><td>CVD</td><td>E8</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#415EH" class="memory-link">415EH</a></td></tr>
										<tr><td>CVI</td><td>E6</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#4152H" class="memory-link">4152H</a></td><td>CVS</td><td>E7</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#4158H" class="memory-link">4158H</a></td></tr>
										<tr><td>DATA</td><td>88</td><td><a href="#1F05H" class="memory-link">1F05</a></td><td>DEF</td><td>DD</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#415BH" class="memory-link">415BH</a></td></tr>
										<tr><td>DEFDBL</td><td>9B</td><td><a href="#1E09H" class="memory-link">1E09</a></td><td>DEFINT</td><td>99</td><td><a href="#1E03H" class="memory-link">1E03</a></td></tr>
										<tr><td>DEFSNG</td><td>9A</td><td><a href="#1E06H" class="memory-link">1E06</a></td><td>DEFSTR</td><td>98</td><td><a href="#1E00H" class="memory-link">1E00</a></td></tr>
										<tr><td>DELETE</td><td>B6</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2BC6H" class="memory-link">2BC6</a></td><td>DIM</td><td>8A</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2608H" class="memory-link">2608</a></td></tr>
										<tr><td>EDIT</td><td>9D</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2E60H" class="memory-link">2E60</a></td><td>ELSE</td><td>95</td><td><a href="#1F07H" class="memory-link">1F07</a></td></tr>
										<tr><td>END</td><td>80</td><td><a href="#1DAEH" class="memory-link">1DAE</a></td><td>EOF</td><td>E9</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#4161H" class="memory-link">4161H</a></td></tr>
										<tr><td>ERL</td><td>C2</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#24DDH" class="memory-link">24DD</a></td><td>ERR</td><td>C3</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#24CFH" class="memory-link">24CF</a></td></tr>
										<tr><td>ERROR</td><td>9E</td><td><a href="#1FF4H" class="memory-link">1FF4</a></td><td>EXP</td><td>E0</td><td><a href="#1439H" class="memory-link">1439</a></td></tr>
										<tr><td>FIELD</td><td>A3</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#417CH" class="memory-link">417C</a></td><td>FIX</td><td>F2</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0B26H" class="memory-link">0B26</a></td></tr>
										<tr><td>FN</td><td>BE</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#4155H" class="memory-link">4155</a></td><td>FOR</td><td>81</td><td><a href="#1CA1H" class="memory-link">1CA1</a></td></tr>
										<tr><td>FRE</td><td>DA</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#27D4H" class="memory-link">27D4</a></td><td>GET</td><td>A4</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#4174H" class="memory-link">4174H</a></td></tr>
										<tr><td>GOSUB</td><td>91</td><td><a href="#1EB1H" class="memory-link">1EB1</a></td><td>GOTO</td><td>5D</td><td><a href="#1EC2H" class="memory-link">1EC2</a></td></tr>
										<tr><td>IF</td><td>8F</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2039H" class="memory-link">2039</a></td><td>INKEY$</td><td>C9</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#019DH" class="memory-link">019D</a></td></tr>
										<tr><td>INP</td><td>DB</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2AEFH" class="memory-link">2AEF</a></td><td>INPUT</td><td>89</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#219AH" class="memory-link">219A</a></td></tr>
										<tr><td>INSTR</td><td>C5</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#419DH" class="memory-link">419D</a></td><td>INT</td><td>D8</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0B37H" class="memory-link">0B37</a></td></tr>
										<tr><td>KILL</td><td>AA</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#4191H" class="memory-link">4191</a></td><td>LEFT$</td><td>F8</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2A61H" class="memory-link">2A61</a></td></tr>
										<tr><td>LEN</td><td>F3</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2A03H" class="memory-link">2A03</a></td><td>LET</td><td>8C</td><td><a href="#1F21H" class="memory-link">1F21</a></td></tr>
										<tr><td>LINE</td><td>9C</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#41A3H" class="memory-link">41A3H</a></td><td>LIST</td><td>B4</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2B2EH" class="memory-link">2B2E</a></td></tr>
										<tr><td>LLIST</td><td>B5</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2B29H" class="memory-link">2B29</a></td><td>LOAD</td><td>A7</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#4188H" class="memory-link">4188H</a></td></tr>
										<tr><td>LOC</td><td>EA</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#4164H" class="memory-link">4164H</a></td><td>LOF</td><td>EB</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#4167H" class="memory-link">4167H</a></td></tr>
										<tr><td>LOG</td><td>DF</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0809H" class="memory-link">0809</a></td><td>LPRINT</td><td>AF</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2067H" class="memory-link">2067</a></td></tr>
										<tr><td>LSET</td><td>AB</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#4197H" class="memory-link">4197</a></td><td>MEM</td><td>C8</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#27C9H" class="memory-link">27C9</a></td></tr>
										<tr><td>MERGE</td><td>A8</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#418BH" class="memory-link">418B</a></td><td>MID$</td><td>FA</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2A9AH" class="memory-link">2A9A</a></td></tr>
										<tr><td>MKD$</td><td>EE</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#4170H" class="memory-link">4170</a></td><td>NAME</td><td>A9</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#418EH" class="memory-link">418EH</a></td></tr>
										<tr><td>NEW</td><td>BB</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1B49H" class="memory-link">1B49</a></td><td>NEXT</td><td>87</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#22B6H" class="memory-link">22B6</a></td></tr>
										<tr><td>NOT</td><td>CB</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25C4H" class="memory-link">25C4</a></td><td>ON</td><td>A1</td><td><a href="#1FC6H" class="memory-link">1FC6</a></td></tr>
										<tr><td>OPEN</td><td>A2</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#4179H" class="memory-link">4179</a></td><td>OR</td><td>D3</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25F7H" class="memory-link">25F7</a></td></tr>
										<tr><td>OUT</td><td>AO</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2AFBH" class="memory-link">2AFB</a></td><td>PEEK</td><td>E5</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2CAAH" class="memory-link">2CAA</a></td></tr>
										<tr><td>POINT</td><td>C6</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0132H" class="memory-link">0132</a></td><td>POKE</td><td>B1</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2CB1H" class="memory-link">2CB1</a></td></tr>
										<tr><td>POS</td><td>DC</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#27F5H" class="memory-link">27F5</a></td><td>PRINT</td><td>B2</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#206FH" class="memory-link">206F</a></td></tr>
										<tr><td>PUT</td><td>A5</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#4182H" class="memory-link">4182</a></td><td>RANDOM</td><td>86</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#01D3H" class="memory-link">01D3</a></td></tr>
										<tr><td>READ</td><td>8B</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#21EFH" class="memory-link">21EF</a></td><td>REM</td><td>93</td><td><a href="#1F07H" class="memory-link">1F07</a></td></tr>
										<tr><td>RESET</td><td>82</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0138H" class="memory-link">0138</a></td><td>RESTORE</td><td>90</td><td><a href="#1D91H" class="memory-link">1D91</a></td></tr>
										<tr><td>RESUME</td><td>9F</td><td><a href="#1FAFH" class="memory-link">1FAFH</a></td><td>RETURN</td><td>92</td><td><a href="#1EDEH" class="memory-link">1EDEH</a></td></tr>
										<tr><td>RIGHT$</td><td>F9</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2A91H" class="memory-link">2A91</a></td><td>RND</td><td>DE</td><td><a href="#14C9H" class="memory-link">14C9</a></td></tr>
										<tr><td>RSET</td><td>AC</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#419AH" class="memory-link">419A</a></td><td>RUN</td><td>8E</td><td><a href="#1EA3H" class="memory-link">1EA3</a></td></tr>
										<tr><td>SAVE</td><td>AD</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#41A0H" class="memory-link">41A0</a></td><td>SET</td><td>83</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0135H" class="memory-link">0135</a></td></tr>
										<tr><td>SGN</td><td>D7</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#098AH" class="memory-link">098A</a></td><td>SIN</td><td>E2</td><td><a href="#1547H" class="memory-link">1547</a></td></tr>
										<tr><td>SQR</td><td>CD</td><td><a href="#13E7H" class="memory-link">13E7</a></td><td>STEP</td><td>cc</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2B01H" class="memory-link">2B01</a></td></tr>
										<tr><td>STOP</td><td>94</td><td><a href="#1DA9H" class="memory-link">1DA9</a></td><td>STR$</td><td>F4</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2836H" class="memory-link">2836</a></td></tr>
										<tr><td>STRING$</td><td>C4</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2A2FH" class="memory-link">2A2F</a></td><td>SYSTEM</td><td>AE</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#02B2H" class="memory-link">02B2</a></td></tr>
										<tr><td>TAB(</td><td>BC</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2137H" class="memory-link">2137</a></td><td>TAN</td><td>E3</td><td><a href="#15A8H" class="memory-link">15A8</a></td></tr>
										<tr><td>THEN</td><td>CA</td><td></td><td>TIME$</td><td>C7</td><td><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm#4176H" class="memory-link">4176</a></td></tr>
										<tr><td>TO</td><td>BD</td><td></td><td>TROFF</td><td>97</td><td><a href="#1DF8H" class="memory-link">1DF8</a></td></tr>
										<tr><td>TRON</td><td>96</td><td><a href="#1DF8H" class="memory-link">1DF8</a></td><td>USING</td><td>BF</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2CBDH" class="memory-link">2CBD</a></td></tr>
										<tr><td>USR</td><td>C1</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#27FEH" class="memory-link">27FE</a></td><td>VAL</td><td>F5</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2AC5H" class="memory-link">2AC5</a></td></tr>
										<tr><td>VARPTR</td><td>C0</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#24EBH" class="memory-link">24EB</a></td><td>+</td><td>CD</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#249FH" class="memory-link">249F</a></td></tr>
										<tr><td>-</td><td>CE</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2532H" class="memory-link">2532</a></td><td>*</td><td>CF</td><td></td></tr>
										<tr><td>/</td><td>D0</td><td></td><td>?</td><td>D1</td><td></td></tr>
										<tr><td>&gt;</td><td>D4</td><td></td><td>=</td><td>D5</td><td></td></tr>
										<tr><td>&lt;</td><td>D6</td><td></td><td>&amp;</td><td>26</td><td></td></tr>
										<tr><td>'</td><td>FB</td><td>3A93</td><td></td><td></td><td></td></tr>
									</tbody>
								</table>
							</div>

							<h2 class="assembly-section-title" id="18C9H">18C9-18F6 - STORAGE LOCATION FOR LEVEL II BASIC ERROR MESSAGES<span class="origrom"> - "ERRTAB"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>18C9</div><div>"NF"</div><div>NEXT without FOR Error Message (Error 00H)</div></div>
									<div class="assembly-row-combined"><div>18CB</div><div>"SN"</div><div>Syntax Error Error Message (Error 02H)</div></div>
									<div class="assembly-row-combined"><div>18CD</div><div>"RG"</div><div>RETURN without GOSUB Error Message (Error 04H)</div></div>
									<div class="assembly-row-combined"><div>18CF</div><div>"OD"</div><div>Out of DATA) Error Message (Error 06H)</div></div>
									<div class="assembly-row-combined"><div>18D1</div><div>"FC"</div><div>Illegal Function Call Error Message (Error 08H)</div></div>
									<div class="assembly-row-combined"><div>18D3</div><div>"OV"</div><div>Overflow Error Message (Error 0AH)</div></div>
									<div class="assembly-row-combined"><div>18D5</div><div>"OM"</div><div>Out of Memory Error Message (Error 0CH)</div></div>
									<div class="assembly-row-combined"><div>18D7</div><div>"UL"</div><div>Underfined Line Number Error Message (Error 0EH)</div></div>
									<div class="assembly-row-combined"><div>18D9</div><div>"BS"</div><div>Subscript out of Range Error Message (Error 10H)</div></div>
									<div class="assembly-row-combined"><div>18DB</div><div>"DD"</div><div>Redimensioned Array Error Message (Error 12H)</div></div>
									<div class="assembly-row-combined"><div>18DD</div><div>"/0"</div><div>Division by Zero Error Message (Error 14H)</div></div>
									<div class="assembly-row-combined"><div>18DF</div><div>"ID"&gt;</div><div>Illegal Direct Operation Error Message (Error 16H)</div></div>
									<div class="assembly-row-combined"><div>18E1</div><div>"TM"</div><div>Type Mismatch Error Message (Error 18H)</div></div>
									<div class="assembly-row-combined"><div>18E3</div><div>"OS"</div><div>Out of String Message (Error 1AH)</div></div>
									<div class="assembly-row-combined"><div>18E5</div><div>"LS"</div><div>Out of Memory Error Message (Error 1CH)</div></div>
									<div class="assembly-row-combined"><div>18E7</div><div>"ST"</div><div>String Too Long Error Message (Error 1EH)</div></div>
									<div class="assembly-row-combined"><div>18E9</div><div>"CN"</div><div>Can't Continue Error Message (Error 20H)</div></div>
									<div class="assembly-row-combined"><div>18EB</div><div>"NR"</div><div>No RESUME Error Message (Error 22H)</div></div>
									<div class="assembly-row-combined"><div>18ED</div><div>"RW"</div><div>RESUME Without Error Error Message (Error 24H)</div></div>
									<div class="assembly-row-combined"><div>18EF</div><div>"UE"</div><div>Unprintable Error Error Message (Error 26H)</div></div>
									<div class="assembly-row-combined"><div>18F1</div><div>"HO"</div><div>Missing Operand Error Message (Error 28H)</div></div>
									<div class="assembly-row-combined"><div>18F3</div><div>"FD"</div><div>Bad file Data Error Message (Error 2AH)</div></div>
									<div class="assembly-row-combined"><div>18F5</div><div>"L3"</div><div>Disk BASIC Command Error Message (Error 2CH)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="18F7H">18F7-1904 - STORAGE LOCATION FOR THE SINGLE PRECISION DIVISION ROUTINE<br>This code is moved from 18F7-191DH to 4080H-40A5H during non-disk initial setup.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>18F7</div><div>SUB 00H<span class="opcode2">D6 00</span></div><div>Subtract the LSB</div></div>
									<div class="assembly-row-combined"><div>18F9</div><div>LD L,A<span class="opcode2">6F</span></div><div>Restore the value to L</div></div>
									<div class="assembly-row-combined"><div>18FA</div><div>LD A,H<span class="opcode2">7C</span></div><div>Get the middle byte</div></div>
									<div class="assembly-row-combined"><div>18FB</div><div>SBC A,00H<span class="opcode2">DE 00</span></div><div>Subtract the middle byte</div></div>
									<div class="assembly-row-combined"><div>18FD</div><div>LD H,A<span class="opcode2">67</span></div><div>Move the difference to H</div></div>
									<div class="assembly-row-combined"><div>18FE</div><div>LD A,B<span class="opcode2">78</span></div><div>Get the MSB</div></div>
									<div class="assembly-row-combined" id="1900H"><div>18FF</div><div>SBC A,00H<span class="opcode2">DE 00</span></div><div>Subtract the MSB</div></div>
									<div class="assembly-row-combined"><div>1901</div><div>LD B,A<span class="opcode2">47</span></div><div>Move it back to A</div></div>
									<div class="assembly-row-combined"><div>1902</div><div>LD A,00H<span class="opcode2">3E 00</span></div><div>Clear A</div></div>
									<div class="assembly-row-combined"><div>1904</div><div>RET<span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1905H">1905-191C - STORAGE LOCATION FOR VALUES PLACED IN RAM UPON INITIALIZATION.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This code is moved to 408E during non-disk initial setup.</p>
							</div>

							<h2 class="assembly-section-title" id="191DH">191D-1923 - MESSAGE STORAGE LOCATION<span class="origrom"> - "ERR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>191D-1923<span class="origrom2">ERR</span></div><div>"Error" + 00H<span class="opcode2">20 45</span></div><div>The word "ERROR"</div></div>
									<div class="assembly-row-combined" id="1924H"><div>1924-1928<span class="origrom2">INTX</span></div><div>" in " + 00H</div><div>The word " IN "</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1929H">1929-192F - MESSAGE STORAGE LOCATION<span class="origrom"> - "REDDY"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1929-192F<span class="origrom2">REDDY</span></div><div>"READY" + 0DH + 00H</div><div>The Level II BASIC READY message is stored here</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1930H">1930-1935 - MESSAGE STORAGE LOCATION<span class="origrom"> - "BRKTXT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1930-1935<span class="origrom2">BNKTXT</span></div><div>"Break" + 00H</div><div>The Level II BASIC BREAK message is stored here</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1936H">1936-1954 - SCAN STACK ROUTINE<span class="origrom"> - "FNDFOR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p> This routine is called with DE as the address of the NEXT index.  It scans the STACK backwards looking for a <span class="code">FOR</span>
 push.  If one is found, it gets the address of the index and compares 
with the DE that was in place when this routine was called.  If it is 
equal, then it exits with A=0 and HL=Address of the variable.  If it is 
not equal it will keep scanning until no FOR push is found and then exit
 with A&lt;&gt;0.<br><br> According to the original ROM source, this 
routine is part of the general storage management routines, and if 
designed to find a <span class="code">FOR</span> entry on the STACK with the variable pointer passed in Register Pair DE. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1936H"><div>1936-1938<span class="origrom2">FNDFOR</span></div><div>LD HL,0004H<span class="opcode2">21 04 00</span></div><div>Load Register Pair HL with 4 so that we can backspace</div></div>
									<div class="assembly-row-combined"><div>1939</div><div>ADD HL,SP<span class="opcode2">39</span></div><div>Add
 the 4 (held in HL) to the current value of the STACK pointer.  HL will 
hold the current STACK pointer, the STACK point will bump forward 4</div></div>
									<div class="assembly-row-combined" id="193AH"><div>193A<span class="origrom2">LOOPER</span></div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load
 Register A with the value held at the current STACK point MINUS 4.  
This is to enable seeing what type of data is on the STACK</div></div>
									<div class="assembly-row-combined"><div>193B</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL so as to backspace one more byte in case a <span class="code">FOR</span> token is located</div></div>
									<div class="assembly-row-combined"><div>193C-193D</div><div>CP 81H<span class="opcode2">FE 81</span></div><div>Check to see if the value in Register A (which is the current STACK pointer - 4) is a <span class="code">FOR</span> token to make sure that the item in the STACK was associated with a FOR loop</div></div>
									<div class="assembly-row-combined"><div>193E</div><div>RET NZ<span class="opcode2">C0</span></div><div>If the item isn't associated with a FOR statement (as the value in Register A isn't a <span class="code">FOR</span> token), exit out of this routine.  This returns with A being non-zero because there was no <span class="code">FOR</span> push</div></div>
									<div class="assembly-row-combined"><div>193F</div><div>LD C,(HL)<span class="opcode2">4E</span></div><div>If we are here, then the entry on the STACK is associated with a FOR statement.  Load Register C with the LSB of the <span class="code">FOR</span>'s variable address</div></div>
									<div class="assembly-row-combined"><div>1940</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL so as to backspace the current STACK pointer by yet another byte</div></div>
									<div class="assembly-row-combined"><div>1941</div><div>LD B,(HL)<span class="opcode2">46</span></div><div>Load Register B with the MSB of the <span class="code">FOR</span>'s variable address</div></div>
									<div class="assembly-row-combined"><div>1942</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL so now HL will be the address of the <span class="code">FOR</span> variable on the STACK</div></div>
									<div class="assembly-row-combined"><div>1943</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value in Register Pair HL (which is the address of the <span class="code">FOR</span> variable) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1944</div><div>LD L,C<span class="opcode2">69</span></div><div>Load Register L with the LSB of the <span class="code">FOR</span> variable's address in Register C</div></div>
									<div class="assembly-row-combined"><div>1945</div><div>LD H,B<span class="opcode2">60</span></div><div>Load Register H with the MSB of the <span class="code">FOR</span> variable's address in Register B</div></div>
									<div class="assembly-row-combined"><div>1946-1947</div><div>LD A,D<br>OR E<span class="opcode2">7A</span></div><div>Z-80
 Trick to check a Register Pair (in this case DE) for zero.  Load D into
 A and then OR that against E.  If both D and E are zero, then A will be
 zero.   This sets up to handle a NEXT statement that doesn't have a 
variable argument</div></div>
									<div class="assembly-row-combined"><div>1948</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange
 the variable address in Register Pair HL with the variable address in 
Register Pair DE so that DE will now hold the address of the <span class="code">FOR</span> variable from the STACK.  This is to ensure that we return with DE pointing to the variable</div></div>
									<div class="assembly-row-combined"><div>1949-194A</div><div><a href="#194DH" class="memory-link">JR Z,194DH<span class="origrom2">JR Z,POPGOF</span></a><span class="opcode2">28 02</span></div><div>Skip
 the next 2 opcodes if the variable address in Register Pair DE was 
equal to zero, meaning that DE was not, in fact, pointing to the 
variable as we needed it to be</div></div>
									<div class="assembly-row-combined"><div>194B</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange
 the variable address in Register Pair HL with the variable address in 
Register Pair DE so that HL will now have the address of the <span class="code">FOR</span> variable from the STACK</div></div>
									<div class="assembly-row-combined"><div>194C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H">RST 18H<span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>This routine was entered with DE being the address of the <span class="code">NEXT</span>
 index, so we need to compare that against the index from the STACK.  To
 do this, we RST 18 to see if the variable address in HL is the same as 
in DE, so we call the COMPARE DE:HL routine, which numerically compares 
DE and HL. Will not work for signed integers (except positive ones). 
Uses the A-register only. The result of the comparison is returned in 
the status Register as:  <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined" id="194DH"><div>194D-194F<span class="origrom2">POPGOF</span></div><div>LD BC,000EH<br><span class="origrom">LD BC,FORSIZ</span><span class="opcode2">01 0E 00</span></div><div>Load Register Pair BC with the value to backspace (i.e., erase) the <span class="code">FOR</span> token (which is 10)</div></div>
									<div class="assembly-row-combined"><div>1950</div><div>POP HL<span class="opcode2">E1</span></div><div>Get the memory pointer from the STACK of the sign of the increment flag and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1951</div><div>RET Z<span class="opcode2">C8</span></div><div>If the variable in the <span class="code">FOR</span> block matched the <span class="code">NEXT</span> index block, then RETURN with HL pointing to the bottom of the entry</div></div>
									<div class="assembly-row-combined"><div>1952</div><div>ADD HL,BC<span class="opcode2">09</span></div><div>If it didn't match, execute that 10 byte stepback in BC for the next possible <span class="code">FOR</span> push</div></div>
									<div class="assembly-row-combined"><div>1953-1954</div><div><a href="#193AH" class="memory-link">JR 193AH<span class="origrom2">JR LOOPER</span></a><span class="opcode2">18 E5</span></div><div>At this point, we should be pointing to the start of the <span class="code">NEXT</span> entry, so JUMP to keep looking until the appropriate <span class="code">FOR</span> block has been located</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1955H">1955-1962 - DATA MOVEMENT ROUTINE<span class="origrom"> - "BLTU"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p> This routine moves a variable into another area specified by
 the caller.  On entry BC is set as the end address of the list to move 
(which is the upper limit); DE is set as the start address of the list 
to move; and HL is the end of the area to move it to.<br><br> According 
to the original ROM source, this routine is part of the general storage 
management routines, and if designed to make space by shoving everything
 forward and to check to make sure a reasonable amount of space remains 
between the top of the STACK and the highest location transferred to.  
On Entry, HL should be the destination of the high address, DE should be
 the low address to be transferred there, and BC should be the high 
address to be transferred there.   On exit, HL=DE=Low BC=The location 
LOW was moved to. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1955H"><div>1955-1957<span class="origrom2">BLTU</span></div><div><a href="#196CH" class="memory-link">CALL 196CH<br><span class="origrom">CALL REASON</span></a><span class="opcode2">CD 6C 19</span></div><div>GOSUB to 196CH to make sure there's enough room in memory for the string area and make sure the STACK won't be overrun</div></div>
									<div class="assembly-row-combined" id="1958H"><div>1958<span class="origrom2">BLTUC</span></div><div>PUSH BC<span class="opcode2">C5</span></div><div>The
 next 3 instructions are really just to exchange HL and BC.  First, save
 the end address of the list to move (stored in BC) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1959</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Save the end address of the list to move (stored in the STACK now) to Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>195A</div><div>POP BC<span class="opcode2">C1</span></div><div>Get the end address of the move from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined" id="195BH"><div>195B<span class="origrom2">BLTLOP</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H">RST 18H<span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Check
 is we are done by checking to see if the memory pointer in HL is the 
same as the memory pointer in DE (to see if the move is finished), so we
 call the COMPARE DE:HL routine, which numerically compares DE and HL. 
Will not work for signed integers (except positive ones). Uses the 
A-register only. The result of the comparison is returned in the status 
Register as:  <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>195C</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Get a byte from the source list to transfer and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>195D</div><div>LD (BC),A<span class="opcode2">02</span></div><div>Transfer it by saving the byte into wherever BC is pointing</div></div>
									<div class="assembly-row-combined" id="195EH"><div>195E</div><div>RET Z<span class="opcode2">C8</span></div><div>Return
 if finished with the move (i.e., the memory pointer in Register Pair HL
 is the same as the value of the memory pointer in Register Pair DE)</div></div>
									<div class="assembly-row-combined"><div>195F</div><div>DEC BC<span class="opcode2">0B</span></div><div>Decrement the source address (in Register Pair BC)</div></div>
									<div class="assembly-row-combined"><div>1960</div><div>DEC HL<span class="opcode2">2B</span></div><div>Decrement the destination address (in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>1961-1962</div><div><a href="#195BH" class="memory-link">JR 195BH<span class="origrom2">JR BLTLOP</span></a><span class="opcode2">18 F8</span></div><div>Loop until the entire block was moved</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1963H">1963-197D - MEMORY CHECK ROUTINE<span class="origrom"> - "GETSTK"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p> This routine computes the amount of space between HL and the
 end of memory at FFC6.  On entry, Register C should hold the number of 
desired bytes.<br><br> According to the original ROM source, this 
routine is part of the general storage management routines, and if 
designed to make sure that a certain number of locations remain 
available for the STACK.  To use this routine, Register C needs to hold 
the number of two byte entries needed, and then do a CALL GETSTK.  This 
routine must be called by any reoutine which puts an arbitrary amount of
 stuff into the STACK (such as a recursive routine like FRMEVL).  It is 
also called by routines such as <span class="code">GOSUB</span> and <span class="code">FOR</span>  which make permanent entries in the STACK. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1963H"><div>1963<span class="origrom2">GETSTK</span></div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value in Register Pair HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>1964-1966</div><div>LD HL,(40FDH)<span class="origrom2">LD HL,(STREND)</span><span class="opcode2">2A FD 40</span></div><div>Load Register Pair HL with the starting address of free memory (which is stored at 40FDH).<br>Note: 40FDH-40FEH holds Free memory pointer</div></div>
									<div class="assembly-row-combined"><div>1967-1968</div><div>LD B,00H<span class="opcode2">06 00</span></div><div>Load Register B with zero</div></div>
									<div class="assembly-row-combined"><div>1969</div><div>ADD HL,BC<span class="opcode2">09</span></div><div>Add 2 times the number of bytes required to start of free area (held in Register Pair BC) to the value in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>196A</div><div>ADD HL,BC<span class="opcode2">09</span></div><div>Add the value in Register Pair BC to the value in Register Pair HL leaving HL to now contain the end of the free area</div></div>
									<div class="assembly-row-combined"><div>196B-196C</div><div>LD A,0E5H<span class="opcode2">3E E5</span></div><div>Z-80 Trick!  See the general explanation at 10F8H</div></div>
									<div class="assembly-row-combined" id="196CH"><div>196C<span class="origrom2">REASON</span></div><div>PUSH HL<span class="opcode2">E5</span></div><div>Now
 we check t omake sure there is at least "NUMLEV" bytes between the 
address and the top of the STACK.  First, save the new free area pointer
 (which is the start) to the STACK</div></div>
									<div class="assembly-row-combined"><div>196D-196E</div><div>LD A,C6H<br><span class="origrom">LD A,256-(2*NUMLEV)</span><span class="opcode2">3E C6</span></div><div>Load Register A with C6H (which is the the LSB of FFC6H; the top of memory)</div></div>
									<div class="assembly-row-combined"><div>196F</div><div>SUB L<span class="opcode2">95</span></div><div>Subtract the LSB of the value of the new memory pointer in Register L from the value in Register A</div></div>
									<div class="assembly-row-combined"><div>1970</div><div>LD L,A<span class="opcode2">6F</span></div><div>Load
 Register L with the adjusted value in Register A (i.e., the free memory
 pointer resulting from subtracting the new starting address)</div></div>
									<div class="assembly-row-combined"><div>1971-1972</div><div>LD A,FFH<span class="opcode2">3E FF</span></div><div>Load Register A with the MSB of the top of memory</div></div>
									<div class="assembly-row-combined"><div>1973</div><div>SBC A,H<span class="opcode2">9C</span></div><div>Subtract
 the MSB of the new memory pointer in Register H from the value in 
Register A.  If the free space list exceeds 7FFC6 then the Carry flag 
gets set, meaning memory overflowed</div></div>
									<div class="assembly-row-combined"><div>1974-1975</div><div><a href="#197AH" class="memory-link">JR C,197AH<span class="origrom2">JR C,OMERR</span></a><span class="opcode2">38 04</span></div><div>If the CARRY flag is set then HL was simply too big.  So we need to display a <span class="code">?OM ERROR</span> since we are out of memory</div></div>
									<div class="assembly-row-combined"><div>1976</div><div>LD H,A<span class="opcode2">67</span></div><div>Next
 we need to determine if the free space list has overflowed the STACK 
area so first we load Register H with the adjusted value in Register A</div></div>
									<div class="assembly-row-combined"><div>1977</div><div>ADD HL,SP<span class="opcode2">39</span></div><div>Add the value of the STACK pointer to the adjusted value in Register Pair HL.  If we are OK, the CARRY FLAG will be set</div></div>
									<div class="assembly-row-combined"><div>1978</div><div>POP HL<span class="opcode2">E1</span></div><div>Restore the original HL on entry back into Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1979</div><div>RET C<span class="opcode2">D8</span></div><div>If the carry flag is set, then we have no overflow - so RETURN to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="197AH">197A-197B - ?OM ERROR ENTRY POINT<span class="origrom"> - "OMERR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="197AH"><div>197A-197B<span class="origrom2">OMERR</span></div><div>LD E,0CH<span class="origrom2">LD E,ERROM</span><span class="opcode2">1E 0C</span></div><div>Load Register E with the <span class="code">?OM ERROR</span></div></div>
									<div class="assembly-row-combined"><div>197C-197D</div><div><a href="#19A2H" class="memory-link">JR 19A2H<span class="origrom2">JR ERROR</span></a><span class="opcode2">18 24</span></div><div>Display an <span class="code">?OM ERROR</span> message</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="197EH">197E-1AF7 - LEVEL II BASIC COMMAND MODE ERROR HANDLING<span class="origrom"> - "PRGEND"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="197EH"><div>197E-1980<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;PRGEND</span></div><div>LD HL,(40A2H)<span class="origrom2">LD HL,(CURLIN)</span><span class="opcode2">2A A2 40</span></div><div>Load Register Pair HL with the value of the current BASIC line number.<br>Note: 40A2H-40A3H holds the current BASIC line number</div></div>
									<div class="assembly-row-combined"><div>1981</div><div>LD A,H<span class="opcode2">7C</span></div><div>Test
 to see if this was a direct command instead a line number by first 
loading Register A with the MSB of the current BASIC line number in 
Register H</div></div>
									<div class="assembly-row-combined"><div>1982</div><div>AND L<span class="opcode2">A5</span></div><div>Combine the LSB of the current BASIC line number in Register L with the MSB of the current line number in Register A</div></div>
									<div class="assembly-row-combined"><div>1983</div><div>INC A<span class="opcode2">3C</span></div><div>Bump
 the value of the combined BASIC line number in Register A.  If the 
current line is FFFFH then we have not started execution of a BASIC 
program yet (meaning we are still in the inputting phase)</div></div>
									<div class="assembly-row-combined"><div>1984-1985</div><div><a href="#198EH" class="memory-link">JR Z,198EH<span class="origrom2">JR Z,ENDCNJ</span></a><span class="opcode2">28 08</span></div><div>Jump to 198EH if Level II BASIC is still in the command mode (rather than being in execution mode)</div></div>
									<div class="assembly-row-combined"><div>1986-1988</div><div>LD A,(40F2H)<span class="origrom2">LD A,(ONEFLG)</span><span class="opcode2">3A F2 40</span></div><div>Load Register A with the error override flag (i.e., if there is an ON ERROR GOTO active)</div></div>
									<div class="assembly-row-combined"><div>1989</div><div>OR A<span class="opcode2">B7</span></div><div>Check to see if the error flag is set</div></div>
									<div class="assembly-row-combined"><div>198A-198B</div><div>LD E,22H<span class="origrom2">LD E,ERRNR<span class="opcode2">1E 22</span></span></div><div>Load Register E with a <span class="code">?NR ERROR</span> code</div></div>
									<div class="assembly-row-combined"><div>198C-198D</div><div><a href="#19A2H" class="memory-link">JR NZ,19A2H<span class="origrom2">JR NZ,ERROR</span></a><span class="opcode2">20 14</span></div><div>Jump to 19A2H if the error flag is set (meaning there was no <span class="code">RESUME</span> address)</div></div>
									<div class="assembly-row-combined" id="198EH"><div>198E-1990<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;ENDCNJ</span></div><div><a href="#1DC1H" class="memory-link">JP 1DC1H<span class="origrom2">JP ENDCON</span></a><span class="opcode2">C3 C1 1D</span></div><div>Otherwise, jump to 1DC1H (to END) because there was an error in the input phase</div></div>
									<div class="assembly-row-combined" id="1991H"><div>1991-1993<span class="origrom2">DATSNE</span></div><div>LD HL,(40DAH)<span class="origrom2">LD HL,(DATLIN)</span><span class="opcode2">2A DA 40</span></div><div>Load Register Pair HL with the <span class="code">DATA</span> line number (which is stored at 16602).<br>Note: 40DAH-40DBH holds DATA line number</div></div>
									<div class="assembly-row-combined"><div>1994-1996</div><div>LD (40A2H),HL<span class="origrom2">LD (CURLIN),HL</span><span class="opcode2">22 A2 40</span></div><div>Make the DATA line number into the CURRENT line number by saving it in Register Pair HL.<br>Note: 40A2H-40A3H holds the current BASIC line number</div></div>

									<div class="assembly-row-combined" id="1997H"><div>1997-1998<span class="origrom2">SNERR</span></div><div>LD E,02H<span class="origrom2">LD E,ERRSN</span><span class="opcode2">1E 02</span></div><div>Load Register E with a <span class="code">?SN ERROR</span> code.<br>SN ERROR entry point</div></div>
									<p class="debug-note">The next few instructions are all Z-80 tricks to allow Register E to hold its value while passing through them all.</p>
									<div class="assembly-row-combined" id="1999H"><div>1999-199B<span class="origrom2">DV0ERR</span></div><div>LD BC,141EH<span class="opcode2">01 1E 14</span></div><div>Z-80 Trick.  JUMPing here will load BC but skip the reload of Register E as follows</div></div>
									<div class="assembly-row-combined" id="199AH"><div>199A-199B</div><div>LD E,14H<span class="origrom2">LD E,ERRDV0</span><span class="opcode2">01 1E 14</span></div><div>Load Register E with a <span class="code">?/0 ERROR</span> code</div></div>
									<div class="assembly-row-combined" id="199CH"><div>199C-199E<span class="origrom2">NFERR</span></div><div>LD BC,001EH<span class="opcode2">01 1E 00</span></div><div>Z-80 Trick.  JUMPing here will load BC but skip the reload of Register E as follows</div></div>
									<div class="assembly-row-combined" id="199DH"><div>199D-199E</div><div>LD E,00H<span class="origrom2">LD E,ERRNF</span><span class="opcode2">1E 00</span></div><div>Load Register E with a <span class="code">?NF ERROR</span> code.<br><span class="code">?NF ERROR</span> entry point</div></div>
									<div class="assembly-row-combined" id="199FH"><div>199F-19A1<span class="origrom2">REERR</span></div><div>LD BC,241EH<span class="origrom2">LD E,ERRRE</span><span class="opcode2">01 1E 24</span></div><div>Z-80 Trick.  JUMPing here will load BC but skip the reload of Register E as follows</div></div>
									<div class="assembly-row-combined" id="19A0H"><div>19A0-19A1</div><div>LD E,24H<span class="origrom2">LD E,ERRRE</span><span class="opcode2">1E 24</span></div><div>Load Register E with a <span class="code">?RW ERROR</span> code.<br><span class="code">?RW ERROR</span> entry point</div></div>
									<div class="assembly-row-combined" id="19A2H"><div>19A2-19A4<span class="origrom2">ERROR</span></div><div>LD HL,(40A2H)<span class="origrom2">LD HL,(CURLIN)</span><span class="opcode2">2A A2 40</span></div><div>Load
 Register Pair HL with the value of the current BASIC line number which 
has the error.  Note: 40A2H-40A3H holds the current BASIC line number</div></div>
									<div class="assembly-row-combined"><div>19A5-19A7</div><div>LD (40EAH),HL<span class="origrom2">LD (ERRLIN),HL</span><span class="opcode2">22 EA 40</span></div><div>Save the value of the current BASIC line number with the error into the RAM Location which tracks the ERL variable.<br>Note: 40EAH-40EBH holds Line number with error</div></div>
									<div class="assembly-row-combined"><div>19A8-19AA</div><div>LD (40ECH),HL<span class="origrom2">LD (DOT),HL</span><span class="opcode2">22 EC 40</span></div><div>Save the value of the current BASIC line number with the error into the RAM location used for EDIT or LIST</div></div>
									<div class="assembly-row-combined" id="19ABH"><div>19AB-19AD<span class="origrom2">ERRESM</span></div><div>LD BC,19B4H<span class="origrom2">LD BC,ERRMOR</span><span class="opcode2">01 B4 19</span></div><div>Load Register Pair BC with the return address of 19B4H which is the continuation address after a reinitialization</div></div>
									<div class="assembly-row-combined" id="19AEH"><div>19AE-19B0<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;ERESET</span></div><div>LD HL,(40E8H)<span class="origrom2">LD HL,(SAVSTK)</span><span class="opcode2">2A E8 40</span></div><div>Load Register Pair HL with the value of the STACK pointer (which is stored at 40E8H).<br>Note: 40E8H-40E9H holds STACK pointer pointer</div></div>
									<div class="assembly-row-combined"><div>19B1-19B3</div><div><a href="#1B9AH" class="memory-link">JP 1B9AH<span class="origrom2">JP STKERR</span></a><span class="opcode2">C3 9A 1B</span></div><div>Jump to 1B9AH to reinitialize the system variables, including reinitializing the STACK to the location now held in SAVSTK</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="19B4H">19B4 - LEVEL II BASIC COMMAND MODE ERROR HANDLING<span class="origrom"> - "ERRMOR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>19B4<span class="origrom2">ERRMOR</span></div><div>POP BC<span class="opcode2">C1</span></div><div>Discard the entry at the top of the STACK (which is the FNDFOR Stopper)</div></div>
									<div class="assembly-row-combined"><div>19B5</div><div>LD A,E<span class="opcode2">7B</span></div><div>Load Register A with the value of the error code in Register E</div></div>
									<div class="assembly-row-combined"><div>19B6</div><div>LD C,E<span class="opcode2">4B</span></div><div>Load Register C with the value of the error code in Register E, as we will need to restore it later as well</div></div>
									<div class="assembly-row-combined"><div>19B7-19B9</div><div>LD (409AH),A<span class="origrom2">LD (ERRFLG),A</span><span class="opcode2">32 9A 40</span></div><div>Save the value of the error code (from in Register A) into 409AH.<br>Note: 409AH holds the RESUME flag</div></div>
									<div class="assembly-row-combined"><div>19BA-19BC</div><div>LD HL,(40E6H)<span class="origrom2">LD (SAVTXT),A</span><span class="opcode2">2A E6 40</span></div><div>Load
 Register Pair HL with the value of the current BASIC program pointer 
(which is stored in 40E6H) (i.e., the address  of the last byte executed
 in the current line).<br>Note: 40E6H-40E7H holds the temporary storage location</div></div>
									<div class="assembly-row-combined"><div>19BD-19BF</div><div>LD (40EEH),HL<span class="origrom2">LD (ERRTXT),HL</span><span class="opcode2">22 EE 40</span></div><div>Save the value of the current BASIC program pointer (which is stored in 40EEH) in Register Pair HL.<br>Note: 40EEH-40EFH is used by RESUME</div></div>
									<div class="assembly-row-combined"><div>19C0</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Load
 Register Pair DE with the value of the current BASIC program pointer in
 Register Pair HL so that the SAVTXT is preserved in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>19C1-19C3</div><div>LD HL,(40EAH)<span class="origrom2">LD HL,(ERRLIN)</span><span class="opcode2">2A EA 40</span></div><div>Load Register Pair HL with the line number where the error occurred.<br>Note: 40EAH-40EBH holds Line number with error</div></div>
									<div class="assembly-row-combined"><div>19C4,19C4</div><div>LD A,H<br>AND L<span class="opcode2">7C</span></div><div>Z-80 Trick to test if HL is zero or not - If H AND L are 0, then they are each zero</div></div>
									<div class="assembly-row-combined"><div>19C6</div><div>INC A<span class="opcode2">3C</span></div><div>Bump
 the value of the combined current BASIC line number.  If the line with 
the error was a direct command, this would have been FFFF, so the INC A 
will then set the ZERO flag if it was direct</div></div>
									<div class="assembly-row-combined"><div>19C7-19C8</div><div><a href="#19D0H" class="memory-link">JR Z,19D0H<span class="origrom2">JR Z,NTMDCN</span></a><span class="opcode2">28 07</span></div><div>If this was a direct command (and ZERO FLAG is set), then we do not want to modify OLDTXT or OLDLIN, so jump to 19D0H</div></div>
									<div class="assembly-row-combined"><div>19C9-19CB</div><div>LD (40F5H),HL<span class="origrom2">LD (OLDLIN),HL</span><span class="opcode2">22 F5 40</span></div><div>Let OLDLIN = ERRLIN by saving the value of the current BASIC line number in Register Pair HL to (40F5H).<br>Note: 40F5H-40F6H holds the last line number executed</div></div>
									<div class="assembly-row-combined"><div>19CC</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Get bacK SAVTXT by swapping HL and DE</div></div>
									<div class="assembly-row-combined"><div>19CD-19CF</div><div>LD (40F7H),HL<span class="origrom2">LD (OLDTXT),HL</span><span class="opcode2">22 F7 40</span></div><div>Let OLDTXT = SAVTXT by saving the value of the current BASIC program pointer in Register Pair HL.<br>Note: 40F7H-40F8H holds Last byte executed</div></div>

									<div class="assembly-row-combined" id="19D0H"><div>19D0-19D2<span class="origrom2">NTMDCN</span></div><div>LD HL,(40F0H)<span class="origrom2">LD HL,(ONELIN)</span><span class="opcode2">2A F0 40</span></div><div>See if we are trapping errors by first loading Register Pair HL with the current <span class="code">ON ERROR</span> address.<br>Note: 40F0H-40F1H is used by <span class="code">ON ERROR</span></div></div>
									<div class="assembly-row-combined"><div>19D3,19D4</div><div>LD A,H<br>OR L<span class="opcode2">7C</span></div><div>Z-80 Trick to test if HL is zero or not - If H OR L are 0, then they are each zero</div></div>
									<div class="assembly-row-combined"><div>19D5</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Load Register Pair DE with the <span class="code">ON ERROR</span> address to go to if there's an error which is currently in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>19D6-19D8</div><div>LD HL,40F2H<span class="origrom2">LD HL,ONEFLG</span><span class="opcode2">21 F2 40</span></div><div>Load Register Pair HL with the address of the error flag (which is 40F2H).<br>Note: 40F2H holds Error flag</div></div>
									<div class="assembly-row-combined"><div>19D9-19DA</div><div><a href="#19E3H" class="memory-link">JR Z,19E3H<span class="origrom2">JR Z,NOTRAP</span></a><span class="opcode2">28 08</span></div><div>Jump to 19E3H (to error out) if we aren't otherwise trapping errors (because there isn't an <span class="code">ON ERROR</span> address)</div></div>
									<div class="assembly-row-combined"><div>19DB</div><div>AND (HL)<span class="opcode2">A6</span></div><div>Since
 Register A is currently non-zero (or we would have jumped away in the 
prior instruction), combining that number with with the ONEFLG will 
result in either a 0 or non-zero based on whether whether the flag was 
already set</div></div>
									<div class="assembly-row-combined"><div>19DC-19DD</div><div><a href="#19E3H" class="memory-link">JR NZ,19E3H<span class="origrom2">JR NZ,NOTRAP</span></a><span class="opcode2">20 05</span></div><div>If the NZ FLAG is set, then it was already set, so JUMP to 19E3H (to error out)</div></div>
									<div class="assembly-row-combined"><div>19DE</div><div>DEC (HL)<span class="opcode2">35</span></div><div>Force an error</div></div>
									<div class="assembly-row-combined"><div>19DF</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Load Register Pair HL with the <span class="code">ON ERROR</span> line address pointer held in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>19E0-19E2</div><div><a href="#1D36H" class="memory-link">JP 1D36H<span class="origrom2">JP GONE4</span></a><span class="opcode2">C3 36 1D</span></div><div>Jump to 1D36H to make that happen</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="19E3H">19E3 - LEVEL II BASIC COMMAND MODE ERROR HANDLING<span class="origrom"> - "NOTRAP"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>19E3<span class="origrom2">NOTRAP</span></div><div>XOR A<span class="opcode2">AF</span></div><div>Zero Register A</div></div>
									<div class="assembly-row-combined"><div>19E4</div><div>LD (HL),A<span class="opcode2">77</span></div><div>Reset
 ONMEFLG.  Clear the error override flag by save a zero (from Register 
A) as the current error flag at the location of the memory pointer in 
Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>19E5</div><div>LD E,C<span class="opcode2">59</span></div><div>Restore the error code (which was tucked away in Register C at 19B6H) into Register E</div></div>
									<div class="assembly-row-combined"><div>19E6-19E8</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#20F9H">CALL 20F9H<span class="origrom2">CALL CRDONZ</span></a><span class="opcode2">CD F9 20</span></div><div>We need to position the video to the next line, so go display a carriage return on the video display if necessary</div></div>
									<div class="assembly-row-combined"><div>19E9-19EB</div><div>LD HL,18C9H<span class="origrom2">LD HL,ERRTAB</span><span class="opcode2">21 C9 18</span></div><div>Load Register Pair HL with the starting address for the table of error messages</div></div>
									<div class="assembly-row-combined"><div>19E6-19E8</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#20F9H">CALL 41A6H<span class="origrom2">CALL EXDSKR</span></a><span class="opcode2">CD F9 20</span></div><div>Check to see if DOS should be handling this</div></div>
									<div class="assembly-row-combined"><div>19EF</div><div>LD D,A<span class="opcode2">57</span></div><div>Since we are non-DOS, we continue by loading Register D with zero</div></div>
									<div class="assembly-row-combined"><div>19F0-19F1</div><div>LD A,3FH<span class="origrom2">LD A,"?"</span><span class="opcode2">3E 3F</span></div><div>Load Register A with a <span class="code">?</span></div></div>
									<div class="assembly-row-combined"><div>19F2-19F4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH">CALL 032AH<span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>GOSUB to 032AH to display the question mark in Register A</div></div>
									<div class="assembly-row-combined"><div>19F5</div><div>ADD HL,DE<span class="opcode2">19</span></div><div>Add the value of the error code in Register Pair DE to the starting address of the table of error messages in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>19F6</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load Register A with the first character of the error message at the location of the table pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>19F7-19F9</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH">CALL 032AH<span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>GOSUB to 032AH to display the first character of the error message in Register A</div></div>
									<div class="assembly-row-combined"><div>19FA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H">RST 10H<span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>Error
 codes are 2 characters so we need to set the second character of the 
error in Register A, call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>19FB-19FD</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH">CALL 032AH<span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>GOSUB to 032AH to display the second character of the error message in Register A</div></div>
									<div class="assembly-row-combined" id="1A00H"><div>19FE-1A00</div><div>LD HL,191DH<span class="origrom2">LD HL,ERR</span><span class="opcode2">21 1D 19</span></div><div>Load Register Pair HL with 191DH which is the starting address of the word "ERROR" message</div></div>
									<div class="assembly-row-combined"><div>1A01</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the starting address of the word "ERROR" (held in HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1A02-1A04</div><div>LD HL,(40EAH)<span class="origrom2">LD HL,(ERRLIN)</span><span class="opcode2">2A EA 40</span></div><div>Load Register Pair HL with the value of the BASIC line number causing the error.<br>Note: 40EAH-40EBH holds Line number with error</div></div>
									<div class="assembly-row-combined"><div>1A05</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Exchange
 the value of the current BASIC line number in Register Pair HL with the
 starting address of the Level II BASIC ERROR message to the STACK</div></div>

									<div class="assembly-row-combined"><div>1A06<span class="origrom2">ERRFIN</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#28A7">CALL 28A7H<span class="origrom2">CALL STROUT</span></a><span class="opcode2">CD A7 28</span></div><div>GOSUB to 28A7 to display the entire word ERROR on screen</div></div>
									<div class="assembly-row-combined"><div>1A09</div><div>POP HL<span class="opcode2">E1</span></div><div>Get the value of the BASIC line number with the error from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1A0A-1A0C</div><div>LD DE,FFFEH<span class="origrom2">LD DE,0 + 65534</span><span class="opcode2">11 FE FF</span></div><div>Load Register Pair DE with FFFEH.<br><br>This basically reserves the line number 65534 as a trigger for the next few steps</div></div>
									<div class="assembly-row-combined"><div>1A0D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H">RST 18H<span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now
 we need to compare the BASIC line number causing the error (held in HL)
 with FFFEH (held in DE) so as to see if we are in the initialization 
routine, so we call the COMPARE DE:HL routine, which numerically 
compares DE and HL. Will not work for signed integers (except positive 
ones). Uses the A-register only. The result of the comparison is 
returned in the status Register as:  <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>1A0E-1A10</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0674H">JP Z,0674H<span class="origrom2">JP Z,INIT</span></a><span class="opcode2">CA 74 06</span></div><div>Jump to 0674H if we are in the initialization routine because the error line number was FFFEH</div></div>
									<div class="assembly-row-combined"><div>1A11</div><div>LD A,H<span class="opcode2">7C</span></div><div>Next,
 let's see if we were in direct mode (i.e., entered from the command 
line).  Load Register A with the MSB of the current BASIC line number in
 Register H</div></div>
									<div class="assembly-row-combined"><div>1A12</div><div>AND L<span class="opcode2">A5</span></div><div>Combine the LSB of the current BASIC line number in Register L with the MSB of the current BASIC line number in Register A</div></div>
									<div class="assembly-row-combined"><div>1A13</div><div>INC A<span class="opcode2">3C</span></div><div>Bump
 the combined value of the current BASIC line number in Register A to 
test to see if the line number is 00H (meaning command mode)</div></div>
									<div class="assembly-row-combined"><div>1A14-1A16</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0FA7H">CALL NZ,0FA7H<span class="origrom2">CALL NZ,INPRT</span></a><span class="opcode2">C4 A7 0F</span></div><div>GOSUB to 0FA7H to display the current BASIC line number in Register Pair HL if Level II BASIC isn't in the command mode</div></div>
									<p class="debug-note">The original ROM has this note:  The 
following code is for "LIST" command stopping and for returning from a 
failed "CVER" and to correct a direct GOSUB which does input.</p>
									<div class="assembly-row-combined"><div>1A17</div><div>LD A,0C1H<span class="opcode2">3E C1</span></div><div>Z-80 Trick!  If passing through from the above routine, then A will loaded and the instruction at 1A18 will be skipped.</div></div>
									<div class="assembly-row-combined" id="1A18H"><div>1A18<span class="origrom2">STPRDY</span></div><div>POP BC<span class="opcode2">C1</span></div><div>Get the value from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined" id="1A19H"><div>1A19-1A1BH<span class="origrom2">READY</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#038BH">CALL 038BH<span class="origrom2">CALL FINLPT</span></a><span class="opcode2">CD 8B 03</span></div><div>Go set the current output device to the video display.<br>Re-entry into BASIC command mode entry point. (see 6CCH also)</div></div>
									<div class="assembly-row-combined" id="1A1CH"><div>1A1C-1A1EH</div><div>CALL 41ACH<span class="origrom2">CALL PRGFIN</span><span class="opcode2">CD AC 41</span></div><div></div></div>
									<div class="assembly-row-combined"><div>1A1F-1A21</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#01F8H">CALL 01F8H<span class="origrom2">CALL CTOFF</span></a><span class="opcode2">CD F8 01</span></div><div>Go turn off the cassette recorder</div></div>
									<div class="assembly-row-combined"><div>1A22-1A24</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#20F9H">CALL 20F9H<span class="origrom2">CALL CRDONZ</span></a><span class="opcode2">CD F9 20</span></div><div>Go display a carriage return if necessary</div></div>
									<div class="assembly-row-combined"><div>1A25-1A27</div><div>LD HL,1929H<span class="origrom2">LD HL,REDDY</span><span class="opcode2">21 29 19</span></div><div>Load Register Pair HL with the starting address of word "READY"</div></div>
									<div class="assembly-row-combined"><div>1A28-1A2A<span class="origrom2">REPINI</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#20F9H">CALL 28A7H<span class="origrom2">CALL STROUT</span></a><span class="opcode2">CD A7 28</span></div><div>Display the word "READY"</div></div>
									<div class="assembly-row-combined"><div>1A2B-1A2D</div><div>LD A,(409AH)<span class="origrom2">LD A,(ERRFLG)</span><span class="opcode2">3A 9A 40</span></div><div>Load Register A with the value of the current error code</div></div>
									<div class="assembly-row-combined"><div>1A2E-1A2F</div><div>SUB 02H<span class="opcode2">D6 02</span></div><div>Check to see if the current error code is a <span class="code">?SN ERROR</span> code by subtracting 2 from the error code, resulting in a zero if its a SN ERROR and any other number if it isn't</div></div>
									<div class="assembly-row-combined"><div>1A30-1A32</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2E53H">CALL Z,2E53H<span class="origrom2">CALL Z,ERREDT</span></a><span class="opcode2">CC 53 2E</span></div><div>If the current error code is a SN ERROR code, then automatically enter EDIT mode on that line via this CALL</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1A33H">1A33 - MAIN LEVEL II BASIC INTERPRETER ENTRY<span class="origrom"> - "MAIN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>If the jump here was from an <span class="code">AUTO</span> call, (40E4H) will have the increment number, (40E1H) will be 0 if no <span class="code">AUTO</span> and non-zero if <span class="code">AUTO</span>, and (40E2H) will have the starting line number.</p>
								<div class="assembly-table">
									<p class="debug-note">While not for this specific routine, this
 is the best place to mention it.  Vernon Hester has pointed out that 
while BASIC is supposed to ignore spaces in commands, it fails to 
properly handle some commands because of spaces<br> If you have a 
statement with a type declaration tag after a number and a space before 
an add or subtract arithmetic operator, the ROM applies the operator as a
 unary operator for the following argument<br> &nbsp;&nbsp;Example: PRINT 2% + N will display two numbers.  PRINT 2%+N will display one number.<br>
 Also, if you have a statement with a type declaration tag after a 
number and a space before a multiply or divide arithmetic operator, the 
ROM willl throw a ?SN ERROR<br> &nbsp;&nbsp;Example: PRINT 2%*N will display a number.  PRINT 2% * N will display a ?SN ERROR. </p>
									<div class="assembly-row-combined"><div>1A33-1A35<span class="origrom2">MAIN</span></div><div>LD HL,FFFFH<span class="opcode2">21 FF FF</span></div><div>Load Register Pair HL with the command mode line number</div></div>
									<div class="assembly-row-combined"><div>1A36-1A38</div><div>LD (40A2H),HL<span class="origrom2">LD (CURLIN),HL</span><span class="opcode2">22 A2 40</span></div><div>Set CURLIN up for direct command mode by saving FFFFH as the current BASIC line number.<br>Note: 40A2H-40A3H holds the current BASIC line number</div></div>
									<div class="assembly-row-combined"><div>1A39-1A3B</div><div>LD A,(40E1H)<span class="origrom2">LD A,(AUTFLG)</span><span class="opcode2">3A E1 40</span></div><div>Load Register A with the value of the <span class="code">AUTO</span> flag.  It will be zero if not in <span class="code">AUTO</span>, and anything else if in AUTO</div></div>
									<div class="assembly-row-combined"><div>1A3C</div><div>OR A<span class="opcode2">B7</span></div><div>Check to see if in the <span class="code">AUTO</span> mode</div></div>
									<div class="assembly-row-combined"><div>1A3D-1A3E</div><div><a href="#1A76H" class="memory-link">JR Z,1A76H<span class="origrom2">JR Z,NTAUTO</span></a><span class="opcode2">28 37</span></div><div>Jump to 1A76H if not in the <span class="code">AUTO</span> mode</div></div>
									<div class="assembly-row-combined"><div>1A3F-1A41</div><div>LD HL,(40E2H)<span class="origrom2">LD HL,(AUTLIN)</span><span class="opcode2">2A E2 40</span></div><div>We are in <span class="code">AUTO</span> mode so load Register Pair HL with the current <span class="code">AUTO</span> line number.<br>Note: 40E2H-40E3H holds Current BASIC line number</div></div>
									<div class="assembly-row-combined"><div>1A42</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the current <span class="code">AUTO</span> line number (stored in Register Pair HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1A43-1A45</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0FAFH">CALL 0FAFH<span class="origrom2">CALL LINPRT</span></a><span class="opcode2">CD AF 0F</span></div><div>Display
 the current AUTO line number on the screen via a GOSUB to 0FAFH to call
 the HL TO ASCII routine at 0FAFH (which converts the value in the HL 
Register Pair (assumed to be an integer) to ASCII</div></div>
									<div class="assembly-row-combined"><div>1A46</div><div>POP DE<span class="opcode2">D1</span></div><div>Get the current <span class="code">AUTO</span> line number from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1A47</div><div>PUSH DE<span class="opcode2">D5</span></div><div>Save the current <span class="code">AUTO</span> line number in Register Pair DE to the STACK</div></div>
									<div class="assembly-row-combined"><div>1A48-1A4A</div><div><a href="#1B2CH" class="memory-link">CALL 1B2CH<span class="origrom2">CALL FNDLIN</span></a><span class="opcode2">CD 2C 1B</span></div><div>See
 if the line number already exists by CALLing the SEARCH FOR LINE NUMBER
 routine at 1B2CH which looks for the line number specified in DE.  
Returns C/Z with the line found in BC, NC/Z with line number is too 
large and HL/BC having the next available location, or NC/NZ with line 
number not found, and BC has the first available one after that</div></div>
									<div class="assembly-row-combined"><div>1A4B-1A4C</div><div>LD A,2AH<span class="opcode2">3E 2A</span></div><div>Load Register A with a <span class="code">*</span> (which will be code for a matching line number)</div></div>
									<div class="assembly-row-combined"><div>1A4D-1A4E</div><div><a href="#1A51H" class="memory-link">JR C,1A51H<span class="origrom2">JR C,AUTELN</span></a><span class="opcode2">38 02</span></div><div>If
 the call to 1B2CH shows a matching line number was found in the BASIC 
program (by returning a C), skip the next instruction so that Register A
 keeps the <span class="code">*</span></div></div>
									<div class="assembly-row-combined"><div>1A4F-1A50</div><div>LD A,20H<span class="origrom2">LD A," "</span><span class="opcode2">3E 20</span></div><div>If we are here, then there was no matching line number so we need to change the next character from a <span class="code">*</span> (which is loaded into Register A which but is not applicable) to a <span class="code">SPACE</span></div></div>

									<div class="assembly-row-combined" id="1A51H"><div>1A51-1A53<span class="origrom2">AUTELN</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH">CALL 032AH<span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go display the character in Register A on the video display (which will be a "*" if a matching line number was found)</div></div>
									<div class="assembly-row-combined"><div>1A54-1A56</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0361H">CALL 0361H<span class="origrom2">CALL INLIN</span></a><span class="opcode2">CD 61 03</span></div><div>GOSUB to 0361H to read a line into the buffer</div></div>
									<div class="assembly-row-combined"><div>1A57</div><div>POP DE<span class="opcode2">D1</span></div><div>Get the current line number from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1A58-1A59</div><div><a href="#1A60H" class="memory-link">JR NC,1A60H<span class="origrom2">JR NC,AUTGOD</span></a><span class="opcode2">30 06</span></div><div>Skip the next 3 opcodes if the <kbd>BREAK</kbd> key wasn't pressed</div></div>
									<div class="assembly-row-combined" id="1A5AH"><div>1A5A<span class="origrom2">AUTRES</span></div><div>XOR A<span class="opcode2">AF</span></div><div>The <kbd>BREAK</kbd> key was pressed so we need to zero Register A to clear the AUTO increment flag</div></div>
									<div class="assembly-row-combined"><div>1A5B-1A5D</div><div>LD (40E1H),A<span class="origrom2">LD (AUTFLG),A</span><span class="opcode2">32 E1 40</span></div><div>Save the value in Register A as the current AUTO flag (to turn off AUTO)</div></div>
									<div class="assembly-row-combined"><div>1A5E-1A5F</div><div><a href="#1A19H" class="memory-link">JR 1A19H<span class="origrom2">JR READY</span></a><span class="opcode2">18 B9</span></div><div>Jump to the normal command mode "READY" routine at 1A19H</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1A60H">1A60H - Part of the AUTO command<span class="origrom"> - "AUTGOD"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1A60-1A62<span class="origrom2">AUTGOD</span></div><div>LD HL,(40E4H)<span class="origrom2">LD HL,(AUTINC)</span><span class="opcode2">2A E4 40</span></div><div>Load Register Pair HL with the value of the <span class="code">AUTO</span> increment.<br>Note: 40E4H-40E5H holds AUTO increment</div></div>
									<div class="assembly-row-combined"><div>1A63</div><div>ADD HL,DE<span class="opcode2">19</span></div><div>Since we didn't BREAK out of the routine we need to keep processing the <span class="code">AUTO</span> so we add the value of the AUTO line number in Register Pair DE with the AUTO increment value in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1A64-1A65</div><div><a href="#1A5AH" class="memory-link">JR C,1A5AH<span class="origrom2">JR C,AUTRES</span></a><span class="opcode2">38 F4</span></div><div>If that addition to the next <span class="code">AUTO</span> line number causes an overflow (by triggering the Carry flag), jump to 1A5AH which is the same as if the <kbd>BREAK</kbd> key was hit</div></div>
									<div class="assembly-row-combined"><div>1A66</div><div>PUSH DE<span class="opcode2">D5</span></div><div>Save the current <span class="code">AUTO</span> line number in Register Pair DE to the STACK</div></div>
									<div class="assembly-row-combined"><div>1A67-1A69</div><div>LD DE,FFF9H<span class="opcode2">11 F9 FF</span></div><div>Load Register Pair DE with the maximum BASIC line number of FFF9H (=65529).<br><br>There is an explanation at 1E5AH as to why 65529 is the highest possible line number (vs 65535 which would make more sense)</div></div>
									<div class="assembly-row-combined"><div>1A6A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H">RST 18H<span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now we need to compare the adjusted <span class="code">AUTO</span>
 line number (in HL) with the maximum BASIC line number (in DE), so we 
call the COMPARE DE:HL routine, which numerically compares DE and HL. 
Will not work for signed integers (except positive ones). Uses the 
A-register only. The result of the comparison is returned in the status 
Register as:  <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>1A6B</div><div>POP DE<span class="opcode2">D1</span></div><div>Get the current <span class="code">AUTO</span> line number from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1A6C-1A6D</div><div><a href="#1A5AH" class="memory-link">JR NC,1A5AH<span class="origrom2">JR NC,AUTRES</span></a><span class="opcode2">30 EC</span></div><div>If the adjusted AUTO line number in Register Pair HL is too large, jump to 1A5AH which is the same as if the <kbd>BREAK</kbd> key was hit</div></div>
									<div class="assembly-row-combined"><div>1A6E-1A70</div><div>LD (40E2H),HL<span class="origrom2">LD (AUTLIN),HL</span><span class="opcode2">22 E2 40</span></div><div>Save the adjusted <span class="code">AUTO</span> line number in Register Pair HL as the current <span class="code">AUTO</span> line number.<br>Note: 40E2H-40E3H holds Current BASIC line number</div></div>
									<div class="assembly-row-combined"><div>1A71-1A72</div><div>OR 0FFH<span class="opcode2">F6 FF</span></div><div>Set all non-zero condition codes by ORing Register A with FFH</div></div>
									<div class="assembly-row-combined"><div>1A73-1A75</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2FEBH">JP 2FEBH<span class="origrom2">JP EDITRT</span></a><span class="opcode2">C3 EB 2F</span></div><div>Jump to the <span class="code">EDIT</span> routine to save the current BASIC line</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1A76H">1A76H - Part of the AUTO command<span class="origrom"> - "NTAUTO"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1A76-1A77<span class="origrom2">NTAUTO</span></div><div>LD A,3EH<span class="origrom2">LD A,"&gt;"</span><span class="opcode2">3E 3E</span></div><div>Load Register A with a <span class="code">&gt;</span> symbol (i.e., the prompt that follows READY)</div></div>
									<div class="assembly-row-combined"><div>1A78-1A7A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH">CALL 032AH<span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go display the Level II BASIC prompt in Register A on the video display</div></div>
									<div class="assembly-row-combined"><div>1A7B-1A7D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0361H">CALL 0361H<span class="origrom2">CALL INLIN</span></a><span class="opcode2">CD 61 03</span></div><div>GOSUB to 0361H to accept input.  HL will hold the buffer address for that input</div></div>
									<div class="assembly-row-combined"><div>1A7E-1A80</div><div><a href="#1A33H" class="memory-link">JP C,1A33H<span class="origrom2">JP C,MAIN</span></a><span class="opcode2">DA 33 1A</span></div><div>Jump to 1A33H if the <kbd>BREAK</kbd> key was pressed</div></div>
									<div class="assembly-row-combined"><div>1A81</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H">RST 10H<span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>Since
 we need to bump the current input buffer pointer in Register Pair HL 
until it points to the first character, call the EXAMINE NEXT SYMBOL 
routine at RST 10H.<br><br>The RST 10H routine parses the characters 
starting at HL+1 for the first non-SPACE,non-09H,non-0BH character it 
finds.  On exit, Register A will hold that character, and the C FLAG is 
set if its alphabetic, and NC FLAG if its alphanumeric.  All strings 
must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>1A82</div><div>INC A<span class="opcode2">3C</span></div><div>Bump the value of the character in Register A.  This sets the status flags but saves the carry flag</div></div>
									<div class="assembly-row-combined"><div>1A83</div><div>DEC A<span class="opcode2">3D</span></div><div>Decrement the value of the character in Register A so we can test for an end of statement</div></div>
									<div class="assembly-row-combined"><div>1A84-1A86</div><div><a href="#1A33H" class="memory-link">JP Z,1A33H<span class="origrom2">JP Z,MAIN</span></a><span class="opcode2">CA 33 1A</span></div><div>Jump to 1A33H if we have an end of statement or a blank statement</div></div>
									<div class="assembly-row-combined"><div>1A87</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the value in Register Pair AF to the STACK (including the carry flag)</div></div>
									<div class="assembly-row-combined"><div>1A88-1A8A</div><div><a href="#1E5AH" class="memory-link">CALL 1E5AH<span class="origrom2">CALL LINGET</span></a><span class="opcode2">CD 5A 1E</span></div><div>Call
 the ASCII TO INTEGER routine at 1E5AH which converts the ASCII string 
pointed to by HL to an integer deposited into DE.  If the routine finds a
 non-numeric character, the conversion is stopped</div></div>
									<div class="assembly-row-combined" id="1A8BH"><div>1A8B<span class="origrom2">BAKSP</span></div><div>DEC HL<span class="opcode2">2B</span></div><div>Top
 of a loop.  Decrement the value of the input buffer pointer in Register
 Pair HL so that it will point to the previous character</div></div>
									<div class="assembly-row-combined"><div>1A8C</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Fetch the character at the location of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1A8D-1A8E</div><div>CP 20H<span class="origrom2">CP " "</span><span class="opcode2">FE 20</span></div><div>Check to see if the character at the location of the input buffer pointer in Register A is a <span class="code">SPACE</span></div></div>
									<div class="assembly-row-combined"><div>1A8F-1A90</div><div><a href="#1A8BH" class="memory-link">JR Z,1A8BH<span class="origrom2">JR Z,BAKSP</span></a><span class="opcode2">28 FA</span></div><div>Loop back to 1A8BH if the character at the location of the input buffer pointer in Register A is a space</div></div>
									<div class="assembly-row-combined"><div>1A91</div><div>INC HL<span class="opcode2">23</span></div><div>Now
 HL points to the last non-space character, so we need to advance one 
--- Bump the value of the input buffer pointer in Register Pair HL so 
that it points to the first character following a line number</div></div>
									<div class="assembly-row-combined"><div>1A92</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load Register A with that character</div></div>
									<div class="assembly-row-combined"><div>1A93-1A94</div><div>CP 20H<span class="origrom2">CP " "</span><span class="opcode2">FE 20</span></div><div>Check to see if the character at the location of the input buffer pointer in Register A is a space</div></div>
									<div class="assembly-row-combined"><div>1A95-1A97</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09C9H">CALL Z,09C9H<span class="origrom2">CALL Z,INXHRT</span></a><span class="opcode2">CC C9 09</span></div><div>If
 it is a space then skip it by a GOSUB to 09C9H which bumps the value of
 the input buffer pointer in Register Pair HL if necessary</div></div>

									<div class="assembly-row-combined" id="1A98H"><div>1A98<span class="origrom2">EDENT</span></div><div>PUSH DE<span class="opcode2">D5</span></div><div>Save
 the BASIC line number in Register Pair DE (which was converted from 
ASCII to an integer in 1A88H through a call to 1E5AH) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1A99-1A9B</div><div><a href="#1BC0H" class="memory-link">CALL 1BC0H<span class="origrom2">CALL CRUNCH</span></a><span class="opcode2">CD C0 1B</span></div><div>Tokenize the input via a GOSUB to 1BC0H.  BC will equal the length of the encoded statement when its done</div></div>
									<div class="assembly-row-combined"><div>1A9C</div><div>POP DE<span class="opcode2">D1</span></div><div>Restore the BASIC line number (which is an integer) from the STACK</div></div>
									<div class="assembly-row-combined"><div>1A9D</div><div>POP AF<span class="opcode2">F1</span></div><div>Get
 the carry flag (from the 1A81H character fetch) and put it in Register 
Pair AF to aid in determining if there even was a line number</div></div>
									<div class="assembly-row-combined"><div>1A9E-1AA0</div><div>LD (40E6H),HL<span class="origrom2">LD (SAVTXT),HL</span><span class="opcode2">22 E6 40</span></div><div>Save the input buffer pointer in Register Pair HL t the temporary storage area for use in RESUMEing a direct statement.<br>Note: 40E6H-40E7H holds the temporary storage location</div></div>
									<div class="assembly-row-combined"><div>1A99-1A9B</div><div><a href="#1BC0H" class="memory-link">CALL 41B2H<span class="origrom2">CALL DIRDO</span></a><span class="opcode2">CD C0 1B</span></div><div>Check to see if DOS should be taking this over</div></div>
									<div class="assembly-row-combined"><div>1AA4-1AA6</div><div><a href="#1D5AH" class="memory-link">JP NC,1D5AH<span class="origrom2">JP NC,GONE</span></a><span class="opcode2">D2 5A 1D</span></div><div>If NC is set then this was a direct statement, so JUMP to 1D5AH as there wasn't a line number with the input</div></div>
									<div class="assembly-row-combined"><div>1AA7</div><div>PUSH DE<span class="opcode2">D5</span></div><div>Save the BASIC line number (as an integer stored in Register Pair DE) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1AA8</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the length (i.e., character count) of the tokenized input (stored in Register Pair BC) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1AA9</div><div>XOR A<span class="opcode2">AF</span></div><div>Zero Register A</div></div>
									<div class="assembly-row-combined"><div>1AAA-1AAC</div><div>LD (40DDH),A<span class="origrom2">LD (BFKLFL),A</span><span class="opcode2">32 DD 40</span></div><div>Save the value in Register A (which is a 00H) as the input flag.<br>Note: 40DDH holds the BUFFER KILLED flag</div></div>
									<div class="assembly-row-combined"><div>1AAD</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H">RST 10H<span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>Since
 we need find the first token, we have to bump the current input buffer 
pointer in Register Pair HL until it points to the next character by 
calling the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The RST 10H 
routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>1AAE</div><div>OR A<span class="opcode2">B7</span></div><div>Set the flags</div></div>
									<div class="assembly-row-combined"><div>1AAF</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the status flag to the STACK</div></div>
									<div class="assembly-row-combined"><div>1AB0</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Load Register Pair HL with the integer value of the BASIC line number (held in Register Pair DE)</div></div>
									<div class="assembly-row-combined"><div>1AB1-1AB3</div><div>LD (40ECH),HL<span class="origrom2">LD (DOT),HL</span><span class="opcode2">22 EC 40</span></div><div>Save the integer value of the line number (held in Register Pair HL) to 40ECH.<br>Note: 40ECH-40EDH holds EDIT line number</div></div>
									<div class="assembly-row-combined"><div>1AB4</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange
 the value of the input buffer pointer in Register Pair DE with the 
integer value of the BASIC line number in Register Pair HL.  This will 
fill DE with the line number for the search routine in the next 
instruction</div></div>
									<div class="assembly-row-combined"><div>1AB5-1AB7</div><div><a href="#1B2CH" class="memory-link">CALL 1B2CH<span class="origrom2">CALL FNDLIN</span></a><span class="opcode2">CD 2C 1B</span></div><div>Call
 the SEARCH FOR LINE NUMBER routine at 1B2CH which looks for the line 
number specified in DE.  Returns C/Z with the line found in BC, NC/Z 
with line number is too large and HL/BC having the next available 
location, or NC/NZ with line number not found, and BC has the first 
available one after that</div></div>

									<div class="assembly-row-combined"><div>1AB8<span class="origrom2">LEXIST</span></div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the address of the line number in the BASIC program (if it exists) in Register Pair BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>1AB9-1ABB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2BE4H">CALL C,2BE4H<span class="origrom2">CALL C,DEL</span></a><span class="opcode2">DC E4 2B</span></div><div>Delete
 the line since there wasn't a matching line number in the BASIC 
program.  The GOSUB to 2BE4H will move the closest line number up in 
memory to make room for another line</div></div>
									<div class="assembly-row-combined"><div>1ABC<span class="origrom2">NODEL</span></div><div>POP DE<span class="opcode2">D1</span></div><div>REstore the pointer to the place to insert the line from the STACK into Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1ABD</div><div>POP AF<span class="opcode2">F1</span></div><div>Restore the status from the 1AADH token scan into Register Pair AF to see if the line had anything on it</div></div>
									<div class="assembly-row-combined"><div>1ABE</div><div>PUSH DE<span class="opcode2">D5</span></div><div>Save the integer address of the BASIC line number where we need to start fixing links to the STACK</div></div>
									<div class="assembly-row-combined"><div>1ABF-1AC0</div><div><a href="#1AE8H" class="memory-link">JR Z,1AE8H<span class="origrom2">JR Z,FINI</span></a><span class="opcode2">28 27</span></div><div>Jump
 to 1AE8H if there was a matching line number in the BASIC program; 
otherwise we move on and a new line has to be added as follows</div></div>
									<div class="assembly-row-combined"><div>1AC1</div><div>POP DE<span class="opcode2">D1</span></div><div>Clear the STACK from the start of the fix links</div></div>
									<div class="assembly-row-combined"><div>1AC2-1AC4</div><div>LD HL,(40F9H)<span class="origrom2">LD HL,(VARTAB)</span><span class="opcode2">2A F9 40</span></div><div>Load Register Pair HL with the end of the BASIC program pointer.<br>Note: 40F9H-40FAH holds the starting address of the simple variable storage area</div></div>
									<div class="assembly-row-combined"><div>1AC5</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Exchange the length of the tokenized input to the STACK with the end of the BASIC program pointer (VARTAB) in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1AC6</div><div>POP BC<span class="opcode2">C1</span></div><div>Get the end of the BASIC program pointer (VARTAB) from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>1AC7</div><div>ADD HL,BC<span class="opcode2">09</span></div><div>Add
 the end of the BASIC program pointer in Register Pair BC to the value 
of the length of the tokenized input in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1AC8</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the adjusted end of the BASIC program pointer (VARTAB) in Register Pair HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>1AC9-1ACB</div><div><a href="#1955H" class="memory-link">CALL 1955H<span class="origrom2">CALL BLTU</span></a><span class="opcode2">CD 55 19</span></div><div>Go check to see if there is enough room in memory for the new BASIC line by GOSUB to 1955H</div></div>
									<div class="assembly-row-combined"><div>1ACC</div><div>POP HL<span class="opcode2">E1</span></div><div>Get the new end of the BASIC program pointer from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1ACD-1ACF</div><div>LD (40F9H),HL<span class="origrom2">LD (VARTAB),HL</span><span class="opcode2">22 F9 40</span></div><div>Save the new end of the BASIC program pointer in Register Pair HL.<br>Note: 40F9H-40FAH holds the starting address of the simple variable storage area</div></div>
									<div class="assembly-row-combined"><div>1AD0</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Load Register Pair HL with the address of the BASIC line</div></div>
									<div class="assembly-row-combined"><div>1AD1</div><div>LD (HL),H<span class="opcode2">74</span></div><div>Save the MSB of the address of the BASIC line in Register H</div></div>
									<div class="assembly-row-combined"><div>1AD2</div><div>POP DE<span class="opcode2">D1</span></div><div>Get the value of the BASIC line number from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1AD3</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value of the memory pointer in Register Pair HL to the STACK.  This will be the place to start to fix links</div></div>
									<div class="assembly-row-combined"><div>1AD4</div><div>INC HL<span class="opcode2">23</span></div><div>Bump
 the value of the memory pointer in Register Pair HL (which bumps it to 
the LSB of the line number entry).  This is so that the ROM doesn't 
think that this link is the end of the program</div></div>
									<div class="assembly-row-combined"><div>1AD5</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL (which bumps it to the MSB of the line number entry)</div></div>
									<div class="assembly-row-combined"><div>1AD6</div><div>LD (HL),E<span class="opcode2">73</span></div><div>Save the LSB of the BASIC line number in Register E at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1AD7</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the line number memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1AD8</div><div>LD (HL),D<span class="opcode2">72</span></div><div>Save
 the MSB of the BASIC line number in Register D at the location of the 
memory pointer in Register Pair HL.  At this point DE should have the 
binary value for the new line number</div></div>
									<div class="assembly-row-combined"><div>1AD9</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the BASIC line number in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1ADA</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Load Register Pair DE with first data byte address following the line number (held in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>1ADB-1ADD</div><div>LD HL,(40A7H)<span class="origrom2">LD HL,(BUFPNT)</span><span class="opcode2">2A A7 40</span></div><div>Load Register Pair HL with the value of the tokenized input pointer<br>Note: 40A7H-40A8H holds Input Buffer pointer</div></div>
									<div class="assembly-row-combined"><div>1ADE</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange the value of the memory pointer in Register Pair DE with the value of the tokenized input pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1ADF</div><div>DEC DE<span class="opcode2">1B</span></div><div>Decrement the value of the tokenized input buffer pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1AE0</div><div>DEC DE<span class="opcode2">1B</span></div><div>Decrement the value of the tokenized input buffer pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined" id="1AE1H"><div>1AE1<span class="origrom2">MLOOPR</span></div><div>LD A,(DE)<span class="opcode2">1A</span></div><div>Top
 of a loop to transfer the line.  Load Register A with the value at the 
location of the tokenized input buffer pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1AE2</div><div>LD (HL),A<span class="opcode2">77</span></div><div>Save the value in Register A at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1AE3</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the store address (held in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>1AE4</div><div>INC DE<span class="opcode2">13</span></div><div>Bump the fetch address (held in Register Pair DE)</div></div>
									<div class="assembly-row-combined"><div>1AE5</div><div>OR A<span class="opcode2">B7</span></div><div>Check to see if the character in Register A is an end of the line character</div></div>
									<div class="assembly-row-combined"><div>1AE6-1AE7</div><div><a href="#1AE1H" class="memory-link">JR NZ,1AE1H<span class="origrom2">JR NZ,MLOOPR</span></a><span class="opcode2">20 F9</span></div><div>Since
 a 0 will mark the end of the line, so long as NZ is set we need to keep
 looping, so loop backup until the whole of the new BASIC line has been 
stored in memory</div></div>
									<div class="assembly-row-combined" id="1AE8H"><div>1AE8<span class="origrom2">FINI</span></div><div>POP DE<span class="opcode2">D1</span></div><div>Get
 the address of the line in the program table from the STACK and put it 
in Register Pair DE.  This would be the start of link fixing area</div></div>
									<div class="assembly-row-combined"><div>1AE9-1AEB</div><div><a href="#1AFCH" class="memory-link">CALL 1AFCH<span class="origrom2">CALL CHEAD</span></a><span class="opcode2">CD FC 1A</span></div><div>Go fix/update line pointers for all lines following the new line</div></div>
									<div class="assembly-row-combined"><div>1AEC-1AEA</div><div><a href="#41B5H" class="memory-link">CALL 41B5H<span class="origrom2">CALL EXFIND</span></a><span class="opcode2">CD B5 41</span></div><div>Check to see if DOS should be handling something</div></div>
									<div class="assembly-row-combined"><div>1AEF-1AF1</div><div><a href="#1B5DH" class="memory-link">CALL 1B5DH<span class="origrom2">CALL RUNC</span></a><span class="opcode2">CD 5D 1B</span></div><div>Do a clear, set up the STACK, and update all the BASIC line pointers</div></div>
									<div class="assembly-row-combined"><div>1AF2-1AF4</div><div><a href="#1B5DH" class="memory-link">CALL 41B8H<span class="origrom2">CALL EXFIN2</span></a><span class="opcode2">CD B8 41</span></div><div>Check to see if DOS should be handling something</div></div>
									<div class="assembly-row-combined"><div>1AF5-1AF7</div><div><a href="#1A33H" class="memory-link">JP 1A33H<span class="origrom2">JP MAIN</span></a><span class="opcode2">C3 33 1A</span></div><div>Go get the input again</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1AF8H">1AF8-1B0F - LINE POINTERS ROUTINE<span class="origrom"> -  "LINKER"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine fixes the line pointers in a BASIC program. This
 is useful, for instance for a renumber program which has to move BASIC 
program lines from one location in memory to an other, which means that 
the line pointers would no longer be valid. This routine will fix them. 
Registers A, HL and DE are used.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1AF8-1AFA<span class="origrom2">LINKER</span></div><div>LD HL,(40A4H)<span class="origrom2">LD HL,(TXTTAB)</span><span class="opcode2">2A A4 40</span></div><div>Load Register Pair HL with the start of the BASIC program pointer (called the PST).<br><b>Note:</b> 40A4H-40A5H holds the starting address of BASIC program text also known as the PROGRAM STATEMENT TABLE (PST)</div></div>
									<div class="assembly-row-combined"><div>1AFB</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Move the PST address to DE</div></div>
									<p class="debug-note">A note in the original rom source code 
says that CHEAD goes through the program storage area in RAM and fixes 
up all the links.  The end of each line is found by searching for a 
zero.  The double zero link is used to detect the end of the program.</p>
									<div class="assembly-row-combined" id="1AFCH"><div>1AFC,1AFD<span class="origrom2">CHEAD</span></div><div>LD H,D<br>LD L,E<span class="opcode2">62</span></div><div>LET HL = DE</div></div>
									<div class="assembly-row-combined"><div>1AFE</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load
 Register A with the value at the location of the memory pointer in 
Register Pair HL so that we can see if we are at the end of a chain</div></div>
									<div class="assembly-row-combined"><div>1AFF</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined" id="1B00H"><div>1B00</div><div>OR (HL)<span class="opcode2">B6</span></div><div>Since
 the first 2 bytes of each line contains the address of the next line, a
 0000H would signify the end byte.  With this, check to see if the 
character at the location of the memory pointer in Register Pair HL is 
an end of the BASIC program character</div></div>
									<div class="assembly-row-combined"><div>1B01</div><div>RET Z<span class="opcode2">C8</span></div><div>Return if done</div></div>
									<p class="debug-note">If we are here, we did not get a 00 end of program, so we continue</p>
									<div class="assembly-row-combined" id="1B02H"><div>1B02</div><div>INC HL<span class="opcode2">23</span></div><div>We
 need HL to be the start of the text.  Since HL is the 'beginning of 
statment pointer', we need to skip over the 3rd and 4th bytes, so bump 
the value of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B03</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B04</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B05</div><div>XOR A<span class="opcode2">AF</span></div><div>Zero Register A and clear the flags</div></div>
									<div class="assembly-row-combined" id="1B06H"><div>1B06<span class="origrom2">CZLOOP</span></div><div>CP (HL)<span class="opcode2">BE</span></div><div>Top
 of a loop.  Check to see if the character at the location of the memory
 pointer in Register HL is an end of the BASIC line character</div></div>
									<div class="assembly-row-combined"><div>1B07</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B08-1B09</div><div><a href="#1B06H" class="memory-link">JR NZ,1B06H<span class="origrom2">JR NZ,CZLOOP</span></a><span class="opcode2">20 FC</span></div><div>Loop until the end of the BASIC line character is found</div></div>
									<div class="assembly-row-combined"><div>1B0A</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange
 the starting address of the current BASIC line in Register Pair DE with
 the starting address of the next BASIC line in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B0B</div><div>LD (HL),E<span class="opcode2">73</span></div><div>Save the LSB of the next BASIC line's starting address in Register E at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B0C</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B0D</div><div>LD (HL),D<span class="opcode2">72</span></div><div>Save the MSB of the next BASIC line's starting address in Register D at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B0E-1B0F</div><div><a href="#1AFCH" class="memory-link">JR 1AFCH<span class="origrom2">JR CHEAD</span></a><span class="opcode2">18 EC</span></div><div>Loop until the end of the program has been found</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1B10H">1B10-1B48 - EVALUATE LINE NUMBERS<span class="origrom"> -  "SCNLINE"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p> This is called by LIST and DELETE.  It converts the starting
 and ending linbers (X-Y) to binary and saves the ending line number on 
the STACK.  Then the code locates the program table address for the 
starting line.  The routine leaves the address of the starting line in 
BC and the ending line number in the STACK.<br><br> According to the 
original ROM source, SCNLIN scans a line range of the form of #-# or #- 
or -# or blank, and then finds the first line in the range.<br><br> For those looking at the original ALTAIR source code which Bill Gates released, this is found at line 30980. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1B10H"><div>1B10-1B12<span class="origrom2">SCNLIN</span></div><div>LD DE,0000H<span class="opcode2">11 00 00</span></div><div>Load Register Pair DE (which will be the list found value) with zero</div></div>
									<div class="assembly-row-combined"><div>1B13</div><div>PUSH DE<span class="opcode2">D5</span></div><div>Save the initial assumption of start-of-list to the STACK</div></div>
									<div class="assembly-row-combined"><div>1B14-1B15</div><div><a href="#1B1FH" class="memory-link">JR Z,1B1FH<span class="origrom2">JR Z,ALLLST</span></a><span class="opcode2">28 09</span></div><div>If
 we are finished (i.e., there aren't any line numbers to be evaluated), 
and the Z FLAG is therefore set, then jump to 1B1FH so list it all</div></div>
									<div class="assembly-row-combined"><div>1B16</div><div>POP DE<span class="opcode2">D1</span></div><div>Get the line number from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1B17-1B19</div><div><a href="#1E4FH" class="memory-link">CALL 1E4FH<span class="origrom2">CALL LINSPC</span></a><span class="opcode2">CD 4F 1E</span></div><div>Go
 evaluate the line number at the location of the current BASIC program 
pointer in Register Pair HL and return with the line number's binary 
value in Register Pair DE.  If there is none, a ZERO will be returned.</div></div>
									<div class="assembly-row-combined"><div>1B1A</div><div>PUSH DE<span class="opcode2">D5</span></div><div>Save the first line number's value (stored in Register Pair DE) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1B1B-1B1C</div><div><a href="#1B28H" class="memory-link">JR Z,1B28H<span class="origrom2">JR Z,SNGLIN</span></a><span class="opcode2">28 0B</span></div><div>If the Z FLAG is set, then there isn't a second line number to process (i.e, LIST 3000-), so JUMP to SNGLIN</div></div>
									<div class="assembly-row-combined"><div>1B1D-1B1E</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H">RST 08H ‚áí  CEH<span class="opcode2">CF CE</span></a></div><div>If we are here, there is a second line number.  That that would have to be preceded by a <span class="code">-</span>
 at the location of the current BASIC program pointer in Register Pair 
HL, call the COMPARE SYMBOL routine which comparess the symbol in the 
input string pointed to by HL Register to the value in the location 
following the RST 08 call.  If there is a match, control is returned to 
address of the RST 08 instruction 2 with the next symbol in in Register A
 and HL incremented by one. If the two characters do not match, a syntax
 error message is given and control returns to the Input Phase)</div></div>
									<div class="assembly-row-combined" id="1B1FH"><div>1B1F-1B21<span class="origrom2">ALLLST</span></div><div>LD DE,FFFAH<span class="opcode2">11 FA FF</span></div><div>Load
 Register Pair DE with the maximum end of range of FFAFH as the second 
line number, as FFAH is the last permitted line number.  Note: FFFFH 
means that the BASIC instruction being interpreted was entered from the 
command line instead of being part of a program</div></div>
									<div class="assembly-row-combined"><div>1B22-1B24</div><div><a href="#1E4FH" class="memory-link">CALL NZ,1E4FH<span class="origrom2">CALL NZ,LINSPC</span></a><span class="opcode2">C4 4F 1E</span></div><div>Go
 evaluate the second line number at the location of the current BASIC 
program pointer in Register Pair HL and return with the line number's 
binary value in Register Pair DE.  Will return with Z flag set if it was
 a number</div></div>
									<div class="assembly-row-combined"><div>1B25-1B27</div><div><a href="#1997H" class="memory-link">JP NZ,1997H<span class="origrom2">JP NZ,SNERR</span></a><span class="opcode2">C2 97 19</span></div><div>Go to the Level II BASIC error routine and display a ?SN ERROR message if the data which followed the token wasn't a line number</div></div>
									<div class="assembly-row-combined" id="1B28H"><div>1B28<span class="origrom2">SNGLIN</span></div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Set
 HL to be the FINAL line number by Loading Register Pair HL with the 
value of the second line number in Register Pair DE and load Register 
Pair DE with the value of the current BASIC program pointer in Register 
Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B29</div><div>POP DE<span class="opcode2">D1</span></div><div>Fetch the value of the FIRST line number from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined" id="1B2AH"><div>1B2A<span class="origrom2">FNDLN1</span></div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Exchange the return address to the STACK into HL and put the value of the second line number onto the STACK</div></div>
									<div class="assembly-row-combined"><div>1B2B</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value of the return address in Register Pair HL to the STACK so we can properly exit later</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1B2CH">1B2CH - SEARCH FOR A LINE NUMBER<span class="origrom"> -  "FNDLIN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p> According to the original ROM source, the FNDLIN routine 
searches the program text for the line whose line number is held in 
Register Pair DE.  DE is preserved.  There are three possible returns:</p><ul> <li>If there is no line in the program which is greater than the one sought, then Z/NC and HL=BC.</li> <li>If
 the line which was searched for was actually found, Z and BC=the link 
field in the line and HL=the link field in the next line.</li> <li>If 
the line was not found, but there is still more lines in the program, 
NZ/NC, BC=the line in the porgram greater than the one searched for, and
 HL = the link field in the next line.</li></ul> This routine searches a
 BASIC program for a BASIC line with a line number matching the value in
 the DE Register Pair.  	To use this routine, the required line number 
must be placed in the DE Register Pair. When a match is found, this 
routine sets the carry flag; the BC Register Pair points to the start of
 the required line, and the HL Register points to the start of the next 
line. HL, AF and BC are used.<br><br> This is the the SEARCH FOR LINE 
NUMBER routine at 1B2C, which searches the Program Statement Table (PST)
 for a BASIC statement with the line number specified in the DE Register
 Pair. All registers are used. The exit conditions are:<ul> <li>C/Z=Line Found and BC is the starting address of the line in the PST and HL is the address following;</li> <li>NC/Z=Line not found or too large and HL/BC will have the address of the next available PST location; and</li> <li>NC/
NZ=Line not found and BC=Address of the first line number greater than 
the one specified and HL will be the address of the following line.</li></ul> For those looking at the original ALTAIR source code which Bill Gates released, this is found at line 31300. <p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1B2C-1B2E<span class="origrom2">FNDLIN</span></div><div>LD HL,(40A4H)<span class="origrom2">LD HL,(TXTTAB)</span><span class="opcode2">2A A4 40</span></div><div>Load Register Pair HL with the value of the start of the BASIC program pointer.<br><b>Note:</b> 40A4H-40A5H holds the starting address of BASIC program text also known as the PROGRAM STATEMENT TABLE (PST)</div></div>
									<div class="assembly-row-combined" id="1B2FH"><div>1B2F,1B30<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;LOOP</span></div><div>LD B,H<br>LD C,L<span class="opcode2">44</span></div><div>LET
 BC = HL so that BC will also hold the address of the current line in 
the PST.  The original ALTAIR source code says that this will also set 
BC to "00" if exiting because we hit the end of the program in this 
loop.</div></div>
									<div class="assembly-row-combined"><div>1B31</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load Register A with the first byte of the word pointer (held in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>1B32</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL to the MSB of the address of the next line</div></div>
									<div class="assembly-row-combined"><div>1B33</div><div>OR (HL)<span class="opcode2">B6</span></div><div>Combine
 the first byte of the word pointer with the second byte of the word 
pointer with the result in Register A and set the status flags</div></div>
									<div class="assembly-row-combined"><div>1B34</div><div>DEC HL<span class="opcode2">2B</span></div><div>Restore HL to the start of the current line</div></div>
									<div class="assembly-row-combined"><div>1B35</div><div>RET Z<span class="opcode2">C8</span></div><div>If the Z FLAG is set, then we are done with this program (i.e., the end of PST or the end of the BASIC program)</div></div>
									<div class="assembly-row-combined"><div>1B36</div><div>INC HL<span class="opcode2">23</span></div><div>It's
 not the end so we need HL to point the line number for the current line
 which means it must advance by 2.  Bump the value of the memory pointer
 in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B37</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B38</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load Register A with the LSB of the current BASIC line number at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B39</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL to point to the MSB of the current BASIC line number</div></div>
									<div class="assembly-row-combined"><div>1B3A</div><div>LD H,(HL)<span class="opcode2">66</span></div><div>Load Register H with the MSB of the current BASIC line number at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B3B</div><div>LD L,A<span class="opcode2">6F</span></div><div>Load Register L with the LSB of the current BASIC line number in Register A.  HL should now hold the line number in the PST</div></div>
									<div class="assembly-row-combined"><div>1B3C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H">RST 18H<span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now
 we need to compare the value of the current BASIC line number in HL and
 the first line number (in DE), so we call the COMPARE DE:HL routine, 
which numerically compares DE and HL. Will not work for signed integers 
(except positive ones). Uses the A-register only. The result of the 
comparison is returned in the status Register as:  <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>1B3D</div><div>LD H,B<span class="opcode2">60</span></div><div>Next we need to set HL to the start of the line before the current one, and that is held in BC</div></div>
									<div class="assembly-row-combined"><div>1B3E</div><div>LD L,C<span class="opcode2">69</span></div><div>Load Register L with the LSB of the memory pointer in Register C</div></div>
									<div class="assembly-row-combined"><div>1B3F</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load Register A with the value at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B40</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B41</div><div>LD H,(HL)<span class="opcode2">66</span></div><div>Load Register H with the MSB of the next BASIC line pointer at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B42</div><div>LD L,A<span class="opcode2">6F</span></div><div>Load Register L with the LSB of the next BASIC line pointer in Register A to form the address of the next line in HL</div></div>
									<div class="assembly-row-combined"><div>1B43</div><div>CCF<span class="opcode2">3F</span></div><div>Complement
 the value of the Carry flag.  The carry will be set if the current line
 number is &lt; the value in DE.  This will clear the Carry flag. </div></div>
									<div class="assembly-row-combined"><div>1B44</div><div>RET Z<span class="opcode2">C8</span></div><div>Return
 if the first line number in Register Pair DE is the same as the current
 BASIC line number.  The line numbers match, so exit C, Z, BC=address of
 the current line, and HL=address of the next line</div></div>
									<div class="assembly-row-combined" id="1B45H"><div>1B45</div><div>CCF<span class="opcode2">3F</span></div><div>We have no match, so complement (reverse) the Carry flag and exit </div></div>
									<div class="assembly-row-combined"><div>1B46</div><div>RET NC<span class="opcode2">D0</span></div><div>if
 the first line number in Register Pair DE is less than the current 
BASIC line number.  BC will be the address of the current line and HL 
will be the address of the next line</div></div>
									<div class="assembly-row-combined"><div>1B47-1B48</div><div><a href="#1B2FH" class="memory-link">JR 1B2FH<span class="origrom2">JR LOOP</span></a><span class="opcode2">18 E6</span></div><div>Loop until the location of the line number has been found in the BASIC program</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1B49H">1B49-1B5C - LEVEL II BASIC <span class="code">NEW</span> ROUTINE<span class="origrom"> - "SCRATH"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p> This is line 321000 in the original ALTAIR BASIC source code<br><br>
 The NEW command turns off the TRACE, resets the AUTO command, zeroes 
out the pointers to the program storage area, and sets the new variable 
storage area. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1B49<span class="origrom2">SCRATH</span></div><div>RET NZ<span class="opcode2">C0</span></div><div>Go to the Level II BASIC error routine and display a <span class="code">?SN ERROR</span> message if there is any input following the <span class="code">NEW</span> token</div></div>
									<div class="assembly-row-combined"><div>1B4A-1B4C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#01C9H">CALL 01C9H<span class="origrom2">CALL CLS</span></a><span class="opcode2">CD C9 01</span></div><div>Call the CLEAR SCREEN routine at 01C9 (which cleanrts the screen, changes to 64 characters, and homes the screen)</div></div>
									<div class="assembly-row-combined" id="1B4DH"><div>1B4D-1B4F<span class="origrom2">SCRTCH</span></div><div>LD HL,(40A4H)<span class="origrom2">LD HL,(TXTTAB)</span><span class="opcode2">2A A4 40</span></div><div>Load Register Pair HL with the start of the PST (the start of the BASIC program).<br><b>Note:</b> 40A4H-40A5H holds the starting address of BASIC program text also known as the PROGRAM STATEMENT TABLE (PST)</div></div>
									<div class="assembly-row-combined"><div>1B50-1B52</div><div><a href="#1DF8H" class="memory-link">CALL 1DF8H<span class="origrom2">CALL TOFF</span></a><span class="opcode2">CD F8 1D</span></div><div>GOSUB to the <span class="code">TROFF</span> routine at 1DF8H (which just loads A with a zero for <span class="code">TROFF</span>, and puts that 0 into 411BH)</div></div>
									<div class="assembly-row-combined"><div>1B53-1B55</div><div>LD (40E1H),A<span class="origrom2">LD (AUTFLG),A</span><span class="opcode2">32 E1 40</span></div><div>Reset the <span class="code">AUTO</span> flag by putting a zero (which is in A due to the GOSUB to the <span class="code">TROFF</span> statement in the above instruction) into 40E1H</div></div>
									<div class="assembly-row-combined"><div>1B56</div><div>LD (HL),A<span class="opcode2">77</span></div><div>We
 need to initialize the PST, and the way to do that is to zero the first
 two bytes so . save a zero at the location of the memory pointer in 
Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B57</div><div>INC HL<span class="opcode2">23</span></div><div>. bump the value of the memory pointer in Register Pair HL </div></div>
									<div class="assembly-row-combined"><div>1B58</div><div>LD (HL),A<span class="opcode2">77</span></div><div>. and save a zero at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B59</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B5A-1B5C</div><div>LD (40F9H),HL<span class="origrom2">LD (VARTAB),HL</span><span class="opcode2">22 F9 40</span></div><div>Save the value in Register Pair HL at 40F9H to initialize the start of the variable list table as the end of the PST.<br>Note: 40F9H-40FAH holds the starting address of the simple variable storage area</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1B5DH">1B5D-1BB2 - LEVEL II BASIC <span class="code">RUN</span> ROUTINE <span class="origrom"> - "RUNC"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p> This routine does a lot of variable resets and other things that are common to <span class="code">NEW</span> as well, so <span class="code">NEW</span> just does the special <span class="code">NEW</span> stuff and than passes right through to here to reset the rest.<br><br> To use a ROM call to RUN a BASIC program, starting with its first line, execute the following instructions:<br>&nbsp;&nbsp;&nbsp;LD HL,1D1EH<br>&nbsp;&nbsp;&nbsp;PUSH HL<br><a href="#1B5DH" class="memory-link">&nbsp;&nbsp;&nbsp;JP 1B5DH</a>. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1B5DH"><div>1B5D-1B5F<span class="origrom2">RUNC</span></div><div>LD HL,(40A4H)<span class="origrom2">LD HL,(TXTTAB)</span><span class="opcode2">2A A4 40</span></div><div>Load Register Pair HL with the PST (the start of the BASIC program pointer).<br><b>Note:</b> 40A4H-40A5H holds the starting address of BASIC program text also known as the PROGRAM STATEMENT TABLE (PST)</div></div>
									<div class="assembly-row-combined"><div>1B60</div><div>DEC HL<span class="opcode2">2B</span></div><div>Decrement the value in Register Pair HL to backspace</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1B61H">1B61H - Subroutine which initializes a lot of stuff<span class="origrom"> - "CLEARC"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Initialize he variable and array space by resetting ARYTAB 
(which is the end of the the simple variable spac) and STREND (which is 
the end of the array storage).  It then falls into STKINI which resets 
the STACK.  HL is preserved.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1B61-1B63<span class="origrom2">CLEARC</span></div><div>LD (40DFH),HL<span class="origrom2">LD (TEMP),HL</span><span class="opcode2">22 DF 40</span></div><div>Save the adjusted value in Register Pair HL into 40DFH.<br>Note: 40DFH-40E0H is used by DOS</div></div>
									<div class="assembly-row-combined"><div>1B64-1B65</div><div>LD B,1AH<span class="opcode2">06 1A</span></div><div>Load Register B with the number of variable names to be initialized (which is 26)</div></div>
									<div class="assembly-row-combined"><div>1B66-1B68</div><div>LD HL,4101H<span class="origrom2">LD HL,DEFTBL</span><span class="opcode2">21 01 41</span></div><div>Load Register Pair HL with the starting address of the variable declaration table (which is 4101H).<br>Note: 4101H-411AH holds Variable Declaration Table</div></div>
									<div class="assembly-row-combined" id="1B69H"><div>1B69-1B6A<span class="origrom2">LOPDFT</span></div><div>LD (HL),04H<span class="opcode2">36 04</span></div><div>Top of a DJNZ loop.  Set the variable at the location of the memory pointer in Register Pair HL to a single precision variable</div></div>
									<div class="assembly-row-combined"><div>1B6B</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL to the next variable</div></div>
									<div class="assembly-row-combined"><div>1B6C-1B6D</div><div><a href="#1B69H" class="memory-link">DJNZ 1B69H<span class="origrom2">DJNZ LOPDFT</span></a><span class="opcode2">10 FB</span></div><div>Loop until all 26 variables have been set to single precision</div></div>
									<div class="assembly-row-combined"><div>1B6E</div><div>XOR A<span class="opcode2">AF</span></div><div>Zero Register A</div></div>
									<div class="assembly-row-combined"><div>1B6F-1B71</div><div>LD (40F2H),A<span class="origrom2">LD (ONEFLG),A</span><span class="opcode2">32 F2 40</span></div><div>Save the value in Register A (which is a zero) as the current value of the <span class="code">RESUME</span> flag to say that there is no error for <span class="code">RESUME</span> to handle.<br>Note: 40F2H holds Error flag</div></div>
									<div class="assembly-row-combined"><div>1B72</div><div>LD L,A<span class="opcode2">6F</span></div><div>Zero Register L</div></div>
									<div class="assembly-row-combined"><div>1B73</div><div>LD H,A<span class="opcode2">67</span></div><div>Zero Register H</div></div>
									<div class="assembly-row-combined"><div>1B74-1B76</div><div>LD (40F0H),HL<span class="origrom2">LD (ONELIN),HL</span><span class="opcode2">22 F0 40</span></div><div>Save a zero (held in Register Pair HL) as the current <span class="code">ON ERROR</span> address.<br>Note: 40F0H-40F1H is used by <span class="code">ON ERROR</span></div></div>
									<div class="assembly-row-combined"><div>1B77-1B79</div><div>LD (40F7H),HL<span class="origrom2">LD (OLDTXT),HL</span><span class="opcode2">22 F7 40</span></div><div>Save a zero (held in Register Pair HL) as the current <kbd>BREAK</kbd> , <span class="code">STOP</span>, or <span class="code">END</span> address.<br>Note: 40F7H-40F8H holds Last byte executed</div></div>
									<div class="assembly-row-combined"><div>1B7A-1B7C</div><div>LD HL,(40B1H)<span class="origrom2">LD HL,(MEMSIZ)</span><span class="opcode2">2A B1 40</span></div><div>Load Register Pair HL with the top of the memory pointer held in 40B1H.<br>Note: 40B1H-40B2H holds MEMORY SIZE? pointer</div></div>
									<div class="assembly-row-combined"><div>1B7D-1B7F</div><div>LD (40D6H),HL<span class="origrom2">LD (FRETOP),HL</span><span class="opcode2">22 D6 40</span></div><div>Save the top of memory pointer (held in Register Pair HL) as the next available address in the string space pointer.<br>Note: 40D6H-40D7H holds the next available location in string space pointer</div></div>
									<div class="assembly-row-combined"><div>1B80-1B82</div><div><a href="#1D91H" class="memory-link">CALL 1D91H<span class="origrom2">CALL RESTORE</span></a><span class="opcode2">CD 91 1D</span></div><div>Go do a <span class="code">RESTORE</span> (which will mess with DE and HL)</div></div>
									<div class="assembly-row-combined"><div>1B83-1B85</div><div>LD HL,(40F9H)<span class="origrom2">LD HL,(VARTAB)</span><span class="opcode2">2A F9 40</span></div><div>Load Register Pair HL with the end of the BASIC program pointer.<br>Note: 40F9H-40FAH holds the starting address of the simple variable storage area</div></div>
									<div class="assembly-row-combined"><div>1B86-1B88</div><div>LD (40FBH),HL<span class="origrom2">LD (ARYTAB),HL</span><span class="opcode2">22 FB 40</span></div><div>Save
 the value in Register Pair HL as the new simple variables pointer.  
40FBH-40FCH holds the starting address of the BASIC array variable 
storage area</div></div>
									<div class="assembly-row-combined"><div>1B89-1B8B</div><div>LD (40FDH),HL<span class="origrom2">LD (STREND),HL</span><span class="opcode2">22 FD 40</span></div><div>Save the value in Register Pair HL as the new array variables pointer.<br>Note: 40FDH-40FEH holds Free memory pointer</div></div>
									<div class="assembly-row-combined"><div>1B80-1B82</div><div><a href="#1D91H" class="memory-link">CALL 1D91H<span class="origrom2">CALL RESTORE</span></a><span class="opcode2">CD 91 1D</span></div><div>Go do a <span class="code">RESTORE</span> (which will mess with DE and HL)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1B8FH">1B8F - Subroutine which initializes a lot of stuff<span class="origrom"> - "STKINI"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the notes in the original ROM source code, this 
routine resets the STACK point, which will also destroy all GOSUBs and 
FORs.  String temporaries are freed, SUBFLG is reset, CONT is forbidden,
 and a dummy entry is put on the STACK, so that FNDFOR will always find a
 NON-"FOR" entry at the bottom of the STACK.  A will be reset to 0 and 
Register Pair DE is preserved.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1B8FH"><div>1B8F<span class="origrom2">STKINI</span></div><div>POP BC<span class="opcode2">C1</span></div><div>Get the return address from the STACK because we are about to change the STACK pointer</div></div>
									<div class="assembly-row-combined"><div>1B90-1B92</div><div>LD HL,(40A0H)<span class="origrom2">LD HL,(STKTOP)</span><span class="opcode2">2A A0 40</span></div><div>Load
 Register Pair HL with the start of string space pointer (which is also 
the end of RAM).  40A0H-40A1H holds the start of string space pointer</div></div>
									<div class="assembly-row-combined"><div>1B93</div><div>DEC HL<span class="opcode2">2B</span></div><div>Decrement the value of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B94</div><div>DEC HL<span class="opcode2">2B</span></div><div>Decrement
 the value of the memory pointer in Register Pair HL (so now HL has the 
start of the string space pointer - 2) so that there is now room for a 
FNDFOR stopper value to be put on the STACK</div></div>
									<div class="assembly-row-combined"><div>1B95-1B97</div><div>LD (40E8H),HL<span class="origrom2">LD (SAVSTK),HL</span><span class="opcode2">22 E8 40</span></div><div>Save the string space pointer - 2 (in Register Pair HL) as the STACK pointer<br>Note: 40E8H-40E9H holds STACK pointer pointer</div></div>
									<div class="assembly-row-combined"><div>1B98</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1B99</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL so it is back to being the start of the string space pointer</div></div>
									<div class="assembly-row-combined" id="1B9AH"><div>1B9A<span class="origrom2">STKERR</span></div><div>LD SP,HL<span class="opcode2">F9</span></div><div>Initialize the STACK by loading the STACK pointer with the start of the string space pointer (held in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>1B9B-1B9D</div><div>LD HL,40B5H<span class="origrom2">LD HL,TEMPST</span><span class="opcode2">21 B5 40</span></div><div>Load Register Pair HL with the start of the string work area (which is 40B5H).<br>Note: 40B5H-40D2H holds Temporary string work area</div></div>
									<div class="assembly-row-combined"><div>1B9E-1BA0</div><div>LD (40B3H),HL<span class="origrom2">LD (TEMPPT),HL</span><span class="opcode2">22 B3 40</span></div><div>Initialize
 the string temporaries by saving the value in Register Pair HL as the 
next available location in the string work area pointer.<br>Note: 40B3H-40B4H holds the next available location in the temporary string work area pointer</div></div>
									<div class="assembly-row-combined"><div>1BA1-1BA3</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#038BH">CALL 038BH<span class="origrom2">CALL FINLPT</span></a><span class="opcode2">CD 8B 03</span></div><div>GOSUB 038BH to set the current output device to the video display</div></div>
									<div class="assembly-row-combined"><div>1BA4-1BA6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2169H">CALL 2169H<span class="origrom2">CALL FINPRT</span></a><span class="opcode2">CD 69 21</span></div><div>Go turn off the cassette recorder</div></div>
									<div class="assembly-row-combined"><div>1BA7</div><div>XOR A<span class="opcode2">AF</span></div><div>Zero Register A</div></div>
									<div class="assembly-row-combined"><div>1BA8</div><div>LD H,A<span class="opcode2">67</span></div><div>Zero Register H</div></div>
									<div class="assembly-row-combined"><div>1BA9</div><div>LD L,A<span class="opcode2">6F</span></div><div>Zero Register L</div></div>
									<div class="assembly-row-combined"><div>1BAA-1BAC<span class="origrom2">WASDIR</span></div><div>LD (40DCH),A<span class="origrom2">LD (SUBFLG),A</span><span class="opcode2">32 DC 40</span></div><div>Clear the <span class="code">FOR</span> statement flag.<br>Note: 40DCH holds FOR flag</div></div>
									<div class="assembly-row-combined"><div>1BAD</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value in Register Pair HL to the STACK to deal with FOR and GOSUB</div></div>
									<div class="assembly-row-combined"><div>1BAE</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the value in Register Pair BC (which is the RETURN ADDRESS) back on the STACK</div></div>
									<div class="assembly-row-combined"><div>1BAF-1BB1<span class="origrom2">GTMPRT</span></div><div>LD HL,(40DFH)<span class="origrom2">LD HL,(TEMP)</span><span class="opcode2">2A DF 40</span></div><div>Restore Register Pair HL so it is preserved</div></div>
									<div class="assembly-row-combined"><div>1BB2</div><div>RET<span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1BB3H">1BB3-1BBF - KEYBOARD INPUT ROUTINE<span class="origrom"> - "QINLIN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the last of the general purpose input routines. This 
routine functions identically to the 0361H routine with the exception 
that it prints a <span class="code">?</span> on the screen (like INPUT does with BASIC) before allowing input from the keyboard.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1BB3H"><div>1BB3-1BB4<span class="origrom2">QINLIN</span></div><div>LD A,3FH<span class="origrom2">LD A,"?"</span><span class="opcode2">3E 3F</span></div><div>Load Register A with a <span class="code">?</span></div></div>
									<div class="assembly-row-combined"><div>1BB5-1BB7</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH">CALL 032AH<span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go display the <span class="code">?</span> (stored in Register A) on the video display</div></div>
									<div class="assembly-row-combined"><div>1BB8-1BB9</div><div>LD A,20H<span class="opcode2">3E 20</span></div><div>Load Register A with a <span class="code">SPACE</span></div></div>
									<div class="assembly-row-combined"><div>1BBA-1BBC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH">CALL 032AH<span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go display the space in Register A on the video display</div></div>
									<div class="assembly-row-combined"><div>1BBD-1BBF</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0361H">JP 0361H<span class="origrom2">JP INLIN</span></a><span class="opcode2">C3 61 03</span></div><div>Jump to the keyboard input routine at 0361H.  Note that this skips the "CRUNCHING" of tokens</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1BC0H">1BC0-1C8F - TOKENIZE INPUT ROUTINE<span class="origrom"> - "CRUNCH"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The original ROM source code says that this routine 
translates all "reserved words" into single bytes with the MSB on.  This
 saves space and time by allowing for table dispatch during execution, 
and, as such, all statements appear together in the ; reserved word list
 in the same ; order they appear in in STMDSP.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1BC0<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;CRUNCH</span></div><div>XOR A<span class="opcode2">AF</span></div><div>Zero Register A</div></div>
									<div class="assembly-row-combined"><div>1BC1-1BC3</div><div>LD (40B0H),A<span class="origrom2">LD (DORES),A</span><span class="opcode2">32 B0 40</span></div><div>Save the value in Register A as the current value of the tokenization flag.<br>Note: 40B0H holds the temporary storage location</div></div>
									<div class="assembly-row-combined"><div>1BC4</div><div>LD C,A<span class="opcode2">4F</span></div><div>Zero Register C</div></div>
									<div class="assembly-row-combined"><div>1BC5</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Load Register Pair DE with the address of the first character after the line number (as stored in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>1BC6-1BC8</div><div>LD HL,(40A7H)<span class="origrom2">LD HL,(BUFPNT)</span><span class="opcode2">2A A7 40</span></div><div>Load Register Pair HL with the starting address of the input buffer.<br>Note: 40A7H-40A8H holds Input Buffer pointer</div></div>
									<div class="assembly-row-combined"><div>1BC9</div><div>DEC HL<span class="opcode2">2B</span></div><div>We need to backspace twice so ... decrement the value of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1BCA</div><div>DEC HL<span class="opcode2">2B</span></div><div>... and again decrement the value of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1BCB</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange the string address - 2 from HL into DE, and the current input string address from DE into HL</div></div>

									<div class="assembly-row-combined" id="1BCCH"><div>1BCC<span class="origrom2">KLOOP</span></div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load Register A with the character at the current location in the buffer (in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>1BCD-1BCE</div><div>CP 20H<span class="opcode2">FE 20</span></div><div>Check to see if that character in Register A is a <span class="code">SPACE</span> that we would want to keep</div></div>
									<div class="assembly-row-combined"><div>1BCF-1BD1</div><div><a href="#1C5BH" class="memory-link">JP Z,1C5BH<span class="origrom2">JP Z,STUFFH</span></a><span class="opcode2">CA 5B 1C</span></div><div>If that character is a <span class="code">SPACE</span> we would want to keep, Jump to 1C5BH to "STUFF" it into the destination line</div></div>
									<div class="assembly-row-combined"><div>1BD2</div><div>LD B,A<span class="opcode2">47</span></div><div>Copy the current character into Register B</div></div>
									<div class="assembly-row-combined"><div>1BD3-1BD4</div><div>CP 22H<span class="opcode2">FE 22</span></div><div>Check to see if the current character is a <span class="code">"</span></div></div>
									<div class="assembly-row-combined"><div>1BD5-1BD7</div><div><a href="#1C77H" class="memory-link">JP Z,1C77H<span class="origrom2">JP Z,STRNG</span></a><span class="opcode2">CA 77 1C</span></div><div>If the current character is a <span class="code">"</span>, Jump to 1C77H to will move the entire field between the quotes into the a code string</div></div>
									<div class="assembly-row-combined"><div>1BD8</div><div>OR A<span class="opcode2">B7</span></div><div>Now we want to check to see if the current character is an END OF LINE, so we need to set up the status flags</div></div>
									<div class="assembly-row-combined"><div>1BD9-1BDB</div><div><a href="#1C7DH" class="memory-link">JP Z,1C7DH<span class="origrom2">JP Z,CRDONE</span></a><span class="opcode2">CA 7D 1C</span></div><div>If the current character is an END OF LINE then we are done, so jump to 1C7DH</div></div>
									<div class="assembly-row-combined"><div>1BDC-1BDE</div><div>LD A,(40B0H)<span class="origrom2">LD A,(DORES)</span><span class="opcode2">3A B0 40</span></div><div>Load Register A with the value of the tokenization flag for <span class="code">DATA</span>.<br>Note: 40B0H holds the temporary storage location</div></div>
									<div class="assembly-row-combined"><div>1BDF</div><div>OR A<span class="opcode2">B7</span></div><div>Check to see if a DATA statement is being processed</div></div>
									<div class="assembly-row-combined"><div>1BE0</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Re-
fetch the current character (from the memory location of the input 
buffer pointer in Register Pair HL) and put it into Register A</div></div>
									<div class="assembly-row-combined"><div>1BE1-1BE3</div><div><a href="#1C5BH" class="memory-link">JP NZ,1C5BH<span class="origrom2">JP NZ,STUFFH</span></a><span class="opcode2">C2 5B 1C</span></div><div>Jump to 1C5BH if a <span class="code">DATA</span> statement is being processed, as we don't want to crunch that</div></div>
									<div class="assembly-row-combined"><div>1BE4-1BE5</div><div>CP 3FH<span class="opcode2">FE 3F</span></div><div>Check to see if the character in Register A is a <span class="code">?</span> (meaning a <span class="code">PRINT</span> statement)</div></div>
									<div class="assembly-row-combined"><div>1BE6-1BE7</div><div>LD A,B2H<span class="origrom2">LD A,$PRINT</span><span class="opcode2">3E B2</span></div><div>Load Register A with a <span class="code">PRINT</span> token</div></div>
									<div class="assembly-row-combined"><div>1BE8-1BEA</div><div><a href="#1C5BH" class="memory-link">JP Z,1C5BH<span class="origrom2">JP Z,STUFFH</span></a><span class="opcode2">CA 5B 1C</span></div><div>If we have a <span class="code">?</span> then make believe it is a "PRINT" token, and jump to 1C5BH to STUFF it into the destination line</div></div>
									<div class="assembly-row-combined"><div>1BEB</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Re-
fetch the current character (from the memory location of the input 
buffer pointer in Register Pair HL) and put it into Register A</div></div>
									<div class="assembly-row-combined"><div>1BEC-1BED</div><div>CP 30H<span class="opcode2">FE 30</span></div><div>Since
 the crunching routine is slow, these next instructions look for 
characters that will not need crunching.  First, check to see if the 
character in Register A is less than a zero character (alpha numeric)</div></div>
									<div class="assembly-row-combined"><div>1BEE-1BEF</div><div><a href="#1BF5H" class="memory-link">JR C,1BF5H<span class="origrom2">JR C,MUSTCR</span></a><span class="opcode2">38 05</span></div><div>Jump to 1BF5H if the character in Register A is less than a zero character, meaning it is not a digit or letter</div></div>
									<div class="assembly-row-combined"><div>1BF0-1BF1</div><div>CP 3CH<span class="opcode2">FE 3C</span></div><div>Next, check to see if the character in Register A is less than &lt; character (which is a test to see if it is <span class="code">0</span>-<span class="code">9</span>, <span class="code">:</span>, <span class="code">;</span>, <span class="code">&lt;</span>, constant or special character</div></div>
									<div class="assembly-row-combined"><div>1BF2-1BF4</div><div><a href="#1C5BH" class="memory-link">JP C,1C5BH<span class="origrom2">JP C,STUFFH</span></a><span class="opcode2">DA 5B 1C</span></div><div>Jump to 1C5BH if the character in Register A is <span class="code">0</span>-<span class="code">9</span>, <span class="code">:</span>, <span class="code">;</span>, <span class="code">&lt;</span>, constant or special character</div></div>

									<div class="assembly-row-combined" id="1BF5H"><div>1BF5<span class="origrom2">MUSTCR</span></div><div>PUSH DE<span class="opcode2">D5</span></div><div>Save the value of the input buffer pointer in Register Pair DE to the STACK</div></div>
									<div class="assembly-row-combined"><div>1BF6-1BF8</div><div>LD DE,164FH<span class="origrom2">LD D,RESLST-1</span><span class="opcode2">11 4F 16</span></div><div>Load
 Register Pair DE with the starting address of the reserved words list, 
minus 1 (since the first instruction in the LOPSKP routine is to INC the
 value)</div></div>
									<div class="assembly-row-combined"><div>1BF9</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the character count (held in Register Pair BC) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1BFA-1BFC</div><div>LD BC,1C3DH<span class="origrom2">LD BC,NOTRES</span><span class="opcode2">01 3D 1C</span></div><div>Load Register Pair BC with a return address after matching the reserved word list</div></div>
									<div class="assembly-row-combined"><div>1BFD</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the return address in Register Pair BC to the STACK </div></div>
									<div class="assembly-row-combined"><div>1BFE-1BFF</div><div>LD B,7FH<span class="opcode2">06 7F</span></div><div>Load Register B with a value to initialize the reserved words counter</div></div>
									<div class="assembly-row-combined" id="1C00H"><div>1C00</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1C01-1C02</div><div>CP 61H<span class="origrom2">CP "A"+20H</span><span class="opcode2">FE 61</span></div><div>Check to see if the character in Register A is lower-case</div></div>
									<div class="assembly-row-combined"><div>1C03-1C04</div><div><a href="#1C0CH" class="memory-link">JR C,1C0CH<span class="origrom2">JR C,TRYAGA</span></a><span class="opcode2">38 07</span></div><div>Jump to 1C0CH if the character in Register A isn't lowercase</div></div>
									<div class="assembly-row-combined"><div>1C05-1C06</div><div>CP 7BH<span class="origrom2">CP "Z"+21H</span><span class="opcode2">FE 7B</span></div><div>Check to see if the character in Register A is within the lower-case range</div></div>
									<div class="assembly-row-combined"><div>1C07-1C08</div><div><a href="#1C0CH" class="memory-link">JR NC,1C0CH<span class="origrom2">JR NC,TRYAGA</span></a><span class="opcode2">30 03</span></div><div>Jump down 2 instructions to 1C0CH if the character in Register A isn't lowercase</div></div>
									<div class="assembly-row-combined"><div>1C09-1C0A</div><div>AND 5FH<span class="origrom2">AND 0101 1111</span><span class="opcode2">E6 5F</span></div><div>Covert the lowercase character in Register A to upper-case</div></div>
									<div class="assembly-row-combined"><div>1C0B</div><div>LD (HL),A<span class="opcode2">77</span></div><div>Replace the current character in the input buffer (tracked by Register Pair HL) with the adjusted character (held in Register A)</div></div>

									<div class="assembly-row-combined" id="1C0CH"><div>1C0C<span class="origrom2">TRYAGA</span></div><div>LD C,(HL)<span class="opcode2">4E</span></div><div>Load Register C with the character at the location of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1C0D</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange
 DE and HL so that DE will now hold the input buffer pointer (TXTPTR) 
and HL will hold the reserved words list pointer ("RESLST")</div></div>

									<div class="assembly-row-combined" id="1C0EH"><div>1C0E<span class="origrom2">LOPSKP</span></div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the reserved words list pointer to the next reserved word and put that in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1C0F</div><div>OR (HL)<span class="opcode2">B6</span></div><div>We
 need to find the start of a reserved word which is done by searching 
the list for a character with its MSB bit on.  So first, check to see if
 bit 7 of the character at the location of the reserved words list 
pointer in Register Pair HL is set</div></div>
									<div class="assembly-row-combined"><div>1C10-1C12</div><div><a href="#1C0EH" class="memory-link">JP P,1C0EH<span class="origrom2">JP P,LOPSKP</span></a><span class="opcode2">F2 0E 1C</span></div><div>Jump to 1C0EH if the character at the location of the reserved words list pointer in Register Pair HL doesn't have bit 7 set</div></div>
									<p class="debug-note">If we are here, the the character in the reserved word list had its MSB on, and is a reserved word.</p>
									<div class="assembly-row-combined"><div>1C13</div><div>INC B<span class="opcode2">04</span></div><div>Bump the reserved words counter being tracked in Register B</div></div>
									<div class="assembly-row-combined"><div>1C14</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the reserved words list pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1C15-1C16</div><div>AND 7FH<span class="origrom2">AND 0111 1111</span><span class="opcode2">E6 7F</span></div><div>Reset the MSB (i.e., Bit 7 aka the Sign Bit) of the character in Register A</div></div>
									<div class="assembly-row-combined"><div>1C17</div><div>RET Z<span class="opcode2">C8</span></div><div>If that set the Z FLAG then we are at the end of ther reserved word list, so, if so RETurn to CALLer</div></div>
									<div class="assembly-row-combined"><div>1C18</div><div>CP C<span class="opcode2">B9</span></div><div>Check
 to see if the character in Register C is the same as the character at 
the location of the reserved words list pointer in Register A</div></div>
									<div class="assembly-row-combined"><div>1C19-1C1A</div><div><a href="#1C0EH" class="memory-link">JR NZ,1C0EH<span class="origrom2">JR NZ,LOPSKP</span></a><span class="opcode2">20 F3</span></div><div>Jump to 1C0EH if the characters don't match</div></div>
									<div class="assembly-row-combined"><div>1C1B</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange
 the value of the reserved words list pointer ("RESLST") in Register 
Pair HL with the value of the input buffer pointer ("TXTPTR") in 
Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1C1C</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value of the input buffer pointer to the STACK in case it turns out that this isn't a match after all</div></div>
									<div class="assembly-row-combined" id="1C1DH"><div>1C1D<span class="origrom2">LOPPSI</span></div><div>INC DE<span class="opcode2">13</span></div><div>Top
 of a loop.  Bump the value of the reserved words list pointer (held in 
Register Pair DE) to the next character of the reserved word being 
checked</div></div>
									<div class="assembly-row-combined"><div>1C1E</div><div>LD A,(DE)<span class="opcode2">1A</span></div><div>Load Register A with the character at the location of the reserved words list pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1C1F</div><div>OR A<span class="opcode2">B7</span></div><div>Check to see if Bit 7 of the character in Register A is set, meaning we just hit a different reserved word</div></div>
									<div class="assembly-row-combined"><div>1C20-1C22</div><div><a href="#1C39H" class="memory-link">JP M,1C39H<span class="origrom2">JP M,FOUND</span></a><span class="opcode2">FA 39 1C</span></div><div>If Bit 7 of that character was set, and we are at a new reserved word, then we have finished matching, so jump to 1C39H</div></div>
									<p class="debug-note">If we are here then we are in the middle 
of checking against the reserved word list, and we are still in the 
middle of a reserved word that might be a potential match.</p>
									<div class="assembly-row-combined"><div>1C23</div><div>LD C,A<span class="opcode2">4F</span></div><div>Load Register C with the current reserved word list character (held in Register A)</div></div>
									<div class="assembly-row-combined"><div>1C24</div><div>LD A,B<span class="opcode2">78</span></div><div>Load Register A with the value of the reserved words counter in Register B</div></div>
									<p class="debug-note">The <span class="code">GOTO</span> reserved word is the only one which allows for spaces to be inside it, so . if we find that we have <span class="code">GO</span> so far, we will call the RST 10H to strip out any intevening spaces before continuing.</p>
									<div class="assembly-row-combined"><div>1C25-1C26</div><div>CP 8DH<span class="origrom2">CP $GOTO</span><span class="opcode2">FE 8D</span></div><div>Check to see if the current reserved word being checked is <span class="code">GOTO</span></div></div>
									<div class="assembly-row-combined"><div>1C27-1C28</div><div><a href="#1C2BH" class="memory-link">JR NZ,1C2BH<span class="origrom2">JR NZ,NTGOTO</span></a><span class="opcode2">20 02</span></div><div>Skip the next 2 instructions if the current reserved word being checked isn't <span class="code">GOTO</span></div></div>
									<div class="assembly-row-combined"><div>1C29</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H">RST 10H<span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>Since
 we need to skip spaces we need to bump the current input buffer pointer
 in Register Pair HL until it points to the next character, call the 
EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The RST 10H routine 
parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>1C2A</div><div>DEC HL<span class="opcode2">2B</span></div><div>Decrement the value of the input buffer pointer in Register Pair HL because the next instruction increments it</div></div>

									<div class="assembly-row-combined" id="1C2BH"><div>1C2B<span class="origrom2">NTGOTO</span></div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the input buffer pointer in Register Pair HL to point to the next character</div></div>
									<div class="assembly-row-combined"><div>1C2C</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load Register A with the next character at the location of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1C2D-1C2E</div><div>CP 61H<span class="origrom2">CP "A"+20H</span><span class="opcode2">FE 61</span></div><div>Check to see if the character in Register A is lower-case</div></div>
									<div class="assembly-row-combined"><div>1C2F-1C30</div><div><a href="#1C33H" class="memory-link">JR C,1C33H<span class="origrom2">JR C,NOTLW1</span></a><span class="opcode2">38 02</span></div><div>If the character in Register A isn't lowercase, skip the next instruction</div></div>
									<div class="assembly-row-combined"><div>1C31-1C32</div><div>AND 5FH<span class="origrom2">AND 0101 1111</span><span class="opcode2">E6 5F</span></div><div>AND the character in Register A against 0101 1111 to get rid of the lowercase bit and make it uppercase</div></div>
									<div class="assembly-row-combined" id="1C33H"><div>1C33<span class="origrom2">NOTLW1</span></div><div>CP C<span class="opcode2">B9</span></div><div>Check
 to see if the character in Register A (the input element) matches the 
character in Register C (the next letter in the reserved word list)</div></div>
									<div class="assembly-row-combined"><div>1C34-1C35</div><div><a href="#1C1DH" class="memory-link">JR Z,1C1DH<span class="origrom2">JR Z,LOPPSI</span></a><span class="opcode2">28 E7</span></div><div>If that character is ALSO a match, loop back to 1C1DH to keep checking that reserved word</div></div>
									<div class="assembly-row-combined"><div>1C36</div><div>POP HL<span class="opcode2">E1</span></div><div>If
 we are here, then the matching process failed, so we need to get back 
the original input buffer pointer into HL and move on to the next 
reserved word</div></div>
									<div class="assembly-row-combined"><div>1C37-1C38</div><div><a href="#1C0CH" class="memory-link">JR 1C0CH<span class="origrom2">JR TRYAGA</span></a><span class="opcode2">18 D3</span></div><div>Jump back to 1C0CH to process the next reserved word against the character at the input buffer</div></div>
									<div class="assembly-row-combined" id="1C39H"><div>1C39<span class="origrom2">FOUND</span></div><div>LD C,B<span class="opcode2">48</span></div><div>Load Register C with the value of the reserved words counter in Register B</div></div>
									<div class="assembly-row-combined"><div>1C3A</div><div>POP AF<span class="opcode2">F1</span></div><div>Clear the old TXTPTR text pointer from the STACK (disposing of the HL push from 1C1CH)</div></div>
									<div class="assembly-row-combined"><div>1C3B</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange the TXTPTR and RESPTR because the NOTRES routine starts with the same instruction flipping them back</div></div>
									<div class="assembly-row-combined"><div>1C3C</div><div>RET<span class="opcode2">C9</span></div><div>RETurn to CALLer (which, by the way, will just pass through, the the RET was reprogrammed to be the next instruction)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1C3DH">1C3D - Part of the tokeninzing routine<span class="origrom"> - "NOTRES"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1C3D<span class="origrom2">NOTRES</span></div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange the reserved words list pointer in Register Pair HL with the input buffer pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1C3E</div><div>LD A,C<span class="opcode2">79</span></div><div>Load Register A with the value of the reserved words counter in Register C</div></div>
									<div class="assembly-row-combined"><div>1C3F</div><div>POP BC<span class="opcode2">C1</span></div><div>Restore the character count into Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>1C40</div><div>POP DE<span class="opcode2">D1</span></div><div>Restore the "STUFF" pointer into Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1C41</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange DE and HL so that DE will now hold the input buffer pointer (TXTPTR) and HL will hold the "STUFF" pointer</div></div>
									<p class="debug-note">The <span class="code">ELSE</span> token 
needs to be treated differently as it is a reserved word which is 
followed by a reserved word.  To deal with this, we put in a fake colon!</p>
									<div class="assembly-row-combined"><div>1C42-1C43</div><div>CP 95H<span class="opcode2">FE 95</span></div><div>Check to see if the token in Register A is an <span class="code">ELSE</span> token</div></div>
									<div class="assembly-row-combined"><div>1C44-1C45</div><div>LD (HL),3AH<span class="origrom2">LD (HL),":"</span><span class="opcode2">36 3A</span></div><div>Save a colon at the "STUFF" pointer location (held in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>1C46-1C47</div><div><a href="#1C4AH" class="memory-link">JR NZ,1C4AH<span class="origrom2">JR NZ,CKSNGQ</span></a><span class="opcode2">20 02</span></div><div>If the token in Register A isn't an <span class="code">ELSE</span> token, skip the next two instructions</div></div>
									<div class="assembly-row-combined"><div>1C48</div><div>INC C<span class="opcode2">0C</span></div><div>Bump the value of the crunched character counter</div></div>
									<div class="assembly-row-combined"><div>1C49</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the "STUFF" pointer (held in Register Pair HL)</div></div>
									<p class="debug-note">The <span class="code">'</span> token needs to be treated differently as it doesn't require a colon.  To deal with this, we put in a fake colon!</p>
									<div class="assembly-row-combined" id="1C4AH"><div>1C4A-1C4B<span class="origrom2">CKSNGQ</span></div><div>CP 0FBH<span class="origrom2">CP SNGQTK</span><span class="opcode2">FE FB</span></div><div>Next we check to see if the token in Register A is a <span class="code">'</span> token</div></div>
									<div class="assembly-row-combined"><div>1C4C-1C4D</div><div><a href="#1C5AH" class="memory-link">JR NZ,1C5AH<span class="origrom2">JR NZ,NTSNGT</span></a><span class="opcode2">20 0C</span></div><div>Jump to 1C5AH if the token in Register A isn't a <span class="code">'</span></div></div>
									<div class="assembly-row-combined"><div>1C4E-1C4F</div><div>LD (HL),3AH<span class="origrom2">LD (HL),":"</span><span class="opcode2">36 3A</span></div><div>Save a ":" at the "STUFF" pointer (held in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>1C50</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the "STUFF" pointer (held in Register Pair HL) because we just inserted a <span class="code">:</span></div></div>
									<div class="assembly-row-combined"><div>1C51-1C52</div><div>LD B,93H<span class="origrom2">LD B,$REM</span><span class="opcode2">06 93</span></div><div>Load Register B with a <span class="code">REM</span> token</div></div>
									<div class="assembly-row-combined"><div>1C53</div><div>LD (HL),B<span class="opcode2">70</span></div><div>Save the <span class="code">REM</span> token in Register B at the location of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1C54</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the "STUFF" pointer (held in Register Pair HL) because we just inserted a <span class="code">REM</span> token</div></div>
									<div class="assembly-row-combined"><div>1C55</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange DE and HL so that DE will now hold the "STUFF" pointer and HL will hold the input buffer pointer</div></div>
									<div class="assembly-row-combined"><div>1C56</div><div>INC C<span class="opcode2">0C</span></div><div>Bump the character counter in Register C</div></div>
									<div class="assembly-row-combined"><div>1C57</div><div>INC C<span class="opcode2">0C</span></div><div>Bump the character counter in Register C</div></div>
									<div class="assembly-row-combined"><div>1C58-1C59</div><div><a href="#1C77H" class="memory-link">JR 1C77H<span class="origrom2">JR STRNG</span></a><span class="opcode2">18 1D</span></div><div>Jump to 1C77H to move all the rest of the text of the line to the "STUFF" buffer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1C5AH">1C5A - Part of the tokeninzing routine<span class="origrom"> - "NTSNGT" and "STUFFH"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1C5AH"><div>1C5A<span class="origrom2">NTSNGT</span></div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange DE and HL so that DE will now hold the "STUFF" pointer</div></div>
									<div class="assembly-row-combined" id="1C5BH"><div>1C5B<span class="origrom2">STUFFH</span></div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1C5C</div><div>LD (DE),A<span class="opcode2">12</span></div><div>Save the value of the token in Register A at the location of the input buffer pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1C5D</div><div>INC DE<span class="opcode2">13</span></div><div>Bump the value of the "STUFF" pointer (held in Register Pair DE)</div></div>
									<div class="assembly-row-combined"><div>1C5E</div><div>INC C<span class="opcode2">0C</span></div><div>Bump the value of the crunched character count</div></div>
									<div class="assembly-row-combined"><div>1C5F-1C60</div><div>SUB 3AH<span class="opcode2">D6 3A</span></div><div>Check to see if the character in Register A is a <span class="code">:</span> to flag a multi-statement line</div></div>
									<div class="assembly-row-combined"><div>1C61-1C62</div><div><a href="#1C67H" class="memory-link">JR Z,1C67H<span class="origrom2">JR Z,COLIS</span></a><span class="opcode2">28 04</span></div><div>If we found a ":" then skip the next two instructions</div></div>
									<div class="assembly-row-combined"><div>1C63-1C64</div><div>CP 4EH<span class="origrom2">CP $DATA</span><span class="opcode2">FE 4E</span></div><div>Check to see if the token in Register A is a <span class="code">DATA</span> token</div></div>
									<div class="assembly-row-combined"><div>1C65-1C66</div><div><a href="#1C6AH" class="memory-link">JR NZ,1C6AH<span class="origrom2">JR NZ,NODATT</span></a><span class="opcode2">20 03</span></div><div>If the token in Register A isn't a <span class="code">DATA</span> token then skip the next instruction</div></div>
									<div class="assembly-row-combined" id="1C67H"><div>1C67-1C69<span class="origrom2">COLIS</span></div><div>LD (40B0H),A<span class="origrom2">LD (DORES),A</span><span class="opcode2">32 B0 40</span></div><div>Save the value in Register A as the tokenization flag for <span class="code">DATA</span>.<br>Note: 40B0H holds the temporary storage location</div></div>
									<div class="assembly-row-combined" id="1C6AH"><div>1C6A-1C6B<span class="origrom2">NODATT</span></div><div>SUB 59H<span class="opcode2">D6 59</span></div><div>Check to see if the token in Register A is a <span class="code">REM</span> token</div></div>
									<div class="assembly-row-combined"><div>1C6C-1C6E</div><div><a href="#1BCCH" class="memory-link">JP NZ,1BCCH<span class="origrom2">JP NZ,KLOOP</span></a><span class="opcode2">C2 CC 1B</span></div><div>Jump to 1BCCH if the token in Register A isn't a <span class="code">REM</span> token</div></div>
									<div class="assembly-row-combined"><div>1C6F</div><div>LD B,A<span class="opcode2">47</span></div><div>Load Register B with a zero, since processing a REM doesn't end with a :, only an END OF LINE (i.e., 0)</div></div>
									<div class="assembly-row-combined" id="1C70H"><div>1C70<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;STR1</span></div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Top of a loop.  Load Register A with the character at the location of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1C71</div><div>OR A<span class="opcode2">B7</span></div><div>Check to see if the character in Register A is an END OF LINE delimiter of 0</div></div>
									<div class="assembly-row-combined"><div>1C72-1C73</div><div><a href="#1C7DH" class="memory-link">JR Z,1C7DH<span class="origrom2">JR Z,CRDONE</span></a><span class="opcode2">28 09</span></div><div>Jump out of this loop to 1C7DH if the character in Register A is an END OF LINE delimeter</div></div>
									<div class="assembly-row-combined"><div>1C74</div><div>CP B<span class="opcode2">B8</span></div><div>Check to see if the character in Register B matches the character in Register A</div></div>
									<div class="assembly-row-combined"><div>1C75-1C76</div><div><a href="#1C5BH" class="memory-link">JR Z,1C5BH<span class="origrom2">JR Z,STUFFH</span></a><span class="opcode2">28 E4</span></div><div>If they match, then we are completely done with gobbling the whole rest of line without checking, so Jump to 1C5BH</div></div>
									<div class="assembly-row-combined" id="1C77H"><div>1C77<span class="origrom2">STRNG</span></div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1C78</div><div>LD (DE),A<span class="opcode2">12</span></div><div>Save the character in Register A to the location of the "STUFF" pointer (in Register Pair DE)</div></div>
									<div class="assembly-row-combined"><div>1C79</div><div>INC C<span class="opcode2">0C</span></div><div>Bump the value of the crunched character count</div></div>
									<div class="assembly-row-combined"><div>1C7A</div><div>INC DE<span class="opcode2">13</span></div><div>Bump the value of the "STUFF" pointer (held in Register Pair DE)</div></div>
									<div class="assembly-row-combined"><div>1C7B-1C7C</div><div><a href="#1C70H" class="memory-link">JR 1C70H<span class="origrom2">JR STR1</span></a><span class="opcode2">18 F3</span></div><div>Loop until an END OF LINE delimiter or a ending quote is found</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1C7DH">1C7D - Part of the tokeninzing routine - Jumped here when an EOL is found<span class="origrom"> - "CRDONE"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1C7D-1C7F<span class="origrom2">CRDONE</span></div><div>LD HL,0005H<span class="opcode2">21 05 00</span></div><div>We are going to need to add 5 bytes to the tokenized character count</div></div>
									<div class="assembly-row-combined"><div>1C80</div><div>LD B,H<span class="opcode2">44</span></div><div>Load Register B with zero</div></div>
									<div class="assembly-row-combined"><div>1C81</div><div>ADD HL,BC<span class="opcode2">09</span></div><div>Add 5 to the length of the tokenized character count so far</div></div>
									<div class="assembly-row-combined"><div>1C82,1C83</div><div>LD B,H<br>LD C,L<span class="opcode2">44</span></div><div>Let BC = HL</div></div>
									<div class="assembly-row-combined"><div>1C84-1C86</div><div>LD HL,(40A7H)<span class="origrom2">LD HL,(BUFPNT)</span><span class="opcode2">2A A7 40</span></div><div>Load Register Pair HL with the start address of the input buffer.<br>Note: 40A7H-40A8H holds Input Buffer pointer</div></div>
									<div class="assembly-row-combined"><div>1C87</div><div>DEC HL<span class="opcode2">2B</span></div><div>Decrement the value of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1C88</div><div>DEC HL<span class="opcode2">2B</span></div><div>Decrement the value of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1C89</div><div>DEC HL<span class="opcode2">2B</span></div><div>Decrement the value of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1C8A</div><div>LD (DE),A<span class="opcode2">12</span></div><div>We need THREE zeroes at the end, so . zero the location of the input buffer pointer in Register Pair DE to denote END OF LINE</div></div>
									<div class="assembly-row-combined"><div>1C8B</div><div>INC DE<span class="opcode2">13</span></div><div>Bump the value of the input buffer pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1C8C</div><div>LD (DE),A<span class="opcode2">12</span></div><div>Zero
 the next two locations of the input buffer pointer in Register Pair DE 
to denote no further link (since this was a direct statement)</div></div>
									<div class="assembly-row-combined"><div>1C8D</div><div>INC DE<span class="opcode2">13</span></div><div>Bump the value of the input buffer pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1C8E</div><div>LD (DE),A<span class="opcode2">12</span></div><div>Zero the location of the input buffer pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1C8F</div><div>RET<span class="opcode2">C9</span></div><div>RETURN t o CALLer since we are done with the CRUNCHing</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1C90H">1C90-1C95 - RST 0018H CODE<span class="origrom"> - "DCOMPR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The RST 18H code is located here. Unsigned compare (HL-DE), 
which numerically compares DE and HL. Will not work for signed integers 
(except positive ones). Uses the A-register only. The result of the 
comparison is returned in the status Register as:  </p><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table>.<p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1C90H"><div>1C90<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;DCOMPR</span></div><div>LD A,H<span class="opcode2">7C</span></div><div>Load Register A with the MSB of the value in Register H</div></div>
									<div class="assembly-row-combined"><div>1C91</div><div>SUB D<span class="opcode2">92</span></div><div>Subtract the value of the MSB of the value in Register D from the MSB of the value in Register A</div></div>
									<div class="assembly-row-combined"><div>1C92</div><div>RET NZ<span class="opcode2">C0</span></div><div>Return if the MSB of the value in Register D doesn't equal the MSB of the value in Register H</div></div>
									<div class="assembly-row-combined"><div>1C93</div><div>LD A,L<span class="opcode2">7D</span></div><div>Load Register A with the LSB of the value in Register L</div></div>
									<div class="assembly-row-combined"><div>1C94</div><div>SUB E<span class="opcode2">93</span></div><div>Subtract the LSB of the value in Register E from the LSB of the value in Register A</div></div>
									<div class="assembly-row-combined"><div>1C95</div><div>RET<span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1C96H">1C96-1CA0 - RST 0008H CODE<span class="origrom"> - "SYNCHR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The RST 8H code is located here.  This is the COMPARE SYMBOL 
routine which comparess the symbol in the input string pointed to by HL 
Register to the value in the location following the RST 08 call.  If 
there is a match, control is returned to address of the RST 08 
instruction 2 with the next symbol in in Register A and HL incremented 
by one. If the two characters do not match, a syntax error message is 
given and control returns to the Input Phase).</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1C96H"><div>1C96<span class="origrom2">SYNCHR</span></div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the current BASIC program pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1C97</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Save
 the return address of the routine by exchanging the value of the 
current BASIC program pointer in Register Pair HL with the value of the 
return address to the STACK</div></div>
									<div class="assembly-row-combined"><div>1C98</div><div>CP (HL)<span class="opcode2">BE</span></div><div>Check
 to see if the character at the location following the RST 08H call 
(stored in Register Pair HL) is the same as the character in Register A</div></div>
									<div class="assembly-row-combined"><div>1C99</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the return address in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1C9A</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Restore the return address (meaning the RST 08H plus 1 byte plus 1 byte) to the STACK pointer</div></div>
									<div class="assembly-row-combined"><div>1C9B-1C9D</div><div><a href="#1D78H" class="memory-link">JP Z,1D78H<span class="origrom2">JP CHRGTR</span></a><span class="opcode2">CA 78 1D</span></div><div>Jump to the RST 0010H code if the characters match</div></div>
									<div class="assembly-row-combined"><div>1C9E-1C90</div><div><a href="#1997H" class="memory-link">JP 1997H<span class="origrom2">JP SNERR</span></a><span class="opcode2">C3 97 19</span></div><div>If they don't match, jump to the <span class="code">?SN ERROR</span> routine</div></div>
								</div>
							</div>

<h2 class="assembly-section-title" id="1CA1H">1CA1-1D1D - Level II BASIC <span class="code">FOR</span> ROUTINE<span class="origrom"> - "FOR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
<div class="card-item">
<p>This routine parses and sets up a FOR...NEXT loop by evaluating the 
initial value, TO limit, and optional STEP, then pushes a fixed 16-byte 
stack frame for later use by NEXT.</p>
<p>Important characteristics:</p>
<ul class="indent025">
<li>The frame is always **exactly 16 bytes** (8 PUSHes of 2 bytes each) 
to allow NEXT to traverse the stack uniformly, regardless of whether the
 loop uses integer or single-precision variables.</li>
<li>A **data type flag** (FFH = integer, 01H = single-precision) is 
stored in the frame (+5 offset) to tell NEXT how to interpret and add 
the STEP/TO values.</li>
<li>Integer loops use 16-bit signed arithmetic for STEP and TO, which 
causes the known ?OV ERROR bug with large steps (e.g., FOR J% = 0 TO 
30000 STEP 5000) due to signed overflow that promotes the result to 
single-precision.</li>
<li>Single-precision loops store full 32-bit floating-point values for STEP and TO.</li>
</ul>
<p>The stack frame for FOR/NEXT loops differs based on whether the index
 is SINGLE PRECISION or INTEGER. They both need to set 16 bytes so that 
the NEXT routine can handle both, but they do not both need 16 bytes. 
Integer would only need 14, so it has padding.</p>
<p><b>Integer FOR/NEXT Stack Frame (16 bytes total)</b></p>
<table class="data-table w10-10-80">
<tbody><tr><th>Offset</th><th>Bytes</th><th>Explanation</th></tr>
<tr><td>+0</td><td>1</td><td>Sign of STEP (+1 or -1)</td></tr>
<tr><td>+1</td><td>1</td><td>FOR token (81H)</td></tr>
<tr><td>+2‚Äì3</td><td>2</td><td>Pointer to loop variable (address in variable storage)</td></tr>
<tr><td>+4</td><td>1</td><td>Sign of STEP (duplicate; +1 or -1)</td></tr>
<tr><td>+5</td><td>1</td><td>Data type flag (FFH = integer)</td></tr>
<tr><td>+6‚Äì9</td><td>4</td><td>UNUSED PADDING (garbage/uninitialized from BC/DE pushes)</td></tr>
<tr><td>+10‚Äì11</td><td>2</td><td>INTEGER STEP value (signed 16-bit: LSB at +10, MSB at +11)</td></tr>
<tr><td>+12‚Äì13</td><td>2</td><td>INTEGER TO value (signed 16-bit: LSB at +12, MSB at +13)</td></tr>
<tr><td>+14‚Äì15</td><td>2</td><td>Line number of the FOR statement</td></tr>
</tbody></table>
<p><b>Single-Precision FOR/NEXT Stack Frame (16 bytes total)</b></p>
<table class="data-table w10-10-80">
<tbody><tr><th>Offset</th><th>Bytes</th><th>Explanation</th></tr>
<tr><td>+0</td><td>1</td><td>Sign of STEP (+1 or -1)</td></tr>
<tr><td>+1</td><td>1</td><td>FOR token (81H)</td></tr>
<tr><td>+2‚Äì3</td><td>2</td><td>Pointer to loop variable (address in variable storage)</td></tr>
<tr><td>+4</td><td>1</td><td>Sign of STEP (duplicate; +1 or -1)</td></tr>
<tr><td>+5</td><td>1</td><td>Data type flag (01H = single precision)</td></tr>
<tr><td>+6‚Äì9</td><td>4</td><td>STEP value (single-precision float: mantissa3, mantissa2, mantissa1, exponent)</td></tr>
<tr><td>+10‚Äì13</td><td>4</td><td>TO value (single-precision float: mantissa3, mantissa2, mantissa1, exponent)</td></tr>
<tr><td>+14‚Äì15</td><td>2</td><td>Line number of the FOR statement</td></tr>
</tbody></table>
<div class="assembly-table">
<p class="debug-note">Vernon Hester has flagged a bug in the FOR...NEXT routines. FOR-NEXT loops with valid integer values should complete, but <span class="code">FOR J% = 0 TO 30000 STEP 5000 : PRINT J%, : NEXT J%</span>
 will trigger an ?OV ERROR. This bug is due to the fact that when adding
 STEP to the loop variable causes signed 16-bit overflow (exceeds 
¬±32767), the arithmetic routine promotes the result to single precision.
 However, NEXT cannot store a single precision value back into an 
integer variable, so it throws ?OV ERROR instead of handling the 
overflow gracefully. Specifically: NEXT calls integer ADD (0BD2H): 
adding STEP to index overflows ¬±32767 ‚Üí promotes to single-precision in 
FAC (4121H‚Äì4124H, NTF=01H/4). Storing back to integer var fails type 
check in LET (1F21H) ‚Üí OV.</p>
<div class="assembly-row-combined"><div>1CA1-1CA2<span class="origrom2">FOR</span></div><div>LD A,64H<span class="opcode2">3E 64</span></div><div>Load Register A with the value for the <span class="code">FOR</span> flag</div></div>
<div class="assembly-row-combined"><div>1CA3-1CA5</div><div>LD (40DCH),A<span class="origrom2">LD (SUBFLG),A</span><span class="opcode2">32 DC 40</span></div><div>Save the value in Register A as the current value of the FOR flag.<br>Note: 40DCH holds <span class="code">FOR</span> flag</div></div>
<div class="assembly-row-combined"><div>1CA6-1CA8</div><div><a href="#1F21H" class="memory-link">CALL 1F21H<span class="origrom2">CALL LET</span></a><span class="opcode2">CD 21 1F</span></div><div>GOSUB
 to the "LET" routine at 1F21H to read the variable, assign it the 
correct initial value, and store a pointer to the RAM variable location 
"TEMP"</div></div>
<div class="assembly-row-combined"><div>1CA9</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Exchange the value of the current BASIC program pointer in Register Pair HL with the value to the STACK</div></div>
<div class="assembly-row-combined"><div>1CAA-1CAC</div><div><a href="#1936H" class="memory-link">CALL 1936H<span class="origrom2">CALL FNDFOR</span></a><span class="opcode2">CD 36 19</span></div><div>Go check to see if there is a <span class="code">FOR</span> statement to the STACK already using the same variable name (called the index)</div></div>
<div class="assembly-row-combined"><div>1CAD</div><div>POP DE<span class="opcode2">D1</span></div><div>Get the current BASIC program pointer from the STACK (which should be the <span class="code">TO</span> token and put it in Register Pair DE</div></div>
<div class="assembly-row-combined"><div>1CAE-1CAF</div><div><a href="#1CB5H" class="memory-link">JR NZ,1CB5H<span class="origrom2">JR NZ,NOTOL</span></a><span class="opcode2">20 05</span></div><div>If there isn't a matching <span class="code">FOR</span>
 statement to the STACK, skip the next 3 instructions (which are 
preparing for a NEXT WITHOUT FOR error) and jump to 1CB5H. If one is 
found, on exit HL will equal the starting address of the <span class="code">FOR</span> push</div></div>
<div class="assembly-row-combined"><div>1CB0</div><div>ADD HL,BC<span class="opcode2">09</span></div><div>Add
 the value in Register Pair BC (which is the offset to the end of the 
STACK frame) to the value in Register Pair HL. In the case where we had a
 matching FOR, we eliminate the matching entry as well as everything 
after it by doing this addition. After this addition, we should be 
pointing to the end of the first <span class="code">FOR</span> frame push</div></div>
<div class="assembly-row-combined"><div>1CB1</div><div>LD SP,HL<span class="opcode2">F9</span></div><div>Remove all the rest by resetting the STACK pointer to end of the first <span class="code">FOR</span> frame push. This also frees up the STACK space and prepares for a NF error</div></div>
<div class="assembly-row-combined"><div>1CB2-1CB4</div><div>LD (40E8H),HL<span class="origrom2">LD (SAVSTK),HL</span><span class="opcode2">22 E8 40</span></div><div>Save the value in Register Pair HL as the STACK pointer, get ready for a NF error.<br>Note: 40E8H-40E9H holds STACK pointer pointer</div></div>
<div class="assembly-row-combined" id="1CB5H"><div>1CB5<span class="origrom2">NOTOL</span></div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange
 Register Pairs DE and HL, so that HL now points to the current BASIC 
program pointer and DE will be the STACK pointer address</div></div>
<div class="assembly-row-combined"><div>1CB6-1CB7</div><div>LD C,08H<span class="opcode2">0E 08</span></div><div>Load Register C with the 1/2 the amount of space (i.e. 16 bytes) needed for a FOR entry</div></div>
<div class="assembly-row-combined"><div>1CB8-1CBA</div><div><a href="#1963H" class="memory-link">CALL 1963H<span class="origrom2">CALL GETSTK</span></a><span class="opcode2">CD 63 19</span></div><div>Go check to see if there is enough memory (i.e., 16 bytes) left by calling 1963H (which is the MEMORY CHECK ROUTINE)</div></div>
<div class="assembly-row-combined"><div>1CBB</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer (which is the code string address before the <span class="code">TO</span>) in Register Pair HL to the STACK</div></div>
<div class="assembly-row-combined"><div>1CBC-1CBE</div><div><a href="#1F05H" class="memory-link">CALL 1F05H<span class="origrom2">CALL DATA</span></a><span class="opcode2">CD 05 1F</span></div><div>Keep
 scanning the current BASIC program (pointer is in Register Pair HL) 
until it points to the end of the BASIC statement. HL should then point 
to the END OF LINE terminator</div></div>
<div class="assembly-row-combined"><div>1CBF</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Exchange
 the adjusted value of the current BASIC program pointer in Register 
Pair HL with the value of the current BASIC program pointer to the STACK</div></div>
<div class="assembly-row-combined"><div>1CC0</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in Register Pair HL to the STACK. This should be pointing to the <span class="code">TO</span> token</div></div>
<div class="assembly-row-combined"><div>1CC1-1CC3</div><div>LD HL,(40A2H)<span class="origrom2">LD HL,(CURLIN)</span><span class="opcode2">2A A2 40</span></div><div>Load Register Pair HL with the value (in binary) of the current BASIC line number.<br>Note: 40A2H-40A3H holds the current BASIC line number</div></div>
<div class="assembly-row-combined"><div>1CC4</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Exchange
 the value of the current BASIC line number in Register Pair HL with the
 value of the current BASIC program pointer to the STACK. Once again, HL
 will point to the current location in the BASIC program</div></div>
<div class="assembly-row-combined"><div>1CC5-1CC6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H">RST 08H ‚áí BDH<span class="origrom2">RST 08H <span class="code">TO</span></span></a><span class="opcode2">CF</span></div><div>Since
 the character at the location of the current BASIC program pointer in 
Register Pair HL must be TO token (BDH) so call the COMPARE SYMBOL 
routine which compares the symbol in the input string pointed to by HL 
Register to the value in the location following the RST 08 call. If 
there is a match, control is returned to the address of the RST 08 
instruction +2 with the next symbol in Register A and HL incremented by 
one. If the two characters do not match, a syntax error message is given
 and control returns to the Input Phase)</div></div>
<div class="assembly-row-combined"><div>1CC7</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H">RST 20H<span class="origrom2">GETYPE</span></a><span class="opcode2">E7</span></div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
 The RST 20H routine determines the type of the current value in 
ACCumulator and returns a combination of STATUS flags and unique numeric
 values in the A Register according to the data mode flag (40AFH). The 
results are returned as follows:<br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
<div class="assembly-row-combined"><div>1CC8-1CCA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0AF6H">JP Z,0AF6H<span class="origrom2">JP Z,TMERR</span></a><span class="opcode2">CA F6 0A</span></div><div>If that test shows we have a STRING, go to the Level II BASIC error routine and display a TM ERROR message</div></div>
<div class="assembly-row-combined"><div>1CCB-1CCD</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0AF6H">JP NC,0AF6H<span class="origrom2">JP NC,TMERR</span></a><span class="opcode2">D2 F6 0A</span></div><div>If that test shows we have a DOUBLE PRECISION number, go display a <span class="code">?TM ERROR</span> message</div></div>
<div class="assembly-row-combined"><div>1CCE</div><div>PUSH AF<span class="opcode2">F5</span></div><div>We have an integer, so let's keep going and save the resulting integer value in Register Pair AF (the type flags) to the STACK</div></div>
<div class="assembly-row-combined"><div>1CCF-1CD1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2337H">CALL 2337H<span class="origrom2">CALL FRMEVL</span></a><span class="opcode2">CD 37 23</span></div><div>Go evaluate the expression at the location of the current BASIC program pointer in Register Pair HL (which should be the <span class="code">TO</span> side) and return with the result in ACCumulator</div></div>
<div class="assembly-row-combined"><div>1CD2</div><div>POP AF<span class="opcode2">F1</span></div><div>Restore the index type flags from the STACK and put it in Register Pair AF</div></div>
<div class="assembly-row-combined"><div>1CD3</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer (which is the code string after the <span class="code">TO</span> pointer) in Register Pair HL to the STACK</div></div>
<div class="assembly-row-combined"><div>1CD4-1CD6</div><div><a href="#1CECH" class="memory-link">JP P,1CECH<span class="origrom2">JP P,SNGFOR</span></a><span class="opcode2">F2 EC 1C</span></div><div>If the flag is positive, then we have a SINGLE PRECISION "FOR" loop</div></div>
<div class="assembly-row-combined"><div>1CD7-1CD9</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A7FH">CALL 0A7FH<span class="origrom2">CALL FRCINT</span></a><span class="opcode2">CD 7F 0A</span></div><div>Call
 the CONVERT TO INTEGER routine at 0A7FH (where the contents of 
ACCumulator are converted from single or double precision to integer and
 deposited into HL)</div></div>
<div class="assembly-row-combined"><div>1CDA</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Exchange the integer value in Register Pair HL from that conversion (the current <span class="code">TO</span> value) with the value of the current BASIC program pointer to the STACK</div></div>
<div class="assembly-row-combined"><div>1CDB-1CCD</div><div>LD DE,0001H<span class="opcode2">11 01 00</span></div><div>Load Register Pair DE with a default <span class="code">STEP</span> value of 1</div></div>
<div class="assembly-row-combined"><div>1CDE</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Fetch the next character from the current BASIC program line (pointer in Register Pair HL) into Register A</div></div>
<div class="assembly-row-combined"><div>1CDF-1CE0</div><div>CP 0CCH<span class="origrom2">CP STEPTK</span><span class="opcode2">FE CC</span></div><div>Check to see if the character in Register A is a <span class="code">STEP</span> token</div></div>
<div class="assembly-row-combined"><div>1CE1-1CE3</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2B01H">CALL Z,2B01H<span class="origrom2">CALL Z,GETINT</span></a><span class="opcode2">CC 01 2B</span></div><div>So now we have a <span class="code">STEP</span>
 token so we have to get the step value into DE. To do this, GOSUB to 
2B01H to evaluate the expression at the location of the current BASIC 
program pointer in Register Pair HL and return with the integer value in
 Register Pair DE if the character in Register A is a STEP token</div></div>
<div class="assembly-row-combined"><div>1CE4</div><div>PUSH DE<span class="opcode2">D5</span></div><div>Save the <span class="code">STEP</span> index value (in Register Pair DE) to the STACK</div></div>
<div class="assembly-row-combined"><div>1CE5</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the current BASIC program pointer (in Register Pair HL) to the STACK</div></div>
<div class="assembly-row-combined"><div>1CE6</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange the <span class="code">STEP</span>
 value (from DE) with the value of the current BASIC program pointer (in
 Register Pair HL). Now HL will have the value so the next call can test
 its size</div></div>
<div class="assembly-row-combined"><div>1CE7-1CE9</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#099EH">CALL 099EH<span class="origrom2">CALL ISIGN</span></a><span class="opcode2">CD 9E 09</span></div><div>GOSUB to 099EH to get the sign of the <span class="code">STEP</span> value into A. It will be A=+1 if positive and A=-1 if negative</div></div>
<div class="assembly-row-combined"><div>1CEA-1CEB</div><div><a href="#1D0EH" class="memory-link">JR 1D0EH<span class="origrom2">JR STPSGN</span></a><span class="opcode2">18 22</span></div><div>Jump down to 1D0EH to finish the entry by putting the sign of the STEP and the dummy entries into the STACK</div></div>
</div>
</div>
<h2 class="assembly-section-title" id="1CECH">1CECH - Part of the Level II BASIC <span class="code">FOR</span> ROUTINE<span class="origrom"> - "SNGFOR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
<div class="card-item">
<div class="assembly-table">
<div class="assembly-row-combined"><div>1CEC-1CEE<span class="origrom2">SNGFOR</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0AB1H">CALL 0AB1H<span class="origrom2">CALL FRCSNG</span></a><span class="opcode2">CD B1 0A</span></div><div>Need the <span class="code">TO</span>
 value to be converted so GOSUB to the CONVERT TO SINGLE PRECISION 
routine at 0AB1H (which converts the contents of ACCumulator from 
integer or double precision into single precision)</div></div>
<div class="assembly-row-combined"><div>1CEF-1CF1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09BFH">CALL 09BFH<span class="origrom2">CALL MOVRF</span></a><span class="opcode2">CD BF 09</span></div><div>Call 09BF which loads the SINGLE PRECISION value in ACCumulator (the <span class="code">TO</span> value) into Register Pair BC/DE</div></div>
<div class="assembly-row-combined"><div>1CF2</div><div>POP HL<span class="opcode2">E1</span></div><div>Get the value of the current BASIC program pointer from the STACK (which should be the end of the <span class="code">TO</span> expression) and put it in Register Pair HL</div></div>
<div class="assembly-row-combined"><div>1CF3,1CF4</div><div>PUSH BC<br>PUSH DE<span class="opcode2">C5</span></div><div>Save all 4 bytes of the <span class="code">TO</span> value to the STACK</div></div>
<div class="assembly-row-combined"><div>1CF5-1CF7</div><div>LD BC,8100H<span class="opcode2">01 00 81</span></div><div>Load Register Pair BC with the exponent and the MSB for a single precision constant</div></div>
<div class="assembly-row-combined"><div>1CF8</div><div>LD D,C<span class="opcode2">51</span></div><div>Zero the NMSB for the single precision constant in Register D</div></div>
<div class="assembly-row-combined"><div>1CF9</div><div>LD E,D<span class="opcode2">5A</span></div><div>Zero
 the LSB for the single precision constant in Register E. Register Pairs
 BC and DE now hold a single precision constant equal to one</div></div>
<div class="assembly-row-combined"><div>1CFA</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the current BASIC program pointer in Register Pair HL</div></div>
<div class="assembly-row-combined"><div>1CFB-1CFC</div><div>CP 0CCH<span class="opcode2">FE CC</span></div><div>Check to see if the character in Register A is a <span class="code">STEP</span> token</div></div>
<div class="assembly-row-combined"><div>1CFD-1CFE</div><div>LD A,01H<span class="opcode2">3E 01</span></div><div>Load Register A with the default <span class="code">STEP</span> value (in this case, 1)</div></div>
<div class="assembly-row-combined" id="1D00H"><div>1CFF-1D00</div><div><a href="#1D0FH" class="memory-link">JR NZ,1D0FH<span class="origrom2">JR NZ,ONEON</span></a><span class="opcode2">20 0E</span></div><div>Skip
 over the next instructions by jumping down to 1D0FH if the character at
 the location of the current BASIC program pointer in Register A isn't a
 STEP token</div></div>
<div class="assembly-row-combined"><div>1D01-1D03</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2338H">CALL 2338H<span class="origrom2">CALL FRMCHK</span></a><span class="opcode2">CD 38 23</span></div><div>Go evaluate the expression at the location of the current BASIC program pointer (which is the <span class="code">STEP</span> instruction) and return with the result in ACCumulator</div></div>
<div class="assembly-row-combined"><div>1D04</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in Register Pair HL to the STACK</div></div>
<div class="assembly-row-combined"><div>1D05-1D07</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0AB1H">CALL 0AB1H<span class="origrom2">CALL FRCSNG</span></a><span class="opcode2">CD B1 0A</span></div><div>Convert the <span class="code">STEP</span>
 value to single precision by calling the CONVERT TO SINGLE PRECISION 
routine at 0AB1H (which converts the contents of ACCumulator from 
integer or double precision into single precision)</div></div>
<div class="assembly-row-combined"><div>1D08-1D0A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09BFH">CALL 09BFH<span class="origrom2">CALL MOVRF</span></a><span class="opcode2">CD BF 09</span></div><div>Load the <span class="code">STEP</span> value into BC/DE by calling 09BF which loads the SINGLE PRECISION value in ACCumulator into Register Pair BC/DE</div></div>
<div class="assembly-row-combined"><div>1D0B-1D0D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0955H">CALL 0955H<span class="origrom2">CALL SIGN</span></a><span class="opcode2">CD 55 09</span></div><div>Go get the sign for the <span class="code">STEP</span> increment value (held in ACCumulator) into Register A. A will be +1 if positive, and -1 if negative</div></div>
<div class="assembly-row-combined" id="1D0EH"><div>1D0E<span class="origrom2">STPSGN</span></div><div>POP HL<span class="opcode2">E1</span></div><div>Get the value of the current BASIC program pointer from the STACK and put it in Register Pair HL</div></div>
<div class="assembly-row-combined" id="1D0FH"><div>1D0F<span class="origrom2">ONEON</span></div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the exponent and the NMSB for the single precision value in Register Pair BC to the STACK</div></div>
<div class="assembly-row-combined"><div>1D10</div><div>PUSH DE<span class="opcode2">D5</span></div><div>Save the NMSB and the LSB for the single precision value in Register Pair DE to the STACK</div></div>
<div class="assembly-row-combined"><div>1D11</div><div>LD C,A<span class="opcode2">4F</span></div><div>Load Register C with the sign value for the <span class="code">STEP</span> value in Register A</div></div>
<div class="assembly-row-combined"><div>1D12</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H">RST 20H<span class="origrom2">GETYPE</span></a><span class="opcode2">E7</span></div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
 The RST 20H routine determines the type of the current value in 
ACCumulator and returns a combination of STATUS flags and unique numeric
 values in the A Register according to the data mode flag (40AFH). The 
results are returned as follows:<br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
<div class="assembly-row-combined"><div>1D13</div><div>LD B,A<span class="opcode2">47</span></div><div>Load Register B with type-adjusted and sign value of the number type flag test in Register A</div></div>
<div class="assembly-row-combined"><div>1D14</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the type-adjusted and sign value in Register Pair BC to the STACK</div></div>
<div class="assembly-row-combined"><div>1D15</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in Register Pair HL to the STACK</div></div>
<div class="assembly-row-combined"><div>1D16-1D18</div><div>LD HL,(40DFH)<span class="origrom2">LD HL,(TEMP)</span><span class="opcode2">2A DF 40</span></div><div>Load Register Pair HL with a pointer to the <span class="code">FOR</span> variable</div></div>
<div class="assembly-row-combined"><div>1D19</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Put the pointer to the variable onto the STACK and restore the pointer to the BASIC program line being examined into HL</div></div>
<div class="assembly-row-combined" id="1D1AH"><div>1D1A-1D1B<span class="origrom2">NXTCON</span></div><div>LD B,81H<span class="origrom2">LD B,$FOR</span><span class="opcode2">06 81</span></div><div>Load Register B with the <span class="code">FOR</span> token</div></div>
<div class="assembly-row-combined"><div>1D1C</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the <span class="code">FOR</span> token and the sign of the <span class="code">STEP</span> increment in BC to the STACK</div></div>
<div class="assembly-row-combined"><div>1D1D</div><div>INC SP<span class="opcode2">33</span></div><div>Since
 a token only takes one byte of space, bump the value of the STACK 
pointer to leave a one byte gap. By continuing onward, we will wind up 
continuing the execution of the code string</div></div>
</div>
</div>


							<h2 class="assembly-section-title" id="1D1EH">1D1E-1D77 - LEVEL II BASIC INTERPRETER<span class="origrom"> -  "NEWSTT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source code, this is where we 
go for a new statement.  The character on the BASIC program line pointed
 to by Register Pair HL should be either a ":" or an END OF LINE.  The 
address of this routine is left on the STACK so that when a statement is
 executed and done, the RETurn comes back here.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1D1EH"><div>1D1E-1D20<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;NEWSTT</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0358H">CALL 0358H<span class="origrom2">CALL ISCHAR</span></a><span class="opcode2">CD 58 03</span></div><div>Go check to see if a key has been pressed</div></div>
									<div class="assembly-row-combined"><div>1D21</div><div>OR A<span class="opcode2">B7</span></div><div>Set the flags.  If a key was hit, test for <span class="code">SHIFT</span>+<span class="code">@</span></div></div>
									<div class="assembly-row-combined"><div>1D22-1D24</div><div><a href="#1DA0H" class="memory-link">CALL NZ,1DA0H<span class="origrom2">CALL NZ,CNTCCN</span></a><span class="opcode2">C4 A0 1D</span></div><div>GOSUB to 1DA0H if the key pressed was a <span class="code">SHIFT</span>+<span class="code">@</span>.  This will save the address of the last byte executed in the current line</div></div>
									<div class="assembly-row-combined"><div>1D25-1D27</div><div>LD (40E6H),HL<span class="origrom2">LD (SAVTXT),HL</span><span class="opcode2">22 E6 40</span></div><div>Save the value of the current BASIC program pointer.  This would be used by <span class="code">CONT</span>, <span class="code">INPUT</span>, <span class="code">CLEAR</span>, and <span class="code">PRINT USING</span><br>Note: 40E6H-40E7H holds the temporary storage location</div></div>
									<div class="assembly-row-combined"><div>1D28-1D2B</div><div>LD (40E8H),SP<span class="origrom2">LD (SAVSTK),SP</span><span class="opcode2">ED 73 E8 40</span></div><div>Save the value of the STACK pointer.<br>Note: 40E8H-40E9H holds STACK pointer pointer</div></div>
									<div class="assembly-row-combined"><div>1D2C</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load
 Register A with the value at the location of the current BASIC program 
pointer in Register Pair HL (which SHOULD be the character which 
terminated the last statement)</div></div>
									<div class="assembly-row-combined"><div>1D2D-1D2E</div><div>CP 3AH<span class="opcode2">FE 3A</span></div><div>Check to see if the character in Register A is a <span class="code">:</span></div></div>
									<div class="assembly-row-combined"><div>1D2F-1D30</div><div><a href="#1D5AH" class="memory-link">JR Z,1D5AH<span class="origrom2">JR Z,GONE</span></a><span class="opcode2">28 29</span></div><div>If the character is a <span class="code">:</span>, jump to 1D5AH since that means this is a brand new statement on this line</div></div>
									<div class="assembly-row-combined"><div>1D31</div><div>OR A<span class="opcode2">B7</span></div><div>There
 wasn't a colon, so the only valid thing we can find now is an END OF 
LINE character (i.e., a NULL).  This will check to see if the character 
in Register A is an end of the BASIC line character</div></div>
									<div class="assembly-row-combined"><div>1D32-1D34</div><div><a href="#1997H" class="memory-link">JP NZ,1997H<span class="origrom2">JP NZ,SNERR</span></a><span class="opcode2">C2 97 19</span></div><div>Go to the Level II BASIC error routine and display a <span class="code">?SN ERROR</span>
 message if the character in Register A isn't an end of the BASIC line 
character since COLON and NULL are the only two valid characters</div></div>
									<div class="assembly-row-combined"><div>1D35</div><div>INC HL<span class="opcode2">23</span></div><div>So
 now we know that we have another line number to check, so bump the 
value of the current BASIC program pointer in Register Pair HL</div></div>

									<div class="assembly-row-combined" id="1D36H"><div>1D36<span class="origrom2">GONE4</span></div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load
 Register A with the LSB of the next BASIC line pointer at the location 
of the current BASIC program pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1D37</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the current BASIC program pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1D38</div><div>OR (HL)<span class="opcode2">B6</span></div><div>Check to see if the next BASIC line pointer is equal to zero</div></div>
									<div class="assembly-row-combined"><div>1D39-1D3B</div><div><a href="#197EH" class="memory-link">JP Z,197EH<span class="origrom2">JP Z,PRGEND</span></a><span class="opcode2">CA 7E 19</span></div><div>If
 that OR matched, then we had two NULL NULL, meaning END OF PROGRAM, so 
JUMP to 197EH since we are at the end of the BASIC program</div></div>
									<div class="assembly-row-combined"><div>1D3C</div><div>INC HL<span class="opcode2">23</span></div><div>If
 we are here, it was not the end of the BASIC program so we need to bump
 the value of the current BASIC program pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1D3D</div><div>LD E,(HL)<span class="opcode2">5E</span></div><div>Load Register E with the LSB of the BASIC line number at the location of the current BASIC program pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1D3E</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the current BASIC program pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1D3F</div><div>LD D,(HL)<span class="opcode2">56</span></div><div>Load Register D with the MSB of the BASIC line number at the location of the current BASIC program pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1D40</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange
 the value of the BASIC line number in Register Pair DE with the value 
of the current BASIC program pointer in Register Pair HL.  HL will now 
hold the line number</div></div>
									<div class="assembly-row-combined"><div>1D41-1D43</div><div>LD (40A2H),HL<span class="origrom2">LD (CURLIN),HL</span><span class="opcode2">22 A2 40</span></div><div>Save the value of the BASIC line number in Register Pair HL into the memory location devoted to tracking that sort of thing</div></div>
									<p class="debug-note">Honor a <span class="code">TRON</span> by showing the line number if it is in effect.</p>
									<div class="assembly-row-combined"><div>1D44-1D46</div><div>LD A,(411BH)<span class="origrom2">LD A,(TRCFLG)</span><span class="opcode2">3A 1B 41</span></div><div>Before we move on, we need to honor a <span class="code">TRON</span>, if its in effect so first we load Register A with the value of the <span class="code">TRON</span> flag.<br>Note: 411BH holds TRON/TROFF flag</div></div>
									<div class="assembly-row-combined"><div>1D47</div><div>OR A<span class="opcode2">B7</span></div><div>Check for <span class="code">TRON</span>.  NZ means that TRACE is on</div></div>
									<div class="assembly-row-combined"><div>1D48-1D49</div><div><a href="#1D59H" class="memory-link">JR Z,1D59H<span class="origrom2">JR Z,NOTTRC</span></a><span class="opcode2">28 0F</span></div><div>Jump out of this routine to 1D59H if <span class="code">TROFF</span></div></div>
									<div class="assembly-row-combined"><div>1D4A</div><div>PUSH DE<span class="opcode2">D5</span></div><div>If we are here, we have to process the code to show the "&lt;nnnn&gt;" of a <span class="code">TRON</span>.  First, save the value of the current BASIC program pointer in Register Pair DE to the STACK</div></div>
									<div class="assembly-row-combined"><div>1D4B-1D4C</div><div>LD A,3CH<span class="opcode2">3E 3C</span></div><div>Load Register A with a <span class="code">&lt;</span></div></div>
									<div class="assembly-row-combined"><div>1D4D-1D4F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH">CALL 032AH<span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go display the &lt; that preceeds the line number in <span class="code">TRON</span> output</div></div>
									<div class="assembly-row-combined"><div>1D50-1D52</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0FAFH">CALL 0FAFH<span class="origrom2">CALL LINPRT</span></a><span class="opcode2">CD AF 0F</span></div><div>Call
 the HL TO ASCII routine at 0FAFH (which converts the value in the HL 
Register Pair (assumed to be an integer) to ASCII and display it at the 
current cursor position on the video screen) to display the current 
BASIC line number</div></div>
									<div class="assembly-row-combined"><div>1D53-1D54</div><div>LD A,3EH<span class="opcode2">3E 3E</span></div><div>Load Register A with a <span class="code">&gt;</span></div></div>
									<div class="assembly-row-combined"><div>1D55-1D57</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH">CALL 032AH<span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go display the &gt; that follows the line number in <span class="code">TRON</span> output</div></div>
									<div class="assembly-row-combined"><div>1D58</div><div>POP DE<span class="opcode2">D1</span></div><div>Get the value of the current BASIC program pointer from the STACK and put it in Register Pair DE</div></div>
									<p class="debug-note">That finishes the TRON routine where we display &lt;nnnn&gt; if it is in effect.</p>
									<div class="assembly-row-combined" id="1D59H"><div>1D59<span class="origrom2">NOTTRC</span></div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Load Register Pair HL with the value of the current BASIC program pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined" id="1D5AH"><div>1D5A<span class="origrom2">GONE</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H">RST 10H<span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We
 need to get the next token.  We bump the current input buffer pointer 
in Register Pair HL until it points to the next character, call the 
EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The RST 10H routine 
parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>1D5B-1D5D</div><div>LD DE,1D1EH<span class="origrom2">LD DE,NEWSTT</span><span class="opcode2">11 1E 1D</span></div><div>Load Register Pair DE with the return address to go to after executing one verb</div></div>
									<div class="assembly-row-combined"><div>1D5E</div><div>PUSH DE<span class="opcode2">D5</span></div><div>Save that return address in Register Pair DE to the STACK</div></div>
									<div class="assembly-row-combined" id="1D5FH"><div>1D5F<span class="origrom2">GONE3</span></div><div>RET Z<span class="opcode2">C8</span></div><div>Return
 (back to 1D1EH) if the character at the location of the current BASIC 
program pointer (in Register Pair HL) is an END OF LINE delimiter</div></div>
									<div class="assembly-row-combined" id="1D60H"><div>1D60-1D61<span class="origrom2">GONE2</span></div><div>SUB 80H<span class="origrom2">SUB $END</span><span class="opcode2">D6 80</span></div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in Register A is a token.  This is accomplished because tokens 
range from 80H-FBH so this would give an index of the current token.  
This is looking for an ON GOTO and ON GOSUB</div></div>
									<div class="assembly-row-combined"><div>1D62-1D64</div><div><a href="#1F21H" class="memory-link">JP C,1F21H<span class="origrom2">JP C,LET</span></a><span class="opcode2">DA 21 1F</span></div><div>If the C FLAG is set, then this must be a <span class="code">LET</span> so jump to 1F21H</div></div>
									<div class="assembly-row-combined"><div>1D65-1D66<span class="origrom2">NUMCMD</span></div><div>CP 3CH<span class="opcode2">FE 3C</span></div><div>Check to see if the token in Register A is below the <span class="code">TAB(</span> token</div></div>
									<div class="assembly-row-combined"><div>1D67-1D69</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2AE7H">JP NC,2AE7H<span class="origrom2">JP NZ,ISMID$</span></a><span class="opcode2">D2 E7 2A</span></div><div>Jump out of here to 2AE7H if the token in Register A is greater than or equal to a <span class="code">TAB(</span> token, meaning <span class="code">TAB(</span> to <span class="code">MID$(</span></div></div>
									<div class="assembly-row-combined"><div>1D6A</div><div>RLCA<span class="opcode2">07</span></div><div>Multiply the token value in Register A by two.  This doubles the remainder of the routine address offset</div></div>
									<div class="assembly-row-combined"><div>1D6B</div><div>LD C,A<span class="opcode2">4F</span></div><div>Load the adjusted token value in Register C from Register A</div></div>
									<div class="assembly-row-combined"><div>1D6C-1D6D</div><div>LD B,00H<span class="opcode2">06 00</span></div><div>Load Register B with zero so that BC now holds "00" and (2 x the token)</div></div>
									<div class="assembly-row-combined"><div>1D6E</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Load Register Pair DE with the value of the current BASIC program pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1D6F-1D71</div><div>LD HL,1822H<span class="origrom2">LD HL,STMDSP</span><span class="opcode2">21 22 18</span></div><div>Load
 Register Pair HL with the list of BASIC execution addresses (called the
 Statement Dispatch Table in the original ROM source code)</div></div>
									<div class="assembly-row-combined"><div>1D72</div><div>ADD HL,BC<span class="opcode2">09</span></div><div>Add
 the value of the token offset in Register Pair BC to the starting 
address of the list of BASIC execution addresses in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1D73</div><div>LD C,(HL)<span class="opcode2">4E</span></div><div>Load Register C with the LSB of the execution address at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1D74</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1D75</div><div>LD B,(HL)<span class="opcode2">46</span></div><div>Load Register B with the MSB of the execution address at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1D76</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the value of the execution address in Register Pair BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>1D77</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Load
 Register Pair HL with the value of the current BASIC program pointer in
 Register Pair DE (i.e., restore the code string address)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1D78H">1D78-1D90 - RST 0010H CODE<span class="origrom"> - "CHRGTR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The RST 10H code is located here.  This is the EXAMINE NEXT 
SYMBOL routine which loads the next character from the string pointed to
 by the HL Register set into the A-register and clears the CARRY flag if
 it is alphabetic, or sets it if is alphanumeric. Blanks and control 
codes 09 and OB are ignored causing the following character to be loaded
 and tested. The HL Register will be incremented before loading any 
character therfore on the first call the HL Register should contain the 
string address minus one. The string must be terminated by a byte of 
zeros).</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1D78H"><div>1D78<span class="origrom2">CHRGTR</span></div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the current BASIC program pointer in Register Pair HL to the next character</div></div>
									<div class="assembly-row-combined"><div>1D79<span class="origrom2">CHRGT2</span></div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load Register A with the value of the character at the location of the current BASIC program pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1D7A-1D7B</div><div>CP 3AH<span class="opcode2">FE 3A</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is greater than or equal to a <span class="code">:</span></div></div>
									<div class="assembly-row-combined"><div>1D7C</div><div>RET NC<span class="opcode2">D0</span></div><div>Return if the character at the location of the current BASIC program pointer in Register A is greater than or equal to a <span class="code">:</span> (meaning <span class="code">:</span>, <span class="code">;</span>, <span class="code">&lt;</span> . <span class="code">Y</span>, <span class="code">Z</span></div></div>
									<div class="assembly-row-combined"><div>1D7D-1D7E<span class="origrom2">CHRCON</span></div><div>CP 20H<span class="origrom2">CP " "</span><span class="opcode2">FE 20</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">SPACE</span></div></div>
									<div class="assembly-row-combined"><div>1D7F-1D81</div><div><a href="#1D78H" class="memory-link">JP Z,1D78H<span class="origrom2">JP Z,CHRGTR</span></a><span class="opcode2">CA 78 1D</span></div><div>Loop if the character at the location of the current BASIC program pointer in Register A is a <span class="code">SPACE</span></div></div>
									<div class="assembly-row-combined"><div>1D82-1D83</div><div>CP 0BH<span class="opcode2">FE 0B</span></div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in Register A is greater than or equal to 0BH (meaning it is not
 a control code)</div></div>
									<div class="assembly-row-combined"><div>1D84-1D85</div><div><a href="#1D8BH" class="memory-link">JR NC,1D8BH<span class="origrom2">JR NC,NOTLFT</span></a><span class="opcode2">30 05</span></div><div>Jump if the character at the location of the current BASIC program pointer in Register A if greater than or equal to 0BH</div></div>
									<div class="assembly-row-combined"><div>1D86-1D87</div><div>CP 09H<span class="opcode2">FE 09</span></div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in Register A is greater than or equal to 09H (meaning a line 
feed or tab)</div></div>
									<div class="assembly-row-combined"><div>1D88-1D8A</div><div><a href="#1D78H" class="memory-link">JP NC,1D78H<span class="origrom2">JP NC,CHRGTR</span></a><span class="opcode2">D2 78 1D</span></div><div>Loop
 back up to get the next character if if the character at the location 
of the current BASIC program pointer in Register A is greater than or 
equal to 09H</div></div>
									<div class="assembly-row-combined" id="1D8BH"><div>1D8B-1D8C<span class="origrom2">NOTLFT</span></div><div>CP 30H<span class="origrom2">CP "0"</span><span class="opcode2">FE 30</span></div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in Register A is greater than or equal to a zero character</div></div>
									<div class="assembly-row-combined"><div>1D8D</div><div>CCF<span class="opcode2">3F</span></div><div>Set the carry flag if that ASCII character is numeric (i.e., greater than or equal to 30H)</div></div>
									<div class="assembly-row-combined"><div>1D8E</div><div>INC A<span class="opcode2">3C</span></div><div>Clear the CARRY FLAG if it is not numeric (i.e., it is less than 30)</div></div>
									<div class="assembly-row-combined"><div>1D8F</div><div>DEC A<span class="opcode2">3D</span></div><div>Set the status flags (except for the CARRY FLAG) according to the character at hand</div></div>
									<div class="assembly-row-combined"><div>1D90</div><div>RET<span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1D91H">1D91-1D9A - LEVEL II BASIC RESTORE ROUTINE<span class="origrom"> - "RESTORE"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1D91H"><div>1D91<span class="origrom2">RESTORE</span></div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Save the contents of HL by loading its contents into DE</div></div>
									<div class="assembly-row-combined"><div>1D92-1D94</div><div>LD HL,(40A4H)<span class="origrom2">LD HL,(TXTTAB)</span><span class="opcode2">2A A4 40</span></div><div>Load Register Pair HL with the start of the BASIC program pointer.<br><b>Note:</b> 40A4H-40A5H holds the starting address of BASIC program text also known as the PROGRAM STATEMENT TABLE (PST)</div></div>
									<div class="assembly-row-combined"><div>1D95</div><div>DEC HL<span class="opcode2">2B</span></div><div>Backspace from the start of the BASIC program pointer, so that it is now TXTTAB - 1</div></div>
									<div class="assembly-row-combined" id="1D96H"><div>1D96-1D98<span class="origrom2">RESFIN</span></div><div>LD (40FFH),HL<span class="origrom2">LD (DATPTR),HL</span><span class="opcode2">22 FF 40</span></div><div>Save the start of the program pointer -1 into 40FFH.<br>Note: 40FFH-4100H holds READ pointer</div></div>
									<div class="assembly-row-combined"><div>1D99</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Restore the poiner to the current character on the BASIC program line being examined back into Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1D9A</div><div>RET<span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1D9BH">1D9B-1DAD - SCAN KEYBOARD ROUTINE<span class="origrom"> - "ISCNTC"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1D9BH"><div>1D9B-1D9D<span class="origrom2">ISCNTC</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0358H">CALL 0358H<span class="origrom2">CALL ISCHAR</span></a><span class="opcode2">CD 58 03</span></div><div>Go scan the keyboard</div></div>
									<div class="assembly-row-combined"><div>1D9E</div><div>OR A<span class="opcode2">B7</span></div><div>Check to see if a key was pressed</div></div>
									<div class="assembly-row-combined"><div>1D9F</div><div>RET Z<span class="opcode2">C8</span></div><div>Return if a key wasn't pressed</div></div>
									<div class="assembly-row-combined" id="1DA0H"><div>1DA0-1DA1<span class="origrom2">CNTCCN</span></div><div>CP 60H<span class="opcode2">FE 60</span></div><div>Check to see if the key pressed in Register A is a <span class="code">SHIFT</span>+<span class="code">@</span></div></div>
									<div class="assembly-row-combined"><div>1DA2-1DA4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0384H">CALL Z,0384H<span class="origrom2">CALL Z,INCHR</span></a><span class="opcode2">CC 84 03</span></div><div>If you got a <span class="code">SHIFT</span>+<span class="code">@</span> we now need to honor that by waiting for yet another key to be pressed</div></div>
									<div class="assembly-row-combined"><div>1DA5-1DA7</div><div>LD (4099H),A<span class="origrom2">LD (CHARC),A</span><span class="opcode2">32 99 40</span></div><div>Save the key pressed in Register A as the value of the last key pressed.<br>Note: 4099H holds the Last key pressed</div></div>
									<div class="assembly-row-combined"><div>1DA8</div><div>DEC A<span class="opcode2">3D</span></div><div>Check to see if the <kbd>BREAK</kbd> key was pressed</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1DA9H">1DA9-1DAD - <span class="code">STOP</span> ROUTINE<span class="origrom"> - "STOP"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1DA9<span class="origrom2">STOP</span></div><div>RET NZ<span class="opcode2">C0</span></div><div>Return if the <kbd>BREAK</kbd> key wasn't pressed.<br>This is the <span class="code">STOP</span> entry point</div></div>
									<div class="assembly-row-combined"><div>1DAA</div><div>INC A<span class="opcode2">3C</span></div><div>Readjust the value of the key pressed in Register A</div></div>
									<div class="assembly-row-combined"><div>1DAB-1DAD</div><div><a href="#1DB4H" class="memory-link">JP 1DB4H<span class="origrom2">JP CONSTP</span></a><span class="opcode2">C3 B4 1D</span></div><div>Jump into the applicable portion of the code that processes <span class="code">END</span></div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1DAEH">1DAE-1DE3 - LEVEL II BASIC <span class="code">END</span> ROUTINE<span class="origrom"> - "END"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1DAE<span class="origrom2">END</span><p></p></div><div>RET NZ<span class="opcode2">C0</span></div><div>Return and display a <span class="code">?SN ERROR</span> message if there is anything following the <span class="code">END</span> token -or- if we did not get a <kbd>BREAK</kbd> </div></div>
									<div class="assembly-row-combined"><div>1DAF</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save all the condition codes and the value in Register Pair AF to the STACK</div></div>
									<div class="assembly-row-combined"><div>1DB0-1DB2</div><div><a href="#41BBH" class="memory-link">CALL Z,41BBH<span class="origrom2">CALL Z,CLSALL</span></a><span class="opcode2">CC BB 41</span></div><div>Jump into DOS to see if it wants to do anything here</div></div>
									<div class="assembly-row-combined"><div>1DB3</div><div>POP AF<span class="opcode2">F1</span></div><div>Restore the condition codes and Register A</div></div>

									<div class="assembly-row-combined" id="1DB4H"><div>1DB4-1DB6<span class="origrom2">CONSTP</span></div><div>LD (40E6H),HL<span class="origrom2">LD (SAVTXT),HL</span><span class="opcode2">22 E6 40</span></div><div>Save the value of the current BASIC program pointer in Register Pair HL.  This will be for a CONTinue.<br>Note: 40E6H-40E7H holds the temporary storage location</div></div>
									<div class="assembly-row-combined"><div>1DB7-1DB9</div><div>LD HL,40B5H<span class="origrom2">LD HL,TEMPST</span><span class="opcode2">21 B5 40</span></div><div>We
 next want to reset the String temp pointer, so load Register Pair HL 
with the starting address of the temporary string work area.<br>Note: 40B5H-40D2H holds Temporary string work area</div></div>
									<div class="assembly-row-combined"><div>1DBA-1DBC</div><div>LD (40B3H),HL<span class="origrom2">LD (TEMPPT),HL</span><span class="opcode2">22 B3 40</span></div><div>Save the value in Register Pair HL as the new temporary string work area pointer.<br>Note: 40B3H-40B4H holds the next available location in the temporary string work area pointer</div></div>
									<div class="assembly-row-combined"><div>1DBD-1DBFH</div><div>LD HL,FFF6H<span class="opcode2">21 F6 FF</span></div><div>Z-80 space saving trick.  If passing down from the prior instruction, the line is run and the next OR FFH line is NOT!</div></div>
									<div class="assembly-row-combined" id="1DBEH"><div>1DBE-1DBF<span class="origrom2">STPEND</span></div><div>OR FFH<span class="opcode2">F6 FF</span></div><div>Force A to be non-zero so as to force the printing of the BREAK message</div></div>
									<div class="assembly-row-combined"><div>1DC0</div><div>POP BC<span class="opcode2">C1</span></div><div>Clears out the NEWSTT return address from the STACK, as we won't be returning</div></div>
									<div class="assembly-row-combined" id="1DC1H"><div>1DC1-1DC3<span class="origrom2">ENDCON</span></div><div>LD HL,(40A2H)<span class="origrom2">LD HL,(CURLIN)</span><span class="opcode2">2A A2 40</span></div><div>Load Register Pair HL with the value of the current BASIC line number in binary.<br>Note: 40A2H-40A3H holds the current BASIC line number</div></div>
									<div class="assembly-row-combined"><div>1DC4</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value of the current BASIC line number (in binary) in Register Pair HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>1DC5</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the value in Register Pair AF to the STACK.  A will be 0 if it is an <span class="code">END</span> and A will be a 1 if it is a <span class="code">STOP</span>.  If A is 0 then it should NOT print the BREAK message</div></div>
									<div class="assembly-row-combined"><div>1DC6</div><div>LD A,L<span class="opcode2">7D</span></div><div>These
 3 instructions test to see if we are in command mode by testing for an 
uninitialized line (meaning a line number of FFFF).  First, load 
Register A with the LSB of the current BASIC line number in Register L</div></div>
									<div class="assembly-row-combined"><div>1DC7</div><div>AND H<span class="opcode2">A4</span></div><div>Combine the MSB of the current BASIC line number in Register H with the LSB of the current BASIC line number in Register A</div></div>
									<div class="assembly-row-combined"><div>1DC8</div><div>INC A<span class="opcode2">3C</span></div><div>Bump the combined value of the current BASIC line number in Register A</div></div>
									<div class="assembly-row-combined"><div>1DC9-1DCA</div><div><a href="#1DD4H" class="memory-link">JR Z,1DD4H<span class="origrom2">JR Z,DIRIS</span></a><span class="opcode2">28 09</span></div><div>Increasing
 FFFF by 1 would flip the Z flag on, meaning there was no line number.  
If there was no line number, skip the next 3 instructions and go to 
1DD4H</div></div>
									<p class="debug-note">If we are here, then there was a line number, so we need to set some locations to enable a CONT command to work.</p>
									<div class="assembly-row-combined"><div>1DCB-1DCD</div><div>LD (40F5H),HL<span class="origrom2">LD (OLDLIN),HL</span><span class="opcode2">22 F5 40</span></div><div>Save the line number we ended on in Register Pair HL.<br>Note: 40F5H-40F6H holds the last line number executed</div></div>
									<div class="assembly-row-combined"><div>1DCE-1DD0</div><div>LD HL,(40E6H)<span class="origrom2">LD HL,(SAVTXT)</span><span class="opcode2">2A E6 40</span></div><div>Load Register Pair HL with the value of the current BASIC program pointer .<br>Note: 40E6H-40E7H holds the temporary storage location</div></div>
									<div class="assembly-row-combined"><div>1DD1-1DD3</div><div>LD (40F7H),HL<span class="origrom2">LD (OLDTXT),HL</span><span class="opcode2">22 F7 40</span></div><div>Save the value of the current BASIC program pointer in Register Pair HL.<br>Note: 40F7H-40F8H holds Last byte executed</div></div>
									<div class="assembly-row-combined" id="1DD4H"><div>1DD4-1DD6<span class="origrom2">DIRIS</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#038BH">CALL 038BH<span class="origrom2">CALL FINLPT</span></a><span class="opcode2">CD 8B 03</span></div><div>Go set the current output device to the video display</div></div>
									<div class="assembly-row-combined"><div>1DD7-1DD9</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#20F9H">CALL 20F9H<span class="origrom2">CALL CRDONZ</span></a><span class="opcode2">CD F9 20</span></div><div>Go display a carriage return if necessary</div></div>
									<div class="assembly-row-combined"><div>1DDA</div><div>POP AF<span class="opcode2">F1</span></div><div>Restore A so we can see if this is an <span class="code">END</span> (where A=0) or a <span class="code">STOP</span> (where A=1)</div></div>
									<div class="assembly-row-combined"><div>1DDB-1DDD</div><div>LD HL,1930H<span class="origrom2">LD HL,BRKTXT</span><span class="opcode2">21 30 19</span></div><div>Load Register Pair HL with the starting address of the <kbd>BREAK</kbd> message</div></div>
									<div class="assembly-row-combined"><div>1DDE-1DE0</div><div><a href="#1A06H" class="memory-link">JP NZ,1A06H<span class="origrom2">JP NZ,ERRFIN</span></a><span class="opcode2">C2 06 1A</span></div><div>Jump to 1A06H if it was a <kbd>BREAK</kbd> or a <span class="code">STOP</span> that halted program execution</div></div>
									<div class="assembly-row-combined"><div>1DE1-1DE3</div><div><a href="#1A18H" class="memory-link">JP 1A18H<span class="origrom2">JP STPRDY</span></a><span class="opcode2">C3 18 1A</span></div><div>At this point it was either due to an <span class="code">END</span>
 statement or an error while in command mode so jump to 1A18H  (note: 
This uses a Z-80 trick as 1A18H is in the middle of a 2 Opcode 
instruction starting at 1A17H)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1DE4H">1DE4-1DF6 - LEVEL II BASIC CONT ROUTINE<span class="origrom"> - "CONT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1DE4-1DE6<span class="origrom2">CONT</span></div><div>LD HL,(40F7H)<span class="origrom2">LD HL,(OLDTXT)</span><span class="opcode2">2A F7 40</span></div><div>Load
 Register Pair HL with the value of the continuation address.  A stored 
text pointer of 0000 is set up by STKINI if there is nothing to CONTinue<br>Note: 40F7H-40F8H holds Last byte executed</div></div>
									<div class="assembly-row-combined"><div>1DE7</div><div>LD A,H<span class="opcode2">7C</span></div><div>Load Register A with the MSB of the continuation address in Register H</div></div>
									<div class="assembly-row-combined"><div>1DE8</div><div>OR L<span class="opcode2">B5</span></div><div>Combine
 the LSB of the continuation address in Register L with the MSB of the 
continuation address in Register A.  If there was nothing in HL, this 
would trigger a Z flag.  There should be nothing in the HL flag if there
 was a STOP, END, hitting <kbd>ENTER<kbd> in response to an INPUT request, and hitting <kbd>BREAK</kbd> </kbd></kbd></div></div>
									<div class="assembly-row-combined"><div>1DE9-1DEA<span class="origrom2">RESERR</span></div><div>LD E,20H<span class="origrom2">LD E,ERRCN</span><span class="opcode2">1E 20</span></div><div>Load Register E with a <span class="code">?CN ERROR</span> code</div></div>
									<div class="assembly-row-combined"><div>1DEB-1DED</div><div><a href="#19A2H" class="memory-link">JP Z,19A2H<span class="origrom2">JP Z,ERROR</span></a><span class="opcode2">CA A2 19</span></div><div>Go to the <span class="code">?CN ERROR</span> routine if <span class="code">CONT</span> isn't possible (meaning the line number was zero)</div></div>
									<div class="assembly-row-combined"><div>1DEE</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>If
 we are here, there was a valid return line number, so load Register 
Pair DE with the value of the continuation line number in Register Pair 
HL</div></div>
									<div class="assembly-row-combined"><div>1DEF-1DF1</div><div>LD HL,(40F5H)<span class="origrom2">LD HL,(OLDLIN)</span><span class="opcode2">2A F5 40</span></div><div>Load HL with the value of the last BASIC line number executed.<br>Note: 40F5H-40F6H holds the last line number executed</div></div>
									<div class="assembly-row-combined"><div>1DF2-1DF4</div><div>LD (40A2H),HL<span class="origrom2">LD (CURLIN),HL</span><span class="opcode2">22 A2 40</span></div><div>Save the last line number executed in Register Pair HL (which had the error) as the current BASIC line number.<br>Note: 40A2H-40A3H holds the current BASIC line number</div></div>
									<div class="assembly-row-combined"><div>1DF5</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Swap so that HL will be the address of the continuation line</div></div>
									<div class="assembly-row-combined"><div>1DF6</div><div>RET<span class="opcode2">C9</span></div><div>Return (continue running but from the <span class="code">CONT</span> line number)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1DF7H">1DF7-1DF8 - TRON ENTRY POINT<span class="origrom"> - "TON"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Turns <span class="code">TRON</span> feature on. Causes line numbers for each BASIC statement executed to be displayed. Uses Register A.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1DF7-1DF8<span class="origrom2">TON</span></div><div>LD A,0AFH<span class="opcode2">3E AF</span></div><div>Load
 Register A with a nonzero value.  Note that this value was chosen 
simply because this is also a Z-80 trick.  If 1DF8 is jumped into, that 
is XOR A which will set A to zero instead of this value</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1DF8H">1DF8 - TROFF ENTRY POINT<span class="origrom"> - "TOFF"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1DF8H"><div>1DF8<span class="origrom2">TOFF</span></div><div>XOR A<span class="opcode2">AF</span></div><div>Z-80 trick.  This command is only visible if jumped to.  This zeros Register A</div></div>
									<p class="debug-note">The following code is common to both TRON and TROFF.</p>
									<div class="assembly-row-combined"><div>1DF9-1DFB</div><div>LD (411BH),A<span class="origrom2">LD (TRCFLG),A</span><span class="opcode2">32 1B 41</span></div><div>Save the value in Register A as the current value of the TRON/TROFF flag.<br>Note: 411BH holds TRON/TROFF flag</div></div>
									<div class="assembly-row-combined"><div>1DFC</div><div>RET<span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1DFDH">1DFD-1DFF - DISK ROUTINE NOT USED BY LEVEL II BASIC<span class="origrom"> - "POPAHT"</span>.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1DFD<span class="origrom2">POPAHT</span></div><div>POP AF</div></div>
									<div class="assembly-row-combined"><div>1DFE<span class="opcode2">E1</span></div><div>POP HL</div><div>Restore the pointer to the BASIC program line being parsed into Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1DFF</div><div>RET</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1E00H">1E00-1E02 - <span class="code">DEFSTR</span> ENTRY POINT<span class="origrom"> - "DEFSTR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1E00-1E01<span class="origrom2">DEFSTR</span><span class="opcode2">1E 03</span></div><div>LD E,03H</div><div>Load Register E with the <span class="code">DEFSTR</span> string number type flag (03H)</div></div>
									<div class="assembly-row-combined"><div>1E02-1E04</div><div>LD BC,021EH<span class="opcode2">01 1E 02</span></div><div>Z-80
 Trick!  If this line is found via pass through, the BC is just loaded 
with this number, and then others, until it hits 1E0BH with E still 
holding 3</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1E03H">1E03-1E05 - DEFINT ENTRY POINT<span class="origrom"> - "DEFINT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1E03-1E04<span class="origrom2">DEFINT</span></div><div>LD E,02H<span class="opcode2">1E 02</span></div><div>Load Register E with the <span class="code">DEFINT</span> integer number type flag (02H)</div></div>
									<div class="assembly-row-combined"><div>1E05</div><div>LD BC,041EH<span class="opcode2">01 1E 04</span></div><div>Z-80
 Trick!  If this line is found via pass through, the BC is just loaded 
with this number, and then others, until it hits 1E0BH with E still 
holding 2</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1E06H">1E06-1E08 - DEFSNG ENTRY POINT<span class="origrom"> - "DEFREA"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1E06-1E07<span class="origrom2">DEFREA</span></div><div>LD E,04H<span class="opcode2">1E 04</span></div><div>Load Register E with the <span class="code">DEFSNG</span> single precision number type flag (04H)</div></div>
									<div class="assembly-row-combined"><div>1E08</div><div>LD BC,081EH<span class="opcode2">01 1E 08</span></div><div>Z-80
 Trick!  If this line is found via pass through, the BC is just loaded 
with this number, and then others, until it hits 1E0BH with E still 
holding 4</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1E09H">1E09-1E0A - DEFDBL ENTRY POINT<span class="origrom"> - "DEFDBL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1E09-1E0A<span class="origrom2">DEFDBL</span></div><div>LD E,08H<span class="opcode2">1E 08</span></div><div>Load Register E with the <span class="code">DEFDBL</span> double precision number type flag (08H)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1E0BH">1E0B-1E3C - COMMON CODE SHARED BY <span class="code">DEFSTR</span>/<span class="code">DEFINT</span>/<span class="code">DEFSNG</span>/<span class="code">DEFDBL</span><span class="origrom"> - "DEFCON"</span>.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>All of those can either have a <span class="code">-</span> for a range of values or be separated by <span class="code">,</span>.  This code needs to figure out the variables that followed the <span class="code">DEF???</span> instruction and then set the variable type (which is currently sitting in Register E) in the variable table</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1E0BH"><div>1E0B-1E0D<span class="origrom2">DEFCON</span></div><div><a href="#1E3DH" class="memory-link">CALL 1E3DH<span class="origrom2">CALL ISLET</span></a><span class="opcode2">CD 3D 1E</span></div><div>A
 call to 1E3DH checks the value at memory location (HL), which would be 
the current BASIC program pointer, to see if it is a letter.  If its 
not, CARRY is set.  If it is, CARRY is clear</div></div>
									<div class="assembly-row-combined"><div>1E0E-1E10</div><div>LD BC,1997H<span class="origrom2">LD BC,SNERR</span><span class="opcode2">01 97 19</span></div><div>Load Register Pair BC with a return address which will return to the <span class="code">?SN ERROR</span> routine</div></div>
									<div class="assembly-row-combined"><div>1E11</div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the ?SN ERROR address (in Register Pair BC) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1E12</div><div>RET C<span class="opcode2">D8</span></div><div>Return if the character at the location of the current BASIC program pointer in Register A isn't alphabetic (meaning that <span class="code">DEF???</span> wasn't followed by a letter)</div></div>
									<div class="assembly-row-combined"><div>1E13-1E14</div><div>SUB 41H<span class="opcode2">D6 41</span></div><div>Subtract 41H from the letter's value in Register A so that it will be in the range of 0-25</div></div>
									<div class="assembly-row-combined"><div>1E15</div><div>LD C,A<span class="opcode2">4F</span></div><div>Load Register C with the offset (i.e., adjusted value in Register A)</div></div>
									<div class="assembly-row-combined"><div>1E16</div><div>LD B,A<span class="opcode2">47</span></div><div>Load Register B with the same, under the assumption that it will get updated at some point</div></div>
									<div class="assembly-row-combined"><div>1E17</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H">RST 10H<span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>Since
 we now need bump the value of the current BASIC program pointer until 
it points to the next character, call the EXAMINE NEXT SYMBOL routine at
 RST 10H.<br><br>The RST 10H routine parses the characters starting at 
HL+1 for the first non-SPACE,non-09H,non-0BH character it finds.  On 
exit, Register A will hold that character, and the C FLAG is set if its 
alphabetic, and NC FLAG if its alphanumeric.  All strings must have a 
00H at the end.</div></div>
									<div class="assembly-row-combined"><div>1E18-1E19</div><div>CP 0CEH<span class="origrom2">CP MINUTK</span><span class="opcode2">FE CE</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">-</span></div></div>
									<div class="assembly-row-combined"><div>1E1A-1E1B</div><div><a href="#1E25H" class="memory-link">JR NZ,1E25H<span class="origrom2">JR NZ,NOTRNG</span></a><span class="opcode2">20 09</span></div><div>If it's not a <span class="code">-</span> we know this isn't a range, so jump to 1E25H because we don't need to get any more variables</div></div>
									<div class="assembly-row-combined"><div>1E1C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H">RST 10H<span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>If we are here, then we know the <span class="code">DEF???</span>
 has a range, so we need another character.  We bump the value of the 
current BASIC program pointer until it points to the next character, 
call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The RST 10H 
routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>1E1D-1E1F</div><div><a href="#1E3DH" class="memory-link">CALL 1E3DH<span class="origrom2">CALL ISLET</span></a><span class="opcode2">CD 3D 1E</span></div><div>A
 call to 1E3DH checks the value at memory location (HL), which would be 
the current BASIC program pointer, to see if it is a letter.  If its 
not, CARRY is set.  If it is, CARRY is clear</div></div>
									<div class="assembly-row-combined"><div>1E20</div><div>RET C<span class="opcode2">D8</span></div><div>Return with a ?SN ERROR if the character at the location of the current BASIC program pointer in Register A isn't alphabetic</div></div>
									<div class="assembly-row-combined"><div>1E21-1E22</div><div>SUB 41H<span class="opcode2">D6 41</span></div><div>Subtract 41H from the letter's value in Register A so that it will be in the range of 0-25</div></div>
									<div class="assembly-row-combined"><div>1E23</div><div>LD B,A<span class="opcode2">47</span></div><div>Overwrite Register B with the offset for the end of range letter variable</div></div>
									<div class="assembly-row-combined"><div>1E24</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H">RST 10H<span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>Since
 we now need bump the value of the current BASIC program pointer until 
it points to the next character, call the EXAMINE NEXT SYMBOL routine at
 RST 10H.<br><br>The RST 10H routine parses the characters starting at 
HL+1 for the first non-SPACE,non-09H,non-0BH character it finds.  On 
exit, Register A will hold that character, and the C FLAG is set if its 
alphabetic, and NC FLAG if its alphanumeric.  All strings must have a 
00H at the end.</div></div>
									<div class="assembly-row-combined" id="1E25H"><div>1E25<span class="origrom2">NOTRNG</span></div><div>LD A,B<span class="opcode2">78</span></div><div>Load Register A with the value of the second letter in Register B</div></div>
									<div class="assembly-row-combined"><div>1E26</div><div>SUB C<span class="opcode2">91</span></div><div>Subtract the value of the first letter in Register C from the value of the second letter in Register A</div></div>
									<div class="assembly-row-combined"><div>1E27</div><div>RET C<span class="opcode2">D8</span></div><div>If
 the varible names are not in ascending order (the one in C is earlier 
than the one in A), the CARRY FLAG will ahve been set, so RETurn to a 
?SN ERROR</div></div>
									<div class="assembly-row-combined"><div>1E28</div><div>INC A<span class="opcode2">3C</span></div><div>Bump the value in Register A so that it holds the number of variable names to be changed</div></div>
									<div class="assembly-row-combined"><div>1E29</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Save the pointer to the next character to be parsed in the BASIC program to the STACK, and clear the error address</div></div>
									<div class="assembly-row-combined"><div>1E2A-1E2C</div><div>LD HL,4101H<span class="origrom2">LD HL,DEFTBL</span><span class="opcode2">21 01 41</span></div><div>Load Register Pair HL with the starting address of the variable declaration table.<br>Note: 4101H-411AH holds Variable Declaration Table</div></div>
									<div class="assembly-row-combined"><div>1E2D-1E2E</div><div>LD B,00H<span class="opcode2">06 00</span></div><div>Load Register B with zero so that the starting offset in Register C can be utilized in 16 bit math</div></div>
									<div class="assembly-row-combined"><div>1E2F</div><div>ADD HL,BC<span class="opcode2">09</span></div><div>Make
 HL point to the first entry in the variable table to be modified by 
adding the value of the first letter in Register Pair BC to the value of
 the starting address of the variable declaration table in Register Pair
 HL</div></div>
									<div class="assembly-row-combined" id="1E30H"><div>1E30<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;LPDCHG</span></div><div>LD (HL),E<span class="opcode2">73</span></div><div>Top
 of a loop.  E was set on entry to string, integer, single precision, or
 double precision as applicable.  Save the number type flag in Register E
 at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1E31</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1E32</div><div>DEC A<span class="opcode2">3D</span></div><div>Decrement
 the count of the number of variables to be changed in Register A so as 
to track the number of changes remaining to be made</div></div>
									<div class="assembly-row-combined"><div>1E33-1E34</div><div><a href="#1E30H" class="memory-link">JR NZ,1E30H<span class="origrom2">JR NZ,LPDCHG</span></a><span class="opcode2">20 FB</span></div><div>Loop until all of the variables in the <span class="code">DEFxxx</span> range have been changed</div></div>
									<div class="assembly-row-combined"><div>1E35</div><div>POP HL<span class="opcode2">E1</span></div><div>Restore the pointer to the BASIC program line being processed into Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1E36</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Fetch the last character in the BASIC program line being processed into Register A</div></div>
									<div class="assembly-row-combined"><div>1E37-1E38</div><div>CP 2CH<span class="opcode2">FE 2C</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">,</span></div></div>
									<div class="assembly-row-combined"><div>1E39</div><div>RET NZ<span class="opcode2">C0</span></div><div>Return if the character at the location of the current BASIC program pointer in Register A isn't a <span class="code">,</span></div></div>
									<div class="assembly-row-combined"><div>1E3A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H">RST 10H<span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>Since
 we now need bump the value of the current BASIC program pointer until 
it points to the next character, call the EXAMINE NEXT SYMBOL routine at
 RST 10H.<br><br>The RST 10H routine parses the characters starting at 
HL+1 for the first non-SPACE,non-09H,non-0BH character it finds.  On 
exit, Register A will hold that character, and the C FLAG is set if its 
alphabetic, and NC FLAG if its alphanumeric.  All strings must have a 
00H at the end.</div></div>
									<div class="assembly-row-combined"><div>1E3B-1E3C</div><div><a href="#1E0BH" class="memory-link">JR 1E0BH<span class="origrom2">JR DEFCON</span></a><span class="opcode2">18 CE</span></div><div>Loop until done with all the variables</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1E3DH">1E3D-1E44 - EXAMINE VARIABLE<span class="origrom"> - "ISLET"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine tests the value pointed to by the HL Register 
Pair and sets the C FLAG if it is an ASCII letter value; and otherwise 
the NC FLAG is set.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1E3DH"><div>1E3D<span class="origrom2">ISLET</span></div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the current BASIC program pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1E3E-1E3F<span class="origrom2">ISLET2</span></div><div>CP 41H<span class="origrom2">CP "A"</span><span class="opcode2">FE 41</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is less than an "A"</div></div>
									<div class="assembly-row-combined"><div>1E40</div><div>RET C<span class="opcode2">D8</span></div><div>Return early if the character at the location of the current BASIC program pointer in Register A is less than an A</div></div>
									<div class="assembly-row-combined"><div>1E41-1E42</div><div>CP 5BH<span class="origrom2">CP "Z"+1</span><span class="opcode2">FE 5B</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is greater than a "Z"</div></div>
									<div class="assembly-row-combined"><div>1E43</div><div>CCF<span class="opcode2">3F</span></div><div>Complement
 the value of the Carry flag. On exit this routine will have the Carry 
flag set if the character at the location of the current BASIC program 
pointer in Register A isn't alphabetic and will have the Carry flag 
cleared if the character at the location of the current BASIC program 
pointer in Register A is alphabetic</div></div>
									<div class="assembly-row-combined"><div>1E44</div><div>RET<span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1E45H">1E45-1E4E - EXAMINE VARIABLE<span class="origrom"> - "INTIDX"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is called when evaluating a subscript for a variable reference.  It will evaluate if the value is positive or negative.<br><br>
 According to the original ROM source code, this routine reads a formula
 from the current position and turns it into a positive integer, with 
the result put into Register Pair DE.  Negative arguments are not 
allowed.  On exit, Register Pair HL wil point to the terminating 
character of the formula on the BASIC program line being examined.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1E45H"><div>1E45<span class="origrom2">INTIDX</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H">RST 10H<span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>Get
 the next symbol from the input.  Bump the value of the current BASIC 
program pointer until it points to the next character, call the EXAMINE 
NEXT SYMBOL routine at RST 10H.<br><br>The RST 10H routine parses the 
characters starting at HL+1 for the first non-SPACE,non-09H,non-0BH 
character it finds.  On exit, Register A will hold that character, and 
the C FLAG is set if its alphabetic, and NC FLAG if its alphanumeric.  
All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined" id="1E46H"><div>1E46-1E48<span class="origrom2">INTID2</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2B02H">CALL 2B02H<span class="origrom2">CALL GETIN2</span></a><span class="opcode2">CD 02 2B</span></div><div>Go
 evaluate the expression at the current location of the BASIC program 
pointer in Register Pair HL and return with the integer result in 
Register Pair DE and the condition codes set based on the high order of 
the result</div></div>
									<div class="assembly-row-combined"><div>1E49</div><div>RET P<span class="opcode2">F0</span></div><div>Return if the integer result in Register Pair DE is positive.  If it is negative, flow down to the <span class="code">?FC ERROR</span></div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1E4AH">1E4A - ?FC ERROR entry point<span class="origrom"> - "FCERR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1E4AH"><div>1E4A-1E4B<span class="origrom2">FCERR</span><p></p></div><div>LD E,08H<span class="opcode2">1E 08</span></div><div>Load Register E with an <span class="code">?FC ERROR</span> code</div></div>
									<div class="assembly-row-combined"><div>1E4C-1E4E</div><div><a href="#19A2H" class="memory-link">JP 19A2H<span class="origrom2">JP ERROR</span></a><span class="opcode2">C3 A2 19</span></div><div>Display a <span class="code">?FC ERROR</span> message.  If this is from a pass through, the error wll show if the integer result in Register Pair DE is negative</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1E4FH">1E4F-1E79 - Line Number Conversion Routine 1 <span class="origrom"> -  "LINSPC"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source code, LINSPC and LINGET 
are identical except t hat LINSPC also permits the use of a "." to act 
as the current line number.  Otherwise, They read the line number from 
the current position in the BASIC program.  Possible line numbers are 
00000-65529.  On exit, DE holds the line number, and HL is updated to 
point to the terminating character, and Register A will contain the 
terminating character with the FLAGs set based on Register A's value.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1E4FH"><div>1E4F<span class="origrom2">LINSPC</span></div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the current BASIC program pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1E50-1E51</div><div>CP 2EH<span class="origrom2">CP "."</span><span class="opcode2">FE 2E</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">.</span></div></div>
									<div class="assembly-row-combined"><div>1E52</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Load Register Pair DE with the value of the current BASIC program pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1E53-1E55</div><div>LD HL,(40ECH)<span class="origrom2">LD HL,(DOT)</span><span class="opcode2">2A EC 40</span></div><div>Load Register Pair HL with the current BASIC line number.<br>Note: 40ECH-40EDH holds current line number</div></div>
									<div class="assembly-row-combined"><div>1E56</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange
 the value of the current BASIC program pointer in Register Pair DE with
 the current BASIC line number in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1E57-1E59</div><div><a href="#1D78H" class="memory-link">JP Z,1D78H<span class="origrom2">JP Z,CHRGTR</span></a><span class="opcode2">CA 78 1D</span></div><div>Jump
 to the RST 10H (EXAMINE NEXT SYMBOL) routine if the character at the 
location of the current BASIC program pointer in Register A is a <span class="code">.</span></div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1E5AH">1E5A - Line Number Conversion Routine 2<span class="origrom"> - "LINGET"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Converts numeric ASCII string pointed to by the HL Register 
Pair, to HEX and places the result in the DE Register Pair. After 
execution HL points to the delimiter and the A Register contains the 
delimiter value. The Z flag is set if the delimiter equals 00 or 3A. Z 
is reset if any other delimiter is used. If there is no string at the 
location pointed to by HL the routine will return a MO ERROR (missing 
operand). If the result in the DE Register Pair exceeds FFFFH an OV 
ERROR (overflow) results.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1E5AH"><div>1E5A<span class="origrom2">LINGET</span></div><div>DEC HL<span class="opcode2">2B</span></div><div>Backspace HL (the current BASIC program pointer) to the current character</div></div>
									<div class="assembly-row-combined" id="1E5BH"><div>1E5B-1E5D<span class="origrom2">LINGT2</span></div><div>LD DE,0000H<span class="opcode2">11 00 00</span></div><div>Since Register Pair DE will be the "accumulator" for the result, start it off at zero</div></div>
									<div class="assembly-row-combined" id="1E5EH"><div>1E5E<span class="origrom2">MORLIN</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H">RST 10H<span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>Top of a loop.  Re-process that previous character through a RST 10H call.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>1E5F</div><div>RET NC<span class="opcode2">D0</span></div><div>Return if the character at the location of the current BASIC program pointer in Register A isn't numeric</div></div>
									<div class="assembly-row-combined"><div>1E60</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in Register Pair HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>1E61</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the value in Register Pair AF (which is the digit plus flags resulting from the RST 10H call) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1E62-1E64</div><div>LD HL,1998H<span class="opcode2">21 98 19</span></div><div>Load Register Pair HL with 6552.<br><br>Why
 6552?  Well, since the Z-80 has no multiply function, checking for any 
possible arbitrary number would require 4 branches for each step in the 
'add to itself until it hits * 10' plus another 4 when adding the last 
digit.  The TRS-80 ROM didn't have that kind of room, nor the time to do
 all that, so they needed a cheat and that cheat was to let it go as 
high 65529.  After all, 6552 + 1 more digit can NEVER exceed 65535, but 
6553 + 1 digit sure can!<br><br>So with this trick, the ROM just needs 
to first check the number against 6552, which, when multiplied by 10, 
and adding one more digit, will never exceed 65529 (because 9 is the 
highest one number can go).<br><br>By using this trick, only 1 
comparison is needed (is it greater or less than 6552) . at the cost of 4
 usable line numbers/memory size setting in the 6553x range.<br><br>Wait,
 you say.  65535-65529 is 6 numbers, so why do you say 4.  Well, another
 shortcut the ROM uses is that it assumes anything at line number 65535 
is being entered in direct mode (i.e., no line number; just a command), 
so 65535 couldn't be a line number.  Similarly, in 1A09, 65534 is 
reserved to trigger the BASIC interpreter to jump to the initial powerup
 routine in the ROM (i.e., a reboot) so you couldn't use that line 
number either</div></div>
									<div class="assembly-row-combined"><div>1E65</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H">RST 18H<span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now
 we need to check to see if the integer value in DE is greater than 
6552, so we call the COMPARE DE:HL routine, which numerically compares 
DE and HL. Will not work for signed integers (except positive ones). 
Uses the A-register only. The result of the comparison is returned in 
the status Register as:  <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>1E66-1E68</div><div><a href="#1997H" class="memory-link">JP C,1997H<span class="origrom2">JP C,SNERR</span></a><span class="opcode2">DA 97 19</span></div><div>Go to the Level II BASIC error routine and display a SN ERROR message if the value in Register Pair DE is greater than 6552</div></div>
									<p class="debug-note">Now we need HL = DE * 10</p>
									<div class="assembly-row-combined"><div>1E69</div><div>LD H,D<span class="opcode2">62</span></div><div>Load Register H with the MSB of the integer total in Register D.<br><br>This is so we can multiply HL (which should hold the number 6552) by 10</div></div>
									<div class="assembly-row-combined"><div>1E6A</div><div>LD L,E<span class="opcode2">6B</span></div><div>Load Register L with the LSB of the integer total in Register E.<br><br>This is so we can multiply HL (which should hold the number 6552) by 10</div></div>
									<div class="assembly-row-combined"><div>1E6B</div><div>ADD HL,DE<span class="opcode2">19</span></div><div>Multiply the integer value in Register Pair HL by two</div></div>
									<div class="assembly-row-combined"><div>1E6C</div><div>ADD HL,HL<span class="opcode2">29</span></div><div>Add
 HL to itself, which is the same as multiplying the integer value in 
Register Pair HL by two. The integer result in Register Pair HL is now 
equal to the integer value in Register Pair DE times four</div></div>
									<div class="assembly-row-combined"><div>1E6D</div><div>ADD HL,DE<span class="opcode2">19</span></div><div>Add
 the integer value in Register Pair DE to the integer value in Register 
Pair HL. The integer result in Register Pair HL is now equal to the 
integer value in Register Pair DE times five</div></div>
									<div class="assembly-row-combined"><div>1E6E</div><div>ADD HL,HL<span class="opcode2">29</span></div><div>Add
 HL to itself, which is the same as multiplying the integer value in 
Register Pair HL by two. The integer result in Register Pair HL is now 
equal to the integer value in Register Pair DE times ten.  Now HL is 
65520</div></div>
									<div class="assembly-row-combined"><div>1E6F</div><div>POP AF<span class="opcode2">F1</span></div><div>Put the last ASCII digit (from the STACK) into AF</div></div>
									<div class="assembly-row-combined"><div>1E70-1E71</div><div>SUB 30H<span class="origrom2">SUB "0"</span><span class="opcode2">D6 30</span></div><div>Convert the ASCII digit in Register A to binary</div></div>
									<div class="assembly-row-combined"><div>1E72</div><div>LD E,A<span class="opcode2">5F</span></div><div>Load Register E with the binary value of the character in Register A</div></div>
									<div class="assembly-row-combined"><div>1E73-1E74</div><div>LD D,00H<span class="opcode2">16 00</span></div><div>Load Register D with zero so that DE will be 0000 through 0009 (the binary equivalent of the digit)</div></div>
									<div class="assembly-row-combined"><div>1E75</div><div>ADD HL,DE<span class="opcode2">19</span></div><div>Add the binary value of the character in Register Pair DE to the integer value in Register Pair HL<br><br>As noted above, adding in any digit can only result in HL going to 65529</div></div>
									<div class="assembly-row-combined"><div>1E76</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Swap DE and HL.  This will have the effect of setting DE to be 10(base 10) * DE + A</div></div>
									<div class="assembly-row-combined"><div>1E77</div><div>POP HL<span class="opcode2">E1</span></div><div>Restore the pointer to the next digit (from the STACK) into HL</div></div>
									<div class="assembly-row-combined"><div>1E78-1E79</div><div><a href="#1E5EH" class="memory-link">JR 1E5EH<span class="origrom2">JR MORLIN</span></a><span class="opcode2">18 E4</span></div><div>Loop until the ASCII to binary conversion has been completed</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1E7AH">1E7A-1EA0 - LEVEL II BASIC <span class="code">CLEAR</span> ROUTINE<span class="origrom"> - "CLEAR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source code, this will change 
the amount of string space allowed.  If no formula is given, the amount 
of string space will remain unchanged.  On entry, if the Z flag is set, 
there was no parameter present</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1E7A-1E7C<span class="origrom2">CLEAR</span></div><div><a href="#1B61H" class="memory-link">JP Z,1B61H<span class="origrom2">JP Z,CLEARC</span></a><span class="opcode2">CA 61 1B</span></div><div>Jump
 to 1B61H (which will set all 26 variables to single precision) if there
 isn't a number of bytes specified to clear for string space</div></div>
									<div class="assembly-row-combined"><div>1E7D-1D7F</div><div><a href="#1E46H" class="memory-link">CALL 1E46H<span class="origrom2">CALL INTID2</span></a><span class="opcode2">CD 46 1E</span></div><div>Go evaluate the number of bytes to be reserved for string space and return with the integer result in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1E80</div><div>DEC HL<span class="opcode2">2B</span></div><div>Decrement the current BASIC program pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1E81</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H">RST 10H<span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>Evaluate
 the next instruction through a RST 10H call.  This will bump the value 
of the current BASIC program pointer until it points to the next 
character, call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The 
RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>1E82</div><div>RET NZ<span class="opcode2">C0</span></div><div>Return
 out of the routine if the character at the location of the current 
BASIC program pointer isn't an end of the BASIC statement character</div></div>
									<div class="assembly-row-combined"><div>1E83</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in Register Pair HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>1E84-1E86</div><div>LD HL,(40B1H)<span class="origrom2">LD HL,(MEMSIZ)</span><span class="opcode2">2A B1 40</span></div><div>Load the top of memory pointer into Register Pair HL.<br>Note: 40B1H-40B2H holds MEMORY SIZE? pointer</div></div>
									<div class="assembly-row-combined"><div>1E87</div><div>LD A,L<span class="opcode2">7D</span></div><div>Load Register A with the LSB of the top of memory pointer in Register L</div></div>
									<div class="assembly-row-combined"><div>1E88</div><div>SUB E<span class="opcode2">93</span></div><div>Subtract the LSB of the number of bytes for string space in Register E from the LSB of the top of memory pointer in Register A</div></div>
									<div class="assembly-row-combined"><div>1E89</div><div>LD E,A<span class="opcode2">5F</span></div><div>Load Register E with the LSB of the start of string space in Register A</div></div>
									<div class="assembly-row-combined"><div>1E8A</div><div>LD A,H<span class="opcode2">7C</span></div><div>Load Register A with the MSB of the top of memory pointer in Register H</div></div>
									<div class="assembly-row-combined"><div>1E8B</div><div>SBC A,D<span class="opcode2">9A</span></div><div>Subtract the MSB of the number of bytes for string space in Register D from the MSB of the top of memory pointer in Register A</div></div>
									<div class="assembly-row-combined"><div>1E8C</div><div>LD D,A<span class="opcode2">57</span></div><div>Load Register D with the MSB of the start of string space pointer in Register A</div></div>
									<div class="assembly-row-combined"><div>1E8D-1E8F</div><div><a href="#197AH" class="memory-link">JP C,197AH<span class="origrom2">JR C,OMERR</span></a><span class="opcode2">DA 7A 19</span></div><div>If
 the CARRY flag was triggered there isn't enough memory for the amount 
of string space specified, so go show a ?OM ERROR message</div></div>
									<div class="assembly-row-combined"><div>1E90-1E92</div><div>LD HL,(40F9H)<span class="origrom2">LD HL,(VARTAB)</span><span class="opcode2">2A F9 40</span></div><div>Load Register Pair HL with the end of the BASIC program pointer.<br>Note: 40F9H-40FAH holds the starting address of the simple variable storage area</div></div>
									<div class="assembly-row-combined"><div>1E93-1E95</div><div>LD BC,0028H<span class="opcode2">01 28 00</span></div><div>Load Register Pair BC with the least amount of space needed for BASIC program variables just so that we have some breathing room</div></div>
									<div class="assembly-row-combined"><div>1E96</div><div>ADD HL,BC<span class="opcode2">09</span></div><div>Add the value in Register Pair BC to the end of BASIC program pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1E97</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H">RST 18H<span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now
 we need to check to the adjusted end of the BASIC program pointer (in 
HL) with the start of the string space pointer (in DE), so we call the 
COMPARE DE:HL routine, which numerically compares DE and HL. Will not 
work for signed integers (except positive ones). Uses the A-register 
only. The result of the comparison is returned in the status Register 
as:  <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>1E98-1E9A</div><div><a href="#197AH" class="memory-link">JP NC,197AH<span class="origrom2">JP NC,OMERR</span></a><span class="opcode2">D2 7A 19</span></div><div>Display an <span class="code">?OM ERROR</span>
 message if the start of string space pointer in Register Pair DE is 
less than the adjusted end of the BASIC program pointer in Register Pair
 HL</div></div>
									<div class="assembly-row-combined"><div>1E9B</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Put the new start of the string area address into HL</div></div>
									<div class="assembly-row-combined"><div>1E9C-1E9E</div><div>LD (40A0H),HL<span class="origrom2">LD (STKTOP),HL</span><span class="opcode2">22 A0 40</span></div><div>Load the start of string space pointer with HL.  40A0H-40A1H holds the start of string space pointer</div></div>
									<div class="assembly-row-combined"><div>1E9F</div><div>POP HL<span class="opcode2">E1</span></div><div>Restore the code string pointer back into HL</div></div>
									<div class="assembly-row-combined"><div>1EA0-1EA2</div><div><a href="#1B61H" class="memory-link">JP 1B61H<span class="origrom2">JP CLEARC</span></a><span class="opcode2">C3 61 1B</span></div><div>Jump to 1B61H</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1EA3H">1EA3-1EB0 - LEVEL II BASIC <span class="code">RUN</span> ROUTINE<span class="origrom"> - "RUN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>On entry, if the Z flag is set, there was no parameter present</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1EA3-1EA5<span class="origrom2">RUN</span></div><div><a href="#1B5DH" class="memory-link">JP Z,1B5DH<span class="origrom2">JP Z,RUNC</span></a><span class="opcode2">CA 5D 1B</span></div><div>Jump to 1B5DH if there isn't a line number specified after the <span class="code">RUN</span> token</div></div>
									<div class="assembly-row-combined"><div>1EA6-1EA9</div><div><a href="#1B5DH" class="memory-link">CALL 41C7H<span class="origrom2">CALL LRUN</span></a><span class="opcode2">CD C7 41</span></div><div>GOSUB
 to 41C7H to see if DOS wants to do anything here - if so clean up the 
BASIC variables and pointer, set HL=TXTTAB-1 and RETurn to NEWSTT</div></div>
									<div class="assembly-row-combined"><div>1EA9-1EAB</div><div><a href="#1B61H" class="memory-link">CALL 1B61H<span class="origrom2">CALL CLEARC</span></a><span class="opcode2">CD 61 1B</span></div><div>Clean up, reset the STACK, CDATPTR, and variables.  Only HL is preserved</div></div>
									<div class="assembly-row-combined"><div>1EAC-1EAE</div><div>LD BC,1D1EH<span class="origrom2">LD BC,NEWSTT</span><span class="opcode2">01 1E 1D</span></div><div>Load Register Pair BC with the continuation address in the execution driver</div></div>
									<div class="assembly-row-combined"><div>1EAF-1EB0</div><div><a href="#1EC1H" class="memory-link">JR 1EC1H<span class="origrom2">JR RUNC2</span></a><span class="opcode2">18 10</span></div><div>Put NEWSTT at the top of STACK (so that a RETurn will jump to it) and then pass through to the <span class="code">GOTO</span> routine via a jump to 1EC1H to begin execution at the nnnn line</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1EB1H">1EB1-1EC1 - LEVEL II BASIC <span class="code">GOSUB</span> ROUTINE<span class="origrom"> - "GOSUB"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source code, the 5 byte GOSUB entry on the STACK is as follows:</p><ul> <li>LOW ADDRESS<ul> <li>1 Byte - The GOSUB token.</li> <li>2 Bytes - The line number of the GOSUB statement.</li> <li>2 Bytes - A pointer to the text of the GOSUB in the BASIC program being executed.</li></ul> </li><li>HIGH ADDRESS</li></ul> Can be used to execute the equivalent of a <span class="code">GOSUB</span>
 statement from an assembly program. It allows a BASIC subroutine to be 
called from an assembly subroutine. After the BASIC subroutine executes,
 control returns to the next statement in the assembly program. All 
registers are used. On entry, the HL must contain an ASCII string with 
the starting line number of the subroutine.<p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1EB1-1EB2<span class="origrom2">GOSUB</span></div><div>LD C,03H<span class="opcode2">0E 03</span></div><div>Load Register B with half the number of bytes needed for the <span class="code">GOSUB</span> push</div></div>
									<div class="assembly-row-combined"><div>1EB3-1EB5</div><div><a href="#1963H" class="memory-link">CALL 1963H<span class="origrom2">CALL GETSTK</span></a><span class="opcode2">CD 63 19</span></div><div>Go make sure that there's enough memory for the <span class="code">GOSUB</span> push</div></div>
									<div class="assembly-row-combined"><div>1EB6</div><div>POP BC<span class="opcode2">C1</span></div><div>Get the NEWSTT return address from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>1EB7</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in Register Pair HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>1EB8</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Create a hole to be filled in later by once again saving the value of the current BASIC program pointer to the STACK</div></div>
									<div class="assembly-row-combined"><div>1EB9-1EBB</div><div>LD HL,(40A2H)<span class="origrom2">LD HL,(CURLIN)</span><span class="opcode2">2A A2 40</span></div><div>Load Register Pair HL with the value of the current BASIC line number in binary.<br>Note: 40A2H-40A3H holds the current BASIC line number</div></div>
									<div class="assembly-row-combined"><div>1EBC</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Put the binary value for the current line number into the hole in the STACK AND restore the code string pointer</div></div>
									<div class="assembly-row-combined"><div>1EBD-1EBE</div><div>LD A,91H<span class="origrom2">LD A,$GOSUB</span><span class="opcode2">3E 91</span></div><div>Load Register A with a <span class="code">GOSUB</span> token</div></div>
									<div class="assembly-row-combined"><div>1EBF</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save the <span class="code">GOSUB</span> token (in Register Pair AF) to the STACK</div></div>
									<div class="assembly-row-combined"><div>1EC0</div><div>INC SP<span class="opcode2">33</span></div><div>Bump the value of the STACK pointer since we just used one space for the GOSUB token</div></div>
									<div class="assembly-row-combined" id="1EC1H"><div>1EC1<span class="origrom2">RUNC2</span></div><div>PUSH BC<span class="opcode2">C5</span></div><div>Save the "NEWSTT" return address in Register Pair BC to the STACK, and now spill down to the <span class="code">GOTO</span> routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1EC2H">1EC2-1EDD - LEVEL II BASIC <span class="code">GOTO</span> ROUTINE<span class="origrom"> - "GOTO"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1EC2H"><div>1EC2-1EC4<span class="origrom2">GOTO</span></div><div><a href="#1E5AH" class="memory-link">CALL 1E5AH<span class="origrom2">CALL LINGET</span></a><span class="opcode2">CD 5A 1E</span></div><div>We
 need to put the line number to branch to into DE so we call ASCII TO 
INTEGER routine at 1E5A which converts the ASCII string pointed to by HL
 to an integer deposited into DE.  If the routine finds a non-numerica 
character, the conversion is stopped</div></div>
									<div class="assembly-row-combined" id="1EC5H"><div>1EC5-1EC7<span class="origrom2">GOTO2</span></div><div><a href="#1F07H" class="memory-link">CALL 1F07H<span class="origrom2">CALL REM</span></a><span class="opcode2">CD 07 1F</span></div><div>Go bump the current BASIC program pointer in Register Pair HL until it points to the end of the current BASIC line</div></div>
									<div class="assembly-row-combined"><div>1EC8</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in Register Pair HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>1EC9-1ECB</div><div>LD HL,(40A2H)<span class="origrom2">LD (CURLIN),HL</span><span class="opcode2">2A A2 40</span></div><div>Load Register Pair HL with the binary equivalent of the last line number.<br>Note: 40A2H-40A3H holds the current BASIC line number</div></div>
									<div class="assembly-row-combined"><div>1ECC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H">RST 18H<span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now
 we need to compare the value of the current BASIC line number (in HL) 
with the value of the line number to branch to (in DE), so we call the 
COMPARE DE:HL routine, which numerically compares DE and HL. Will not 
work for signed integers (except positive ones). Uses the A-register 
only. The result of the comparison is returned in the status Register 
as:  <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>1ECD</div><div>POP HL<span class="opcode2">E1</span></div><div>Get the value of the current BASIC program pointer from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1ECE</div><div>INC HL<span class="opcode2">23</span></div><div>Bump
 the value of the current BASIC program pointer in Register Pair HL so 
as to restore the code string address.  DE holds the line number 
specified</div></div>
									<div class="assembly-row-combined"><div>1ECF-1ED1</div><div><a href="#1B2FH" class="memory-link">CALL C,1B2FH<span class="origrom2">CALL C,LOOP</span></a><span class="opcode2">DC 2F 1B</span></div><div>If
 the line number to branch to (in Register Pair DE) is greater than the 
current BASIC line number then go find where the line number is located,
 starting with the current line</div></div>
									<div class="assembly-row-combined"><div>1ED2-1ED4</div><div><a href="#1B2CH" class="memory-link">CALL NC,1B2CH<span class="origrom2">CALL NC,FNDLIN</span></a><span class="opcode2">D4 2C 1B</span></div><div>If
 the line number to branch to (in Register Pair DE) is less than the 
current BASIC line number, then go find where the line number is located
 by calling the SEARCH FOR LINE NUMBER routine at 1B2CH which looks for 
the line number specified in DE.  Returns C/Z with the line found in BC,
 NC/Z with line number is too large and HL/BC having the next available 
location, or NC/NZ with line number not found, and BC has the first 
available one after that.<br>Yes, this is a second search that kicks in 
if the prior search (which started at the current line number) failed, 
as this one will start at the beginning of the program</div></div>
									<div class="assembly-row-combined"><div>1ED5,1ED6</div><div>LD H,B<br>LD L,C<span class="opcode2">60</span></div><div>Let HL = BC (which is holding the address of the requested line number</div></div>
									<div class="assembly-row-combined"><div>1ED7</div><div>DEC HL<span class="opcode2">2B</span></div><div>Decrement
 the value of the current BASIC program pointer in Register Pair HL to 
now point to the End of Line terminator from the previous line</div></div>
									<div class="assembly-row-combined"><div>1ED8</div><div>RET C<span class="opcode2">D8</span></div><div>If
 a line number was found then the CARRY FLAG would have been set.  If 
so, RETURN from this routine to the execution driver (to start execution
 at the new line number), otherwise pass through to the ?UL ERROR 
routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1ED9H">1ED9-1EDD - LEVEL II BASIC <span class="code">?UL ERROR</span> ROUTINE<span class="origrom"> - "USERR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1ED9-1EDA<span class="origrom2">USERR</span></div><div>LD E,0EH<span class="origrom2">LD E,ERRUS</span><span class="opcode2">1E 0E</span></div><div>Load Register E with an <span class="code">?UL ERROR</span> code</div></div>
									<div class="assembly-row-combined"><div>1EDB-1EDD</div><div><a href="#19A2H" class="memory-link">JP 19A2H<span class="origrom2">JP ERROR</span></a><span class="opcode2">C3 A2 19</span></div><div>Since the line number wasn't found, display a <span class="code">?UL ERROR</span> message</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1EDEH">1EDE-1E04 - LEVEL II BASIC <span class="code">RETURN</span> ROUTINE<span class="origrom"> - "RETURN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Returns control to the BASIC statement following the last <span class="code">GOSUB</span>
 call.   An assembly program called by a BASIC subroutine may wish to 
return directly to the orginal caller without returning through the 
subroutine entry point. This exit can be used for that return. The 
return address to the STACK for the call to the assembly program must be
 cleared before returning via 1EDFH.  On entry, if the Z flag is set, 
there was no parameter present.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1EDE<span class="origrom2">RETURN</span></div><div>RET NZ<span class="opcode2">C0</span></div><div>Display a <span class="code">?SN ERROR</span> message if there is anything following the <span class="code">RETURN</span> token</div></div>
									<div class="assembly-row-combined"><div>1EDF-1EE0</div><div>LD D,0FFH<span class="opcode2">16 FF</span></div><div>Load
 Register D with FFH (a dummy address for the search routine to ensure 
that the variable pointer in Register Pair DE does not find a match)</div></div>
									<div class="assembly-row-combined"><div>1EE1-1EE3</div><div><a href="#1936H" class="memory-link">CALL 1936H<span class="origrom2">CALL FNDFOR</span></a><span class="opcode2">CD 36 19</span></div><div>Go past all the <span class="code">FOR</span>
 entries in the STACK via this CALL which backspaces the STACK pointer 
by four and return with the value at the location of the STACK pointer 
in Register A</div></div>
									<div class="assembly-row-combined"><div>1EE4</div><div>LD SP,HL<span class="opcode2">F9</span></div><div>Update the STACK by loading the STACK pointer with the new value in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1EE5-1EE7HS</div><div>LD (40E8H),HL<span class="origrom2">LD (SAVSTK),HL</span><span class="opcode2">22 E8 40</span></div><div>Save the STACK pointer position in Register Pair HL.<br>Note: 40E8H-40E9H holds STACK pointer pointer</div></div>
									<div class="assembly-row-combined"><div>1EE8-1EE9</div><div>CP 91H<span class="origrom2">CP $GOSUB</span><span class="opcode2">FE 91</span></div><div>Check to see if the value in Register A is a <span class="code">GOSUB</span> token</div></div>
									<div class="assembly-row-combined"><div>1EEA-1EEB</div><div>LD E,04H<span class="origrom2">LD E,ERRRG</span><span class="opcode2">1E 04</span></div><div>Load Register E with a <span class="code">?RG ERROR</span> code</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1EECH">1EEC - RG ERROR entry point.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1EEC-1EEE</div><div><a href="#19A2H" class="memory-link">JP NZ,19A2H<span class="origrom2">JP NZ,ERROR</span></a><span class="opcode2">C2 A2 19</span></div><div>Display a <span class="code">?RG ERROR</span> message if there isn't a <span class="code">GOSUB</span> push to the STACK</div></div>
									<div class="assembly-row-combined"><div>1EEF</div><div>POP HL<span class="opcode2">E1</span></div><div>Otherwise, get the line number that the <span class="code">GOSUB</span> was from from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1EF0-1EF2</div><div>LD (40A2H),HL<span class="origrom2">LD (CURLIN),HL</span><span class="opcode2">22 A2 40</span></div><div>Save the <span class="code">GOSUB</span> line number in Register Pair HL as the current BASIC line number.<br>Note: 40A2H-40A3H holds the current BASIC line number</div></div>
									<p class="debug-note">The next few instructions set up to see if there was GOSUB from the command line instead of insiude a program.</p>
									<div class="assembly-row-combined"><div>1EF3</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the current BASIC line number in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1EF4</div><div>LD A,H<span class="opcode2">7C</span></div><div>Load Register A with the MSB of the adjusted current BASIC 1ine number in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1EF5</div><div>OR L<span class="opcode2">B5</span></div><div>Combine
 the LSB of the adjusted current BASIC line number in Register L with 
the adjusted MSB of the current BASIC line number in Register A.  This 
is a test for an overflow or direct command mode</div></div>
									<div class="assembly-row-combined"><div>1EF6-1EF7</div><div><a href="#1EFFH" class="memory-link">JR NZ,1EFFH<span class="origrom2">JR NZ,GOBACK</span></a><span class="opcode2">20 07</span></div><div>If the NZ FLAG is set, then this was NOT in direct command mode, so JUMP to 1EFF to do the RETURN</div></div>
									<div class="assembly-row-combined"><div>1EF8-1EFA</div><div>LD A,(40DDH)<span class="origrom2">LD A,(BFKLFL)</span><span class="opcode2">3A DD 40</span></div><div>If we are here, we may have a one liner!  Load Register A with the command mode flag.<br>Note: 40DDH holds INPUT flag</div></div>
									<div class="assembly-row-combined"><div>1EFB</div><div>OR A<span class="opcode2">B7</span></div><div>Set the flags</div></div>
									<div class="assembly-row-combined"><div>1EFC-1EFE</div><div><a href="#1A18H" class="memory-link">JP NZ,1A18H<span class="origrom2">JP NZ,STPRDY</span></a><span class="opcode2">C2 18 1A</span></div><div>Jump to 1A18H if Level II BASIC, instead of doing a RETURN, since we are in direct command mode</div></div>
									<div class="assembly-row-combined" id="1EFFH"><div id="1F00H">1EFF-1F01<span class="origrom2">GOBACK</span></div><div>LD HL,1D1EH<span class="origrom2">LD HL,NEWSTT</span><span class="opcode2">21 1E 1D</span></div><div>Load Register Pair HL with the return address of NEWSTT</div></div>
									<div class="assembly-row-combined"><div>1F02</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Put
 the "NEWSTT" return address into the top of the STACK and put the 
current location on the program line being parsed back into Register 
Pair HL</div></div>
									<div class="assembly-row-combined"><div>1F03-1F04</div><div>LD A,0E1H<span class="opcode2">3E E1</span></div><div>Z-80 Trick!  If passing through will just change Register A to this value, but NOT do a POP HL</div></div>
									<div class="assembly-row-combined"><div>1F04<span class="origrom2">DATAH</span></div><div>POP HL<span class="opcode2">E1</span></div><div>If
 this is jumped to, then process a POP HL, which would NOT be processed 
if this is passed through.  If this line is processed, then its purpose 
is to restore the pointer to the current character on the BASIC program 
line being processed back into Register Pair HL</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1F05H">1F05-1F20 - SCAN ROUTINE<span class="origrom"> - "DATA"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1F05H"><div>1F05<span class="origrom2">DATA</span></div><div>LD BC,0E3AH<span class="opcode2">01 3A 0E</span></div><div>This
 part of a Z-80 Trick.  If this line is hit by passing through, then BC 
is simply changed and the next instruction at 1F07H is never executed</div></div>
									<div class="assembly-row-combined" id="1F07H"><div>1F07-1F08<span class="origrom2">REM</span></div><div>LD C,00H<span class="opcode2">0E 00</span></div><div>Load Register C with zero</div></div>
									<div class="assembly-row-combined" id="1F0BH"><div>1F09-1F0A</div><div>LD B,00H<span class="opcode2">06 00</span></div><div>Load Register B with zero, as the only terminator inside quotes or a REM is a NULL terminator</div></div>
									<p class="debug-note">The notes in the original ROM source code
 explain that when a quote is seen, the second terminator is traded, so 
in a DATA statement a colon inside quotations will have no effect.</p>
									<div class="assembly-row-combined"><div>1F0B<span class="origrom2">EXCHQT</span></div><div>LD A,C<span class="opcode2">79</span></div><div>Top of a loop.  Load Register A with the stop scan character in Register C</div></div>
									<div class="assembly-row-combined"><div>1F0C</div><div>LD C,B<span class="opcode2">48</span></div><div>Load Register C with the stop scan character in Register B</div></div>
									<div class="assembly-row-combined"><div>1F0D</div><div>LD B,A<span class="opcode2">47</span></div><div>Load Register B with the stop scan character in Register A</div></div>
									<div class="assembly-row-combined" id="1F0EH"><div>1F0E<span class="origrom2">REMER</span></div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Top of a loop.  Load Register A with the character at the location of the current BASIC program pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1F0F</div><div>OR A<span class="opcode2">B7</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is an END OF LINE terminator</div></div>
									<div class="assembly-row-combined"><div>1F10</div><div>RET Z<span class="opcode2">C8</span></div><div>Return
 if the character at the location of the current BASIC program pointer 
in Register A is an END OF LINE terminator, because an END OF LINE 
terminator will stop everything, including quote things or a REM</div></div>
									<div class="assembly-row-combined"><div>1F11</div><div>CP B<span class="opcode2">B8</span></div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in Register A is the same as the stop scan character in Register
 B</div></div>
									<div class="assembly-row-combined"><div>1F12</div><div>RET Z<span class="opcode2">C8</span></div><div>Return
 if the character at the location of the current BASIC program pointer 
in Register A is the same as the stop scan character in Register B</div></div>
									<div class="assembly-row-combined"><div>1F13</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the current BASIC program pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1F14-1F15</div><div>CP 22H<span class="origrom2">CP "<kbd>"</kbd> "</span><span class="opcode2">FE 22</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a quote</div></div>
									<div class="assembly-row-combined"><div>1F16-1F17</div><div><a href="#1F0BH" class="memory-link">JR Z,1F0BH<span class="origrom2">JR Z,EXCHQT</span></a><span class="opcode2">28 F3</span></div><div>Loop back if the character at the location of the current BASIC program pointer in Register A is a quote, as we need to trade</div></div>
									<p class="debug-note">The notes in the original ROM source code say that when an <span class="code">IF</span> takes a false branch, it must find the appropriate <span class="code">ELSE</span> to start execution at.  "DATA" counts the number of <span class="code">IF</span>'s it sees so that the <span class="code">ELSE</span> code can matche <span class="code">ELSE</span>'s with <span class="code">IF</span>'s.  This count is kept in Register D.</p>
									<div class="assembly-row-combined"><div>1F18-1F19</div><div>SUB 8FH<span class="origrom2">SUB $IF</span><span class="opcode2">D6 8F</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">IF</span> token</div></div>
									<div class="assembly-row-combined"><div>1F1A-1F1B</div><div><a href="#1F0EH" class="memory-link">JR NZ,1F0EH<span class="origrom2">JR NZ,REMER</span></a><span class="opcode2">20 F2</span></div><div>Loop back to 1F0EH if the character at the location of the current BASIC program pointer in Register A isn't an <span class="code">IF</span> token</div></div>
									<div class="assembly-row-combined"><div>1F1C</div><div>CP B<span class="opcode2">B8</span></div><div>Since
 a REM cannot be SMASHed, we only increment Register D if Register B 
does not equal zero.  So . Check to see if the character at the location
 of the current BASIC program pointer in Register A is the same as the 
character in Register B</div></div>
									<div class="assembly-row-combined"><div>1F1D</div><div>ADC A,D<span class="opcode2">8A</span></div><div>As long as Regisister B is not zero, add the value in Register D to the value in Register A</div></div>
									<div class="assembly-row-combined"><div>1F1E</div><div>LD D,A<span class="opcode2">57</span></div><div>Load Register D with the value in Register A</div></div>
									<div class="assembly-row-combined"><div>1F1F-1F20</div><div><a href="#1F0EH" class="memory-link">JR 1F0EH<span class="origrom2">JR REMER</span></a><span class="opcode2">18 ED</span></div><div>Loop back to 1F0EH until scan is completed</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1F21H">1F21-1F6B - LEVEL II BASIC LET ROUTINE<span class="origrom"> - "LET"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1F21-1F23<span class="origrom2">LET</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#260DH">CALL 260DH<span class="origrom2">CALL PTRGET</span></a><span class="opcode2">CD 0D 26</span></div><div>Call
 the FIND ADDRESS OF VARIABLE routine at 260DH which searches the 
Variable List Table for a variable name which matches the name in the 
string pointed to in HL, and return the address of that variable in DE 
(and if there is no variable, it creates it, zeroes it, and returns THAT
 location)</div></div>
									<div class="assembly-row-combined"><div>1F24-1F25</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H">RST 08H ‚áí  D5H<span class="origrom2">RST 08H EQULTK</span></a><span class="opcode2">CF</span></div><div>Test if the variable name is followed by a <span class="code">=</span>.
  Since the character at the location of the current BASIC program 
pointer in Register Pair HL must be an EQUAL sign (D5) so call the 
COMPARE SYMBOL routine which comparess the symbol in the input string 
pointed to by HL Register to the value in the location following the RST
 08 call.  If there is a match, control is returned to address of the 
RST 08 instruction 2 with the next symbol in in Register A and HL 
incremented by one. If the two characters do not match, a syntax error 
message is given and control returns to the Input Phase)</div></div>
									<div class="assembly-row-combined"><div>1F26</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange the address of the variable in Register Pair DE with the value of the current BASIC program pointer in Register Pair HL</div></div>
									<p class="debug-note">A note in the original ROM source code explains that the following sets up "TEMP" for the <span class="code">FOR</span> command so when user-functions call REDINP, the "TEMP" doesn't get changed.</p>
									<div class="assembly-row-combined"><div>1F27-1F29</div><div>LD (40DFH),HL<span class="origrom2">LD (TEMP),HL</span><span class="opcode2">22 DF 40</span></div><div>Save the addres of the variable in Register Pair HL.<br>Note: 40DFH-40E0H is a common temporary storage area</div></div>
									<div class="assembly-row-combined"><div>1F2A</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange the value of the current BASIC program pointer in Register Pair DE with the address of the variable in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1F2B<span class="origrom2">REDINP</span></div><div>PUSH DE<span class="opcode2">D5</span></div><div>Save the address of the variable in Register Pair DE to the STACK</div></div>
									<div class="assembly-row-combined"><div>1F2C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H">RST 20H<span class="origrom2">GETYPE</span></a><span class="opcode2">E7</span></div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in 
ACCumulator and returns a combination of STATUS flags and unique numeric
 values in the A Register according to the data mode flag (40AFH).  The 
results are returned as follows:<br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>1F2D</div><div>PUSH AF<span class="opcode2">F5</span></div><div>Save
 the value in Register Pair AF to the STACK.  A will be -1 for an 
integer, 0 for a string, 1 for single precision, and 5 for double 
precision</div></div>
									<div class="assembly-row-combined"><div>1F2E-1F30<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;LETCN3</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2337H">CALL 2337H<span class="origrom2">CALL FRMEVL</span></a><span class="opcode2">CD 37 23</span></div><div>Go
 evaluate the expression at the location of the current BASIC program 
pointer in Register Pair HL and return with the result in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>1F31<span class="origrom2">LETCON</span></div><div>POP AF<span class="opcode2">F1</span></div><div>Get the variable type of the variable into Register A</div></div>
									<div class="assembly-row-combined"><div>1F32<span class="origrom2">LETCN2</span></div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Exchange
 (SP) and HL so that the address of the variable is now held in Register
 Pair HL and the pointer to the current character in the BASIC program 
being processed goes to the top of the STACK</div></div>
									<div class="assembly-row-combined" id="1F33H"><div>1F33-1F34<span class="origrom2">INPCOM</span></div><div>ADD A,03H<span class="opcode2">C6 03</span></div><div>Top
 of a loop.  Adjust the value in Register A so that it will hold the 
correct number type flag (i.e., A will be 2 for integer, 3 for string, 4
 for single precision, and 8 for double precision)</div></div>
									<div class="assembly-row-combined"><div>1F35-1F37</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2819H">CALL 2819H<span class="origrom2">CALL DOCNVF</span></a><span class="opcode2">CD 19 28</span></div><div>Go to 2819H to convert the result in ACCumulator to the same number type for the variable held in Register A</div></div>
									<div class="assembly-row-combined"><div>1F38-1F3A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A03H">CALL 0A03H<span class="origrom2">CALL VDFACS</span></a><span class="opcode2">CD 03 0A</span></div><div>Set Register Pair DE to equal the start position of good data in ACCumulator and call the GETYPE</div></div>
									<div class="assembly-row-combined"><div>1F3B</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the address of the variable in Register Pair HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>1F3C-1F3D</div><div><a href="#1F66H" class="memory-link">JR NZ,1F66H<span class="origrom2">JR NZ,COPNUM</span></a><span class="opcode2">20 28</span></div><div>If the result is anumber, JUMP to force it and copy</div></div>
									<div class="assembly-row-combined"><div>1F3E-1F40</div><div>LD HL,(4121H)<span class="origrom2">LD HL,(FACLO)</span><span class="opcode2">2A 21 41</span></div><div>Load Register Pair HL with the starting address of the string's VARPTR in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>1F41</div><div>PUSH HL<span class="opcode2">E5</span></div><div>Save the VARPTR for the string result in Register Pair HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>1F42</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the VARPTR for the string result in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1F43</div><div>LD E,(HL)<span class="opcode2">5E</span></div><div>Load Register E with the LSB of the address for the string at the location of the VARPTR for the string in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1F44</div><div>INC HL<span class="opcode2">23</span></div><div>Bump the value of the VARPTR for the string result in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1F45</div><div>LD D,(HL)<span class="opcode2">56</span></div><div>Load Register D with the MSB of the address for the string at the location of the VARPTR for the string in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1F46-1F48</div><div>LD HL,(40A4H)<span class="origrom2">LD HL,(TXTTAB)</span><span class="opcode2">2A A4 40</span></div><div>Load Register Pair HL with the start of the BASIC program.<br><b>Note:</b> 40A4H-40A5H holds the starting address of BASIC program text also known as the PROGRAM STATEMENT TABLE (PST)</div></div>
									<div class="assembly-row-combined"><div>1F49</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H">RST 18H<span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now
 we need to compare the start of the BASIC program area (in HL) with the
 address of the string result in DE, so we call the COMPARE DE:HL 
routine, which numerically compares DE and HL. Will not work for signed 
integers (except positive ones). Uses the A-register only. The result of
 the comparison is returned in the status Register as:  <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>1F4A-1F4B</div><div><a href="#1F5AH" class="memory-link">JR NC,1F5AH<span class="origrom2">JR NC,INBUFC</span></a><span class="opcode2">30 0E</span></div><div>If
 the address of the string result in Register Pair DE is less than the 
start of the BASIC program area in Register Pair HL, then the data is 
really in the buffer, so JUMP to do the copy</div></div>
									<div class="assembly-row-combined"><div>1F4C-1F4E</div><div>LD HL,(40A0H)<span class="origrom2">LD HL,(STKTOP)</span><span class="opcode2">2A A0 40</span></div><div>We
 want to see if it points into string space, so load Register Pair HL 
with the start of the string space pointer.  40A0H-40A1H holds the start
 of string space pointer</div></div>
									<div class="assembly-row-combined"><div>1F4F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H">RST 18H<span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now
 we need to compare the start of the string space pointer (in HL) with 
the address of the string result in DE, so we call the COMPARE DE:HL 
routine, which numerically compares DE and HL. Will not work for signed 
integers (except positive ones). Uses the A-register only. The result of
 the comparison is returned in the status Register as:  <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>1F50</div><div>POP DE<span class="opcode2">D1</span></div><div>Get the VARPTR for the string result from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1F51-1F52</div><div><a href="#1F62H" class="memory-link">JR NC,1F62H<span class="origrom2">JR NC,DNTCPY</span></a><span class="opcode2">30 0F</span></div><div>If
 NC is set, then we have a literal, which we do not want to copy, so 
JUMP if the address of the string result in Register Pair DE was less 
than the start of the string space pointer in Register Pair HL</div></div>
									<p class="debug-note">Next, we need to see if it is a variable by checking the descriptor.  If it is not a variable, we do not want to copy it.</p>
									<div class="assembly-row-combined"><div>1F53-1F55</div><div>LD HL,(40F9H)<span class="origrom2">LD HL,(VARTAB)</span><span class="opcode2">2A F9 40</span></div><div>Load Register Pair HL with the simple variables pointer.<br>Note: 40F9H-40FAH holds the starting address of the simple variable storage area</div></div>
									<div class="assembly-row-combined"><div>1F56</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H">RST 18H<span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now
 we need to compare the address of the VARPTR for the string result in 
Register Pair DE with the simple variables pointer in Register Pair HL, 
so we call the COMPARE DE:HL routine, which numerically compares DE and 
HL. Will not work for signed integers (except positive ones). Uses the 
A-register only. The result of the comparison is returned in the status 
Register as:  <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>1F57-1F58</div><div><a href="#1F62H" class="memory-link">JR NC,1F62H<span class="origrom2">JR NC,DNTCPY</span></a><span class="opcode2">30 09</span></div><div>Jump
 if the address of the VARPTR for the string result in Register Pair DE 
is less than the simple variables pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1F59-1F5AH</div><div>LD A,D1H<span class="opcode2">3E D1</span></div><div>Z-80
 Trick.  If we are passing through to this location, then A will get 
changed and the next instruction (i.e., the POP DE) will not get 
executed</div></div>
									<div class="assembly-row-combined" id="1F5AH"><div>1F5A<span class="origrom2">INBUFC</span></div><div>POP DE<span class="opcode2">D1</span></div><div>Get the VARPTR for the string result from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1F5B-1F5D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#29F5H">CALL 29F5H<span class="origrom2">CALL FRETMS</span></a><span class="opcode2">CD F5 29</span></div><div>Free up the TEMP without freeing up any string space</div></div>
									<div class="assembly-row-combined"><div>1F5E</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange
 the VARPTR for the string in Register Pair DE with the string's address
 in Register Pair HL, because the next instruction copies where HL 
points to</div></div>
									<div class="assembly-row-combined"><div>1F5F-1F61</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2843H">CALL 2843H<span class="origrom2">CALL STRCPY</span></a><span class="opcode2">CD 43 28</span></div><div>Copy the variable in the string space OR strings with data in the buffer into string space</div></div>
									<div class="assembly-row-combined" id="1F62H"><div>1F62-1F64<span class="origrom2">DNTCPY</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#29F5H">CALL 29F5H<span class="origrom2">CALL FRETMS</span></a><span class="opcode2">CD F5 29</span></div><div>Free up the TEMP without freeing up any string space</div></div>
									<div class="assembly-row-combined"><div>1F65</div><div>EX (SP),HL<span class="opcode2">E3</span></div><div>Exchange HL and (SP).  HL will contain the place to store the VARPTR.  (SP) will have nothing important</div></div>
									<div class="assembly-row-combined" id="1F66H"><div>1F66-1F68<span class="origrom2">COPNUM</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09D3H">CALL 09D3H<span class="origrom2">CALL VMOVE</span></a><span class="opcode2">CD D3 09</span></div><div>Copy a descriptor or value to its proper location in memory</div></div>
									<div class="assembly-row-combined"><div>1F69</div><div>POP DE<span class="opcode2">D1</span></div><div>Get the top entry of the STACK.  It is either garbage or information for a "FOR"</div></div>
									<div class="assembly-row-combined"><div>1F6A</div><div>POP HL<span class="opcode2">E1</span></div><div>Get the value of the current BASIC program pointer from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1F6B</div><div>RET<span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1F6CH">1F6C-1FAE - LEVEL II BASIC ERROR <span class="code">ON</span> ROUTINE<span class="origrom"> - "ONGOTO"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1F6C-1F6D<span class="origrom2">ONGOTO</span></div><div>CP 9EH<span class="origrom2">CP $ERROR</span><span class="opcode2">FE 9E</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is an <span class="code">ERROR</span> token (since this is supposed to be <span class="code">ON ERROR</span></div></div>
									<div class="assembly-row-combined"><div>1F6E-1F6F</div><div><a href="#1F95H" class="memory-link">JR NZ,1F95H<span class="origrom2">JR NZ,NTOERR</span></a><span class="opcode2">20 25</span></div><div>Jump down to 1F95H if the character at the location of the current BASIC program pointer in Register A isn't an <span class="code">ERROR</span> token</div></div>
									<div class="assembly-row-combined"><div>1F70</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H">RST 10H<span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>If we are here, we have <span class="code">ON ERROR</span>
 but we do need to see what's next.  Since we now need bump the value of
 the current BASIC program pointer until it points to the next 
character, call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The 
RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>1F71-1F72</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H">RST 08H ‚áí  8DH<span class="origrom2">RST 08H $GOTO</span></a><span class="opcode2">CF</span></div><div>The next valid character at the location of the current BASIC program pointer in Register Pair HL must be a <span class="code">GOTO</span>
 token (=8DH) so call the COMPARE SYMBOL routine which comparess the 
symbol in the input string pointed to by HL Register to the value in the
 location following the RST 08 call.  If there is a match, control is 
returned to address of the RST 08 instruction 2 with the next symbol in 
in Register A and HL incremented by one. If the two characters do not 
match, a syntax error message is given and control returns to the Input 
Phase)</div></div>
									<div class="assembly-row-combined"><div>1F73-1F75</div><div><a href="#1E5AH" class="memory-link">CALL 1E5AH<span class="origrom2">CALL LINGET</span></a><span class="opcode2">CD 5A 1E</span></div><div>The
 next thing in the program line needs to be a line number, so convert 
the next constant into binary (with the result in DE).  To do this, call
 the ASCII TO INTEGER routine at 1E5A which converts the ASCII string 
pointed to by HL to an integer deposited into DE.  If the routine finds a
 non-numeric character, the conversion is stopped</div></div>
									<div class="assembly-row-combined"><div>1F76</div><div>LD A,D<span class="opcode2">7A</span></div><div>We need to test to see if the line number in DE is a zero.  So . load Register A with the MSB of the line number in Register D</div></div>
									<div class="assembly-row-combined"><div>1F77</div><div>OR E<span class="opcode2">B3</span></div><div>Combine the LSB of the line number in Register E with the MSB of the line number in Register A to see if we have a zero as in <span class="code">ON ERROR GOTO 0</span></div></div>
									<div class="assembly-row-combined"><div>1F78-1F79</div><div><a href="#1F83H" class="memory-link">JR Z,1F83H<span class="origrom2">JR Z,RESTRP</span></a><span class="opcode2">28 09</span></div><div>If we have an <span class="code">ON ERROR GOTO 0</span>, we need to reset the error trap, so JUMP to 1F83H</div></div>
									<div class="assembly-row-combined"><div>1F7A-1F7C</div><div><a href="#1B2AH" class="memory-link">CALL 1B2AH<span class="origrom2">CALL FNDLN1</span></a><span class="opcode2">CD 2A 1B</span></div><div>Next
 we need to see if the line number actuall exists!  Go find the location
 of the line number in Register Pair DE and return with the location of 
the line number in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>1F7D<br>1F7E</div><div>LD D,B<br>LD E,C<span class="opcode2">50</span></div><div>Put the pointer to the line number (held in BC) into DE</div></div>
									<div class="assembly-row-combined"><div>1F7F</div><div>POP HL<span class="opcode2">E1</span></div><div>Restore
 the location of the current position in the BASIC program being 
processed from the top of the STACK into Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1F80-1F82</div><div><a href="#1ED9H" class="memory-link">JP NC,1ED9H<span class="origrom2">JP NC,USERR</span></a><span class="opcode2">D2 D9 1E</span></div><div>If the NC FLAG is set, then the BASIC line number was not found, so we need to JUMP to display a ?UL ERROR</div></div>
									<div class="assembly-row-combined" id="1F83H"><div>1F83<span class="origrom2">RESTRP</span></div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange
 DE and HL, so that HL will now hold the pointer to the line number and 
DE will hold the location of the current BASIC program pointer</div></div>
									<div class="assembly-row-combined"><div>1F84-1F86</div><div>LD (40F0H),HL<span class="origrom2">LD (ONELIN),HL</span><span class="opcode2">22 F0 40</span></div><div>Save the pointer to the line number held in in Register Pair HL.<br>Note: 40F0H-40F1H is used by <span class="code">ON ERROR</span></div></div>
									<div class="assembly-row-combined"><div>1F87</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Exchange
 the value of the current BASIC program pointer in Register Pair DE with
 the location of the BASIC line in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1F88</div><div>RET C<span class="opcode2">D8</span></div><div>RETURN out of this routine to the execution driver if it was not <span class="code">ON ERROR GOTO 0000</span></div></div>
									<div class="assembly-row-combined"><div>1F89-1F8B</div><div>LD A,(40F2H)<span class="origrom2">LD A,(ONEFLG)</span><span class="opcode2">3A F2 40</span></div><div>Load Register A with the value of the error flag so we can see if we are in an ON . ERROR routine.<br>Note: 40F2H holds Error flag</div></div>
									<div class="assembly-row-combined"><div>1F8C</div><div>OR A<span class="opcode2">B7</span></div><div>Check to see if the error flag is set</div></div>
									<div class="assembly-row-combined"><div>1F8D</div><div>RET Z<span class="opcode2">C8</span></div><div>If
 the Z FLAG is set, then we are not in an ON . ERROR routine and we can 
just RETURN to CALLer because we have already disabled the trapping</div></div>
									<div class="assembly-row-combined"><div>1F8E-1F90</div><div>LD A,(409AH)<span class="origrom2">LD A,(ERRFLG)</span><span class="opcode2">3A 9A 40</span></div><div>Load Register A with the error code.<br>Note: 409AH holds the RESUME flag</div></div>
									<div class="assembly-row-combined"><div>1F91</div><div>LD E,A<span class="opcode2">5F</span></div><div>Load Register E with the value of the error code in Register A</div></div>
									<div class="assembly-row-combined"><div>1F92-1F94</div><div><a href="#19ABH" class="memory-link">JP 19ABH<span class="origrom2">JP ERRESM</span></a><span class="opcode2">C3 AB 19</span></div><div>Force the error to occur via a JUMP to the Level II error routine and display the error message for the error code in Register E</div></div>

								</div>
							</div>

							<h2 class="assembly-section-title" id="1F95H">1F95 - Still in the <span class="code">ON</span> routine<span class="origrom"> - "NTOERR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>We know it isn't <span class="code">ON ERROR</span>.  We now need to deal with the possibility that it was an <span class="code">ON n GOTO</span> or <span class="code">ON n GOSUB</span>.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1F95H"><div>1F95-1F97<span class="origrom2">NTOERR</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2B1CH">CALL 2B1CH<span class="origrom2">CALL GETBYT</span></a><span class="opcode2">CD 1C 2B</span></div><div>First we need to get the <span class="code">n</span>
 so go evaluate the expression at the location of the current BASIC 
program pointer and return with the result in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1F98</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load
 Register A with the next character (which should be a token or 
terminator) at the location of the current BASIC program pointer in 
Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1F99</div><div>LD B,A<span class="opcode2">47</span></div><div>Save that character into Register B</div></div>
									<div class="assembly-row-combined"><div>1F9A-1F9B</div><div>CP 91H<span class="origrom2">CP $GOSUB</span><span class="opcode2">FE 91</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">GOSUB</span> token</div></div>
									<div class="assembly-row-combined"><div>1F9C-1F9D</div><div><a href="#1FA1H" class="memory-link">JR Z,1FA1H<span class="origrom2">JR Z,ISGOSU</span></a><span class="opcode2">28 03</span></div><div>Skip the next 2 opcodes if the character at the location of current BASIC program pointer in Register A is a <span class="code">GOSUB</span> token </div></div>
									<div class="assembly-row-combined"><div>1F9E-1F9F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H">RST 08H ‚áí  8DH<span class="origrom2">RST 08H $GOTO<span class="opcode2">CF</span></span></a></div><div>Now let's test to see if the next character is the token for a <span class="code">GOTO</span>,
 call the COMPARE SYMBOL routine which comparess the symbol in the input
 string pointed to by HL Register to the value in the location following
 the RST 08 call.  If there is a match, control is returned to address 
of the RST 08 instruction 2 with the next symbol in in Register A and HL
 incremented by one. If the two characters do not match, a syntax error 
message is given and control returns to the Input Phase)</div></div>
									<div class="assembly-row-combined"><div>1FA0</div><div>DEC HL<span class="opcode2">2B</span></div><div>Decrement the value of the current BASIC program pointer in Register Pair HL to point to the <span class="code">GOTO</span> token</div></div>
									<div class="assembly-row-combined" id="1FA1H"><div>1FA1<span class="origrom2">ISGOSU</span></div><div>LD C,E<span class="opcode2">4B</span></div><div>Load Register C with the character count of the expression after the <span class="code">ON</span> token in Register E (i.e., the "n" from <span class="code">ON n GOTO</span></div></div>
									<div class="assembly-row-combined" id="1FA2H"><div>1FA2<span class="origrom2">LOOPON</span></div><div>DEC C<span class="opcode2">0D</span></div><div>Top of a loop.  Decrement the line number counter in Register C to test to make sure there are enough skips</div></div>
									<div class="assembly-row-combined"><div>1FA3</div><div>LD A,B<span class="opcode2">78</span></div><div>Load Register A with the token in Register B (which is either a <span class="code">GOSUB</span> or <span class="code">GOTO</span> token)</div></div>
									<div class="assembly-row-combined"><div>1FA4-1FA6</div><div><a href="#1D60H" class="memory-link">JP Z,1D60H<span class="origrom2">JP Z,GONE2</span></a><span class="opcode2">CA 60 1D</span></div><div>If we are done (i.e., C hit ZERO) then Jump to 1D60H</div></div>
									<div class="assembly-row-combined"><div>1FA7-1FA9</div><div><a href="#1E5BH" class="memory-link">CALL 1E5BH<span class="origrom2">CALL LINGT2</span></a><span class="opcode2">CD 5B 1E</span></div><div>We
 need to slip over the line number so we GOSUB to 1E5BH to evaluate the 
line number at the location of the current BASIC program pointer and 
return with the result in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1FAA-1FAB</div><div>CP 2CH<span class="origrom2">CP ","</span><span class="opcode2">FE 2C</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">COMMA</span>.  If not, it is the ent of the statement</div></div>
									<div class="assembly-row-combined"><div>1FAC</div><div>RET NZ<span class="opcode2">C0</span></div><div>If the character at the location of the current BASIC program pointer in Register A isn't a <span class="code">,</span> then we must be at the end of the line</div></div>
									<div class="assembly-row-combined"><div>1FAD-1FAE</div><div><a href="#1FA2H" class="memory-link">JR 1FA2H<span class="origrom2">JR LOOPON</span></a><span class="opcode2">18 F3</span></div><div>Otherwise, keep grabbing and processing line numbers</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1FAFH">1FAF-1FF3 - LEVEL II BASIC <span class="code">RESUME</span> ROUTINE<span class="origrom"> - "RESUME"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1FAF-1FB1<span class="origrom2">RESUME</span></div><div>LD DE,40F2H<span class="origrom2">LD DE,ONEFLG</span><span class="opcode2">11 F2 40</span></div><div>Load Register Pair DE with the address of the Level II BASIC error flag.<br>Note: 40F2H holds Error flag</div></div>
									<div class="assembly-row-combined"><div>1FB2</div><div>LD A,(DE)<span class="opcode2">1A</span></div><div>Load
 Register A with the error flag at the location of the memory pointer in
 Register Pair DE.  It will be FF if there is an error, and a zero 
otherwise</div></div>
									<div class="assembly-row-combined"><div>1FB3</div><div>OR A<span class="opcode2">B7</span></div><div>Check for an error</div></div>
									<div class="assembly-row-combined"><div>1FB4-1FB6</div><div><a href="#19A0H" class="memory-link">JP Z,19A0H<span class="origrom2">JP Z,REERR</span></a><span class="opcode2">CA A0 19</span></div><div>If we processed a RESUME but yet there was no error, then display an <span class="code">?RW ERROR</span> message</div></div>
									<div class="assembly-row-combined"><div>1FB7</div><div>INC A<span class="opcode2">3C</span></div><div>Clear the error flag in Register A</div></div>
									<div class="assembly-row-combined"><div>1FB8-1FBA</div><div>LD (409AH),A<span class="origrom2">LD (ERRFLG),A</span><span class="opcode2">32 9A 40</span></div><div>Clear the error flag (by putting a 0 into 409AH) so that way if a <kbr>BREAK is hit, it won't give an error</kbr></div></div>
									<div class="assembly-row-combined"><div>1FBB</div><div>LD (DE),A<span class="opcode2">12</span></div><div>Reset the error flag at the location of the memory pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1FBC</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the current BASIC program pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1FBD-1FBE</div><div>CP 87H<span class="origrom2">CP $NEXT</span><span class="opcode2">FE 87</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">NEXT</span> token</div></div>
									<div class="assembly-row-combined"><div>1FBF-1FC0</div><div><a href="#1FCDH" class="memory-link">JR Z,1FCDH<span class="origrom2">JR Z,RESNXT</span></a><span class="opcode2">28 0C</span></div><div>Jump down to 1FCDH if the character at the location of the current BASIC program pointer in Register A is a <span class="code">NEXT</span> token (as in <span class="code">RESUME NEXT</span></div></div>
									<div class="assembly-row-combined"><div>1FC1-1FC3</div><div><a href="#1E5AH" class="memory-link">CALL 1E5AH<span class="origrom2">CALL LINGET</span></a><span class="opcode2">CD 5A 1E</span></div><div>Get
 the binary equivalent of the line number into DE by calling the ASCII 
TO INTEGER routine at 1E5A which converts the ASCII string pointed to by
 HL to an integer deposited into DE.  If the routine finds a non-numeric
 character, the conversion is stopped</div></div>
									<div class="assembly-row-combined"><div>1FC4</div><div>RET NZ<span class="opcode2">C0</span></div><div>Exit to the execution driver if there wasn't a line number at the location of the current BASIC program pointer</div></div>
									<div class="assembly-row-combined"><div>1FC5<br>1FC6</div><div>LD A,D<span class="opcode2">7A</span></div><div>Prepare to test DE for Zero using the Z-80 trick of LD A,MSB and OR LSB</div></div>
									<div class="assembly-row-combined"><div>1FC7-1FC9</div><div><a href="#1EC5H" class="memory-link">JP NZ,1EC5H<span class="origrom2">JP NZ,GOTO2</span></a><span class="opcode2">C2 C5 1E</span></div><div>If the line number was NOT zero (i.e., it was <span class="code">RESUME nnnn</span>), then JUMP there!</div></div>
									<div class="assembly-row-combined"><div>1FCA</div><div>INC A<span class="opcode2">3C</span></div><div>Prepare to set a non-Zero condition code so that it will indicate <span class="code">RESUME 0</span></div></div>
									<div class="assembly-row-combined"><div>1FCB-1FCC</div><div><a href="#1FCFH" class="memory-link">JR 1FCFH<span class="origrom2">JR RESTXT</span></a><span class="opcode2">18 02</span></div><div>Jump to the <span class="code">RESUME 0</span> at 1FCFH</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1FCDH">1FCDH - Part of the <span class="code">RESUME</span> ROUTINE<span class="origrom"> - "RESNXT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1FCDH"><div>1FCD<span class="origrom2">RESNXT</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H">RST 10H<span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>Since
 we now need bump the value of the current BASIC program pointer until 
it points to the next character, call the EXAMINE NEXT SYMBOL routine at
 RST 10H.<br><br>The RST 10H routine parses the characters starting at 
HL+1 for the first non-SPACE,non-09H,non-0BH character it finds.  On 
exit, Register A will hold that character, and the C FLAG is set if its 
alphabetic, and NC FLAG if its alphanumeric.  All strings must have a 
00H at the end.</div></div>
									<div class="assembly-row-combined"><div>1FCE</div><div>RET NZ<span class="opcode2">C0</span></div><div>Return if this is the end of the BASIC statement</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1FCFH">1FCF - This is the <span class="code">RESUME 0</span> routine<span class="origrom"> - "RESTXT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="1FCFH"><div>1FCF-1FD1<span class="origrom2">RESTXT</span></div><div>LD HL,(40EEH)<span class="origrom2">LD HL,(ERRTXT)</span><span class="opcode2">2A EE 40</span></div><div>Get the value of the current BASIC program pointer and put it in Register Pair HL.<br>Note: 40EEH-40EFH is used by <span class="code">RESUME</span></div></div>
									<div class="assembly-row-combined"><div>1FD2</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Load Register Pair DE with the value of the current BASIC program pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>1FD3-1FD5</div><div>LD HL,(40EAH)<span class="origrom2">LD HL,(ERRLIN)</span><span class="opcode2">2A EA 40</span></div><div>Load Register Pair HL with the current BASIC line number.<br>Note: 40EAH-40EBH holds Line number with error</div></div>
									<div class="assembly-row-combined"><div>1FD6-1FD8</div><div>LD (40A2H),HL<span class="origrom2">LD (CURLIN),HL</span><span class="opcode2">22 A2 40</span></div><div>Save the value of the current BASIC line number in Register Pair HL.  This is where we will resume execution.<br>Note: 40A2H-40A3H holds the current BASIC line number</div></div>
									<div class="assembly-row-combined"><div>1FD9</div><div>EX DE,HL<span class="opcode2">EB</span></div><div>Load Register Pair HL with the value of the current BASIC program pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>1FDA</div><div>RET NZ<span class="opcode2">C0</span></div><div>Return to the execution driver if this is <span class="code">RESUME</span></div></div>
									<div class="assembly-row-combined"><div>1FDB</div><div>LD A,(HL)<span class="opcode2">7E</span></div><div>Get the character at the location of the current BASIC program pointer in Register Pair HL and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>1FDC</div><div>OR A<span class="opcode2">B7</span></div><div>Check
 the character at the location of the current BASIC program pointer in 
Register A to see if its an end of the BASIC line character</div></div>
									<div class="assembly-row-combined"><div>1FDD-1FDE</div><div><a href="#1FE3H" class="memory-link">JR NZ,1FE3H<span class="origrom2">JR NZ,NOTBGL</span></a><span class="opcode2">20 04</span></div><div>If A was ZERO, then the character would be <span class="code">:</span>
 or an end of the BASIC line character.  Jump forward to 1FE3H if the 
character at the location of the current BASIC program pointer in 
Register A isn't an end of the BASIC line character or a ":"</div></div>
									<div class="assembly-row-combined"><div>1FDF</div><div>INC HL<span class="opcode2">23</span></div><div>We
 need to skip the header, so we are going to move HL down 4 positions.  
Bump the value of the current BASIC program pointer in Register Pair HL 
to skip over the zero byte terminator</div></div>
									<div class="assembly-row-combined"><div>1FE0</div><div>INC HL<span class="opcode2">23</span></div><div>Bump
 the value of the current BASIC program pointer in Register Pair HL to 
skip over the LSB of the pointer to the next statement</div></div>
									<div class="assembly-row-combined"><div>1FE1</div><div>INC HL<span class="opcode2">23</span></div><div>Bump
 the value of the current BASIC program pointer in Register Pair HL to 
skip over the MSB of the pointer to the next statement</div></div>
									<div class="assembly-row-combined"><div>1FE2</div><div>INC HL<span class="opcode2">23</span></div><div>Bump
 the value of the current BASIC program pointer in Register Pair HL to 
skip over the LSB of the line number in binary for the line following 
the error</div></div>
									<div class="assembly-row-combined" id="1FE3H"><div>1FE3<span class="origrom2">NOTBGL</span></div><div>INC HL<span class="opcode2">23</span></div><div>Bump
 the value of the current BASIC program pointer in Register Pair HL to 
skip over the MSB of the line number in binary for the line following 
the error so that it points to the start of the next statement</div></div>
									<div class="assembly-row-combined"><div>1FE4</div><div>LD A,D<span class="opcode2">7A</span></div><div>Load Register A with the MSB of the line number with the error in Register D</div></div>
									<div class="assembly-row-combined"><div>1FE5</div><div>AND E<span class="opcode2">A3</span></div><div>Combine
 the LSB of the line number with the error in Register E with the MSB of
 the line number with the error in Register A.  This begins the test for
 the end of program marker</div></div>
									<div class="assembly-row-combined"><div>1FE6</div><div>INC A<span class="opcode2">3C</span></div><div>Bump
 the combined value of the line number with the error in Register A.  If
 this was a direct statement, rather than a program line, this will set 
the Z FLAG</div></div>
									<div class="assembly-row-combined"><div>1FE7-1FE9</div><div><a href="#1F05H" class="memory-link">JP NZ,1F05H<span class="origrom2">JP NZ,DATA</span></a><span class="opcode2">C2 05 1F</span></div><div>Jump to NEWSTT and stop if this was part of a program (and not a direct command)</div></div>
									<div class="assembly-row-combined"><div>1FEA-1FEC</div><div>LD A,(40DDH)<span class="origrom2">LD A,(BFKLFL)</span><span class="opcode2">3A DD 40</span></div><div>Load Register A with the buffer kill flag</div></div>
									<div class="assembly-row-combined"><div>1FED</div><div>DEC A<span class="opcode2">3D</span></div><div>Check to see if the command mode flag in Register A is set</div></div>
									<div class="assembly-row-combined"><div>1FEE-1FF0</div><div><a href="#1DBEH" class="memory-link">JP Z,1DBEH<span class="origrom2">JP Z,STPEND</span></a><span class="opcode2">CA BE 1D</span></div><div>Jump to 1DBEH if Level II BASIC is in the command mode because you cant CONTinue/RESUME if you are in command mode</div></div>
									<div class="assembly-row-combined"><div>1FF1-1FF3</div><div><a href="#1F05H" class="memory-link">JP 1F05H<span class="origrom2">JP DATA</span></a><span class="opcode2">C3 05 1F</span></div><div>Exit the routine by jumping to 1F05H to get the next statement</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="1FF4H">1FF4H-2007 - LEVEL II BASIC ERROR ROUTINE - "ERRORS"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This evaluates n for <span class="code">ERROR n</span></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>1FF4-1FF6<span class="origrom2">ERRORS</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2B1CH">CALL 2B1CH<span class="origrom2">CALL GETBYT</span></a><span class="opcode2">CD 1C 2B</span></div><div>Get
 the error code parameter which was passed by a GOSUB to 2B1CH which 
evaluates the expression at the location of the current BASIC program 
pointer in Register Pair HL and return with the result in A</div></div>
									<div class="assembly-row-combined"><div>1FF7</div><div>RET NZ<span class="opcode2">C0</span></div><div>Return if this isn't the end of the BASIC statement</div></div>
									<div class="assembly-row-combined"><div>1FF8</div><div>OR A<span class="opcode2">B7</span></div><div>Set up to check to see if the error number in Register A is equal to zero</div></div>
									<div class="assembly-row-combined"><div>1FF9-1FFB</div><div><a href="#1E4AH" class="memory-link">JP Z,1E4AH<span class="origrom2">JP Z,FCERR</span></a><span class="opcode2">CA 4A 1E</span></div><div>If the error code was zero, then that's an error in itself, so display an <span class="code">?FC ERROR</span> message</div></div>
									<div class="assembly-row-combined"><div>1FFC</div><div>DEC A<span class="opcode2">3D</span></div><div>Subtract one from the error code in Register A</div></div>
									<div class="assembly-row-combined"><div>1FFD</div><div>ADD A,A<span class="opcode2">87</span></div><div>Multiply the error code in Register A by two (so now A = 2(A-1))</div></div>
									<div class="assembly-row-combined"><div>1FFE</div><div>LD E,A<span class="opcode2">5F</span></div><div>Load Register E with 2(A-1)</div></div>
									<div class="assembly-row-combined" id="2000H"><div>1FFF-2000</div><div>CP 2DH<span class="origrom2">CP LSTERR</span><span class="opcode2">FE 2D</span></div><div>Check to see if the error code in Register A is less than 45</div></div>
									<div class="assembly-row-combined"><div>2001-2002</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2005H">JR C,2005H<span class="origrom2">JR C,GOERR</span></a><span class="opcode2">38 02</span></div><div>Jump forward 1 instruction (i.e., skip the line that sets up for an error of <span class="code">?UE ERROR</span>) if the error code (in Register A) is in range (i.e., less than 45)</div></div>
								</div>
							</div>
						</div>
					</div>

						<div class="section-wrapper">
							<h2 id="pagenav">Disassembly Navigation<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="section-content">
								<div class="top-menu-shorter">
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0000H">0000</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0100H">0100</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0200H">0200</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0300H">0300</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0400H">0400</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0500H">0500</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0600H">0600</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0700H">0700</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0800H">0800</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0900H">0900</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A00H">0A00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0B00H">0B00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0C00H">0C00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0D00H">0D00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0E00H">0E00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0F00H">0F00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1000H">1000</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1100H">1100</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1200H">1200</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1300H">1300</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1400H">1400</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1500H">1500</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1600H">1600</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1608H">Reserved Words</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#18C9H">Error Messages</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1900H">1900</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1A00H">1A00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1B00H">1B00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C00H">1C00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D00H">1D00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E00H">1E00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1F00H">1F00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2000H">2000</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2100H">2100</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2200H">2200</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2300H">2300</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2400H">2400</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2500H">2500</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2600H">2600</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2700H">2700</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2800H">2800</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2900H">2900</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2A00H">2A00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2B00H">2B00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2C00H">2C00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2D00H">2D00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2E00H">2E00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2F00H">2F00</a>
								</div>
							</div>
						</div>
					</div>
				</main></div>
			
		</div>
	
	<!-- Fancybox JavaScript -->
	<script src="Model%20I%20ROM%20Explained%20-%20Part%202_files/fancybox.umd.js"></script>
	<!-- Initialize Fancybox -->
	<script>
		Fancybox.bind("[data-fancybox]", {
			Toolbar: {
				display: {
					left: ["infobar"],
					middle: [],
					right: ["slideshow", "thumbs", "close"],
				},
			},
			Thumbs: {
				autoStart: false,
			},
		});
	</script>
	<!-- Last Modified Date -->
	<script>
		document.write("<p style='text-align:right; padding: 10px 20px; font-style: italic; font-size: 0.85em; color: #666;'>Last edited: " + document.lastModified + "</p>");
	</script><p style="text-align:right; padding: 10px 20px; font-style: italic; font-size: 0.85em; color: #666;">Last edited: 01/17/2026 14:51:56</p>
	<script>
	document.addEventListener('DOMContentLoaded', function() {
		// OpCode Toggle
		const opCodeToggle = document.getElementById('OpCodeToggle');
		if (opCodeToggle) {
			opCodeToggle.addEventListener('change', function() {
				const opcodes = document.querySelectorAll('.opcode2');
				opcodes.forEach(el =>{
					el.style.display = this.checked ? 'inline' : 'none';
				});
			});
		}
		// Labels Toggle
		const labelsToggle = document.getElementById('LabelsToggle');
		if (labelsToggle) {
			labelsToggle.addEventListener('change', function() {
				const labels = document.querySelectorAll('.origrom2');
				labels.forEach(el =>{
					el.style.display = this.checked ? 'inline' : 'none';
				});
			});
		}
	});
	</script>

<div id="mobile-overlay" class="mobile-menu-overlay"></div></body></html>