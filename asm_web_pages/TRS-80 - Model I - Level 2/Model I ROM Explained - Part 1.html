<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="TRS-80 Revived Site by Ira Goldklang's is an archive of everything related to the Tandy Radio Shack TRS-80 microcomputer lines. Site contains emulators, programs, manuals, books, patches, games, hints, discussions, and tons more.">
	<meta name="author" content="Ira Goldklang">
	<meta name="robots" content="index, follow">
	<link rel="icon" href="https://www.trs-80.com/icon.ico" type="image/x-icon">
	<link rel="canonical" href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm">
	<meta property="og:title" content="TRS-80 Revived Site - Ira Goldklang's TRS-80 Archive">
	<meta property="og:description" content="Complete archive of TRS-80 emulators, programs, manuals, books, and games for Tandy Radio Shack TRS-80 computers.">
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm">
	<meta name="twitter:card" content="summary">
	<meta name="twitter:title" content="TRS-80 Revived Site">
	<meta name="twitter:description" content="Complete archive of TRS-80 emulators, programs, and resources.">
	<title>Model I ROM Explained - Part 1</title>
	<!-- Load your existing CSS file -->
	<link rel="stylesheet" href="Model%20I%20ROM%20Explained%20-%20Part%201_files/trs80-css.css">
	<link rel="stylesheet" href="Model%20I%20ROM%20Explained%20-%20Part%201_files/trs80-hamburger.css">
	<!-- Fancybox CSS -->
	<link rel="stylesheet" href="Model%20I%20ROM%20Explained%20-%20Part%201_files/fancybox.css">
	<!-- Load the component loader -->
	<script src="Model%20I%20ROM%20Explained%20-%20Part%201_files/trs80-loader.js"></script>
	<script src="Model%20I%20ROM%20Explained%20-%20Part%201_files/trs80-hamburger.js"></script>
</head>
<body class="trs80-loaded"><button id="hamburger-btn" class="hamburger-menu" aria-label="Toggle menu">
            <span></span>
            <span></span>
            <span></span>
        </button>
	<div class="site-container">
		<!-- Header will be loaded here -->
		<div id="header"><style>
    .trs80-header-grid {
        display: grid;
        /* 'auto' lets the images take only needed space, '1fr' gives the rest to the text */
        grid-template-columns: auto 1fr auto;
        grid-template-rows: 1fr;
        grid-column-gap: 20px;
        grid-row-gap: 0;
        background-color: #003399;
        margin-top: 10px;
        padding: 10px;
        /* This ensures all items in the grid (images and text) are aligned to the top */
        align-items: start;
    }

    .trs80-header-left { grid-area: 1 / 1 / 2 / 2; display: flex; align-items: start; }
    .trs80-header-center { grid-area: 1 / 2 / 2 / 3; text-align: center; }
    .trs80-header-right { grid-area: 1 / 3 / 2 / 4; display: flex; align-items: start; justify-content: flex-end; }

    .trs80-title { color: white !important; font-size: 170%; text-align: center; margin: 0 0 10px 0; font-weight: bold; }

    .trs80-description {
        color: white !important;
        font-size: 120%;
        text-align: center;
        margin: 0 auto 15px auto;
        padding: 0 10px;
        line-height: 1.4;
    }

    .trs80-header-grid img { border: 0 !important; margin: 0 2px; }
    .trs80-img-60 { width: 60px; }
    .trs80-img-80 { width: 80px; }
    .trs80-img-90 { width: 90px; }
    .trs80-img-100 { width: 100px; }

    /* Search Button Styling */
    .header-search-container {
        margin-bottom: 10px;
    }

    .header-search-link {
        display: inline-block;
        background: #ffcc00; /* Retro TRS-80 Amber */
        color: #003399 !important;
        padding: 6px 15px;
        border-radius: 4px;
        font-weight: bold;
        font-size: 0.9em;
        text-decoration: none;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        transition: transform 0.2s, background 0.2s;
    }

    .header-search-link:hover {
        background: #ffe066;
        transform: scale(1.05);
        text-decoration: none;
    }

    @media screen and (max-width: 768px) {
        .trs80-header-grid {
            grid-template-columns: 1fr;
            grid-template-rows: auto auto auto;
            text-align: center;
            justify-items: center;
        }
        .trs80-header-left { grid-area: 1 / 1 / 2 / 2; justify-content: center; }
        .trs80-header-center { grid-area: 2 / 1 / 3 / 2; }
        .trs80-header-right { grid-area: 3 / 1 / 4 / 2; justify-content: center; }
        .trs80-title { font-size: 130%; }
        .trs80-description { font-size: 100%; text-align: center; }
        .trs80-img-60 { width: 50px; }
        .trs80-img-80 { width: 65px; }
        .trs80-img-90 { width: 75px; }
        .trs80-img-100 { width: 80px; }
    }
</style>

<div class="trs80-header-grid">
    <div class="trs80-header-left">
        <img src="Model%20I%20ROM%20Explained%20-%20Part%201_files/computer-model1-keyboardandscreen-100.png" alt="[Model I]" class="trs80-img-60">
        <img src="Model%20I%20ROM%20Explained%20-%20Part%201_files/computer-model3-rsc05-blur-x100.png" alt="[Model III]" class="trs80-img-60">
        <img src="Model%20I%20ROM%20Explained%20-%20Part%201_files/computer-model4-rsc10-x100.png" alt="[Model 4]" class="trs80-img-90">
    </div>

    <div class="trs80-header-center">
        <p class="trs80-title">Welcome To Ira Goldklang's TRS-80 Revived Site</p>

        <p class="trs80-description">
            TRS-80 Revived Site is an archive of everything related to 
the Tandy Radio Shack TRS-80 home microcomputer lines. Site contains 
emulators, programs, manuals, books, patches, games, hints, discussions,
 and tons more.
        </p>

        <div class="header-search-container">
            <a href="https://www.trs-80.com/main-search-site.htm" class="header-search-link">
                <span class="search-icon">üîç</span> SEARCH THIS SITE
            </a>
        </div>
    </div>

    <div class="trs80-header-right">
        <img src="Model%20I%20ROM%20Explained%20-%20Part%201_files/computer-model-4p-sideways-view-x100.png" alt="[Model 4P]" class="trs80-img-90">
        <img src="Model%20I%20ROM%20Explained%20-%20Part%201_files/computer-model100-ccf836-x100.png" alt="[Model 100]" class="trs80-img-80">
        <img src="Model%20I%20ROM%20Explained%20-%20Part%201_files/computer-pc2-rsc07-x100.png" alt="[Pocket Computer]" class="trs80-img-100">
    </div>
</div>
</div>
		<!-- Content wrapper with sidebar and main content -->
		<div class="content-wrapper">
			<!-- Left Navigation will be loaded here -->
			<aside class="sidebar" id="navbar"><div class="navigationpanelv2">
	<div class="nav-entry-block">
		<h2>FIRST TIME VISITORS</h2>
		<p style="font-size:150%; margin-top:0; text-align:center; color:red;"><a href="https://www.trs-80.com/main-welcome.htm">Visit the WELCOME page</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>Services</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-faq-reading-disks.htm" style="color:red !important;">Do you have TRS-80 Disks?  Send them in for Preservation and Conversion for use in an Emulator</a></li>
			<li><a href="https://www.trs-80.com/main-disketterequest.htm">Request Real DOS Disks</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>General</h2>
		<ul>
			<li><a href="https://www.trs-80.com/index.html">Site News</a></li>
			<li><a href="https://www.trs-80.com/main-introduction-to-emulators.htm">Intro to Emulation</a></li>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-interviews.htm">Interviews</a></span>
				<ul>
					<li><a href="https://americanhistory.si.edu/comphist/gates.htm">Bill Gates</a></li>
					<li><a href="http://www.trs-80.org/interview-bill-hogue/">Bill Hogue</a></li>
					<li><a href="http://www.trs-80.org/interview-dan-gookin/">Dan Gookin</a></li>
					<li><a href="https://www.trs-80.com/sub-interview-don-french.htm">Don French</a></li>
					<li><a href="https://bluebilby.com/dubois-mcnamara/">Dubouis &amp; McNamara</a></li>
					<li><a href="http://www.trs-80.org/interview-j-weaver/">J. Weaver Jr.</a></li>
					<li><a href="http://www.trs-80.org/interview-jack-crenshaw/">Jack Crenshaw</a></li>
					<li><a href="http://www.trs-80.org/interview-jim-stutsman/">Jim Stutsman</a></li>
					<li><a href="http://www.48k.ca/JoshLavinsky.html">Josh Lavinsky</a></li>
					<li><a href="http://www.trs-80.org/interview-kevin-tschudi/">Kevin Tschudi</a></li>
					<li><a href="http://www.trs-80.org/interview-paul-andreasen/">Paul Andreasen</a></li>
					<li><a href="https://www.trs-80.com/sub-interview-steve-leininger.htm">Steven W. Leininger</a></li>
					<li><a href="https://www.trs-80.com/sub-interview-bill-demas.htm">William Demas</a></li>
				</ul>
			</li>
			<li><a href="https://www.trs-80.com/main-shipping.htm">Shipping a TRS-80</a></li>
			<li><a href="https://www.trs-80.com/main-lore.htm">Radio Shack Lore</a></li>
			<li><a href="https://www.trs-80.com/main-fun-stuff.htm">Fun Stuff</a></li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>Help The Site!</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-missing-software.htm">Missing Software</a></li>
			<li><a href="https://www.trs-80.com/main-missing-magazines.htm">Missing Magazines</a></li>
			<li><a href="https://www.trs-80.com/main-faq-reading-disks.htm">Send in Your Disks for Archiving</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Searches</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-search-site.htm">Site-Wide Search</a></li>
			<li><a href="https://www.trs-80.com/main-search-software.htm">Software Search</a></li>
			<li><a href="https://www.trs-80.com/main-search-magazines.htm">Magazine Search</a></li>
			<li><a href="https://www.trs-80.com/main-search-rs-catalogs.htm">Catalog Search</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Emulation and Virtual Media</h2>
		<span>Info and Downloads:</span>
		<ul>
			<li><a href="https://www.trs-80.com/main-emulators.htm">Emulators</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-tape-utilities.htm">Virtual Tape Utilities</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-disk-utilities.htm">Virtual Disk Utilities</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-misc-utilities.htm">Misc TRS-80 Utilities</a></li>
		</ul>
		<span>How To Convert:</span>
		<ul>
			<li><a href="https://www.trs-80.com/main-emulation-conversion-tapes.htm">Tapes to Virtual</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-conversion-disks.htm">Disks to Virtual</a></li>
			<li><a href="https://www.classic-computers.org.nz/system-80/software_esf_archive-imaging.htm">Stringy Floppy to Virtual</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Advanced</h2>
		<span>Internal Operations</span>
		<ul>
			<li>
				<span class="submenu-toggle">ROM/Z-80 Info</span>
				<ul>
					<li><a href="https://www.trs-80.com/main-internal-rom-related.htm#compared">ROMs Compared</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-level-1.htm">Model I Level 1 ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm">Model I Level II ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm">Model III Level II ROM</a></li>
					<li><a href="https://github.com/kiwisincebirth/TRS-80">Model III Level II Compilable Source</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4.htm">Model 4 ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4-xdrom-main.htm">Model 4 XDROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4p.htm">Model 4P Boot ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-network-4.htm">Network 4 ROM</a></li>
					<li><a href="https://www.gatesnotes.com/microsoft-original-source-code">Orig Source Code</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-bugs.htm">Bugs</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-rom-addresses.htm">Memory map and address reference</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-entry-points.htm">Entry Points to routines</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-io-and-misc-routines.htm">I/O and Misc ROM routines</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-math-calls.htm">Math Routines</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-rst-vectors.htm">RST vectors and Disk BASIC entry points</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-z80-info.htm">Reference for Z-80 opcodes and undocumented command</a></li>
				</ul>
			</li>
			<li><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm">RAM Addresses/Routines</a></li>
			<li><a href="https://www.trs-80.com/main-internal-ports-and-i-o.htm">Ports and I/O Devices</a></li>
			<li><a href="https://www.trs-80.com/sub-rom-dcbs.htm">Device Control Blocks (DCB's)</a></li>
			<li><a href="https://www.trs-80.com/main-internal-keyboard-map.htm">Keyboard Map</a></li>
		</ul>

		<span>Disassemblies</span>
		<ul>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-disassemblies.htm">Disassemblies</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-level-1.htm">Level I ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm">Level II ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm">Model III ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-4-durda.htm">Frank Durda Modified C-ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4.htm">Model 4 ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4p.htm">Model 4P Bootstrap ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4-xdrom-main.htm">XDROM - Frank Durda's Model 4 ROM C replacement</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-dos-nd80-m1-main.htm">NEWDOS/80 v2.0</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-dos-td13-main.htm">TRSDOS v1.3</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-dos-td23-main.htm">TRSDOS v2.3</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-network-4.htm">Network 4 Transporter ROM code analysis</a></li>
				</ul>
			</li>
		</ul>

		<span>Zaps/Patches/Fixes</span>
		<ul>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-zaps-and-patches.htm">Zaps and Patches</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/main-zaps-and-patches.htm#dos">DOS</a></li>
					<li><a href="https://www.trs-80.com/sub-zaps-sw-electric-pencil.htm">Electric Pencil</a></li>
					<li><a href="https://www.trs-80.com/sub-zaps-sw-general.htm">Other Software</a></li>
					<li><a href="https://www.trs-80.com/main-zaps-and-patches.htm#software-zaps-and">ZIPs of Patches</a></li>
				</ul>
			</li>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-tips-and-tricks.htm">Tips and Tricks</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/sub-tips-hard-drive.htm">Hard Drive Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-packing.htm">String Packing and USR Routines</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-level2.htm">Level II Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-reference-dos-newdos80-main.htm#tips">NEWDOS/80 Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-dos.htm">Other DOS Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-graphics.htm">TRS-80 Graphics</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-file-formats.htm">Tape and File Formats/Structures</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-easter-eggs.htm">Bugs and Easter Eggs</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-misc.htm">Misc Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-model-3.htm">Model III Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-model-4.htm">Model 4 Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-model-4p.htm">Model 4P Tips and Tricks</a></li>
				</ul>
			</li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>TRS-80 Models</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-models.htm">Timeline</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model1.htm">Model I</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model2.htm">Model II</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model3.htm">Model III</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model4.htm">Model 4/4P/4D</a></li>
			<li><a href="https://www.trs-80.com/sub-models-coco.htm">Color (Coco 1-3, MC-10)</a></li>
			<li><a href="https://www.trs-80.com/sub-models-laptops.htm">Laptops (100/200/600)</a></li>
			<li><a href="https://www.trs-80.com/sub-models-pocket.htm">Pocket (PC-1 to PC-8)</a></li>
			<li><a href="https://www.trs-80.com/sub-models-clones.htm">Clones</a></li>
			<li><a href="https://www.trs-80.com/sub-models-printers.htm">Printers</a></li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>Reference</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-reference-dos-trsdos-main.htm">TRSDOS</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-dos-dosplus.htm">DOSPlus</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-dos-newdos80-main.htm">NEWDOS/80</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-multidos.htm">MULTIDOS</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-dos-cpm.htm">CP/M</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-level-2-basic.htm">Level II BASIC Ref</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Detailed Products</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-details-orchestra.htm">ORCH-80/85/90</a></li>
			<li><a href="https://www.trs-80.com/sub-details-speed-up-boards.htm">Speed-Up Boards</a></li>
			<li><a href="https://www.trs-80.com/sub-details-scott-adams.htm">Scott Adams Adventures</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Tandy Publications</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-rs-csbs.htm">Customer Service Bulletins</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-memos.htm">Memos / Bulletins / Releases</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-cc-answers.htm">Comp Center Answers</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-catalogs.htm">Catalogs</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-comics.htm">Comic Books</a></li>
		</ul>
		<span>Microcomputer News</span>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-rs-micronewsletter-usa.htm">USA Edition</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-micronewsletter-aus.htm">Australian Edition</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-micronewsletter-other.htm">Other Editions</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Publications</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-books.htm">Books</a></li>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-magazine-main-menu.htm">Magazines (Non-Tandy)</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/sub-mag-80micro-main.htm">80 Microcomputing</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-80-notebook.htm">80 Notebook</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-80us-detail.htm">80 U.S. Journal</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-alternatesource-detail.htm">The Alternate Source</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-baron.htm">Baron's Microcomputing</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-cie.htm">C.I.E.</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-cload.htm">CLOAD</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-codeworks.htm">CodeWorks</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-computernews80.htm">Computer News 80</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-computer-user.htm">Computer User</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-creative.htm">Creative Computing</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-hecomputronics-detail.htm">H&amp;E Computronics</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-lsi-journal.htm">LDOS / LSI</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-micro80.htm">Micro-80</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-misosys-notes.htm">Misosys Notes</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-misosys-quarterly.htm">Misosys Quarterly</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-softside-detail.htm">Softside</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-the8ighty.htm">The 8ighty</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-trace.htm">Trace</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-trs8bit.htm">TRS8Bit</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-trstimes.htm">TRSTimes</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-other.htm">Other Magazines</a></li>
				</ul>
			</li>
			<li><a href="https://www.trs-80.com/sub-publications-manuals-software-1.htm">Software Manuals</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-user-groups-1.htm">User's Group Newsletters</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-catalogs.htm">Catalogs (Non-Tandy)</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-flyers.htm">Product Flyers</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-company-news.htm">Company Newsletters</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>This Section for TRS-80 Hardware Owners</h2>
		<span>TRS-80 Upgrades/Parts:</span>
		<ul>
			<li><a href="https://www.trs-80.com/main-upgrades.htm">Upgrades and Parts</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-parts-thingverse.htm">Schematics/3-D Printable Parts</a></li>
		</ul>
		<span>TRS-80 Repairs:</span>
		<ul>
			<li class="navbumpv2"><a href="https://www.trs-80.com/main-repairs.htm">Main Repair Page</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-repair-people.htm">Repair People</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-how-to-open.htm">Opening a TRS-80</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-eprom.htm">Using an EPROM</a></li>
		</ul>
		<span>Hardware Mods and Hacks:</span>
		<ul>
			<li><a href="https://www.trs-80.com/sub-tips-modifications-model-1.htm">Model I</a></li>
			<li><a href="https://www.trs-80.com/sub-tips-modifications-model-3.htm">Model III</a></li>
			<li><a href="https://www.trs-80.com/sub-tips-modifications-model-4.htm">Model 4</a></li>
		</ul>
		<span>Other Items ...</span>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-manuals-hardware-1.htm">Hardware Manuals</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-manuals-service.htm">Service Manuals</a></li>
			<li><a href="https://voidstar.blog/tandy-radio-shack-computer-cassette-recorder-trs-ccr-usage/">Using a Computer / Tablet / Smartphone for Cassette I/O</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Misc</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-emailme.htm">Send Me Email</a></li>
			<li><a href="https://www.trs-80.com/main-old-news.htm">Archived News and Guestbook</a></li>
			<li><a href="https://www.trs-80.com/main-personalstories.htm">Personal Stories Submitted</a></li>
			<li><a href="https://www.trs-80.com/main-emaillinks.htm">Email and other TRS-80 Sites</a></li>
			<li><a href="https://www.trs-80.com/main-copyrights.htm">Copyrights</a></li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>
</div></aside>
			<!-- Main Content -->
			<main class="main-content">
				<div class="main-page-container">
				<h1>Model I ROM Explained - Part 1</h1>
					<div class="section-wrapper">
						<h2 id="page-customization">Page Customization<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
						<div class="section-content">
							<div class="toggle-container">
								<label class="toggle-label">
									<input type="checkbox" id="OpCodeToggle">
									Display OPCodes
								</label>
							</div>
							<div class="toggle-container">
								<label class="toggle-label">
									<input type="checkbox" id="LabelsToggle" checked="checked">
									Display Labels
								</label>
							</div>
						</div>
					</div>

					<div class="section-wrapper">
						<h2 id="pagenav">Disassembly Navigation<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
						<div class="section-content">
							<div class="top-menu-shorter">
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0000H">0000</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0100H">0100</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0200H">0200</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0300H">0300</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0400H">0400</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0500H">0500</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0600H">0600</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0700H">0700</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0800H">0800</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0900H">0900</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A00H">0A00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0B00H">0B00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0C00H">0C00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0D00H">0D00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0E00H">0E00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0F00H">0F00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1000H">1000</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1100H">1100</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1200H">1200</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1300H">1300</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1400H">1400</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1500H">1500</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1600H">1600</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1608H">Reserved Words</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#18C9H">Error Messages</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1900H">1900</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1A00H">1A00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1B00H">1B00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C00H">1C00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D00H">1D00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E00H">1E00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1F00H">1F00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2000H">2000</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2100H">2100</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2200H">2200</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2300H">2300</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2400H">2400</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2500H">2500</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2600H">2600</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2700H">2700</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2800H">2800</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2900H">2900</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2A00H">2A00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2B00H">2B00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2C00H">2C00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2D00H">2D00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2E00H">2E00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2F00H">2F00</a>
							</div>
						</div>
					</div>

					<div class="section-wrapper">
						<h2 id="notes">Notes:<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
						<div class="section-content">
							<ul>
								<li>The ROM had to be one big long program starting from 0000H 
and ending at 2FFFH and everything it does had to be wedged into that 
single long block of code. This means that jumps to other locations are a
 necessity because once a particular portion of the ROM executes, if it 
was allowed to keep going, unintended portions would also execute. With 
this, there is a LOT of jumping away.</li>
								<li>There are only so many variables and only so many Z-80 instructions. There is no Z-80 instruction, for example, <span class="code">LD BC,SP</span>.
 With this, there is a huge amount of variable swapping. I would dare 
say that whatever part of the ROM isn't jumping, is just swapping 
variables around. The ROM would be a fraction of the size if there were 
more variables and more Z-80 instructions.</li>
							</ul>
						</div>
					</div>


					<div class="section-wrapper">
						<h2 id="rom-constants">ROM Constants<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
						<div class="section-content">
							<p>The ROM was written by Bill Gates, Paul Allen, and M Davidoff 
on a PDP-10. Since the source code was cross-compiled, the authors put 
in some variables and constants:</p>
							<div class="assembly-table">
								<div class="assembly-row-combined"><div>$CODE</div><div>0</div><div>Used by the authors when testing. When applied to the ROM itself, all references to $CODE are 0</div></div>
								<div class="assembly-row-combined"><div>CURCHR</div><div>95</div><div>Cursor character</div></div>
								<div class="assembly-row-combined"><div>STRSZD</div><div>50</div><div>Number
 of bytes reserved for the STRING area. This can be adjusted in BASIC by
 using the CLEAR nnnn function, which defaults to 50</div></div>
								<div class="assembly-row-combined"><div>DSEL$</div><div>37E1</div><div>Disk Drive Select Latch Address. Value of 01H is Drive :0</div></div>
								<div class="assembly-row-combined"><div>PRTAD$</div><div>37E8</div><div>Line Printer Address. If a parallel line printer is in use, it is mapped to this address</div></div>
								<div class="assembly-row-combined"><div>CSEL$</div><div>37E4</div><div>Cassette Select Latch Address. Values: 0-1 - SELECT TAPE DRIVE: 0=#1 1=#2</div></div>
								<div class="assembly-row-combined"><div>FDCAD$</div><div>37EC</div><div>Floppy Disk Controller COMMAND/STATUS</div></div>
								<div class="assembly-row-combined"><div>KEYAD$</div><div>3800</div><div>Keyboard Address Matrix</div></div>
								<div class="assembly-row-combined"><div>DSPAD$</div><div>3C00</div><div>Video RAM / Screen Addresses</div></div>
								<div class="assembly-row-combined"><div>CHARC</div><div>4099H</div><div>Last key pressed on the keyboard</div></div>
								<div class="assembly-row-combined"><div>CASIO$</div><div>255</div><div>The cassette I/O port</div></div>
								<div class="assembly-row-combined"><div>VALTYP</div><div>40AFH</div><div>Type
 variable flag for value in Work-Register-Area-1. Will be 2 for Integer,
 3 for string, 4 for single precision, and 8 for double precision</div></div>
								<div class="assembly-row-combined"><div>DSCTMP</div><div>40D3H</div><div>VARPTR storage area for string currently being created by BASIC</div></div>
								<div class="assembly-row-combined"><div>CLMWID</div><div>14</div><div>Comma column width</div></div>
								<div class="assembly-row-combined"><div>DATPSC</div><div>256</div><div>Data bytes in a diskette sector</div></div>
								<div class="assembly-row-combined"><div>LINLN</div><div>80</div><div>Terminal maximum line length</div></div>
								<div class="assembly-row-combined"><div>LPTLEN</div><div>80 / 132</div><div>Printer maximum line width, Regular / LPT3</div></div>
								<div class="assembly-row-combined"><div>BUFLEN</div><div>72 / 255</div><div>Buffer size for INPUT / Long Lines</div></div>
								<div class="assembly-row-combined"><div>NAMLEN</div><div>40</div><div>Maximum filename length</div></div>
								<div class="assembly-row-combined"><div>NUMTMP</div><div>3</div><div>Number of String Temporaries</div></div>
								<div class="assembly-row-combined"><div>NUMLEV</div><div>0*20+19+2*5</div><div>Number of STACK Levels Reserved</div></div>
							</div>
						</div>
					</div>


					<div class="section-wrapper">
						<h2 id="main-disassembly">Main Disassembly<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2><br>
						<div class="section-content">
							<h2 class="assembly-section-title" id="0000H">0000H-0004H - Power Up Routine<span class="origrom">- "START"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>0000-0002 Disables the interrupts, clears the A register, then jumps to initialisation routine at 674H</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="0000H"><div>0000<span class="origrom2" style="display: inline;">START</span></div><div>DI<span class="opcode2" style="display: none;">F3</span></div><div>Disables the interrupts and turns off clock</div></div>
									<div class="assembly-row-combined"><div>0001</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Clears the A Register and status</div></div>
									<div class="assembly-row-combined"><div>0002-0004</div><div><a href="#0674H" class="memory-link">JP 0674H<span class="origrom2" style="display: inline;">JP INIT</span></a><span class="opcode2" style="display: none;">C3 74 06</span></div><div>Go to the Level II BASIC initialization routine</div></div>
									<div class="assembly-row-combined"><div>0005-0007</div><div>JP 4000H<span class="origrom2" style="display: inline;">JP RST1$</span><span class="opcode2" style="display: none;">C3 00 40</span></div><div>Go to RST 0008H code via 4000H.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0008H">0008H - RST 08H - Syntax Check<span class="origrom">- "SYNTAX"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine is used for scanning strings. It compares the 
character pointed to by the HL Register Pair with the character pointed 
to by the return address on the top of the STACK. If they are not equal 
an SN ERROR will result; if they are equal then the return address on 
the STACK will be incremented to bypass the test character and control 
will be passed to RST 10H logic.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0008<span class="origrom2" style="display: inline;">SYNTAX</span><br>(RST 008H)</div><div><a href="https://www.trs-80.com/sub-disassem-dos-td23-sys-0.htm#4000H" class="memory-link">JP 4000H<span class="origrom2" style="display: inline;">JP RST1$</span></a><span class="opcode2" style="display: none;">C3 00 40</span></div><div>Jumps
 to 4000H. 4000H passes control to 1C96H. This routine is used for 
scanning strings. It compares the character pointed to by the HL 
Register Pair with the character pointed to by the return address on the
 top of the STACK (Note that a RST instruction is in effect a CALL and 
places a return address on the STACK) formula: (HL)=((SP))? If they are 
not equal an SN ERROR will result; if they are equal then the return 
address on the STACK will be incremented to bypass the test character 
and control will be passed to RST 10H logic. RST 8H is used to look for 
expected characters in a string and then return with (HL) pointing to 
the next non-blank character. (see RST l0H) (BC and DE registers 
unaffected.). This routine can be used by CALLing 1C96H or RST 8H.<br><br>This
 is the COMPARE SYMBOL routine which compares the symbol in the input 
string pointed to by HL Register to the value in the location following 
the RST 08 call. If there is a match, control is returned to address of 
the RST 08 instruction 2 with the next symbol in Register A and HL 
incremented by one. If the two characters do not match, a syntax error 
message is given and control returns to the Input Phase.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="000BH">000BH-000CH - Disk Routine<span class="origrom">- "WHERE"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>000B<span class="origrom2" style="display: inline;">WHERE</span></div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the address from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>000C</div><div>JP (HL)<span class="opcode2" style="display: none;">E9</span></div><div>Jump to the location of the address in Register Pair HL</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="000DH">000DH-000FH - Disk Bootstrap<span class="origrom">- "$BOOT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>000D-000F<span class="origrom2" style="display: inline;">$BOOT</span></div><div><a href="#069FH" class="memory-link">JP 069FH<span class="origrom2" style="display: inline;">JP BOOT</span></a><span class="opcode2" style="display: none;">C3 9F 06</span></div><div>Jump to the disk load and run sector routine at 069FH</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0010H">0010H-0012H - RST 10H - Get a Character from the Buffer<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine increments HL and tests the characters pointed 
to by the HL Register Pair. It will bypass any spaces and characters 9 
and 10 (shifted left and down arrows respectively). Upon return from 
this routine HL will point to the next non-blank character.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0010<br>(RST 010H)</div><div><a href="https://www.trs-80.com/sub-disassem-dos-td23-sys-0.htm#4003H" class="memory-link">JP 4003H<span class="origrom2" style="display: inline;">JP RST2$</span></a><span class="opcode2" style="display: none;">C3 03 40</span></div><div>Jumps to 1D78H (RST 0010H vector) through 4003H.<br><br>This
 routine INCrements HL and tests the characters pointed to by the HL 
Register Pair. It will bypass any spaces and CHAR'S 9 and 10 (shifted 
left and down arrows respectively). Upon return from this routine HL 
will point to the next non-blank character; the carry flag will be SET 
(C=1) if HL is pointing to a number and the Z flag will be SET if the 
character pointed to happens to be zero (ASCII 30H) or 3AH (":"). The 
carry flag will be RESET (0) if the character is non-numeric. (BC and DE
 registers are unaffected) This routine can be used by CALLing 1D78H or 
RST 10H</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0013H">0013H-0017H - Input Routine<span class="origrom">- "$GET"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine inputs a byte from an input device. When 
calling, DE = starting address of DCB of device. On exit, A = byte 
received from device, Z set if device ready. Uses AF.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0013<span class="origrom2" style="display: inline;">$GET</span></div><div>PUSH BC<span class="opcode2" style="display: none;">C5</span></div><div>Save the value in Register Pair BC on the STACK</div></div>
									<div class="assembly-row-combined"><div>0014-0015</div><div>LD B,01H<span class="opcode2" style="display: none;">06 01</span></div><div>Load Register B with the device type entry code of 01H</div></div>
									<div class="assembly-row-combined"><div>0016-0017</div><div><a href="#0046H" class="memory-link">JR 0046H<span class="origrom2" style="display: inline;">JR CIOJ</span></a><span class="opcode2" style="display: none;">18 2E</span></div><div>Jump to the Level II BASIC driver entry routine at 0046H</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0018H">0018H - RST 18H - Compare DE:HL<span class="origrom">- "RST18"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine compares two 16 bit values in HL and DE and sets
 the S and Z flags accordingly (they are set in the same way as for a 
normal 8 bit CP). All registers are unchanged except for A.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0018<span class="origrom2" style="display: inline;">RST18</span></div><div><a href="https://www.trs-80.com/sub-disassem-dos-td23-sys-0.htm#4006H" class="memory-link">JP 4006H<span class="origrom2" style="display: inline;">JP RST3$</span></a><span class="opcode2" style="display: none;">C3 06 40</span></div><div>Jumps
 to 1C90H through 4006H. This routine can be called by using RST 18H or 
CALL lC90H. It compares two 16 bit values in HL and DE and sets the S 
and Z flags accordingly (they are set in the same way as for a normal 8 
bit CP). All registers are unchanged except for A.<br><br>This is the 
COMPARE DE:HL routine, which numerically compares DE and HL. Will not 
work for signed integers (except positive ones). Uses the A-register 
only. The result of the comparison is returned in the status Register 
as: <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="001BH">001BH-001EH - Driver Entry Routine - Part 1<span class="origrom">- "PUT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine outputs a byte to a device. When calling, A = 
output byte, DE = starting address of DCB of device. On exit, Z set if 
device ready. Uses AF.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>001B<span class="origrom2" style="display: inline;">PUT</span></div><div>PUSH BC<span class="opcode2" style="display: none;">C5</span></div><div>Save the value in Register Pair BC on the STACK</div></div>
									<div class="assembly-row-combined"><div>001C-001D</div><div>LD B,02H<span class="opcode2" style="display: none;">06 02</span></div><div>Load Register B with the device type entry code of 02H</div></div>
									<div class="assembly-row-combined"><div>001E-001F</div><div><a href="#0046H" class="memory-link">JR 0046H<span class="origrom2" style="display: inline;">JR CIOJ</span></a><span class="opcode2" style="display: none;">18 26</span></div><div>Jump to the Level II BASIC driver entry routine at 0046H</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0020H">0020H - RST 20H - Data Mode Check<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Returns a combination of STATUS flags and unique numeric 
values in the A Register according to the data mode flag (40AFH). 
Integer = NZ/C/M/E and A is -1; String = Z/C/P/E and A is 0; Single 
Precision = NZ/C/P/O and A is 1; and Double Precision is NZ/NC/P/E and A
 is 5.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0020<br>(RST 020H)</div><div><a href="https://www.trs-80.com/sub-disassem-dos-td23-sys-0.htm#4009H" class="memory-link">JP 4009H<span class="origrom2" style="display: inline;">JP RST4$</span></a><span class="opcode2" style="display: none;">C3 09 40</span></div><div>This
 routine jumps to 25D9H through 4009H. If the NTF=8 then C=RESET or else
 C=SET, Z flag will be SET if NTF=3 (S flag is valid also.). After 
execution of RST 20H or CALL 25D9H, A will contain the value NTF-3, all 
other registers are unchanged.<br><br>Returns a combination of STATUS flags and unique numeric values in the A Register according to the data mode flag (40AFH).<br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table>This
 CALL is usually made to determine the type of the current value in the 
ACCumulator (i.e., 4121H-4122H). It should be used with caution, however
 since the mode flag and ACCumulator can get out of phase particularly 
if some of the CALLS described here are used to load ACCumulator</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0023H">0023H-0027H - Disk Routine<span class="origrom">- "$CTL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0023<span class="origrom2" style="display: inline;">$CTL</span></div><div>PUSH BC<span class="opcode2" style="display: none;">C5</span></div><div>Save the value in register pair BC on the STACK.</div></div>
									<div class="assembly-row-combined"><div>0024-0025</div><div>LD B,04H<span class="opcode2" style="display: none;">06 04</span></div><div>Load register B with the device type entry code of 04H.</div></div>
									<div class="assembly-row-combined"><div>0026-0027</div><div><a href="#0046H" class="memory-link">JR 0046H<span class="origrom2" style="display: inline;">JR CIOJ</span></a><span class="opcode2" style="display: none;">18 1E</span></div><div>Jump to the Level II BASIC driver entry routine at 0046H</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0028H">0028H - RST 28H - DOS Function Call<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Jumps to 400CH which contains C9H (RET) under Level II BASIC.
 This vector is only used by Disk BASIC. It is called by the BREAK key 
routine, and can be used to intercept the BREAK key logic.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0028<br>(RST 028H)</div><div><a href="https://www.trs-80.com/sub-disassem-dos-td23-sys-0.htm#400CH" class="memory-link">JP 400CH<span class="origrom2" style="display: inline;">JP RST5$</span></a><span class="opcode2" style="display: none;">C3 0C 40</span></div><div>Jumps
 to 400CH which contains C9H (RET) under Level II BASIC. This vector is 
only used by Disk BASIC. It is called by the BREAK key routine, and can 
be used to intercept the BREAK key logic.<br><br>This is the DOS 
FUNCTION CALL routine at RST 28 (which passes request code in A-register
 to DOS for processing. Returns for non-disk system. For disk systems, 
the A Register must contain a legitimate DOS function code. If the code 
is positive, the CALL is ignored and control returns to the caller. Note
 that the DOS routine discards the return address stored on the STACK by
 the RST instruction. After processing control will be returned to the 
previous address on the STACK)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="002BH">002BH-002FH - Keyboard Routine<span class="origrom">- "$KBD"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Keyboard scanning routine. Performs an instantaneous scan of 
the keyboard. If no key is depressed control is returned to the caller 
with the A Register and status Register set to zero. If any key (except 
the BREAK key) is active the ASCII value for that character is returned 
in the A-register.</p>
								<p>Of the 3 keyboard scanning routines, this is the most 
fundamental one. If no key is pressed when the CALL is executed, the 
code falls through with A = 00H. If you want to wait for a key to be 
pressed, you would use <a href="#0049H" class="memory-link">CALL 0049H</a>or you would write a routine that jumps back to the call if A is 0.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>002B-002D<span class="origrom2" style="display: inline;">$KBD</span></div><div>LD DE,4015H<span class="origrom2" style="display: inline;">LD DE,KDCB$</span><span class="opcode2" style="display: none;">11 15 40</span></div><div>Load Register Pair DE with the starting address of the keyboard device control block.<br>Note: 4015H holds Keyboard DCB - Device type</div></div>
									<div class="assembly-row-combined"><div>002E-002F</div><div><a href="#0013H" class="memory-link">JR 0013H<span class="origrom2" style="display: inline;">JR $GET</span></a><span class="opcode2" style="display: none;">18 E3</span></div><div>JUMP to the Level II BASIC driver entry routine.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0030H">0030H - RST 30H - Load Debug<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This location passes control to 400FH which contains a RET (C9H) under Level II. This location is only used by a Disk system.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0030<br>(RST 030H)</div><div><a href="https://www.trs-80.com/sub-disassem-dos-td23-sys-0.htm#400FH" class="memory-link">JP 400FH<span class="origrom2" style="display: inline;">JP RST6$</span></a><span class="opcode2" style="display: none;">C3 0F 40</span></div><div>This location passes control to 400FH which contains a RET (C9H) under Level II. This location is only used by a Disk system.<br>This
 is the LOAD DEBUG routine, and loads the DEBUG program and transfers 
control to it. When DEBUG processing is complete, control is returned to
 the orginal caller. For non-disk systems control is returned 
immediately.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0033H">0033H-0037H - Video Routine<span class="origrom">- "$DSP"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Character print routine. A CALL 33H will print a character at
 the current cursor position. The A Register must contain the ASCII code
 for the character or graphics figure that is to be printed before 
CALLing this routine. The DE Register Pair is used by the routine.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0033-0035<span class="origrom2" style="display: inline;">$DSP</span></div><div>LD DE,401DH<span class="origrom2" style="display: inline;">LD DE,DDCB$</span><span class="opcode2" style="display: none;">11 1D 40</span></div><div>Load register pair DE with 401DH which is the starting address of the video display device control block.</div></div>
									<div class="assembly-row-combined"><div>0036-0037</div><div><a href="#001BH" class="memory-link">JR 001BH<span class="origrom2" style="display: inline;">JR $PUT</span></a><span class="opcode2" style="display: none;">18 E3</span></div><div>JUMP to the Level II BASIC driver entry routine at 001BH.<br><b>NOTE:</b>
  001BH saves BC to the STACK, Loads B with a 02H device code, and then 
JUMPs to 0046H which JUMPs to the keyboard entry driver routine at 
0674H.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0038H">0038H - RST 38H - Interrupt Entry Point<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the system entry point for all interrupts. It 
contains a jump to a section of code in the Communications Region 
designed to field interrupts.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0038<br>(RST 038H)</div><div><a href="https://www.trs-80.com/sub-disassem-dos-td23-sys-0.htm#4012H" class="memory-link">JP 4012H<span class="origrom2" style="display: inline;">JP RST7$</span></a><span class="opcode2" style="display: none;">C3 12 40</span></div><div>This location will pass control to 4012H. This location is only used by a Disk system.<br><br>This
 is the INTERRUPT ENTRY POINT routine at RST 38H which is the system 
entry point for all interrupts. It contains a jump to a section of code 
in the Communications Region designed to field interrupts. That section 
of code consists of a DI (disables further interrupts) followed by a RET
 (returns to the point of interrupt) for non-disk systems, or a jump to 
an interrupt processor in SYSO if it is a DOS system. For DOS systems 
the interrupt handler consists of a task scheduler, where the exact 
cause of the interrupt is determined (usually a clock interrupt) and the
 next task from the task control block is executed. After task 
completion, control returns to the point of interrupt</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="003BH">003BH-003FH - Printer Routine<span class="origrom">- "$PRT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Character LPRINT routine. Same as 33H but outputs to line 
printer. A call to 003BH causes the character contained in the 
A-register to be sent to the printer. A line count is maintained by the 
driver in the DCB. When a full page has been printed (66 lines), the 
line count is reset and the status Register returned to the caller is 
set to zero.</p>
								<p>Control codes recognized by the printer driver are:</p>
								<ul>
									<li>00=Returns the printer status in the upper two bits of the 
A-register and sets the status as zero if not busy, and non-zero if 
busy.</li>
									<li>OB=Unconditionally skips to the top of the next page.</li>
									<li>OC=Resets the line count (DCB 4) and compares its previous 
value to the lines per page (DCB 3) value. If the line count was zero, 
no action is taken. If the line count was non-zero then a skip to the 
top form is performed.</li>
									<li>OD=Line terminator. Causes line count to be incremented and tested for full page. Usually causes the printer to begin printing.</li>
								</ul>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>003B-003D<span class="origrom2" style="display: inline;">$PRT</span></div><div>LD DE,4025H<span class="origrom2" style="display: inline;">LD DE,PDCB$</span><span class="opcode2" style="display: none;">11 25 40</span></div><div>Load register pair DE with 4025H which is the starting address of the printer device control block.</div></div>
									<div class="assembly-row-combined"><div>003E-003F</div><div><a href="#001BH" class="memory-link">JR 001BH<span class="origrom2" style="display: inline;">JR $PUT</span></a><span class="opcode2" style="display: none;">18 DB</span></div><div>Jump to the Level II BASIC printer driver entry routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0040H">0040H-0042H - Input Routine<span class="origrom">- "$KEYIN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0040-0042<span class="origrom2" style="display: inline;">$KEYIN</span></div><div><a href="#05D9H" class="memory-link">JP 05D9H<span class="origrom2" style="display: inline;">JP KEYIN</span></a><span class="opcode2" style="display: none;">C3 D9 05</span></div><div>Jump
 to the "WAIT FOR NEXT LINE" keyboard input routine at 05D9 (which takes
 keyboard entry until a carriage return, a break, or buffer overrun 
occurs)</div></div>
									<div class="assembly-row-combined"><div>0043</div><div>RET</div><div></div></div>
									<div class="assembly-row-combined"><div>0044<span class="opcode2" style="display: none;">00</span></div><div>NOP</div><div></div></div>
									<div class="assembly-row-combined"><div>0045</div><div>NOP</div><div></div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0046H">0046H-0048H - Driver Entry Routine - Part 2<span class="origrom">- "CIOJ"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0046-0048<span class="origrom2" style="display: inline;">CIOJ</span><span class="opcode2" style="display: none;">C3 C2 03</span></div><div><a href="#03C2H" class="memory-link">JP 03C2H<span class="origrom2" style="display: inline;">JP CIO</span></a></div><div>Jump to the Level II BASIC keyboard driver entry routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0049H">0049H-004FH - Keyboard Routine<span class="origrom">- "$KEY"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>A call to 0049H returns as soon as any key on keyboard is 
pressed, exactly how the INKEY$ function works in BASIC. ASCII value for
 character entered is returned in A register. If you don't want the 
program to hold while waiting for a key, you would use <a href="#002BH" class="memory-link">CALL 002BH</a>instead.</p>
								<p>Character input routine. This routine is the same as 2BH 
except that it will not return until a key is pressed, which often makes
 it more useful than 2BH. Character is returned in the A Register (AF 
and DE used).</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0049-004B<span class="origrom2" style="display: inline;">$KEY</span></div><div><a href="#002BH" class="memory-link">CALL 002BH<span class="origrom2" style="display: inline;">CALL $KBD</span></a><span class="opcode2" style="display: none;">CD 2B 00</span></div><div>Go scan the keyboard and return with the key pressed, if any, in Register A.<br><br>A
 CALL to this memory location returns as soon as any key on keyboard is 
pressed. ASCII value for character entered is returned in A register. 
Uses A, status, and DE registers.<br><br>Character input routine. This 
routine is the same as 2BH (=Scan the Keyboard routine) except that it 
will not return until a key is pressed</div></div>
									<div class="assembly-row-combined"><div>004C</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check the value in Register A to see if a key was pressed</div></div>
									<div class="assembly-row-combined"><div>004D</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>Return if a key was pressed</div></div>
									<div class="assembly-row-combined"><div>004E-004F</div><div><a href="#0049H" class="memory-link">JR 0049H<span class="origrom2" style="display: inline;">JR $KEY</span></a><span class="opcode2" style="display: none;">18 F9</span></div><div>Loop until a key is pressed</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0050H">0050H-005FH - Keyboard Lookup Table<span class="origrom">- "KEYTAB"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is a table of control characters used by BASIC.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0050<span class="origrom2" style="display: inline;">KEYTAB</span></div><div>0DH</div><div>ENTER (0DH)</div></div>
									<div class="assembly-row-combined"><div>0051</div><div>0DH</div><div>Shift ENTER (0DH)</div></div>
									<div class="assembly-row-combined"><div>0052</div><div>1FH</div><div>CLEAR (1FH)</div></div>
									<div class="assembly-row-combined"><div>0053</div><div>1FH</div><div>Shift CLEAR (1FH)</div></div>
									<div class="assembly-row-combined"><div>0054</div><div>01H</div><div>BREAK (01H)</div></div>
									<div class="assembly-row-combined"><div>0055</div><div>01H</div><div>Shift BREAK (01H)</div></div>
									<div class="assembly-row-combined"><div>0056</div><div>5BH</div><div>Up Arrow (5BH)</div></div>
									<div class="assembly-row-combined"><div>0057</div><div>1BH</div><div>Shift Up Arrow (1BH) aka Escape</div></div>
									<div class="assembly-row-combined"><div>0058</div><div>0AH</div><div>Down Arrow (0AH) aka Line Feed</div></div>
									<div class="assembly-row-combined"><div>0059</div><div>1AH</div><div>ROM before v1.3 - Shift Down Arrow (1AH); ROM v1.3 - NOP to permit Shift-Down-Arrow to act as a control key</div></div>
									<div class="assembly-row-combined"><div>005A</div><div>08H</div><div>Left Arrow (08H)</div></div>
									<div class="assembly-row-combined"><div>005B</div><div>18H</div><div>Shift Left Arrow (18H)</div></div>
									<div class="assembly-row-combined"><div>005C</div><div>09H</div><div>Right Arrow (09H)</div></div>
									<div class="assembly-row-combined"><div>005D</div><div>19H</div><div>Shift Right Arrow (19H)</div></div>
									<div class="assembly-row-combined"><div>005E</div><div>20H</div><div>SPACE (20H)</div></div>
									<div class="assembly-row-combined"><div>005F</div><div>20H</div><div>Shift SPACE (20H)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0060H">0060H-0065H - Delay Routine<span class="origrom">- "$PAUSE"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is a delay loop. The BC Register Pair is used as the 
loop counter. The duration of the delay, in microseconds, is the value 
of BC times 14.66. Register A is used.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0060<span class="origrom2" style="display: inline;">PAUSE</span></div><div>DEC BC<span class="opcode2" style="display: none;">0B</span></div><div>Decrement the counter in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>0061-0062</div><div>LD A,B<br>OR C<span class="opcode2" style="display: none;">78 B1</span></div><div>There
 is no way to COMPARE BC against anything, so the common "trick" is to 
load Register A with Register B and then OR it against Register C. If 
you do this, Register A can only be zero if both Registers B and C are 
zero</div></div>
									<div class="assembly-row-combined"><div>0063-0064</div><div><a href="#0060H" class="memory-link">JR NZ,0060H<span class="origrom2" style="display: inline;">JR NZ,PAUSE</span></a><span class="opcode2" style="display: none;">20 FB</span></div><div>Loop until the counter in Register Pair BC is equal to zero</div></div>
									<div class="assembly-row-combined"><div>0065</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0066H">0066H-0068H - NMI Vector<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>0066 is the location to which program control jumps when the RESET button is pressed (Non Maskable Interrupt address).</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0066-0068<span class="origrom2" style="display: inline;">NMI</span></div><div>LD SP,0600H<span class="origrom2" style="display: inline;">LD SP,$CODE + 3000 Octal</span><span class="opcode2" style="display: none;">31 00 06</span></div><div>Set the STACK pointer to 0600H.<br><br>This is the location to which program control jumps when the RESET button is pressed (Non Maskable Interrupt address)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0069H">0069H-0074H - NMI Interrupt Routine (RESET)<span class="origrom">- "$INITIO"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This part of the initialization routine checks to see if a 
disk drive is connected. If so, it will jump to 00H. (This is why the 
reset button will reinitialize DOS.)</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0069-006B</div><div>LD A,(37ECH)<span class="origrom2" style="display: inline;">LD A,FDCAD$</span><span class="opcode2" style="display: none;">3A EC 37</span></div><div>Load Register A with the disk controller status (stored in 37ECH)
										<table class="data-table">
											<thead><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead>
											<tbody> <tr><td>Not<br>Ready</td><td>Protected</td><td>Head<br>Loaded</td><td>Seek<br>Error</td><td>CRC<br>Error</td><td>Track 00</td><td>Index</td><td>Busy</td></tr> </tbody>
										</table>
									</div></div>
									<div class="assembly-row-combined"><div>006C</div><div>INC A<span class="opcode2" style="display: none;">3C</span></div><div>Increment the disk controller status in Register A</div></div>
									<div class="assembly-row-combined"><div>006D-006E</div><div>CP 02H<span class="opcode2" style="display: none;">FE 02</span></div><div>Check the value in Register A to see if a disk is present. It is usually FFH if there is no expansion interface operating</div></div>
									<div class="assembly-row-combined"><div>006F-0071</div><div><a href="#0000H" class="memory-link">JP NC,0000H<span class="origrom2" style="display: inline;">JP NC,START</span></a><span class="opcode2" style="display: none;">D2 00 00</span></div><div>If a disk is present, go to the Level II BASIC power up routine</div></div>
									<div class="assembly-row-combined"><div>0072-0074</div><div><a href="#06CCH" class="memory-link">JP 06CCH<span class="origrom2" style="display: inline;">JP RESETR</span></a><span class="opcode2" style="display: none;">C3 CC 06</span></div><div>Since
 we are without disk drives at this, this would be for power on or reset
 ... so jump to the Level II BASIC READY routine at 06CCH</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0075H">0075H-0104H - Initialization Routine<span class="origrom">- "INIT2"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is part of the Level II initialization procedure. It 
moves a block of memory from 18F7H to 191EH up to 4080H to 40A7H 
(reserved RAM area).</p>
								<p>Note: 4080H-408DH is a division support routine.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0075-0077</div><div>LD DE,4080H<span class="origrom2" style="display: inline;">LD DE,RAMLOW</span><span class="opcode2" style="display: none;">11 80 40</span></div><div>Load register pair DE with 4080H which is the start of the ROM storage location of the Level II BASIC division routine.</div></div>
									<div class="assembly-row-combined"><div>0078-007A</div><div>LD HL,18F7H<span class="origrom2" style="display: inline;">LD HL,CONSTR</span><span class="opcode2" style="display: none;">21 F7 18</span></div><div>Load register pair HL with the RAM storage location of the Level II BASIC division routine.</div></div>
									<div class="assembly-row-combined"><div>007B-007D</div><div>LD BC,0027H<span class="origrom2" style="display: inline;">LD BC,CNSLNR+1</span><span class="opcode2" style="display: none;">01 27 00</span></div><div>Load register pair BC with the length of the Level II BASIC division routine (39 bytes).</div></div>
									<div class="assembly-row-combined"><div>007E-007F</div><div>LDIR<span class="opcode2" style="display: none;">ED B0</span></div><div>Move the Level II BASIC division routine in ROM (18F7H-191DH) to RAM (4080H-40A6H)</div></div>
									<div class="assembly-row-combined"><div>0080-0082</div><div>LD HL,41E5H<span class="origrom2" style="display: inline;">LD HL,BUFINI-3</span><span class="opcode2" style="display: none;">21 E5 41</span></div><div>Continue with the communication region initialization by loading Register Pair HL with a RAM pointer to 41E5H</div></div>
									<div class="assembly-row-combined"><div>0083-0084</div><div>LD (HL),3AH<span class="origrom2" style="display: inline;">LD (HL),":"</span><span class="opcode2" style="display: none;">36 3A</span></div><div>Save a 3AH (which a ":") at the location of the memory pointer in Register Pair HL (which is 41E5H)</div></div>
									<div class="assembly-row-combined"><div>0085</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the memory pointer in Register Pair HL from 41E5H to 41E6H</div></div>
									<div class="assembly-row-combined"><div>0086</div><div>LD (HL),B<span class="opcode2" style="display: none;">70</span></div><div>Zero out 41E6H (the location of the memory pointer in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>0087</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the memory pointer in Register Pair HL from 41E6H to 41E7H</div></div>
									<div class="assembly-row-combined"><div>0088-0089</div><div>LD (HL),2CH<span class="origrom2" style="display: inline;">LD (HL),","</span><span class="opcode2" style="display: none;">36 2C</span></div><div>Save a 2CH (which is a ",") at 41E7H (the location of the memory pointer in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>008A</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the memory pointer in Register Pair HL from 41E7H to 41E8H, which is the input/output buffer BUFINI</div></div>
								</div>
								<p>This loads 40A7H with the I/O buffer location address 41E8H. 
(40A7H is the I/O buffer pointer and can be changed to relocate the 
buffer.)</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>008B-008D</div><div>LD (40A7H),HL<span class="origrom2" style="display: inline;">LD (BUFPNT),HL</span><span class="opcode2" style="display: none;">22 A7 40</span></div><div>This
 loads the input buffer pointer (held at 40A7H) with the keyboard buffer
 location address of 41E8H. (40A7H is the I/O buffer pointer and can be 
changed to relocate the buffer.). Save the value in Register Pair HL as 
the starting address of the keyboard input buffer area.<br>Note: 40A7H-40A8H holds the input Buffer pointer</div></div>
									<div class="assembly-row-combined"><div>008E-0090</div><div>LD DE,012DH<span class="origrom2" style="display: inline;">LD DE,NAVERR</span><span class="opcode2" style="display: none;">11 2D 01</span></div><div>In preparation for a jump, load Register Pair DE with the starting address of the <span class="code">?L3 ERROR</span> routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0091H">0091H-0104H - The rest of the initialization routine.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>First, it fills the RAM locations pointing to all 28 DOS 
BASIC commands, set them to point to ?L3 ERROR, ask MEMORY SIZE ?, sets 
the memory pointers accordingly and prints RADIO SHACK LEVEL II BASIC, 
then it jumps to 1A19H which is the entry point for the BASIC command 
mode.
								</p><div class="assembly-table">
									<div class="assembly-row-combined"><div>0091-0092</div><div>LD B,1CH<span class="origrom2" style="display: inline;">LD B,ERCNT</span><span class="opcode2" style="display: none;">06 1C</span></div><div>Since
 there are 28 pre-defined DOS BASIC commands in ROM, load Register B 
with the number of times (=28) to save the jump to the <span class="code">?L3 ERROR</span> routine</div></div>
									<div class="assembly-row-combined"><div>0093-0095</div><div>LD HL,4152H<span class="origrom2" style="display: inline;">LD HL,ERCALL</span><span class="opcode2" style="display: none;">21 52 41</span></div><div>Load
 Register Pair HL with the starting address of the Disk Basic links 
(which is 4152H) in preparation for generating an error if disk basic 
commands are attempted.<br>Note: 4152H-41A3H holds Disk Basic links</div></div>
									<div class="assembly-row-combined" id="0096H"><div>0096-0097<span class="origrom2" style="display: inline;">ERLOPS</span></div><div>LD (HL),0C3H<span class="opcode2" style="display: none;">36 C3</span></div><div>Save a C3H (the first OPCODE for JP nnnn) to the first of every 3 byte instruction in the Disk Basic command list</div></div>
									<div class="assembly-row-combined"><div>0098</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the memory pointer in Register Pair HL to point to the 2nd of each 3 byte instruction in the Disk Basic command list</div></div>
									<div class="assembly-row-combined"><div>0099</div><div>LD (HL),E<span class="opcode2" style="display: none;">73</span></div><div>Save the LSB of the <span class="code">?L3 ERROR</span> routine's starting address in Register E (i.e., a 2DH) to the 2nd of each 3 byte instruction in the Disk Basic command list</div></div>
									<div class="assembly-row-combined"><div>009A</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment
 the memory pointer in register pair HL to the 3rd instruction of each 3
 byte instruction in the Disk Basic command list, so as to point to the 
associated JUMP xxxxH command.</div></div>
									<div class="assembly-row-combined"><div>009B</div><div>LD (HL),D<span class="opcode2" style="display: none;">72</span></div><div>Save the MSB of the <span class="code">?L3 ERROR</span> routine's starting address in register D (i.e., a 01H) to the location of the memory pointer in register pair HL.<br><b>NOTE:</b>  Now we have JUMP 2D01H as the instruction.  012DH is the JUMP point for a <span class="code">?L3 ERROR</span>.</div></div>
									<div class="assembly-row-combined"><div>009C</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the memory pointer in Register Pair HL to the 1st byte of the next Disk Basic command in the list</div></div>
									<div class="assembly-row-combined"><div>009D-009E</div><div><a href="#0096H" class="memory-link">DJNZ 0096H<span class="origrom2" style="display: inline;">DJNZ ERLOPS</span></a><span class="opcode2" style="display: none;">10 F7</span></div><div>Do this for all 28 disk basic commands until all of the Disk Basic links have been set to jump to the <span class="code">?L3 ERROR</span> routine.</div></div>
									<div class="assembly-row-combined"><div>009F-00A0</div><div>LD B,15H<span class="origrom2" style="display: inline;">LD B,RETCNT</span><span class="opcode2" style="display: none;">06 15</span></div><div>Load
 Register B with the number of DOS links to set to RETs. Note: HL is 
41A6H at this point. In the original ROM source, this was "LD B,RETCNT"</div></div>
									<div class="assembly-row-combined" id="00A1H"><div>00A1-00A2<span class="origrom2" style="display: inline;">LOPRTS</span></div><div>LD (HL),0C9H<span class="opcode2" style="display: none;">36 C9</span></div><div>Save a C9H (i.e. RETurn) to the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined"><div>00A3</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment
 the memory pointer in Register Pair HL, as it is irrelevant what this 
memory location holds since RET is a single OPCODE</div></div>
									<div class="assembly-row-combined"><div>00A4</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment
 the memory pointer in Register Pair HL, as it is irrelevant what this 
memory location holds since RET is a single OPCODE</div></div>
									<div class="assembly-row-combined"><div>00A5</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the memory pointer in Register Pair HL to point to the next error jump instruction</div></div>
									<div class="assembly-row-combined"><div>00A6-00A7</div><div><a href="#00A1H" class="memory-link">DJNZ 00A1H<span class="origrom2" style="display: inline;">DJNZ LOPRTS</span></a><span class="opcode2" style="display: none;">10 F9</span></div><div>Loop from 4156H until all of the DOS links have been set to RETs</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="00A8H">00A8H - VIDEO AND PRINTER ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>00A8-00AA</div><div>LD HL,42E8H<span class="origrom2" style="display: inline;">LD HL,ENBINI</span><span class="opcode2" style="display: none;">21 E8 42</span></div><div>Load
 Register Pair HL with the starting address of user RAM (which is 
42E8H).  In the original ROM source, this address was "ENBINI" although 
this is also defined as "TSTACK" elsewhere</div></div>
									<div class="assembly-row-combined"><div>00AB</div><div>LD (HL),B<span class="opcode2" style="display: none;">70</span></div><div>Zero the end of the buffer (i.e., 42E8H, the location of the memory pointer in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>00AC-00AE</div><div>LD SP,41F8H<span class="origrom2" style="display: inline;">LD SP,BUFINI+20</span><span class="opcode2" style="display: none;">31 F8 41</span></div><div>Set the current STACK pointer to 41F8H (which is 16888).  In the original ROM source, this address was set as "BUFINI+20"</div></div>
									<div class="assembly-row-combined"><div>00AF-00B1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1B8FH" class="memory-link">CALL 1B8FH<span class="origrom2" style="display: inline;">CALL STKINI</span></a><span class="opcode2" style="display: none;">CD 8F 1B</span></div><div>Go initialize the Level II BASIC variables and pointers</div></div>
									<div class="assembly-row-combined"><div>00B2-00B4</div><div><a href="#01C9H" class="memory-link">CALL 01C9H<span class="origrom2" style="display: inline;">CALL CLS</span></a><span class="opcode2" style="display: none;">CD C9 01</span></div><div>Call the CLEAR SCREEN routine at 01C9 (which clears the screen, changes to 64 characters, and homes the screen)</div></div>
									<div class="assembly-row-combined" id="00B5H"><div>00B5-00B7<span class="origrom2" style="display: inline;">MEMGET</span></div><div>LD HL,0105H<span class="origrom2" style="display: inline;">LD HL,MEMMSG</span><span class="opcode2" style="display: none;">21 05 01</span></div><div>Load
 Register Pair HL with the starting address of the MEMORY SIZE? message 
in ROM.  In the original ROM source, this address was set as "LD 
HL,MEMMSG"</div></div>
									<div class="assembly-row-combined"><div>00B8-00BA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#28A7H" class="memory-link">CALL 28A7H<span class="origrom2" style="display: inline;">CALL STROUT</span></a><span class="opcode2" style="display: none;">CD A7 28</span></div><div>Call the WRITE MESSAGE routine at 28A7H to print the message pointed to by HL.<br><span class="bold">NOTE:</span><br><ul><li>The routine at 28A7 displays the message pointed to by HL on current system output device (usually video).</li><li>The string to be displayed must be terminated by a byte of machine zeros or a carriage return code 0D.</li><li>If terminated with a carriage return, control is returned to the caller after taking the DOS exit at 41D0H (JP 5B99H).</li></ul></div></div>
									<div class="assembly-row-combined"><div>00BB-00BD</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1BB3H" class="memory-link">CALL 1BB3H<span class="origrom2" style="display: inline;">CALL QINLIN</span></a><span class="opcode2" style="display: none;">CD B3 1B</span></div><div>Print a "?" and get input from the keyboard</div></div>
									<div class="assembly-row-combined"><div>00BE-00BF</div><div><a href="#00B5H" class="memory-link">JR C,00B5H<span class="origrom2" style="display: inline;">JR C,MEMGET</span></a><span class="opcode2" style="display: none;">38 F5</span></div><div>If
 the BREAK key was pressed, ask again.  Note: 1BB3H jumps around A LOT 
but it is 0661H which processes a BREAK key, and starts by setting the 
carry flag</div></div>
									<div class="assembly-row-combined"><div>00C0</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H<span class="origrom2" style="display: inline;">CHRGET</span></a><span class="opcode2" style="display: none;">D7</span></div><div>Since
 we now need to increment the input buffer pointer until it points to 
the first character of the input, call the EXAMINE NEXT SYMBOL routine 
at RST 10H.<br><br>The RST 10H routine parses the characters starting at
 HL+1 for the first non-SPACE,non-09H,non-0BH character it finds.  On 
exit, Register A will hold that character, and the C FLAG is set if its 
alphabetic, and NC FLAG if its alphanumeric.  All strings must have a 
00H at the end.</div></div>
									<div class="assembly-row-combined"><div>00C1</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Set
 the status flag based on if the character at the location of the input 
buffer pointer in register A is an end of the input character (00H).</div></div>
									<div class="assembly-row-combined"><div>00C2-00C3</div><div><a href="#00D6H" class="memory-link">JR NZ,00D6H<span class="origrom2" style="display: inline;">JR NZ,TYPMEM</span></a><span class="opcode2" style="display: none;">20 12</span></div><div>Jump forward to 00D6H if there was a response to the MEMORY SIZE? question</div></div>
									<div class="assembly-row-combined"><div>00C4-00C6<span class="origrom2" style="display: inline;">MEMSIZ</span></div><div>LD HL,434CH<span class="origrom2" style="display: inline;">LD HL,TSTACK+100</span><span class="opcode2" style="display: none;">21 4C 43</span></div><div>If
 just an ENTER was hit, need to figure it out dynamically, so load 
Register Pair HL with the starting address for the memory size check, 
which is 100 bytes (064H) after ENBINI</div></div>
									<div class="assembly-row-combined"><div>00C7<span class="origrom2" style="display: inline;">LOOPMM</span></div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>We are going to start testing RAM at 444DH (Decimal: 17485) toward 65535, so increment the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined"><div>00C8-00C9</div><div>LD A,H<br>OR L<span class="opcode2" style="display: none;">7C</span></div><div>There
 is no way to COMPARE HL against anything, so the common "trick" is to 
load Register A with Register H and then OR it against Register L.  If 
you do this, Register A can only be zero if both Registers H and L are 
zero</div></div>
									<div class="assembly-row-combined"><div>00CA-00CB</div><div><a href="#00E7H" class="memory-link">JR Z,00E7H<span class="origrom2" style="display: inline;">JR Z,USEDEF</span></a><span class="opcode2" style="display: none;">28 1B</span></div><div>Since
 we need to scan all the way up to 65535, jump to 00E7H (which drops the
 memory size pointer by 1) if the current memory pointer in Register 
Pair HL is equal to zero</div></div>
									<div class="assembly-row-combined"><div>00CC</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load Register A with the value at the location of the current memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>00CD</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Load Register B with the value in Register A to preserve it, as A is about to get used</div></div>
									<div class="assembly-row-combined"><div>00CE</div><div>CPL<span class="opcode2" style="display: none;">2F</span></div><div>Complement the value in Register A (which is basically a test pattern)</div></div>
									<div class="assembly-row-combined"><div>00CF</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save the test pattern in register A to the location of the current memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined"><div>00D0</div><div>CP (HL)<span class="opcode2" style="display: none;">BE</span></div><div>Check to see if the value at the location of the memory pointer in register pair HL is the same as the value in register A.</div></div>
									<div class="assembly-row-combined"><div>00D1</div><div>LD (HL),B<span class="opcode2" style="display: none;">70</span></div><div>Put back the original memory value (which was saved in B) to the location of the memory pointed in register pair HL.</div></div>
									<div class="assembly-row-combined"><div>00D2-00D3</div><div><a href="#00C7H" class="memory-link">JR Z,00C7H<span class="origrom2" style="display: inline;">JR Z,LOOPMM</span></a><span class="opcode2" style="display: none;">28 F3</span></div><div>If the address exists, loop back to 00C7H until the end of memory is found.</div></div>
									<div class="assembly-row-combined"><div>00D4-00D5</div><div><a href="#00E7H" class="memory-link">JR 00E7H<span class="origrom2" style="display: inline;">JR USEDEF</span></a><span class="opcode2" style="display: none;">18 11</span></div><div>If the address didn't exist, jump to 00E7H (which goes to he next address and tries again).</div></div>
									<div class="assembly-row-combined" id="00D6H"><div>00D6-00D8<span class="origrom2" style="display: inline;">TYPMEM</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E5AH" class="memory-link">CALL 1E5AH<span class="origrom2" style="display: inline;">CALL LINGET</span></a><span class="opcode2" style="display: none;">CD 5A 1E</span></div><div>Here
 the MEMORY SIZE? answer is in HL so call the ASCII TO INTEGER routine 
at 1E5AH (which will put the answer into DE in integer format).<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 routine at 1E5A converts the ASCII string pointed to by HL to an 
integer deposited into DE.  If the routine finds a non-numerica 
character, the conversion is stopped</li></ul></div></div>
									<div class="assembly-row-combined"><div>00D9</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if Register A is equal to zero</div></div>
									<div class="assembly-row-combined"><div>00DA-00DC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1997H" class="memory-link">JP NZ,1997H<span class="origrom2" style="display: inline;">JP NZ,SNERR</span></a><span class="opcode2" style="display: none;">C2 97 19</span></div><div>Display a <span class="code">?SN ERROR</span>if Register A is not equal to zero</div></div>
									<div class="assembly-row-combined"><div>00DD</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Swap
 DE (where the integer version of the MEMORY SIZE? answer is located) 
and HL, so that Register Pair HL now has with the MEMORY SIZE answer 
again, but in integer format</div></div>
									<div class="assembly-row-combined"><div>00DE</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement the MEMORY SIZE? in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>00DF-00E0</div><div>LD A,8FH<span class="opcode2" style="display: none;">3E 8F</span></div><div>Load Register A with a memory test value of <span class="code">8F</span>or <span class="code">10001111</span></div></div>
									<div class="assembly-row-combined"><div>00E1</div><div>LD B,(HL)<span class="opcode2" style="display: none;">46</span></div><div>Load Register B with the value at the location of the MEMORY SIZE? pointer in Register Pair HL (to save the data thats there)</div></div>
									<div class="assembly-row-combined"><div>00E2</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Put the test pattern (in A which is 8FH) into that the location of the MEMORY SIZE? pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>00E3</div><div>CP (HL)<span class="opcode2" style="display: none;">BE</span></div><div>Check to see if the value in the memory location set in HL matches the test pattern in A.</div></div>
									<div class="assembly-row-combined"><div>00E4</div><div>LD (HL),B<span class="opcode2" style="display: none;">70</span></div><div>Restore the old memory contents back.</div></div>
									<div class="assembly-row-combined"><div>00E5-00E6</div><div><a href="#00B5H" class="memory-link">JR NZ,00B5H<span class="origrom2" style="display: inline;">JR NZ,MEMGET</span></a><span class="opcode2" style="display: none;">20 CE</span></div><div>The test at MEMORY SIZE? -1 failed so we have to ask MEMORY SIZE again by jumping to 00B5H.</div></div>
									<div class="assembly-row-combined"><div>00E7<span class="origrom2" style="display: inline;">USEDEF</span></div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement the memory size pointer in Register Pair HL, so it is the amount of memory - 2</div></div>
									<div class="assembly-row-combined"><div>00E8-00EA</div><div>LD DE,4414H<span class="origrom2" style="display: inline;">LD DE,TSTACK+300</span><span class="opcode2" style="display: none;">11 14 44</span></div><div>Load Register Pair DE with the minimum MEMORY SIZE? response, which is 300 bytes (012CH) past ENBINI</div></div>
									<div class="assembly-row-combined"><div>00EB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H<span class="origrom2" style="display: inline;">COMPAR</span></a><span class="opcode2" style="display: none;">DF</span></div><div>Now
 we need to check to see if the MEMORY SIZE? pointer (in HL) is less 
than the minimum MEMORY SIZE? response (in DE), so we call the COMPARE 
DE:HL routine, which numerically compares DE and HL. Will not work for 
signed integers (except positive ones). Uses the A-register only. The 
result of the comparison is returned in the status Register as:  <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>00EC-00EE</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#197AH" class="memory-link">JP C,197AH<span class="origrom2" style="display: inline;">JR C,OMERR</span></a><span class="opcode2" style="display: none;">DA 7A 19</span></div><div>If
 C is set, then the amount of actual memory (in HL) is less than the 
minimum memory required (in DE), so we have to go to the Level II BASIC 
error routine and display an OM ERROR.</div></div>
									<div class="assembly-row-combined"><div>00EF-00F1<span class="origrom2" style="display: inline;">STRSZD</span></div><div>LD DE,FFCEH<span class="origrom2" style="display: inline;">LD DE,65536-STRSZD</span><span class="opcode2" style="display: none;">11 CE FF</span></div><div>Load Register Pair DE with the default size of the string area (i.e., negative fifty)</div></div>
									<div class="assembly-row-combined"><div>00F2-00F4</div><div>LD (40B1H),HL<span class="origrom2" style="display: inline;">LD (MEMSIZ),HL</span><span class="opcode2" style="display: none;">22 B1 40</span></div><div>Save the MEMORY SIZE? amount (which is in HL) to 40B1H (which holds the MEMORY SIZE? pointer).</div></div>
									<div class="assembly-row-combined"><div>00F5</div><div>ADD HL,DE<span class="opcode2" style="display: none;">19</span></div><div>Subtract the size of the string data (which was -50) from the highest memory address (stored in HE).</div></div>
									<div class="assembly-row-combined"><div>00F6-00F8</div><div>LD (40A0H),HL<span class="origrom2" style="display: inline;">LD (STKTOP),HL</span><span class="opcode2" style="display: none;">22 A0 40</span></div><div>Save the start of string space pointer (which is now held Register Pair HL) to 40A0H.<br>Note: 40A0H-40A1H holds the start of string space pointer</div></div>
									<div class="assembly-row-combined"><div>00F9-00FB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1B4DH" class="memory-link">CALL 1B4DH<span class="origrom2" style="display: inline;">CALL SCRTCH</span></a><span class="opcode2" style="display: none;">CD 4D 1B</span></div><div>Go initialize/reset the Level II BASIC variables and pointers.</div></div>
									<div class="assembly-row-combined"><div>00FC-00FE</div><div>LD HL,0111H<span class="origrom2" style="display: inline;">LD HL,HDGMSG</span><span class="opcode2" style="display: none;">21 11 01</span></div><div>Load
 Register Pair HL with the starting address of the RADIO SHACK LEVEL II 
BASIC message. 00FFH-0101H Go display the RADIO SHACK LEVEL II BASIC 
message</div></div>
									<div class="assembly-row-combined"><div>00FF-0101</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#28A7H" class="memory-link">CALL 28A7H<span class="origrom2" style="display: inline;">CALL STROUT</span></a><span class="opcode2" style="display: none;">CD A7 28</span></div><div>We need to display the RADIO SHACK LEVEL II BASIC message so we call the WRITE MESSAGE routine at 28A7.<br><span class="bold">NOTE:</span><br><ul><li>The routine at 28A7 displays the message pointed to by HL on current system output device (usually video).</li><li>The string to be displayed must be terminated by a byte of machine zeros or a carriage return code 0D.</li><li>If terminated with a carriage return, control is returned to the caller after taking the DOS exit at 41D0H (JP 5B99H).</li></ul></div></div>
									<div class="assembly-row-combined"><div>0102-0104</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1A19H" class="memory-link">JP 1A19H<span class="origrom2" style="display: inline;">JP READY</span></a><span class="opcode2" style="display: none;">C3 19 1A</span></div><div>Go to the Level II BASIC READY routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0105H">0105H-0110H - MESSAGE STORAGE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The "MEMORY SIZE" message is located here</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0105-0110<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;MEMMSG</span></div><div class="span2and3">"MEMORY SIZE?" + 00H</div></div>
									<div class="assembly-row-combined"><div>0111-012C</div><div class="span2and3">"RADIO SHACK LEVEL II BASIC" + 0DH +00H</div></div>
									<div class="assembly-row-combined"><div>*0105H-010D</div><div>"MEM SIZE"+00H</div><div>In ROM 1.2, this shortend the "MEMORY SIZE"</div></div>
									<div class="assembly-row-combined"><div>*010E-011B</div><div>"R/S L2 BASIC" + 0DH + 00H</div><div>In ROM 1.2, this is shortend version</div></div>
									<div class="assembly-row-combined"><div>*011C</div><div>PUSH BC</div><div>*In
 ROM v1.2 this is the debounce routine.  First, Put the Row Address in 
BC into the STACK so BC can be used for the debounce routine</div></div>
									<div class="assembly-row-combined"><div>*011D-011F</div><div>LD BC,0500H</div><div>Put 0500H into BC (which would be the debounce delay)</div></div>
									<div class="assembly-row-combined"><div>*0120-0122</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#0060H" class="memory-link">CALL 0060H<span class="origrom2" style="display: inline;">CALL PAUSE</span></a></div><div>Call the delay at 0060H based on the delay count in BC (which is 7.33 milliseconds)</div></div>
									<div class="assembly-row-combined"><div>*0123</div><div>POP BC</div><div>Restore the Row Address back to BC</div></div>
									<div class="assembly-row-combined"><div>*0124</div><div>LD A,(BC)</div><div>Reload the original flags from active row</div></div>
									<div class="assembly-row-combined"><div>*0125</div><div>AND E</div><div>Combine the current flag lists with the original flag bits</div></div>
									<div class="assembly-row-combined"><div>*0126</div><div>RET Z</div><div>Return to caller if zero because the row was not active on the second test</div></div>
									<div class="assembly-row-combined"><div>*0127</div><div>LD A,D</div><div>Reload the original flags from active row</div></div>
									<div class="assembly-row-combined"><div>*0128</div><div>RCLA</div><div>Multiply
 the row index by 2. (Note: This was needed because a RCLA was 
sacrificed at the call location to give up the bytes needed for the 
call)</div></div>
									<div class="assembly-row-combined"><div>*0129</div><div>RCLA </div><div>Multiply
 the row index by 2. (Note: This was needed because a RCLA was 
sacrificed at the call location to give up the bytes needed for the 
call)</div></div>
									<div class="assembly-row-combined"><div>*012A-012C</div><div>JP 03FEH</div><div>Resume the keyboard driver routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="012DH">012DH-0131H - ?L3 ERROR ROUTINE<span class="origrom">- "NAVERR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>012D-012E<span class="origrom2" style="display: inline;">NAVERR</span></div><div>LD E,2CH<span class="origrom2" style="display: inline;">LD E,ERRNAV</span><span class="opcode2" style="display: none;">1E 2C</span></div><div>Load Register E with the <span class="code">?L3 ERROR</span>code of 2CH</div></div>
									<div class="assembly-row-combined"><div>012F-0131</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#19A2H" class="memory-link">JP 19A2H<span class="origrom2" style="display: inline;">JP ERROR</span></a><span class="opcode2" style="display: none;">C3 A2 19</span></div><div>Go to the Level II BASIC error routine with 2CH loaded into Register E.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0132H">0132H-0134H - LEVEL II BASIC <span class="code">POINT</span>COMMAND ENTRY POINT <span class="origrom">- "GRPHCS" or "POINT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>0132, 0135, 0138 These are the entry points for the POINT, 
SET and the RESET commands in that order, see Part 2 for more data on 
the graphics routines</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0132<span class="origrom2" style="display: inline;">GRPHCS</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H<span class="origrom2" style="display: inline;">CHRGET</span></a><span class="opcode2" style="display: none;">D7</span></div><div>Since
 we need to bump the current BASIC program pointer until it points to 
the next character, call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>0133</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>A will wind up being 0 if the <span class="code">POINT</span>command was entered ... otherwise</div></div>
									<div class="assembly-row-combined" id="0134H"><div>0134</div><div>LD BC,803EH<span class="opcode2" style="display: none;">01 3E 80</span></div><div>Z-80
 Trick! The byte at this memory location, 01H, is there to turn the real
 instruction that follows (the operative action of the SET command) into
 a harmless LD BC,xxxx.  This way, they didn't have to jump over SET or 
RESET to get to the common graphics code.  If parsing straight down, 
this loads BC with 0380H and then moves to 0136H.  But if jump straight 
to 0136H, you skip that 01H opcode, and get a real instruciton of 3EH 
80H</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0135H">0135H-0137H - LEVEL II BASIC <span class="code">SET</span>COMMAND<span class="origrom">- "SET"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0135-0136<span class="origrom2" style="display: inline;">SET</span></div><div>LD A,80H<span class="opcode2" style="display: none;">3E 80</span></div><div>Load Register A with 80H (which is 128) which is <span class="code">SET</span></div></div>
									<div class="assembly-row-combined"><div>0136</div><div>ADD A,B<span class="opcode2" style="display: none;">80</span></div><div>Z-80 Trick - See <a href="#0134H" class="memory-link">the note at 0134H</a>for an explanation</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0138H">0138H-0139H - LEVEL II BASIC <span class="code">RESET</span>COMMAND ENTRY POINT<span class="origrom">- "RESET"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0138-0139<span class="origrom2" style="display: inline;">RESET</span></div><div>LD A,01H<span class="opcode2" style="display: none;">3E 01</span></div><div>Load Register A with 01H which is <span class="code">RESET</span></div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="013AH">013AH-019CH GRAPHICS ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Common code for <span class="code">SET</span>/<span class="code">RESET</span>/<span class="code">POINT</span>- A will be 0 if <span class="code">POINT</span>, 80H if <span class="code">SET</span>and 1 for <span class="code">RESET</span>.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>013A</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the flag which indicates which command was requested (held in Register A) to the STACK</div></div>
									<div class="assembly-row-combined"><div>013B-013C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 28H<span class="origrom2" style="display: inline;">SYNCHK "("</span></a><span class="opcode2" style="display: none;">CF</span></div><div>Since <span class="code">SET</span>/<span class="code">RESET</span>/<span class="code">POINT</span>all
 need a "(" to start with, call the COMPARE SYMBOL routine which 
comparess the symbol in the input string pointed to by HL Register to 
the value in the location following the RST 08 call.  If there is a 
match, control is returned to address of the RST 08 instruction 2 with 
the next symbol in in Register A and HL incremented by one. If the two 
characters do not match, a syntax error message is given and control 
returns to the Input Phase)</div></div>
									<div class="assembly-row-combined"><div>013D-013F</div><div>CALL 2B1CH<span class="origrom2" style="display: inline;">CALL GETBYT</span><span class="opcode2" style="display: none;">CD 1C 2B</span></div><div>Go
 evaluate the expression at the location of the current BASIC program 
pointer in Register Pair HL (which is the X variable) and return with 
the 8-bit value in Register A</div></div>
									<div class="assembly-row-combined"><div>0140-0141</div><div>CP 80H<span class="opcode2" style="display: none;">FE 80</span></div><div>Check to see if the X value in Register A is greater than 128</div></div>
									<div class="assembly-row-combined"><div>0142-0144</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E4AH" class="memory-link">JP NC,1E4AH<span class="origrom2" style="display: inline;">JP NC,FCERR</span></a><span class="opcode2" style="display: none;">D2 4A 1E</span></div><div>If A is greater than 127, go to 1E4AH to display a <span class="code">?FC ERROR</span></div></div>
									<div class="assembly-row-combined"><div>0145</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the requested coordinate's X value in Register A on the STACK</div></div>
									<div class="assembly-row-combined"><div>0146-0147</div><div>RST 08H ‚áí 2CH<span class="origrom2" style="display: inline;">SYNCHK ","</span><span class="opcode2" style="display: none;">CF</span></div><div>At this point we have <span class="code">SET</span>/<span class="code">RESET</span>/<span class="code">POINT</span>, an open parenthesis, and an X variable, so now we must find a <span class="code">,</span>.
  To do this call the COMPARE SYMBOL routine which comparess the symbol 
in the input string pointed to by HL Register to the value in the 
location following the RST 08 call.  If there is a match, control is 
returned to address of the RST 08 instruction 2 with the next symbol in 
in Register A and HL incremented by one. If the two characters do not 
match, a syntax error message is given and control returns to the Input 
Phase)</div></div>
									<div class="assembly-row-combined"><div>0148-014A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2B1CH" class="memory-link">CALL 2B1CH<span class="origrom2" style="display: inline;">CALL GETBYT</span></a><span class="opcode2" style="display: none;">CD 1C 2B</span></div><div>Go
 evaluate the expression at the location of the current BASIC program 
pointer in Register Pair HL (which is the Y variable) and return with 
the 8-bit value in Register A</div></div>
									<div class="assembly-row-combined"><div>014B-014C</div><div>CP 30H<span class="opcode2" style="display: none;">FE 30</span></div><div>Check to see if the Y value in Register A is greater than 47</div></div>
									<div class="assembly-row-combined"><div>014D-014F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E4AH" class="memory-link">JP NC,1E4AH<span class="origrom2" style="display: inline;">JP NC,FCERR</span></a><span class="opcode2" style="display: none;">D2 4A 1E</span></div><div>If the Y value is greater than 48, go to 1E4AH to display a <span class="code">?FC ERROR</span></div></div>
									<div class="assembly-row-combined"><div>0150-0151</div><div>LD D,0FFH<span class="opcode2" style="display: none;">16 FF</span></div><div>Prepare to divide y coordinate by 3 ... load Register D with starting quotient</div></div>
									<div class="assembly-row-combined"><div>0152<span class="origrom2" style="display: inline;">LOPMD3</span></div><div>INC D<span class="opcode2" style="display: none;">14</span></div><div>Increment the quotient in Register D</div></div>
									<div class="assembly-row-combined"><div>0153-0154</div><div>SUB 03H<span class="opcode2" style="display: none;">D6 03</span></div><div>Divide by subtraction; in this case subtract 3 from Register A</div></div>
									<div class="assembly-row-combined"><div>0155-0156</div><div><a href="#0152H" class="memory-link">JR NC,0152H<span class="origrom2" style="display: inline;">JR NC,LOPMD3</span></a><span class="opcode2" style="display: none;">30 FB</span></div><div>Loop until Register D equals the Y value divided by 3</div></div>
									<div class="assembly-row-combined"><div>0157-0158</div><div>ADD 03H<span class="opcode2" style="display: none;">C6 03</span></div><div>Make the remainder positive by adjust the remainder in Register A by adding back 3</div></div>
									<div class="assembly-row-combined"><div>0159</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Save the remainder (in Register A) to Register C.</div></div>
									<div class="assembly-row-combined"><div>015A</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the requested coordindate's X value from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>015B</div><div>ADD A,A<span class="opcode2" style="display: none;">87</span></div><div>Multiply the X value in Register A by two, storing the result in Register A</div></div>
									<div class="assembly-row-combined"><div>015C</div><div>LD E,A<span class="opcode2" style="display: none;">5F</span></div><div>Load Register E with the newly doubled Register A</div></div>
									<div class="assembly-row-combined"><div>015D-015E</div><div>LD B,02H<span class="opcode2" style="display: none;">06 02</span></div><div>Load Register B with the number of times to shift Register Pair DE right (which is 2)</div></div>
									<div class="assembly-row-combined"><div>015F<span class="origrom2" style="display: inline;">SHFTW</span></div><div>LD A,D<span class="opcode2" style="display: none;">7A</span></div><div>Load Register A with the adjusted Y value in Register D</div></div>
									<div class="assembly-row-combined"><div>0160</div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Divide
 the adjusted Y value in Register A by two.  RRA rotates the contents of
 Register A right one bit position, with Bit 0 going to the CARRY FLAG, 
and the CARRY FLAG going to Bit 7.  RRA also can be used to divide a 
number in 2.</div></div>
									<div class="assembly-row-combined"><div>0161</div><div>LD D,A<span class="opcode2" style="display: none;">57</span></div><div>Save the new Y value in register A in register D.</div></div>
									<div class="assembly-row-combined"><div>0162</div><div>LD A,E<span class="opcode2" style="display: none;">7B</span></div><div>Load register A with the adjusted X value in register E.</div></div>
									<div class="assembly-row-combined"><div>0163</div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Divide
 the adjusted X value in Register A by two.  RRA rotates the contents of
 Register A right one bit position, with Bit 0 going to the CARRY FLAG, 
and the CARRY FLAG going to Bit 7.  RRA also can be used to divide a 
number in 2.</div></div>
									<div class="assembly-row-combined"><div>0164</div><div>LD E,A<span class="opcode2" style="display: none;">5F</span></div><div>Load register E with the new X value in register A.</div></div>
									<div class="assembly-row-combined"><div>0165-0166</div><div><a href="#015FH" class="memory-link">DJNZ 015FH<span class="origrom2" style="display: inline;">DJNZ DHFTW</span></a><span class="opcode2" style="display: none;">10 F8</span></div><div>Loop until the memory offset in Register Pair DE has been figured</div></div>
									<div class="assembly-row-combined"><div>0167</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Now we need to computer the position of the point so load Register A with the value in Register C</div></div>
									<div class="assembly-row-combined"><div>0168</div><div>ADC A,A<span class="opcode2" style="display: none;">8F</span></div><div>Multiply the value in Register A by two and add the value of the Carry flag to Register A</div></div>
									<div class="assembly-row-combined"><div>0169</div><div>INC A<span class="opcode2" style="display: none;">3C</span></div><div>Increment the value in Register A</div></div>
									<div class="assembly-row-combined"><div>016A</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Save the bit position in Register A in Register B</div></div>
									<div class="assembly-row-combined"><div>016B</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A and reset the Carry flag</div></div>
									<div class="assembly-row-combined"><div>016C</div><div>SCF<span class="opcode2" style="display: none;">37</span></div><div>Set the Carry flag</div></div>
									<div class="assembly-row-combined"><div>016D<span class="origrom2" style="display: inline;">PWR2</span></div><div>ADC A,A<span class="opcode2" style="display: none;">8F</span></div><div>Add the value of the Carry flag to Register A</div></div>
									<div class="assembly-row-combined"><div>016E-016F</div><div><a href="#016DH" class="memory-link">DJNZ 016DH<span class="origrom2" style="display: inline;">DJNZ PWR2</span></a><span class="opcode2" style="display: none;">10 FD</span></div><div>Loop back to the prior instruction until the graphic mask has been completed in Register A</div></div>
									<div class="assembly-row-combined"><div>0170</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Save the graphic mask in Register A in Register C</div></div>
									<div class="assembly-row-combined"><div>0171</div><div>LD A,D<span class="opcode2" style="display: none;">7A</span></div><div>Load Register A with the MSB of the video memory offset in Register D</div></div>
									<div class="assembly-row-combined"><div>0172-0173</div><div>OR 3CH<span class="origrom2" style="display: inline;">OR 0011 1100</span><span class="opcode2" style="display: none;">F6 3C</span></div><div>Mask
 the MSB of the video memory offset in Register A with 0011 1100 so that
 it will point to the correct location in video RAM (i.e., the 
applicable screen RAM address)</div></div>
									<div class="assembly-row-combined"><div>0174</div><div>LD D,A<span class="opcode2" style="display: none;">57</span></div><div>Save the MSB of the video memory pointer in Register A in Register D</div></div>
									<div class="assembly-row-combined"><div>0175</div><div>LD A,(DE)<span class="opcode2" style="display: none;">1A</span></div><div>Load Register A with the character at the location of the video memory pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0176</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the character in Register A is a graphic character</div></div>
									<div class="assembly-row-combined"><div>0177-0179</div><div><a href="#017CH" class="memory-link">JP M,017CH<span class="origrom2" style="display: inline;">JP M,FND4</span></a><span class="opcode2" style="display: none;">FA 7C 01</span></div><div>Skip over the next instruction if the character in Register A is a graphic character</div></div>
									<div class="assembly-row-combined"><div>017A-017B</div><div>LD A,80H<span class="opcode2" style="display: none;">3E 80</span></div><div>Since
 the character at the screen location turned out not to be a graphics 
character, we need to set it to a blank graphics character, so load 
Register A with a blank graphic character which is CHR$(128)</div></div>
									<div class="assembly-row-combined"><div>017C<span class="origrom2" style="display: inline;">FND4</span></div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Save the character which is being modified by the SET/RESET (held in Register A) into Register B</div></div>
									<div class="assembly-row-combined"><div>017D</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the operation being called (SET/RESET/POINT) and the flags from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>017E</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Set the flags according to the graphic mode in Register A</div></div>
									<div class="assembly-row-combined"><div>017F</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Get the existing graphic character on the screen (held in Register B) and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>0180-0181</div><div><a href="#0192H" class="memory-link">JR Z,0192H<span class="origrom2" style="display: inline;">JR Z,TBIT</span></a><span class="opcode2" style="display: none;">28 10</span></div><div>Jump forward to 0192H if the graphic mode is <span class="code">POINT</span></div></div>
									<div class="assembly-row-combined"><div>0182</div><div>LD (DE),A<span class="opcode2" style="display: none;">12</span></div><div>Save the graphic character in Register A at the location of the video memory pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0183-0185</div><div><a href="#018FH" class="memory-link">JP M,018FH<span class="origrom2" style="display: inline;">JP M,SBIT</span></a><span class="opcode2" style="display: none;">FA 8F 01</span></div><div>Jump forward to 018FH if the graphic mode is <span class="code">SET</span></div></div>
									<div class="assembly-row-combined"><div>0186</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with the graphic mask in Register C</div></div>
									<div class="assembly-row-combined"><div>0187</div><div>CPL<span class="opcode2" style="display: none;">2F</span></div><div>Reverse the graphic mask in Register A</div></div>
									<div class="assembly-row-combined"><div>0188</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the adjusted graphic mask in Register A</div></div>
									<div class="assembly-row-combined"><div>0189</div><div>LD A,(DE)<span class="opcode2" style="display: none;">1A</span></div><div>Load Register A with the character at the location of the video memory pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>018A</div><div>AND C<span class="opcode2" style="display: none;">A1</span></div><div>RESET the graphic bit by combining the graphic mask in Register C with the graphic character in Register A</div></div>
									<div class="assembly-row-combined"><div>018B<span class="origrom2" style="display: inline;">FINSTB</span></div><div>LD (DE),A<span class="opcode2" style="display: none;">12</span></div><div>Save the adjusted graphic character in Register A at the location of the video memory pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>018C-018D<span class="origrom2" style="display: inline;">FINPTB</span></div><div>RST 08H 29H<span class="origrom2" style="display: inline;">SYNCHK ")"</span><span class="opcode2" style="display: none;">CF</span></div><div>Check the syntax. The character at the location of the current BASIC program pointer in Register Pair HL must be a <span class="code">)</span>character (")" is 29H)</div></div>
									<div class="assembly-row-combined"><div>018E</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
									<div class="assembly-row-combined"><div>018F<span class="origrom2" style="display: inline;">SBIT</span></div><div>OR C<span class="opcode2" style="display: none;">B1</span></div><div>SET the graphic bit by combining the graphic mask in Register C with the graphic character in Register A</div></div>
									<div class="assembly-row-combined"><div>0190-0191</div><div><a href="#018BH" class="memory-link">JR 018BH<span class="origrom2" style="display: inline;">JP FINSTB</span></a><span class="opcode2" style="display: none;">18 F9</span></div><div>Jump back a few bytes to 018BH</div></div>
									<div class="assembly-row-combined"><div>0192<span class="origrom2" style="display: inline;">TBIT</span></div><div>AND C<span class="opcode2" style="display: none;">A1</span></div><div>POINT the graphic bit by combining the graphic mask in Register C with the graphic character in Register A</div></div>
									<div class="assembly-row-combined"><div>0193-0194</div><div>ADD 0FFH<span class="origrom2" style="display: inline;">ADD -1</span><span class="opcode2" style="display: none;">C6 FF</span></div><div>Subtract one from the value in Register A</div></div>
									<div class="assembly-row-combined"><div>0195</div><div>SBC A,A<span class="opcode2" style="display: none;">9F</span></div><div>Adjust the value in Register A so that A will equal zero if the bit was off in Register A</div></div>
									<div class="assembly-row-combined"><div>0196</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the current BASIC program pointer in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0197-0199</div><div><a href="#098DH" class="memory-link">CALL 098DH<span class="origrom2" style="display: inline;">CALL CONIA</span></a><span class="opcode2" style="display: none;">CD 8D 09</span></div><div>Save the value in Register A as the current result in the ACCumulator (i.e., 4121H-4122H)</div></div>
									<div class="assembly-row-combined"><div>019A</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the current BASIC program pointer from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>019B-019C</div><div><a href="#018CH" class="memory-link">JR 018CH<span class="origrom2" style="display: inline;">JR FINPTB</span></a><span class="opcode2" style="display: none;">18 EF</span></div><div>Jump to 018CH</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="019DH">019DH-01C8H - LEVEL II BASIC <span class="code">INKEY$</span> routine<span class="origrom">- "INKEY"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>019D<span class="origrom2" style="display: inline;">INKEY</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H<span class="origrom2" style="display: inline;">CHRGET</span></a><span class="opcode2" style="display: none;">D7</span></div><div>Since
 we need to bump the current BASIC program pointer in Register Pair HL 
until it points to the next character, call the EXAMINE NEXT SYMBOL 
routine at RST 10H.<br><br>The RST 10H routine parses the characters 
starting at HL+1 for the first non-SPACE,non-09H,non-0BH character it 
finds.  On exit, Register A will hold that character, and the C FLAG is 
set if its alphabetic, and NC FLAG if its alphanumeric.  All strings 
must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>019E</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the current BASIC program pointer in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>019F-01A1</div><div>LD A,(4099H)<span class="origrom2" style="display: inline;">LD A,(CHARC)</span><span class="opcode2" style="display: none;">3A 99 40</span></div><div>Put the last key pressed (stored at 4099H) and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>01A2</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Set the status flags.</div></div>
									<div class="assembly-row-combined"><div>01A3-01A4</div><div><a href="#01ABH" class="memory-link">JR NZ,01ABH<span class="origrom2" style="display: inline;">JR NZ,BUFCIN</span></a><span class="opcode2" style="display: none;">20 06</span></div><div>Jump to 01ABH (to skip the next character scan) if a key has been pressed</div></div>
									<div class="assembly-row-combined"><div>01A5-01A7<span class="origrom2" style="display: inline;">MRCHRI</span></div><div><a href="#0358H" class="memory-link">CALL 0358H<span class="origrom2" style="display: inline;">CALL ISCHAR</span></a><span class="opcode2" style="display: none;">CD 58 03</span></div><div>Go scan the keyboard</div></div>
									<div class="assembly-row-combined"><div>01A8</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Set the status flags.</div></div>
									<div class="assembly-row-combined"><div>01A9-01AA</div><div><a href="#01BCH" class="memory-link">JR Z,01BCH<span class="origrom2" style="display: inline;">JR Z,NULRT</span></a><span class="opcode2" style="display: none;">28 11</span></div><div>Jump to 01BCH if a key wasn't pressed</div></div>
									<div class="assembly-row-combined"><div>01AB<span class="origrom2" style="display: inline;">BUFCIN</span></div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the key pressed (held in Register A) to the top of STACK</div></div>
									<div class="assembly-row-combined"><div>01AC</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Clear the buffered character by zeroing Register A</div></div>
									<div class="assembly-row-combined"><div>01AD-01AF</div><div>LD (4099H),A<span class="origrom2" style="display: inline;">LD (CHARC),A</span><span class="opcode2" style="display: none;">32 99 40</span></div><div>Save the value in Register A as the last key pressed (which is kept at 16537).<br>Note: 4099H holds the last key pressed</div></div>
									<div class="assembly-row-combined"><div>01B0</div><div>INC A<span class="opcode2" style="display: none;">3C</span></div><div>Increment the value in Register A (which is going to represet the size of the character string to be built)</div></div>
									<div class="assembly-row-combined"><div>01B1-01B3</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2857H" class="memory-link">CALL 2857H<span class="origrom2" style="display: inline;">CALL STRINI</span></a><span class="opcode2" style="display: none;">CD 57 28</span></div><div>Make sure there is room 1 byte of space in the string space RAM area by calling 2857H to make an entry in string space</div></div>
									<div class="assembly-row-combined"><div>01B4</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the last key pressed from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>01B5-01B7</div><div>LD HL,(40D4H)<span class="origrom2" style="display: inline;">LD HL,(DSCTMP+1)</span><span class="opcode2" style="display: none;">2A D4 40</span></div><div>Load Register Pair HL with 2nd byte of the VARPTR for the string being created (which starts at 40D3H)</div></div>
									<div class="assembly-row-combined"><div>01B8</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save the last key pressed in Register A at the location of the string pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>01B9-01BB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2884H" class="memory-link">JP 2884H<span class="origrom2" style="display: inline;">JP PUTNEW</span></a><span class="opcode2" style="display: none;">C3 84 28</span></div><div>Go save the string's VARPTR as the current result.</div></div>
									<div class="assembly-row-combined"><div>01BC-01BE<span class="origrom2" style="display: inline;">NULRT</span></div><div>LD HL,1928H<span class="origrom2" style="display: inline;">LD HL,REDDY-1</span><span class="opcode2" style="display: none;">21 28 19</span></div><div>Load Register Pair HL with the starting address of the "READY" message (which is 6440)</div></div>
									<div class="assembly-row-combined"><div>01BF-01C1</div><div>LD (4121H),HL<span class="origrom2" style="display: inline;">LD (FACLO),HL</span><span class="opcode2" style="display: none;">22 21 41</span></div><div>Save the address in Register Pair HL as the current result in the ACCumulator (i.e., 4121H-4122H)</div></div>
									<div class="assembly-row-combined"><div>01C2-01C3</div><div>LD A,03H<span class="opcode2" style="display: none;">3E 03</span></div><div>Load Register A with a string number type flag</div></div>
									<div class="assembly-row-combined"><div>01C4-01C6</div><div>LD (40AFH),A<span class="origrom2" style="display: inline;">LD (VALTYP),A</span><span class="opcode2" style="display: none;">32 AF 40</span></div><div>Save the value in Register A as the current number type (which is at 16559).<br>Note: 40AFH holds current variable's type flag</div></div>
									<div class="assembly-row-combined"><div>01C7</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the current BASIC program pointer from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>01C8</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="01C9H">01C9H-01D2H - LEVEL II BASIC <span class="code">CLS</span> routine<span class="origrom">- "CLS"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>A CALL 1C9H will clear the screen, select 64 characters and home the cursor. All registers are used.<br><br>To use a ROM call to clear the screen, CALL 01C9H. The cursor is reset to the home position, which is 3C00H.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>01C9-01CA<span class="origrom2" style="display: inline;">CLS</span></div><div>LD A,1CH<span class="opcode2" style="display: none;">3E 1C</span></div><div>Load Register A with the ASCII character to home the cursor</div></div>
									<div class="assembly-row-combined"><div>01CB-01CD</div><div><a href="#033AH" class="memory-link">CALL 033AH<span class="origrom2" style="display: inline;">CALL OUT2D</span></a><span class="opcode2" style="display: none;">CD 3A 03</span></div><div>Go send the character in Register A (i.e., the ASCII character to home the cursor) to the video display</div></div>
									<div class="assembly-row-combined"><div>01CE-01CF</div><div>LD A,1FH<span class="opcode2" style="display: none;">3E 1F</span></div><div>Load Register A with the ASCII character to clear to the end of the screen</div></div>
									<div class="assembly-row-combined"><div>01D0-01D2</div><div><a href="#033AH" class="memory-link">JP 033AH<span class="origrom2" style="display: inline;">JP OUT2D</span></a><span class="opcode2" style="display: none;">C3 3A 03</span></div><div>Go send the character in Register A (i.e., the ASCII character to clear to the end of the screen) to the video display</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="01D3H">01D3H-01D8H - LEVEL II BASIC <span class="code">RANDOM</span> routine<span class="origrom">- "RANDOM"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is part of the <span class="code">RANDOM</span> routine which takes a value out of the REFRESH register, stores it in location 40ABH and then returns.<br><br>A call to 01D3H reseeds the random number seed (location 40AB) with the current contents of the refresh register.<br><br>NOTE:
 To run a RANDOM (seed the random number generator) via a ROM call just 
call CALL 01D3H.  This causes the contents of R (memory refresh) to be 
stored in 40ABH.  The entire 24 bit seed is stored in 40AAH-40ACH.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>01D3<span class="origrom2" style="display: inline;">RANDOM</span></div><div>LD A,R<span class="opcode2" style="display: none;">ED 5F</span></div><div>Load Register A with the current value of the refresh register</div></div>
									<div class="assembly-row-combined"><div>01D5-01D7</div><div>LD (40ABH),A<span class="origrom2" style="display: inline;">LD (RNDX+1),A</span><span class="opcode2" style="display: none;">32 AB 40</span></div><div>Save the pseudi-random value in Register A to 40ABH (the random number seed)</div></div>
									<div class="assembly-row-combined"><div>01D8</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="01D9H">01D9H-01F7H - CASSETTE ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<p>Output a pulse to the cassette recorder</p>
									<div class="assembly-row-combined"><div>01D9-01DB<span class="origrom2" style="display: inline;">CTPULS</span></div><div>LD HL,0FC01H<span class="origrom2" style="display: inline;">LD HL,&lt;252*256&gt;+1</span><span class="opcode2" style="display: none;">21 01 FC</span></div><div>Load Register Pair HL with the command to send to the cassette ... here, a top of pulse</div></div>
									<div class="assembly-row-combined"><div>01DC-01DE</div><div><a href="#0221H" class="memory-link">CALL 0221H<span class="origrom2" style="display: inline;">CALL CTCHG</span></a><span class="opcode2" style="display: none;">CD 21 02</span></div><div>Go send the command to the cassette controller</div></div>
									<p class="debug-note">Delay loop between pulses</p>
									<div class="assembly-row-combined"><div>01DF-01E0</div><div>LD B,0BH<span class="opcode2" style="display: none;">06 0B</span></div><div>Load Register B with the delay count of 80 milliseconds</div></div>
									<div class="assembly-row-combined"><div>01E1-01E2<span class="origrom2" style="display: inline;">CT1</span></div><div><a href="#01E1H" class="memory-link">DJNZ 01E1H<span class="origrom2" style="display: inline;">DJNZ CT1</span></a><span class="opcode2" style="display: none;">10 FE</span></div><div>Loop for delay</div></div>
									<div class="assembly-row-combined"><div>01E3-01E5</div><div>LD HL,0FC02H<span class="origrom2" style="display: inline;">LD HL,&lt;252*256&gt;+2</span><span class="opcode2" style="display: none;">21 02 FC</span></div><div>Load Register Pair HL with the command to send to the cassette ... here, a bottom of pulse</div></div>
									<div class="assembly-row-combined"><div>01E6-01E8</div><div><a href="#0221H" class="memory-link">CALL 0221H<span class="origrom2" style="display: inline;">CALL CTCHG</span></a><span class="opcode2" style="display: none;">CD 21 02</span></div><div>Go send the command to the cassette controller</div></div>
									<div class="assembly-row-combined"><div>01E9-01EA</div><div>LD B,0BH<span class="opcode2" style="display: none;">06 0B</span></div><div>Load Register B with the delay count of 80 milliseconds</div></div>
									<div class="assembly-row-combined"><div>01EB-01EC<span class="origrom2" style="display: inline;">CT2</span></div><div><a href="#01EBH" class="memory-link">DJNZ 01EBH<span class="origrom2" style="display: inline;">DJNZ CT2</span></a><span class="opcode2" style="display: none;">10 FE</span></div><div>Loop for delay</div></div>
									<div class="assembly-row-combined"><div>01ED-01EF</div><div>LD HL,0FC00H<span class="origrom2" style="display: inline;">LD HL,H,&lt;252*256&gt;</span><span class="opcode2" style="display: none;">21 00 FC</span></div><div>Load Register Pair HL with the command to send to the cassette</div></div>
									<div class="assembly-row-combined"><div>01F0-01F2</div><div><a href="#0221H" class="memory-link">CALL 0221H<span class="origrom2" style="display: inline;">CALL CTCHG</span></a><span class="opcode2" style="display: none;">CD 21 02</span></div><div>Go send the command to the cassette controller ... here, a terminate pulse</div></div>
									<div class="assembly-row-combined"><div>01F3-01F4</div><div>LD B,5CH<span class="opcode2" style="display: none;">06 5C</span></div><div>Load Register B with the delay count of 671 milliseconds</div></div>
									<div class="assembly-row-combined"><div>01F5-01F6<span class="origrom2" style="display: inline;">CT3</span></div><div><a href="#01F5H" class="memory-link">DJNZ 01F5H<span class="origrom2" style="display: inline;">DJNZ CT3</span></a><span class="opcode2" style="display: none;">10 FE</span></div><div>Loop for delay</div></div>
									<div class="assembly-row-combined"><div>01F7</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="01F8H">01F8H-01FDH - CASSETTE ROUTINE (TURN OFF CASSETTE)<span class="origrom">- "CTOFF"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>01F8<span class="origrom2" style="display: inline;">CTOFF</span></div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the value in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>01F9-01FB</div><div>LD HL,FB00H<span class="origrom2" style="display: inline;">LD HL,&lt;251*256&gt;</span><span class="opcode2" style="display: none;">21 00 FB</span></div><div>Load Register Pair HL with the command to send to the cassette to turn it off</div></div>
									<div class="assembly-row-combined"><div>01FC-01FD</div><div><a href="#0219H" class="memory-link">JR 0219H<span class="origrom2" style="display: inline;">JR CTCHG2</span></a><span class="opcode2" style="display: none;">18 1B</span></div><div>Jump to the cassette driver routine at 0219H</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="01FEH">01FEH-0211H- CASSETTE ROUTINE (EVALUATE DRIVE NUMBER)<span class="origrom">- "CTON"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>01FE<span class="origrom2" style="display: inline;">CTON</span></div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Get the character at the location of the current BASIC program pointer and put it in Register A</div></div>
									<div class="assembly-row-combined" id="0200H"><div>01FF-0200</div><div>SUB 23H<span class="origrom2" style="display: inline;">SUB "#"</span><span class="opcode2" style="display: none;">D6 23</span></div><div>Check to see if the character in Register A is a <span class="code">#</span>character</div></div>
									<div class="assembly-row-combined"><div>0201-0202</div><div>LD A,00H<span class="opcode2" style="display: none;">3E 00</span></div><div>Zero Register A</div></div>
									<div class="assembly-row-combined"><div>0203-0204</div><div><a href="#0212H" class="memory-link">JR NZ,0212H<span class="origrom2" style="display: inline;">JR NZ,DEFDRV</span></a><span class="opcode2" style="display: none;">20 0D</span></div><div>Jump
 to the TURN ON MOTOR routine at 0212H if the character at the location 
of the current BASIC program pointer in Register Pair HL isn't a # 
character</div></div>
									<div class="assembly-row-combined"><div>0205-0207</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2B01H" class="memory-link">CALL 2B01H<span class="origrom2" style="display: inline;">CALL G</span></a><span class="opcode2" style="display: none;">CD 01 2B</span></div><div>Go
 evaluate the drive number at the location of the current BASIC program 
pointer in Register Pair HL and return with the drive number in Register
 E</div></div>
									<div class="assembly-row-combined"><div>0208-0209</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 2CH<span class="origrom2" style="display: inline;">SYNCHK ","</span></a><span class="opcode2" style="display: none;">CF</span></div><div>We need to see if the character at the location of the current BASIC program pointer in Register Pair HL is a <span class="code">,</span>, so call the RST 08H routine to do so</div></div>
									<div class="assembly-row-combined"><div>020A</div><div>LD A,E<span class="opcode2" style="display: none;">7B</span></div><div>Need to convert from the negative number to positive so, load Register A with the drive number in Register E .</div></div>
									<div class="assembly-row-combined"><div>020B</div><div>AND D<span class="opcode2" style="display: none;">A2</span></div><div>... and combine the MSB of the drive number in Register D with the LSB of the drive number in Register A and then .</div></div>
									<div class="assembly-row-combined"><div>020C-020D</div><div>ADD 02H<span class="opcode2" style="display: none;">C6 02</span></div><div>... add 2 to make the drive number in Register A positive</div></div>
									<div class="assembly-row-combined"><div>020E-0210</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E4AH" class="memory-link">JP NC,1E4AH<span class="origrom2" style="display: inline;">JP NC, FCERR</span></a><span class="opcode2" style="display: none;">D2 4A 1E</span></div><div>If the drive number in Register A is invalid, jump to 14E4H to display a FC ERROR</div></div>
									<div class="assembly-row-combined" id="0221H"><div>0211</div><div>DEC A<span class="opcode2" style="display: none;">3D</span></div><div>Decrement the drive number in Register A</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0212H">0212H-021DH - CASSETTE ROUTINE (TURN ON CASSETTE)<span class="origrom"> - "DEFDRV"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>CALL 212H will select the cassette unit specified in 
A-Register and start the motor. Units are numbered from one. Put 00H in A
 Register to turn on cassette 1, or O1H to turn on cassette 2.  All 
registers are used.<br><br>To use a ROM call to turn on the cassette, execute the following instructions: <span class="code">LD A,0</span>and then <span class="code">CALL 0212H</span></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0212-0214<span class="origrom2" style="display: inline;">DEFDRV</span></div><div>LD (37E4H),A<span class="opcode2" style="display: none;">32 E4 37</span></div><div>Set the current drive as specified by Register A</div></div>
									<div class="assembly-row-combined"><div>0215</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the current BASIC program pointer in Register Pair HL on the STACK so we can use HL for the next instruction</div></div>
									<div class="assembly-row-combined"><div>0216-0218</div><div>LD HL,0FF04H<span class="origrom2" style="display: inline;">H,&lt;255*256&gt;+4</span><span class="opcode2" style="display: none;">21 04 FF</span></div><div>Load Register Pair HL with the command to turn on the cassette motor</div></div>
									<div class="assembly-row-combined"><div>0219-021B<span class="origrom2" style="display: inline;">CTCHG2</span></div><div><a href="#0221H" class="memory-link">CALL 0221H<span class="origrom2" style="display: inline;">CALL CTCHG</span></a><span class="opcode2" style="display: none;">CD 21 02</span></div><div>Go send the "turn on the cassette motor" command stored in HL to the cassette controller</div></div>
									<div class="assembly-row-combined"><div>021C</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the current BASIC program pointer from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>021D</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="021EH">021EH-022BH - CASSETTE ROUTINE<span class="origrom">- "CTSTAT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>021E-0220<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;CTSTAT</span></div><div>LD HL,0FF00H<span class="origrom2" style="display: inline;">LD HL,&lt;255*256&gt;</span><span class="opcode2" style="display: none;">21 00 FF</span></div><div>Load Register Pair HL with the mask to preserve video controller flags, but otherwise clear the cassette latch</div></div>
									<div class="assembly-row-combined"><div>0221-0223<span class="origrom2" style="display: inline;">CTCHG</span></div><div>LD A,(403DH)<span class="origrom2" style="display: inline;">LD A,(CAST$)</span><span class="opcode2" style="display: none;">3A 3D 40</span></div><div>Load
 Register A with the contents of 403DH, which contains, among other 
things, the screen resolution (32 or 64 wide; Bit 3) the tape relay 
on/off instruction (Bit 2) and the positive/negative audio pulses (Bits 
0-1).<br>Note: 403DH-4040H is used by DOS</div></div>
									<div class="assembly-row-combined"><div>0224</div><div>AND H<span class="opcode2" style="display: none;">A4</span></div><div>Combine the value in Register H with the contents of (403DH)</div></div>
									<div class="assembly-row-combined"><div>0225</div><div>OR L<span class="opcode2" style="display: none;">B5</span></div><div>Combine the value to send to the cassette in Register L with the adjusted value in Register A</div></div>
									<div class="assembly-row-combined"><div>0226-0227</div><div>OUT (0FFH),A<span class="origrom2" style="display: inline;">OUT (CASIO$),A</span><span class="opcode2" style="display: none;">D3 FF</span></div><div>Send the value in Register A to port 255 (which is the cassette and video port)</div></div>
									<div class="assembly-row-combined"><div>0228-022A</div><div>LD (403DH),A<span class="origrom2" style="display: inline;">LD (CAST$),A</span><span class="opcode2" style="display: none;">32 3D 40</span></div><div>Save the value in Register A into (403DH).<br>Note: 403DH-4040H is used by DOS</div></div>
									<div class="assembly-row-combined"><div>022B</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="022CH">022CH-0234H - CASSETTE ROUTINE (BLINK **)<span class="origrom">- "BCASIN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Alternately displays and clears an asterisk in the upper right hand comer. Uses all registers.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>022C-022E<span class="origrom2" style="display: inline;">BCASIN</span></div><div>LD A,(3C3FH)<span class="opcode2" style="display: none;">3A 3F 3C</span></div><div>Get
 the character being displayed in the upper right hand corner of the 
video display from 3C3FH and put that character in Register A</div></div>
									<div class="assembly-row-combined"><div>022F-0230</div><div>XOR 0AH<span class="opcode2" style="display: none;">EE 0A</span></div><div>If the character in Register A is a <span class="code">*</span>then make it a <kbd>SPACE</kbd> , else if the character in Register A is a <kbd>SPACE</kbd> make it a <span class="code">*</span></div></div>
									<div class="assembly-row-combined"><div>0231-0233</div><div>LD (3C3FH),A<span class="opcode2" style="display: none;">32 3F 3C</span></div><div>Display the character in Register A in the upper right hand comer of the video display</div></div>
									<div class="assembly-row-combined"><div>0234</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0235H">0235H-0240H - CASSETTE ROUTINE (READ A BYTE)<span class="origrom">- "CASIN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Read One Byte: Reads one byte from the currently selected 
unit. The byte read is returned in the A-register. All other registers 
are preserved<br><br>This routine will read a byte from tape. A CALL 
235H will return with the byte read from tape in the A Register BC, DE 
and HL are unchanged<br><br>To use a ROM call to read a character from 
cassette (after the cassette has been turned on and leader and sync have
 been found), CALL 0235H. The input character will be in the A register.
 Again, the routine at 0235H must be called frequently enough to sustain
 the 500 baud rate if more than one character is to be read. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0235<span class="origrom2" style="display: inline;">CASIN</span></div><div>PUSH BC<span class="opcode2" style="display: none;">C5</span></div><div>Save the value in Register Pair BC on the STACK</div></div>
									<div class="assembly-row-combined"><div>0236</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the value in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0237-0238</div><div>LD B,08H<span class="opcode2" style="display: none;">06 08</span></div><div>Load Register B (which is what DJNZ decrements to loop) with the number of bits to read (which is 8)</div></div>
									<div class="assembly-row-combined"><div>0239-023B<span class="origrom"><br>CTB0</span></div><div><a href="#0241H" class="memory-link">CALL 0241H<span class="origrom2" style="display: inline;">CALL CTBIT</span></a><span class="opcode2" style="display: none;">CD 41 02</span></div><div>Go read a bit from the cassette recorder (the resulting byte from the 8 bits will be accumulated into the A register)</div></div>
									<div class="assembly-row-combined"><div>023C-023D</div><div><a href="#0239H" class="memory-link">DJNZ 0239H<span class="origrom2" style="display: inline;">DJNZ CTB0</span></a><span class="opcode2" style="display: none;">10 FB</span></div><div>Loop that instruction until all eight bits have been read into A</div></div>
									<div class="assembly-row-combined"><div>023E</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the value from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>023F</div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>Get the value from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>0240</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0241H">0241H-0260H - CASSETTE ROUTINE (READ A BIT)<span class="origrom">- "CTBIT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Routine waits for timing pulse, and then performs a timing 
loop. When the time is up it tests the tape for a bit, which will be "1"
 if present and "0" if not. A CALL 241H is used by 235H eight times to 
input one byte.<br><br>0264 Writes the byte in the A Register to tape. BC, DE and HL are unchanged by a CALL 264H</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0241<span class="origrom2" style="display: inline;">CTBIT</span></div><div>PUSH BC<span class="opcode2" style="display: none;">C5</span></div><div>Save the value in Register Pair BC on the STACK</div></div>
									<div class="assembly-row-combined"><div>0242</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the value in Register A on the STACK</div></div>
									<div class="assembly-row-combined"><div>0243-0244<span class="origrom"><br>CB0</span></div><div>IN A,(0FFH)<span class="origrom2" style="display: inline;">IN A,(CASIO$)</span><span class="opcode2" style="display: none;">DB FF</span></div><div>Read a bit from the cassette port (waiting for a clock pulse)</div></div>
									<div class="assembly-row-combined"><div>0245</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Rotate
 Register A left one bit position with the contents of bit 7 copied to 
the carry flag.  By doing this, the start bit would rotate to the carry 
flag for easy testing</div></div>
									<div class="assembly-row-combined"><div>0246-0247</div><div><a href="#0243H" class="memory-link">JR NC,0243H<span class="origrom2" style="display: inline;">JR NC,CB0</span></a><span class="opcode2" style="display: none;">30 FB</span></div><div>If NC is set, we do not yet have the start bit, so loop back to 0243H until the start bit is found</div></div>
									<div class="assembly-row-combined"><div>0248-0249</div><div>LD B,40H<span class="opcode2" style="display: none;">06 41</span></div><div>No that we have the start bit we need a delay, so load Register B with the delay count of 40H</div></div>
									<div class="assembly-row-combined"><div>*0248H-0249</div><div>LD B,60H</div><div>In ROM v1.2, load B with a delay count of 60H (=476/703 microseconds) instead of 40H</div></div>
									<div class="assembly-row-combined"><div>024A-024B<span class="origrom"><br>CB1</span></div><div><a href="#024AH" class="memory-link">DJNZ 024AH</a><span class="origrom2" style="display: inline;">DJNZ CB1</span><span class="opcode2" style="display: none;">10 FE</span></div><div>Loop (don't jump unless B is zero; with a decrement of B each time) for delay</div></div>
									<div class="assembly-row-combined"><div>024C-024E</div><div><a href="#021EH" class="memory-link">CALL 021EH</a><span class="origrom2" style="display: inline;">CALL CTSTAT</span><span class="opcode2" style="display: none;">CD 1E 02</span></div><div>Go clear the cassette controller so we can get to reading</div></div>
									<div class="assembly-row-combined"><div>024F-0250</div><div>LD B,76H<span class="opcode2" style="display: none;">06 76</span></div><div>We need a delay so load Register B with the delay count of 76H</div></div>
									<div class="assembly-row-combined"><div>*024FH-0250</div><div>LD B,85H</div><div>In ROM v1.2, load B with a delay count of 60H (=476/703 microseconds) instead of 40H</div></div>
									<div class="assembly-row-combined"><div>0251-0252<span class="origrom"><br>CB2</span></div><div><a href="#0251H" class="memory-link">DJNZ 0251H<span class="origrom2" style="display: inline;">DJNZ CB2</span></a><span class="opcode2" style="display: none;">10 FE</span></div><div>Loop for delay</div></div>
									<div class="assembly-row-combined"><div>0253-0254</div><div>IN A,(0FFH)<span class="opcode2" style="display: none;">DB FF</span></div><div>Read a bit from the cassette port</div></div>
									<div class="assembly-row-combined"><div>0255</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Since we are going to need to use A, load A's value (the bit read from the cassette port) into Register B</div></div>
									<div class="assembly-row-combined"><div>0256</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the value from the STACK (which was the bits already read for this byte) and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>0257-0258</div><div>RLC B<span class="opcode2" style="display: none;">CB 10</span></div><div>Shift the that data bit read in Register B into the Carry flag</div></div>
									<div class="assembly-row-combined"><div>0259</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Shift the value in the Carry flag (which was B) into Register A</div></div>
									<div class="assembly-row-combined"><div>025A</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the value in Register A on the STACK because its gonna get erased by the next step</div></div>
									<div class="assembly-row-combined"><div>025B-025D</div><div><a href="#021EH" class="memory-link">CALL 021EH<span class="origrom2" style="display: inline;">CALL CTSTAT</span></a><span class="opcode2" style="display: none;">CD 1E 02</span></div><div>Go clear the cassette controller so we can get to reading</div></div>
									<div class="assembly-row-combined"><div>025E</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the value from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>025F</div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>Get the value from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>0260</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0261H">0261H-0263H - CASSETTE ROUTINE<span class="origrom">- "TWOCSO"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0261-0263<span class="origrom2" style="display: inline;">TWOCSO</span></div><div><a href="#0264H" class="memory-link">CALL 0264H<span class="origrom2" style="display: inline;">CALL CASOUT</span></a><span class="opcode2" style="display: none;">CD 64 02</span></div><div>Write
 the clock pulse by calling the WRITE ONE BYTE TO CASSETTE routine at 
0264H (which writes the byte in the A Register to the cassette drive 
selected in the A register)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0264H">0264H-027DH - CASSETTE ROUTINE (WRITE A BYTE)<span class="origrom">- "CASOUT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Writes the byte in the A Register to tape. BC, DE and HL are unchanged by a CALL 264H.<br><br>To
 use a ROM call to write a character onto cassette tape (after the 
cassette has been turned on and leader and sync have been recorded), 
load the character into the A Register And CALL 0264H. If more than one 
character is to be written, the CALL 0264H must be executed with 
sufficient frequency to sustain the 500 baud recording rate. The routine
 provides automatic timing. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0264<span class="origrom2" style="display: inline;">CASOUT</span></div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the value in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0265</div><div>PUSH BC<span class="opcode2" style="display: none;">C5</span></div><div>Save the value in Register Pair BC on the STACK</div></div>
									<div class="assembly-row-combined"><div>0266</div><div>PUSH DE<span class="opcode2" style="display: none;">D5</span></div><div>Save the value in Register Pair DE on the STACK</div></div>
									<div class="assembly-row-combined"><div>0267</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the value in Register A on the STACK</div></div>
									<div class="assembly-row-combined"><div>0268-0269</div><div>LD C,08H<span class="opcode2" style="display: none;">0E 08</span></div><div>Load Register C with the number of bits to be written (i.e., 8)</div></div>
									<div class="assembly-row-combined"><div>026A</div><div>LD D,A<span class="opcode2" style="display: none;">57</span></div><div>Load Register D with the byte to be written from Register A because A is about to get used in the next line</div></div>
									<div class="assembly-row-combined"><div>026B-026D<span class="origrom"><br>BYT0</span></div><div><a href="#01D9H" class="memory-link">CALL 01D9H<span class="origrom2" style="display: inline;">CALL CTPULS</span></a><span class="opcode2" style="display: none;">CD D9 01</span></div><div>Go write the start/clock bit</div></div>
									<div class="assembly-row-combined"><div>026E</div><div>LD A,D<span class="opcode2" style="display: none;">7A</span></div><div>Load Register A with the byte to be written in Register D</div></div>
									<div class="assembly-row-combined"><div>026F</div><div>RLCA<span class="opcode2" style="display: none;">07</span></div><div>Shift the bit to be written into the Carry flag</div></div>
									<div class="assembly-row-combined"><div>0270</div><div>LD D,A<span class="opcode2" style="display: none;">57</span></div><div>Save the adjusted byte to be written in Register A in Register D</div></div>
									<div class="assembly-row-combined"><div>0271-0272</div><div><a href="#027EH" class="memory-link">JR NC,027EH<span class="origrom2" style="display: inline;">JR NC,BYT2</span></a><span class="opcode2" style="display: none;">30 0B</span></div><div>Jump if the bit to be written is equal to zero</div></div>
									<div class="assembly-row-combined"><div>0273-0275</div><div><a href="#01D9H" class="memory-link">CALL 01D9H<span class="origrom2" style="display: inline;">CALL CTPULS</span></a><span class="opcode2" style="display: none;">CD D9 01</span></div><div>Go write that (non-zero) bit</div></div>
									<div class="assembly-row-combined"><div>0276<span class="origrom"><br>BYT1</span></div><div>DEC C<span class="opcode2" style="display: none;">0D</span></div><div>Decrement the counter in Register C</div></div>
									<div class="assembly-row-combined"><div>0277-0278</div><div><a href="#026BH" class="memory-link">JR NZ,026BH<span class="origrom2" style="display: inline;">JR NZ,BYT0</span></a><span class="opcode2" style="display: none;">20 F2</span></div><div>Loop until all eight bits have been written</div></div>
									<div class="assembly-row-combined"><div>0279</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the value from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>027A</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Get the value from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>027B</div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>Get the value from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>027C</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the value from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>027D</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="027EH">027EH-0283H - CASSETTE ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>027E-027F<span class="origrom2" style="display: inline;">BYT2</span></div><div>LD B,87H<span class="opcode2" style="display: none;">06 87</span></div><div>Load Register B with the delay count of 87H (Decimal: 135)</div></div>
									<div class="assembly-row-combined"><div>0280-0281<span class="origrom2" style="display: inline;">BYT3</span></div><div><a href="#0280H" class="memory-link">DJNZ 0280H<span class="origrom2" style="display: inline;">DJNZ BYT3</span></a><span class="opcode2" style="display: none;">10 FE</span></div><div>Loop for the delay</div></div>
									<div class="assembly-row-combined"><div>0282-0283</div><div><a href="#0276H" class="memory-link">JR 0276H<span class="origrom2" style="display: inline;">JR BYT1</span></a><span class="opcode2" style="display: none;">18 F2</span></div><div>Jump to 0276H to count the number of bits written</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0284H">0284H-0292H - CASSETTE ROUTINE (TURN ON CASSETTE AND WRITE LEADER)<span class="origrom">- "CWRTON"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>A call to 0284H writes a Level II leader on currently 
selected unit. The leader consists of 256 (decimal) binary zeros 
followed by a A5H. Uses the B and A registers.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0284-0286<span class="origrom2" style="display: inline;">CWONWL</span></div><div><a href="#01FEH" class="memory-link">CALL 01FEH<span class="origrom2" style="display: inline;">CALL CTON</span></a><span class="opcode2" style="display: none;">CD FE 01</span></div><div>Go evaluate the cassette drive number and turn on that cassette drive's motor</div></div>
									<div class="assembly-row-combined"><div>0287-0288</div><div>LD B,0FFH<span class="opcode2" style="display: none;">06 FF</span></div><div>Writes tape leader and the A5H sync byte. DE and HL are unchanged.<br><br>Load Register B with the number of bytes to be written</div></div>
									<div class="assembly-row-combined"><div>0289</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A</div></div>
									<div class="assembly-row-combined"><div>028A-028C<span class="origrom"><br>CSAV1</span></div><div><a href="#0264H" class="memory-link">CALL 0264H<span class="origrom2" style="display: inline;">CALL CASOUT</span></a><span class="opcode2" style="display: none;">CD 64 02</span></div><div>Calls
 the WRITE ONE BYTE TO CASSETTE routine at 0264H (which writes the byte 
in the A Register to the cassette drive selected in the A register)</div></div>
									<div class="assembly-row-combined"><div>028D-028E</div><div><a href="#028AH" class="memory-link">DJNZ 028AH<span class="origrom2" style="display: inline;">DJNZ CSAV1</span></a><span class="opcode2" style="display: none;">10 FB</span></div><div>Loop until leader has been written</div></div>
									<div class="assembly-row-combined"><div>028F-0290</div><div>LD A,A5H<span class="opcode2" style="display: none;">3E A5</span></div><div>Load Register A with the sync byte value</div></div>
									<div class="assembly-row-combined"><div>0291-0292</div><div><a href="#0264H" class="memory-link">JR 0264H<span class="origrom2" style="display: inline;">JR CASOUT</span></a><span class="opcode2" style="display: none;">18 D1</span></div><div>Calls
 the WRITE ONE BYTE TO CASSETTE routine at 0264H (which writes the byte 
in the A Register to the cassette drive selected in the A register).  In
 this case, it writes the SYNC byte</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0293H">0293H-029EH - CASSETTE ROUTINE (TURN ON CASSETTE AND READ LEADER)<span class="origrom">- "CSRDON"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0293-0295<span class="origrom2" style="display: inline;">CSRDON</span></div><div><a href="#01FEH" class="memory-link">CALL 01FEH<span class="origrom2" style="display: inline;">CALL CTON</span></a><span class="opcode2" style="display: none;">CD FE 01</span></div><div>Go evaluate the drive number and turn on that cassette drive's motor</div></div>
									<p class="debug-note">Read Leader: Reads the currently selected
 cassette unit until an end of leader (A5) is found. An asterisk is 
displayed in the upper right hand corner of the video display when the 
end is found. Uses the A-register<br><br>Reads from tape until the 
leader is found, then keeps going until it is bypassed and the sync byte
 (ASH) is found, when it returns. DE, BC and HL are unchanged by this</p>
									<div class="assembly-row-combined"><div>0296<span class="origrom2" style="display: inline;">CSRDON+3</span></div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Reads
 from tape until the leader is found, then keeps going until it is 
bypassed and the sync byte (A5H) is found, when it returns. DE, BC and 
HL are unchanged by this.<br><br>Save the current BASIC program pointer in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0297</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A and status flags</div></div>
									<div class="assembly-row-combined"><div>0298-029A<span class="origrom"><br>CLOD1</span></div><div><a href="#0241H" class="memory-link">CALL 0241H<span class="origrom2" style="display: inline;">CALL CTBIT</span></a><span class="opcode2" style="display: none;">CD 41 02</span></div><div>Top of a loop.  GOSUB to read a byte from the cassette and return with it in Register A</div></div>
									<div class="assembly-row-combined"><div>029B-029C</div><div>CP A5H<span class="opcode2" style="display: none;">FE A5</span></div><div>Check to see if the byte read from the cassette in Register A is a sync byte</div></div>
									<div class="assembly-row-combined"><div>029D-029E</div><div><a href="#0298H" class="memory-link">JR NZ,0298H<span class="origrom2" style="display: inline;">JR NZ, CLOD1</span></a><span class="opcode2" style="display: none;">20 F9</span></div><div>Loop until sync byte found</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="029FH">029FH-02A8H - CASSETTE ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Places the double asterisk in the right top corner to show that the sync byte has been found</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>029F-02A0</div><div>LD A,2FH <span class="origrom2" style="display: inline;">LD A,"*"</span><span class="opcode2" style="display: none;">3E 2A</span></div><div>Places the double asterisk in the right top corner to show that the sync byte has been found.<br><br>Load Register A with a <span class="code">*</span>character.  ("*" is 2AH)</div></div>
									<div class="assembly-row-combined"><div>02A1-02A3</div><div>LD (3C3EH),A<span class="opcode2" style="display: none;">32 3E 3C</span></div><div>Display the <span class="code">*</span>character in Register A on the video display at location 15422</div></div>
									<div class="assembly-row-combined"><div>02A4-02A6</div><div>LD (3C3FH),A<span class="opcode2" style="display: none;">32 3F 3C</span></div><div>Display the <span class="code">*</span>character in Register A on the video display at location 15423</div></div>
									<div class="assembly-row-combined"><div>02A7</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the current BASIC program pointer from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>02A8</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="02A9H">02A9H-0329H - LEVEL II SYSTEM ROUTINE-ENTRY POINT<span class="origrom">- "ENBLK"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>02A9-02AB<span class="origrom2" style="display: inline;">ENBLK</span></div><div><a href="#0314H" class="memory-link">CALL 0314H<span class="origrom2" style="display: inline;">CALL CADRIN</span></a><span class="opcode2" style="display: none;">CD 14 03</span></div><div>Go read 2 bytes from the cassette, which should be the start/execution address, and return with it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>02AC-02AE</div><div>LD (40DFH),HL<span class="origrom2" style="display: inline;">LD (TEMP),HL</span><span class="opcode2" style="display: none;">22 DF 40</span></div><div>Save the just read execution address from HL into 40DFH.<br>Note: 40DFH-40E0H is also used by DOS</div></div>
									<div class="assembly-row-combined"><div>02AF-02B1</div><div><a href="#01F8H" class="memory-link">CALL 01F8H<span class="origrom2" style="display: inline;">CALL CTOFF</span></a><span class="opcode2" style="display: none;">CD F8 01</span></div><div>Go turn off the cassette motor</div></div>
									<div class="assembly-row-combined" id="02B2H"><div>02B2-02B4<span class="origrom2" style="display: inline;">SYSTEM</span></div><div><a href="https://www.trs-80.com/sub-disassem-dos-td23-sys-0.htm#41E2H" class="memory-link">CALL 41E2H<span class="origrom2" style="display: inline;">CALL SYSOUT</span></a><span class="opcode2" style="display: none;">CD E2 41</span></div><div>Go call the DOS link at 41E2H.<br>In NEWDOS 2.1, this is called during a SYSTEM operation.</div></div>
									<p class="debug-note">This location passes control to the routine used by the BASIC command SYSTEM</p>
									<div class="assembly-row-combined"><div>02B5-02B7</div><div>LD SP,4288H<span class="origrom2" style="display: inline;">LD SP,BUFINI+160</span><span class="opcode2" style="display: none;">31 88 42</span></div><div>Set
 the STACK pointer to 4288H (which is the assumed load address).  This 
location passes control to the routine used by the BASIC command SYSTEM.</div></div>
									<div class="assembly-row-combined"><div>02B8-02BA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#20FEH" class="memory-link">CALL 20FEH<span class="origrom2" style="display: inline;">CALL CRDO</span></a><span class="opcode2" style="display: none;">CD FE 20</span></div><div>GOSUB to display a carriage return on the video display if necessary</div></div>
									<div class="assembly-row-combined"><div>02BB-02BC</div><div>LD A,2AH<span class="origrom2" style="display: inline;">LD A,"*"</span><span class="opcode2" style="display: none;">3E 2A</span></div><div>Load Register A with an <span class="code">*</span> character (which will form the next prompt)</div></div>
									<div class="assembly-row-combined"><div>02BD-02BF</div><div><a href="#032AH" class="memory-link">CALL 032AH<span class="origrom2" style="display: inline;">CALL OUTDO</span></a><span class="opcode2" style="display: none;">CD 2A 03</span></div><div>Go display the <span class="code">*</span> character in Register A on the video display</div></div>
									<div class="assembly-row-combined"><div>02C0-02C2</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1BB3H" class="memory-link">CALL 1BB3H<span class="origrom2" style="display: inline;">CALL QINLIN</span></a><span class="opcode2" style="display: none;">CD B3 1B</span></div><div>We need a filename now, so go get the input from the keyboard</div></div>
									<div class="assembly-row-combined"><div>02C3-02C5</div><div><a href="#06CCH" class="memory-link">JP C,06CCH<span class="origrom2" style="display: inline;">JP C,RESETR</span></a><span class="opcode2" style="display: none;">DA CC 06</span></div><div>If a <kbd>BREAK</kbd> key was hit (because the Carry flag is now on), go to the Level II BASIC READY routine</div></div>
									<div class="assembly-row-combined"><div>02C6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H<span class="origrom2" style="display: inline;">CHRGET</span></a><span class="opcode2" style="display: none;">D7</span></div><div>Since
 we need to bump the input buffer pointer in Register Pair HL until it 
points to the first character input, call the EXAMINE NEXT SYMBOL 
routine at RST 10H.<br><br>The RST 10H routine parses the characters 
starting at HL+1 for the first non-SPACE,non-09H,non-0BH character it 
finds.  On exit, Register A will hold that character, and the C FLAG is 
set if its alphabetic, and NC FLAG if its alphanumeric.  All strings 
must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>02C7-02C9</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1997H" class="memory-link">JP Z,1997H<span class="origrom2" style="display: inline;">JP Z,SNERR</span></a><span class="opcode2" style="display: none;">CA 97 19</span></div><div>Display a <span class="code">?SN ERROR</span>if there wasn't any input</div></div>
									<div class="assembly-row-combined"><div>02CA-02CB</div><div>CP 2FH<span class="origrom2" style="display: inline;">LD A,"/"</span><span class="opcode2" style="display: none;">FE 2F</span></div><div>Check to see if the character at the location of the input buffer pointer in Register A is a <span class="code">/</span>character</div></div>
									<div class="assembly-row-combined"><div>02CC-02CD</div><div><a href="#031DH" class="memory-link">JR Z,031DH<span class="origrom2" style="display: inline;">JR Z, GODO</span></a><span class="opcode2" style="display: none;">28 4F</span></div><div>Jump to 031DH if the character at the location of the input buffer pointer in Register A is a <span class="code">/</span></div></div>
									<div class="assembly-row-combined"><div>02CE-02D0</div><div><a href="#0293H" class="memory-link">CALL 0293H<span class="origrom2" style="display: inline;">CALL CSRDON</span></a><span class="opcode2" style="display: none;">CD 93 02</span></div><div>Go turn on the cassette motor.</div></div>
									<div class="assembly-row-combined"><div>02D1-02D3<span class="origrom"><br>LOPHD</span></div><div><a href="#0235H" class="memory-link">CALL 0235H<span class="origrom2" style="display: inline;">CALL CASIN</span></a><span class="opcode2" style="display: none;">CD 35 02</span></div><div>Top
 of a small loop.  Calls the READ ONE BYTE FROM CASSETTE routine at 
0235H (whichh reads one byte from the cassette drive specified in 
Register A, and returns the byte in Register A)</div></div>
									<div class="assembly-row-combined"><div>02D4-02D5</div><div>CP 55H<span class="opcode2" style="display: none;">FE 55</span></div><div>Check to see if the byte read from the cassette in Register A is a header byte (=55H)</div></div>
									<div class="assembly-row-combined"><div>02D6-02D7</div><div><a href="#02D1H" class="memory-link">JR NZ,02D1H<span class="origrom2" style="display: inline;">JR NZ,LOPHD</span></a><span class="opcode2" style="display: none;">20 F9</span></div><div>Loop until the header byte is found.</div></div>
									<div class="assembly-row-combined"><div>02D8-02D9</div><div>LD B,06H<span class="opcode2" style="display: none;">06 06</span></div><div>If
 were here, we got the header byte, so load Register B with the length 
of the filename to read from the cassette (which is 6 characters)</div></div>
									<div class="assembly-row-combined" id="02DAH"><div>02DA<span class="origrom2" style="display: inline;">CHKBYT</span></div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load Register A with the character at the location of the current input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>02DB</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the character at the location of the current input buffer pointer in Register A is an end of input character</div></div>
									<div class="assembly-row-combined"><div>02DC-02DD</div><div><a href="#02E7H" class="memory-link">JR Z,02E7H<span class="origrom2" style="display: inline;">JR Z,GETDT</span></a><span class="opcode2" style="display: none;">28 09</span></div><div>Jump
 out of this 'read the filename from the cassette' routine if the 
character at the location of the current input buffer pointer in 
Register A is an end of input character</div></div>
									<div class="assembly-row-combined"><div>02DE-02E0</div><div><a href="#0235H" class="memory-link">CALL 0235H<span class="origrom2" style="display: inline;">CALL CASIN</span></a><span class="opcode2" style="display: none;">CD 35 02</span></div><div>Calls
 the READ ONE BYTE FROM CASSETTE routine at 0235H (which reads one byte 
from the cassette drive specified in Register A, and returns the byte in
 Register A)</div></div>
									<div class="assembly-row-combined"><div>02E1</div><div>CP (HL)<span class="opcode2" style="display: none;">BE</span></div><div>Check
 to see if the character at the location of the current input buffer 
pointer in Register Pair HL is the same as the character read from the 
cassette in Register A</div></div>
									<div class="assembly-row-combined"><div>02E2</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>02E3-02E4</div><div><a href="#02D1H" class="memory-link">JR NZ,02D1H<span class="origrom2" style="display: inline;">JR NZ,LOPHD</span></a><span class="opcode2" style="display: none;">20 EC</span></div><div>Jump
 to 02D1H (skip to the next program on cassette) if the character at the
 location of the current input buffer pointer in Register Pair HL isn't 
the same as the character read from the cassette in Register A</div></div>
									<div class="assembly-row-combined"><div>*02E2-02E3</div><div><a href="#02D1H" class="memory-link">JR NZ,02D1H<span class="origrom2" style="display: inline;">JR NZ,LOPHD</span></a></div><div>Jump
 to 02D1H (skip to the next program on cassette) if the character at the
 location of the current input buffer pointer in Register Pair HL isn't 
the same as the character read from the cassette in Register A</div></div>
									<div class="assembly-row-combined"><div>*02E4</div><div>INC HL</div><div>Increment the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>02E5-02E6</div><div><a href="#02DAH" class="memory-link">DJNZ 02DAH<span class="origrom2" style="display: inline;">DJNZ CHKBYT</span></a><span class="opcode2" style="display: none;">10 F3</span></div><div>Loop until the whole of the filename has been read from the cassette and checked against the user response.</div></div>
									<div class="assembly-row-combined"><div>02E7-02E9<span class="origrom"><br>GETDT</span></div><div><a href="#022CH" class="memory-link">CALL 022CH<span class="origrom2" style="display: inline;">CALL BCASIN</span></a><span class="opcode2" style="display: none;">CD 2C 02</span></div><div>Call
 the BLINK ASTERISK routine at 022CH which alternatively displays and 
clears an asterisk in the upper right hand corner of the video display</div></div>
									<div class="assembly-row-combined"><div>02EA-02EC<span class="origrom2" style="display: inline;">GETDT2</span></div><div><a href="#0235H" class="memory-link">CALL 0235H<span class="origrom2" style="display: inline;">CALL CASIN</span></a><span class="opcode2" style="display: none;">CD 35 02</span></div><div>Calls
 the READ ONE BYTE FROM CASSETTE routine at 0235H (whichh reads one byte
 from the cassette drive specified in Register A, and returns the byte 
in Register A)</div></div>
									<div class="assembly-row-combined"><div>02ED-02EE</div><div>CP 78H<span class="opcode2" style="display: none;">FE 78</span></div><div>Check to see if the byte read from the cassette in Register A is an execution address header byte (which is 78H)</div></div>
									<div class="assembly-row-combined"><div>02EF-02F0</div><div><a href="#02A9H" class="memory-link">JR Z,02A9H<span class="origrom2" style="display: inline;">JR Z,ENBLK</span></a><span class="opcode2" style="display: none;">28 B8</span></div><div>Jump if the byte read from the cassette in Register A is an execution address header byte</div></div>
									<div class="assembly-row-combined"><div>02F1-02F2</div><div>CP 3CH<span class="opcode2" style="display: none;">FE 3C</span></div><div>Check to see if the byte read from the cassette in Register A is a file block header byte (which is 3CH)</div></div>
									<div class="assembly-row-combined"><div>02F3-02F4</div><div><a href="#02EAH" class="memory-link">JR NZ,02EAH<span class="origrom2" style="display: inline;">JR NZ,GETDT2</span></a><span class="opcode2" style="display: none;">20 F5</span></div><div>Loop until either an execution address header byte or a file block header byte is read from the cassette.</div></div>
									<div class="assembly-row-combined"><div>02F5-02F7</div><div><a href="#0235H" class="memory-link">CALL 0235H<span class="origrom2" style="display: inline;">CALL CASIN</span></a><span class="opcode2" style="display: none;">CD 35 02</span></div><div>Calls
 the READ ONE BYTE FROM CASSETTE routine at 0235H (which reads one byte 
from the cassette drive specified in Register A, and returns the byte in
 Register A)</div></div>
									<div class="assembly-row-combined"><div>02F8</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Load Register B with the count of bytes to be loaded in Register A</div></div>
									<div class="assembly-row-combined"><div>02F9-02FB</div><div><a href="#0314H" class="memory-link">CALL 0314H<span class="origrom2" style="display: inline;">CALL CADRIN</span></a><span class="opcode2" style="display: none;">CD 14 03</span></div><div>Read the file block's starting address from the cassette and return with it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>02FC</div><div>ADD A,L<span class="opcode2" style="display: none;">85</span></div><div>For
 purposes of calculating a checksum, add the LSB of the file block's 
starting address in Register L to the MSB of the file block's starting 
address in Register A</div></div>
									<div class="assembly-row-combined"><div>02FD</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the file block's starting checksum in Register A</div></div>
									<div class="assembly-row-combined" id="0300H"><div>02FE-0300<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;LDATIN</span></div><div><a href="#0235H" class="memory-link">CALL 0235H<span class="origrom2" style="display: inline;">CALL CASIN</span></a><span class="opcode2" style="display: none;">CD 35 02</span></div><div>Calls
 the READ ONE BYTE FROM CASSETTE routine at 0235H (which reads one byte 
from the cassette drive specified in Register A, and returns the byte in
 Register A)</div></div>
									<div class="assembly-row-combined"><div>0301</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save the byte read from the cassette in Register A at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0302</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0303</div><div>ADD A,C<span class="opcode2" style="display: none;">81</span></div><div>Add the value of the current checksum in Register C to the value in Register A</div></div>
									<div class="assembly-row-combined"><div>0304</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the updated checksum in Register A</div></div>
									<div class="assembly-row-combined"><div>0305-0306</div><div><a href="#02FEH" class="memory-link">DJNZ 02FEH<span class="origrom2" style="display: inline;">DJNZ LDATIN</span></a><span class="opcode2" style="display: none;">10 F7</span></div><div>Loop until the whole file block has been read.</div></div>
									<div class="assembly-row-combined"><div>0307-0309</div><div><a href="#0235H" class="memory-link">CALL 0235H<span class="origrom2" style="display: inline;">CALL CASIN</span></a><span class="opcode2" style="display: none;">CD 35 02</span></div><div>Calls
 the READ ONE BYTE FROM CASSETTE routine at 0235H (which reads one byte 
from the cassette drive specified in Register A, and returns the byte in
 Register A).  This reads in the checksum from cassette</div></div>
									<div class="assembly-row-combined"><div>030A</div><div>CP C<span class="opcode2" style="display: none;">B9</span></div><div>Check to see if the computed checksum in Register C is the same as the checksum read from the cassette in Register A</div></div>
									<div class="assembly-row-combined"><div>030B-030C</div><div><a href="#02E7H" class="memory-link">JR Z,02E7H<span class="origrom2" style="display: inline;">JR Z,GETDT</span></a><span class="opcode2" style="display: none;">28 DA</span></div><div>If its the same, jump to 02E7H because the next instructions are for bad checksums.</div></div>
									<div class="assembly-row-combined"><div>030D-030E</div><div>LD A,43H<span class="opcode2" style="display: none;">3E 43</span></div><div>Load Register A with a <span class="code">C</span>character</div></div>
									<div class="assembly-row-combined"><div>030F-0311</div><div>LD (3C3EH),A<span class="opcode2" style="display: none;">32 3E 3C</span></div><div>Display the <span class="code">C</span>character in Register A on the video display (at 15422)</div></div>
									<div class="assembly-row-combined"><div>0312-0313</div><div><a href="#02EAH" class="memory-link">JR 02EAH<span class="origrom2" style="display: inline;">JR GETDT2</span></a><span class="opcode2" style="display: none;">18 D6</span></div><div>Jump to 02EAH and keep reading bytes</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0314H">0314H - Read 2 bytes from the tape into Register Pair HL<span class="origrom">- "CADRIN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine is commonly used by the SYSTEM routine to read 
the last two bytes on tape which give the entry point. A JP (HL) can 
then be executed to jump to the location specified, when used for this 
purpose. Only HL is used by this routine</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0314<span class="origrom2" style="display: inline;">CADRIN</span></div><div><a href="#0235H" class="memory-link">CALL 0235H<span class="origrom2" style="display: inline;">CALL CASIN</span></a><span class="opcode2" style="display: none;">CD 35 02</span></div><div>Calls
 the READ ONE BYTE FROM CASSETTE routine at 0235H (whichh reads one byte
 from the cassette drive specified in Register A, and returns the byte 
in Register A)</div></div>
									<div class="assembly-row-combined"><div>0317</div><div>LD L,A<span class="opcode2" style="display: none;">6F</span></div><div>Load Register L with the byte read from the cassette in Register A (which is the LSB of the 16 bit value)</div></div>
									<div class="assembly-row-combined"><div>0318-031A</div><div><a href="#0235H" class="memory-link">CALL 0235H<span class="origrom2" style="display: inline;">CALL CASIN</span></a><span class="opcode2" style="display: none;">CD 35 02</span></div><div>Calls
 the READ ONE BYTE FROM CASSETTE routine at 0235H (whichh reads one byte
 from the cassette drive specified in Register A, and returns the byte 
in Register A)</div></div>
									<div class="assembly-row-combined"><div>031B</div><div>LD H,A<span class="opcode2" style="display: none;">67</span></div><div>Load Register H with the byte read from the cassette in Register A (which is the MSB of the 16 bit value)</div></div>
									<div class="assembly-row-combined"><div>031C</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="031DH">031DH - Execute the Cassette Program which was Loaded<span class="origrom">- "GODO"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>031D<span class="origrom2" style="display: inline;">GODO</span></div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Load Register Pair DE with the pointer to the BASIC command line being processed (held in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>031E-0320</div><div>LD HL,(40DFH)<span class="origrom2" style="display: inline;">LD HL,(TEMP)</span><span class="opcode2" style="display: none;">2A DF 40</span></div><div>Load Register Pair HL with the execution address (which is stored at 40DFH).<br>Note: 40DFH-40E0H is also used by DOS</div></div>
									<div class="assembly-row-combined"><div>0321</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>So
 that we can run a RST 10H in the next instruction, we need to exchange 
the execution address in Register Pair HL with the input buffer pointer 
in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0322</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H<span class="origrom2" style="display: inline;">CHRGET</span></a><span class="opcode2" style="display: none;">D7</span></div><div>Since
 we need to bump the current input buffer pointer in Register Pair HL 
until it points to the next character, call the EXAMINE NEXT SYMBOL 
routine at RST 10H.<br><br>The RST 10H routine parses the characters 
starting at HL+1 for the first non-SPACE,non-09H,non-0BH character it 
finds.  On exit, Register A will hold that character, and the C FLAG is 
set if its alphabetic, and NC FLAG if its alphanumeric.  All strings 
must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>0323-0325</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E5AH" class="memory-link">CALL NZ,1E5AH<span class="origrom2" style="display: inline;">CALL NZ,LINGET</span></a><span class="opcode2" style="display: none;">C4 5A 1E</span></div><div>Call
 the ASCII TO INTEGER routine at 1E5AH.  NOTE: The routine at 1E5A 
converts the ASCII string pointed to by HL to an integer deposited into 
DE.  If the routine finds a non-numeric character, the conversion is 
stopped</div></div>
									<div class="assembly-row-combined"><div>0326-0327</div><div><a href="#02B2H" class="memory-link">JR NZ,02B2H<span class="origrom2" style="display: inline;">JR NZ,SYSTEM</span></a><span class="opcode2" style="display: none;">20 8A</span></div><div>Jump if it turns out there weren't any digits (i.e., bad input) in the input</div></div>
									<div class="assembly-row-combined"><div>0328</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Since
 there were digits (or else we would have jumped in the prior 
instruction), exchange the input buffer pointer in Register Pair HL with
 the execution address in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0329</div><div>JP (HL)<span class="opcode2" style="display: none;">E9</span></div><div>Jump to the execution address (i.e. "/xxxx") which is in Register Pair HL</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="032AH">032AH-0347H - OUTPUT ROUTINE<span class="origrom">- "OUTCH1" and "OUTDO"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is a general purpose output routine which outputs a byte
 from the A Register to video, tape or printer. In order to use it, the 
location 409CH must be loaded with -1 for tape, 0 for video or 1 for the
 line printer.<br>Note: 409CH holds the current output device flag: -1=cassette, 0=video and 1=printer.<br><br>This
 routine outputs a byte to device determined by byte stored at (409CH) -
 FFH=Tape, 0=Video, l=Printer. When calling, A = output byte. Uses AF. 
Warning: This routine CALLs a Disk BASIC link at address 41ClH which may
 have to be "plugged" with a RETurn (C9H) instruction. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>032A<span class="origrom2" style="display: inline;">OUTDO</span></div><div>PUSH BC<span class="opcode2" style="display: none;">C5</span></div><div>We are going to need to use Register C, so push Register Pair BC into the STACK</div></div>
									<div class="assembly-row-combined"><div>032B</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the character to be output in Register A</div></div>
									<div class="assembly-row-combined"><div>032C-032E</div><div><a href="https://www.trs-80.com/sub-disassem-dos-td23-sys-0.htm#41C1H" class="memory-link">CALL 41C1H<span class="origrom2" style="display: inline;">CALL EXOUTC</span></a><span class="opcode2" style="display: none;">CD C1 41</span></div><div>Go call the DOS link at 41ClH.<br>In NEWDOS 2.1, this writes to the system output device.</div></div>
									<div class="assembly-row-combined"><div>032F-0331</div><div>LD A,(409CH)<span class="origrom2" style="display: inline;">LD A,(PRTFLG)</span><span class="opcode2" style="display: none;">3A 9C 40</span></div><div>Load Register A with the current output device number stored in 409CH.<br>Note: 409CH holds the current output device flag: -1=cassette, 0=video and 1=printer</div></div>
									<div class="assembly-row-combined"><div>0332</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Since <span class="code">LD</span>doesn't set flags, in order to be able to test Register A using flags we need to execute an <span class="code">OR A</span>first.  This will enable us to set the flags according to the current output device number in Register A</div></div>
									<div class="assembly-row-combined"><div>0333</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with the character to be output in Register C</div></div>
									<div class="assembly-row-combined"><div>0334</div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>Get the value from the STACK and put it in Register Pair BC</div></div>
									<p class="debug-note">At this point, A is either +1, -1, or 0. 
 The ROM handles this by testing for a positive number (1 = Cassette), 
and then a non-zero number (-1 = Printer), and then flows down (0 = 
Display) if neither of those apply</p>
									<div class="assembly-row-combined"><div>0335-0337</div><div><a href="#0264H" class="memory-link">JP M,0264H<span class="origrom2" style="display: inline;">JP M,CASOUT</span></a><span class="opcode2" style="display: none;">FA 64 02</span></div><div>If
 the value of the current output device number is positive it means 
CASSETTE, so jump to the the WRITE ONE BYTE TO CASSETTE routine at 0264H
 (which writes the byte in the A Register to the cassette drive selected
 in the A register)</div></div>
									<div class="assembly-row-combined"><div>0338-0339</div><div><a href="#039CH" class="memory-link">JR NZ,039CH<span class="origrom2" style="display: inline;">JR NZ,OUTLPT</span></a><span class="opcode2" style="display: none;">20 62</span></div><div>Jump to 039CH if the character in Register A is to be sent to the printer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="032AH">033AH-0347H - OUTPUT ROUTINE<span class="origrom">- "OUT2D"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>A Print routine which performs the same function as 33H 
except that it doesn't destroy the contents of the DE Register Pair. 
This means that all the general purpose registers are saved, which is 
often desirable<br><br>To use a ROM call to print a single character at 
the current cursor position, and to update the cursor position, load the
 ASCII value of the character into the A Register And then CALL 033AH.<br><br>To
 display special functions using a ROM call, load the A Register with 
the value given below for the special function and then CALL 033AH.
									</p><ol>
										<li>Backspace and erase previous character - 08H</li>
										<li>Carriage return and linefeed - 0DH</li>
										<li>Turn on cursor - 0EH</li>
										<li>Turn off cursor - 0FH</li>
										<li>Convert to 32 characters per line mode - 17H</li>
										<li>Backspace cursor - 18H</li>
										<li>Advance cursor one position - 19H</li>
										<li>Downward line feed - 1AH</li>
										<li>Upward line feed - 1BH</li>
										<li>Home (cursor to upper left corner) - 1CH</li>
										<li>Move cursor to beginning of current line - 1DH</li>
										<li>Erase from cursor position to end of line - 1EH</li>
										<li>Erase from cursor position to end of screen - 1FH</li>
									</ol>
								<p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>033A<span class="origrom2" style="display: inline;">OUT2D</span></div><div>PUSH DE<span class="opcode2" style="display: none;">D5</span></div><div>If
 we're here, then that value in A wasn't going to the cassette or the 
printer, so it must be going to the video.  This routine performs the 
same function as 33H except that it doesn't destroy the contents of the 
DE Register Pair. This means that all the general purpose registers are 
saved, which is often desirable.<br><br>Save the value in Register Pair DE on the STACK</div></div>
									<div class="assembly-row-combined"><div>033B-033D</div><div><a href="#0033H" class="memory-link">CALL 0033H<span class="origrom2" style="display: inline;">CALL $DSP</span></a><span class="opcode2" style="display: none;">CD 33 00</span></div><div>Call the DISPLAY A CHARACTER routine at 0033H (which puts the character in Register A on the video screen)</div></div>
									<div class="assembly-row-combined"><div>033E</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the character in Register A on the STACK</div></div>
									<div class="assembly-row-combined"><div>033F-0341</div><div><a href="#0348H" class="memory-link">CALL 0348H<span class="origrom2" style="display: inline;">CALL DSPPOS</span></a><span class="opcode2" style="display: none;">CD 48 03</span></div><div>Go update the current cursor position and test to see if the display memory is full.</div></div>
									<div class="assembly-row-combined"><div>0342-0344</div><div>LD (40A6H),A<span class="origrom2" style="display: inline;">LD (TTYPOS),A</span><span class="opcode2" style="display: none;">32 A6 40</span></div><div>Save the current cursor line position stored in 40A6H to Register A.<br>Note: 40A6H holds the current cursor line position</div></div>
									<div class="assembly-row-combined"><div>0345</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the character from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>0346</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Get the value from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0347</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0348H">0348H-0357H - VIDEO ROUTINE<span class="origrom">- "DSPPOS"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0348-034A<span class="origrom2" style="display: inline;">DSPPOS</span></div><div>LD A,(403DH)<span class="origrom2" style="display: inline;">LD A,(CAST$)</span><span class="opcode2" style="display: none;">3A 3D 40</span></div><div>Load
 Register A with the contents of 403DH, which contains, among other 
things, the screen resolution (32 or 64 wide; Bit 3) the tape relay 
on/off instruction (Bit 2) and the positive/negative audio pulses (Bits 
0-1).<br>Note: 403DH-4040H is used by DOS</div></div>
									<div class="assembly-row-combined"><div>034B-034C</div><div>AND 08H<span class="origrom2" style="display: inline;">AND 0000 1000</span><span class="opcode2" style="display: none;">E6 08</span></div><div>Mask Register A against 00001000 to isolate Bit 3 (the 32/64 character per line flag) in Register A</div></div>
									<div class="assembly-row-combined"><div>034D-034F</div><div>LD A,(4020H)<span class="origrom2" style="display: inline;">LD A,(CURSOR)</span><span class="opcode2" style="display: none;">3A 20 40</span></div><div>Load Register A with the LSB of the current cursor position.<br>Note: 4020H-4021H holds Video DCB - Cursor location</div></div>
									<div class="assembly-row-combined"><div>0350-0351</div><div><a href="#0355H" class="memory-link">JR Z,0355H<span class="origrom2" style="display: inline;">JR Z,NT32PS</span></a><span class="opcode2" style="display: none;">28 03</span></div><div>If
 Bit 3 of 403DH was a zero, then we have 64 characters per line mode so 
JUMP down a few instructions to skip over the division needed to drop 
everything by half to 32 character mode</div></div>
									<div class="assembly-row-combined"><div>0352</div><div>RRCA<span class="opcode2" style="display: none;">0F</span></div><div>Divide the LSB of the current cursor position in Register A by two</div></div>
									<div class="assembly-row-combined"><div>0353-0354</div><div>AND 1FH<span class="origrom2" style="display: inline;">AND 0001 1111</span><span class="opcode2" style="display: none;">E6 1F</span></div><div>Mask
 the cursor line position in Register A for 32 character per line (AND 
against 0001 1111) to force its position to be no less than 3C00H</div></div>
									<div class="assembly-row-combined" id="0355H"><div>0355-0356</div><div>AND 3FH<span class="origrom2" style="display: inline;">AND 0011 1111</span><span class="opcode2" style="display: none;">E6 3F</span></div><div>Mask
 the cursor line position in Register A for 64 characters per line (AND 
against 0011 1111) to force its position to be no more than 3FFFH</div></div>
									<div class="assembly-row-combined"><div>0357</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0358H">0358H-0360H - KEYBOARD ROUTINE<span class="origrom">- "ISCHAR"</span><br>Here
 is the routine to simulate the INKEY$ function. It performs exactly the
 same function as 2BH but it restores all registers, whereas 2BH 
destroys the contents of the DE Register Pair. This makes 35BH more 
useful than 2BH<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0358-035A<span class="origrom2" style="display: inline;">ISCHAR</span></div><div><a href="https://www.trs-80.com/sub-disassem-dos-td23-sys-0.htm#41C4H" class="memory-link">CALL 41C4H<span class="origrom2" style="display: inline;">CALL EXINC</span></a><span class="opcode2" style="display: none;">CD C4 41</span></div><div>Go call the DOS link at 41C4H</div></div>
									<p class="debug-note">Here is the routine to simulate the 
INKEY$ function. It performs exactly the same function as 2BH but it 
restores all registers, whereas 2BH destroys the contents of the DE 
Register Pair. This makes 35BH more useful than 2BH</p>
									<div class="assembly-row-combined"><div>035B</div><div>PUSH DE<span class="opcode2" style="display: none;">D5</span></div><div>Since the next routine uses DE, save the value in Register Pair DE on the STACK</div></div>
									<div class="assembly-row-combined"><div>035C-035E</div><div><a href="#002BH" class="memory-link">CALL 002BH<span class="origrom2" style="display: inline;">CALL $KBD</span></a><span class="opcode2" style="display: none;">CD 2B 00</span></div><div>Call the SCAN KEYBOARD routine at 002BH</div></div>
									<div class="assembly-row-combined"><div>035F</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Get the value from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0360</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0361H">0361H-0383H - INPUT ROUTINE<span class="origrom">- "INLIN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is one of the general purpose input routines (see 5D9 
and 1BB3 also). This routine inputs a string from the keyboard, up to a 
maximum of 240 characters (F0H), and echoes them to the screen. It puts 
this data into a buffer located at the address pointed to by the buffer 
pointer at 40A7H. (e.g. If 40A7H contains 5000H the data will be stored 
from 5000H onwards). The string is terminated with a zero byte. The 
program returns from this routine as soon as the ENTER key has been 
pressed. When it does so, HL contains the start address of the input 
string and B contains the length of the string. (RST 10H can be used to 
make HL point to the first character of the string, if required.).<br>Note: 40A7H-40A8H holds the input Buffer pointer.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0361<span class="origrom2" style="display: inline;">INLIN</span></div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A to clear the buffered character</div></div>
									<div class="assembly-row-combined"><div>0362-0364</div><div>LD (4099H),A<span class="origrom2" style="display: inline;">LD (CHARC),A</span><span class="opcode2" style="display: none;">32 99 40</span></div><div>Save the value in Register A as the last key pressed (which is stored in 4099H).<br>Note: 4099H holds the Last key pressed</div></div>
									<div class="assembly-row-combined"><div>0365-0367</div><div>LD (40A6H),A<span class="origrom2" style="display: inline;">LD (TTYPOS),A</span><span class="opcode2" style="display: none;">32 A6 40</span></div><div>Save the value in Register A as the current cursor line position (which is stored in 40A6H).<br>Note: 40A6H holds the current cursor line position</div></div>
									<div class="assembly-row-combined"><div>0368-036A</div><div><a href="https://www.trs-80.com/sub-disassem-dos-td23-sys-0.htm#41AFH" class="memory-link">CALL 41AFH<span class="origrom2" style="display: inline;">CALL INLINE</span></a><span class="opcode2" style="display: none;">CD AF 41</span></div><div>Go call the DOS link at 41AFH.<br>In NEWDOS 2.1, this is the satrt of keyboard input</div></div>
									<div class="assembly-row-combined"><div>036B</div><div>PUSH BC<span class="opcode2" style="display: none;">C5</span></div><div>Save Register Pair BC on the STACK</div></div>
									<div class="assembly-row-combined"><div>036C-036E</div><div>LD HL,(40A7H)<span class="origrom2" style="display: inline;">LD HL,(BUFPNT)</span><span class="opcode2" style="display: none;">2A A7 40</span></div><div>Load Register Pair HL with the starting address of the input buffer (which is stored in 40A7H).<br>Note: 40A7H-40A8H holds the input Buffer pointer</div></div>
									<div class="assembly-row-combined"><div>036F-0370</div><div>LD B,0F0H<span class="opcode2" style="display: none;">06 F0</span></div><div>Load Register B with the length of the input buffer (which is 240)</div></div>
									<div class="assembly-row-combined"><div>0371-0373</div><div><a href="#05D9H" class="memory-link">CALL 05D9H<span class="origrom2" style="display: inline;">CALL KEYIN</span></a><span class="opcode2" style="display: none;">CD D9 05</span></div><div>"WAIT
 FOR NEXT LINE" keyboard input routine at 05D9H (which takes keyboard 
entry until a carriage return, a break, or buffer overrun occurs)</div></div>
									<div class="assembly-row-combined"><div>0374</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the flags on the STACK.</div></div>
									<div class="assembly-row-combined"><div>0375</div><div>LD C,B<span class="opcode2" style="display: none;">48</span></div><div>Load Register C with the length of the input in Register B</div></div>
									<div class="assembly-row-combined"><div>0376-0377</div><div>LD B,00H<span class="opcode2" style="display: none;">06 00</span></div><div>Zero Register B so that Register Pair BC will have the length of the input</div></div>
									<div class="assembly-row-combined"><div>0378</div><div>ADD HL,BC<span class="opcode2" style="display: none;">09</span></div><div>Add the length of the input in Register Pair BC to the starting address of the input buffer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0379-037A</div><div>LD (HL),00H<span class="opcode2" style="display: none;">36 00</span></div><div>Save an end of the input character at the location of the end of input pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>037B-037D</div><div>LD HL,(40A7H)<span class="origrom2" style="display: inline;">LD HL,(BUFPNT)</span><span class="opcode2" style="display: none;">2A A7 40</span></div><div>Load Register Pair HL with the starting address of the input buffer (which is 40A7H).<br>Note: 40A7H-40A8H holds the input Buffer pointer</div></div>
									<div class="assembly-row-combined"><div>037E</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the flags from the STACK.</div></div>
									<div class="assembly-row-combined"><div>037F</div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>Get the value from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>0380</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement the input buffer pointer in Register Pair HL (so that HL is the input area pointer - 1)</div></div>
									<div class="assembly-row-combined"><div>0381</div><div>RET C<span class="opcode2" style="display: none;">D8</span></div><div>Return if the <kbr>BREAKkey was pressed</kbr></div></div>
									<div class="assembly-row-combined"><div>0382</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Otherwise (i.e., the <kbd>BREAK</kbd> key was not pressed), zero all the status flags.</div></div>
									<div class="assembly-row-combined"><div>0383</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0384H">0384H-038AH - KEYBOARD ROUTINE<span class="origrom">- "INCHR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Waits for keypress</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0384-0386<span class="origrom2" style="display: inline;">INCHR</span></div><div><a href="#0358H" class="memory-link">CALL 0358H<span class="origrom2" style="display: inline;">CALL ISCHAR</span></a><span class="opcode2" style="display: none;">CD 58 03</span></div><div>Go scan the keyboard.</div></div>
									<div class="assembly-row-combined"><div>0387</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if a key was pressed.</div></div>
									<div class="assembly-row-combined"><div>0388</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>Return if a key was pressed (meaning OR A was set to NZ).</div></div>
									<div class="assembly-row-combined"><div>0389-038A</div><div><a href="#0384H" class="memory-link">JR 0384H<span class="origrom2" style="display: inline;">JR INCHR</span></a><span class="opcode2" style="display: none;">18 F9</span></div><div>Loop until a key is pressed.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="038BH">038BH-039BH - PRINTER ROUTINE - "FINLPT"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine resets device type flag at 409CH to zero (output
 to video display), also outputs a carriage return to the line printer 
if printer is not at beginning of line (determined by checking the 
contents of the printer line position flag at 409BH - if flag contains 
zero, printer is at start of line). Note that if printer line position 
flag does not contain zero and the printer is not on line, the computer 
will "hang up" waiting for a "printer ready" signal.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>038B<span class="origrom2" style="display: inline;">FINLPT</span></div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A, which then means it contains the device code for VIDEO</div></div>
									<div class="assembly-row-combined"><div>038C-038E</div><div>LD (409CH),A<span class="origrom2" style="display: inline;">LD (PRTFLG),A</span><span class="opcode2" style="display: none;">32 9C 40</span></div><div>Save the value in Register A (the current output device code of video) to 409CH.<br>Note: 409CH holds the current output device flag: -1=cassette, 0=video and 1=printer</div></div>
									<div class="assembly-row-combined"><div>038F-0391</div><div>LD A,(409BH)<span class="origrom2" style="display: inline;">LD A,(LPTPOS)</span><span class="opcode2" style="display: none;">3A 9B 40</span></div><div>Load Register A with the current printer carriage position (which is stored at 409BH).<br>Note: 409BH holds the printer carriage position</div></div>
									<div class="assembly-row-combined"><div>0392</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Set the flags for the carriage position in Register A</div></div>
									<div class="assembly-row-combined"><div>0393</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>Return if the carriage position in Register A is equal to zero</div></div>
									<div class="assembly-row-combined"><div>0394-0395</div><div>LD A,0DH<span class="origrom2" style="display: inline;">LD A,<kbd>ENTER</kbd> </span><span class="opcode2" style="display: none;">3E 0D</span></div><div>Load Register A with a "<span class="code">CARRIAGE RETURN</span>"</div></div>
									<div class="assembly-row-combined"><div>0396</div><div>PUSH DE<span class="opcode2" style="display: none;">D5</span></div><div>Save the value in Register Pair DE on the STACK</div></div>
									<div class="assembly-row-combined"><div>0397-0399</div><div><a href="#039CH" class="memory-link">CALL 039CH<span class="origrom2" style="display: inline;">CALL OUTPUT</span></a><span class="opcode2" style="display: none;">CD 9C 03</span></div><div>Go send the carriage return character in Register A to the printer</div></div>
									<div class="assembly-row-combined"><div>039A</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Get the value from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>039B</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="039CH">039CH-03C1H - PRINTER ROUTINE<span class="origrom">- "OUTLPT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the LPRINT routine. All registers are saved. The byte to be printed should be in the A register.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>039C<span class="origrom2" style="display: inline;">OUTLPT</span></div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the value in Register Pair AF on the STACK</div></div>
									<div class="assembly-row-combined"><div>039D</div><div>PUSH DE<span class="opcode2" style="display: none;">D5</span></div><div>Save the value in Register Pair DE on the STACK</div></div>
									<div class="assembly-row-combined"><div>039E</div><div>PUSH BC<span class="opcode2" style="display: none;">C5</span></div><div>Save the value in Register Pair BC on the STACK</div></div>
									<div class="assembly-row-combined"><div>039F</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the character to be sent to the printer in Register A</div></div>
									<div class="assembly-row-combined"><div>03A0-03A1</div><div>LD E,00H<span class="opcode2" style="display: none;">1E 00</span></div><div>Zero Register E (which will ultimately hold the new character/line count of 0CH, 0DH, or 0AH)</div></div>
									<div class="assembly-row-combined"><div>03A2-03A3<span class="origrom2" style="display: inline;">OUTDO</span></div><div>CP 0CH<span class="opcode2" style="display: none;">FE 0C</span></div><div>Check to see if the character to be sent to the printer in Register A is equal to 0CH (which is 'skip to next line')</div></div>
									<div class="assembly-row-combined"><div>03A4-03A5</div><div><a href="#03B6H" class="memory-link">JR Z,03B6H<span class="origrom2" style="display: inline;">JR Z,LZRPOS</span></a><span class="opcode2" style="display: none;">28 10</span></div><div>Jump to 03B6H if the character to be sent to the printer in Register A is equal to 0CH</div></div>
									<div class="assembly-row-combined"><div>03A6-03A7</div><div>CP 0AH<span class="origrom2" style="display: inline;">LD A,<kbd>LINE FEED</kbd> <span class="opcode2" style="display: none;">FE 0A</span></span></div><div>Check to see if the character to be sent to the printer in Register A is a line feed character (i.e., 0AH)</div></div>
									<div class="assembly-row-combined"><div>03A8-03A9</div><div><a href="#03ADH" class="memory-link">JR NZ,03ADH<span class="origrom2" style="display: inline;">JR NZ,LZRNOT</span></a><span class="opcode2" style="display: none;">20 03</span></div><div>Jump to 03ADH if the character to be sent to the printer in Register A isn't a line feed character</div></div>
									<div class="assembly-row-combined"><div>03AA-03AB</div><div>LD A,0DH<span class="origrom2" style="display: inline;">LD A,<kbd>CARRIAGE RETURN</kbd> </span><span class="opcode2" style="display: none;">3E 0D</span></div><div>Load Register A with a carriage return character (i.e., 0DH)</div></div>
									<div class="assembly-row-combined"><div>03AC</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the character to be sent to printer in Register A</div></div>
									<div class="assembly-row-combined"><div>03AD-03AE<span class="origrom2" style="display: inline;">LZRNOT</span></div><div>CP 0DH<span class="opcode2" style="display: none;">FE 0D</span></div><div>Check to see if the character to be sent to the printer in Register A is a carriage return character</div></div>
									<div class="assembly-row-combined"><div>03AF-03B0</div><div><a href="#03B6H" class="memory-link">JR Z,03B6H<span class="origrom2" style="display: inline;">JR Z,LZRPOS</span></a><span class="opcode2" style="display: none;">28 05</span></div><div>Jump to 03B6H if the character to be sent to the printer in Register A is a carriage return character</div></div>
									<div class="assembly-row-combined"><div>03B1-03B3</div><div>LD A,(409BH)<span class="origrom2" style="display: inline;">LD A,(LPTPOS)</span><span class="opcode2" style="display: none;">3A 9B 40</span></div><div>Load Register A with the current printer carriage position (stored in 409BH).<br>Note: 409BH holds the printer carriage position</div></div>
									<div class="assembly-row-combined"><div>03B4</div><div>INC A<span class="opcode2" style="display: none;">3C</span></div><div>Increment the current carriage position in Register A</div></div>
									<div class="assembly-row-combined"><div>03B5</div><div>LD E,A<span class="opcode2" style="display: none;">5F</span></div><div>Load Register E with the current carriage position in Register A</div></div>
									<div class="assembly-row-combined"><div>03B6<span class="origrom2" style="display: inline;">LZRPOS</span></div><div>LD A,E<span class="opcode2" style="display: none;">7B</span></div><div>Load
 Register A with the current carriage position in Register E.  Why do 
this since its obviously already done?  Becasuse this is a jump point!</div></div>
									<div class="assembly-row-combined"><div>03B7-03B9</div><div>LD (409BH),A<span class="origrom2" style="display: inline;">LD (LPTPOS),A</span><span class="opcode2" style="display: none;">32 9B 40</span></div><div>Save the current carriage position (which is stored in 409BH) in Register A.<br>Note: 409BH holds the printer carriage position</div></div>
									<div class="assembly-row-combined"><div>03BA</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with the character to be sent to the printer in Register C</div></div>
									<div class="assembly-row-combined"><div>03BB-03BD</div><div><a href="#003BH" class="memory-link">CALL 003BH<span class="origrom2" style="display: inline;">CALL $PRT</span></a><span class="opcode2" style="display: none;">CD 3B 00</span></div><div>Call the PRINT CHARACTER routine at 003B (which sends the character in the C Register to the printer)</div></div>
									<div class="assembly-row-combined"><div>03BE</div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>Get the value from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>03BF</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Get the value from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>03C0</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the value from the STACK and put it in Register Pair AF</div></div>
									<div class="assembly-row-combined"><div>03C1</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="03C2H">03C2H-03E2H - DRIVER ENTRY ROUTINE<span class="origrom">- "CIO"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine is called from a RST 14 (with a device code of 
01H in Register B), RST 1C (with a device code of 02H in Register B), 
and RST 24 (with a device code of 04H in Register B).<br><br>On entry, BC shoud contain the Device Control Block and A may contain (if needed) the output control/data<br><br>According
 to the original ROM notes, this is the Character I/O Linkage to Device 
Driver routine.  On entry Register Pair DE to point at the Device 
Control Block and Register A will hold the output or control data, if 
any.  On exit, the codes depend on whether a byte or a control code was 
passed.  If this was an I/O operation, Register A will hold that 
input/output data byte.  If this was a I/O control operation, Register A
 will hold the device status and the Z FLAG will be set if the device is
 ready. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>03C2<span class="origrom2" style="display: inline;">CIO</span></div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>03C3-03C4</div><div>PUSH IX<span class="opcode2" style="display: none;">DD E5</span></div><div>Save the value in Register Pair IX on the STACK</div></div>
									<div class="assembly-row-combined"><div>03C5</div><div>PUSH DE<span class="opcode2" style="display: none;">D5</span></div><div>Save the starting address of the device control block in Register Pair DE on the STACK</div></div>
									<div class="assembly-row-combined"><div>03C6-03C7</div><div>POP IX<span class="opcode2" style="display: none;">DD E1</span></div><div>Get the starting address of the device control block from the STACK and put it in Register Pair IX, so now IX = DCB + 0</div></div>
									<div class="assembly-row-combined"><div>03C8</div><div>PUSH DE<span class="opcode2" style="display: none;">D5</span></div><div>Save the value in Register Pair DE on the STACK</div></div>
									<div class="assembly-row-combined"><div>03C9-03CB</div><div>LD HL,03DDH<span class="origrom2" style="display: inline;">LD HL,CIORTN</span><span class="opcode2" style="display: none;">21 DD 03</span></div><div>Load Register Pair HL with a return address of 03DDH</div></div>
									<div class="assembly-row-combined"><div>03CC</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the return address in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>03CD</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Save the character to process (current held in Register A) to Register C so we can use Register A</div></div>
									<div class="assembly-row-combined"><div>03CE</div><div>LD A,(DE)<span class="opcode2" style="display: none;">1A</span></div><div>Load Register A with the device type code (stored the memory location pointed to by DE)</div></div>
									<div class="assembly-row-combined"><div>03CF</div><div>AND B<span class="opcode2" style="display: none;">A0</span></div><div>Isolate the device code bits in A by AND'ing with the device codes in B</div></div>
									<div class="assembly-row-combined"><div>03D0</div><div>CP B<span class="opcode2" style="display: none;">B8</span></div><div>Check to see if the updated device type code in Register A is the same as the driver entry code in Register B</div></div>
									<div class="assembly-row-combined"><div>03D1-03D3</div><div><a href="https://www.trs-80.com/sub-disassem-dos-td23-sys-0.htm#4033H" class="memory-link">JP NZ,4033H<span class="origrom2" style="display: inline;">JP NZ,CIO$</span></a><span class="opcode2" style="display: none;">C2 33 40</span></div><div>Jump
 to the DOS exit link at 4033H if the updated device type code in 
Register A isn't the same as the driver entry code in Register B</div></div>
									<div class="assembly-row-combined"><div>03D4-03D5</div><div>CP 02H<span class="opcode2" style="display: none;">FE 02</span></div><div>At
 this point we know that the updated device type code in A is the same 
as the driver code entry, so let's move on.  First, reset the flags</div></div>
									<div class="assembly-row-combined"><div>03D6-03D8</div><div>LD L,(IX+01H)<span class="opcode2" style="display: none;">DD 6E 01</span></div><div>Load
 Register L with the LSB of the driver entry address at the location of 
the device control block pointer in Register Pair IX plus one</div></div>
									<div class="assembly-row-combined"><div>03D9-03DB</div><div>LD H,(IX+02H)<span class="opcode2" style="display: none;">DD 66 02</span></div><div>Load
 Register H with the MSB of the driver entry address at the location of 
the device control block pointer in Register Pair IX plus one</div></div>
									<div class="assembly-row-combined"><div>03DC</div><div>JP (HL)<span class="opcode2" style="display: none;">E9</span></div><div>Jump to the driver entry address in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>03DD<span class="origrom2" style="display: inline;">CIORTN</span></div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Get the value from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>03DE-03DF</div><div>POP IX<span class="opcode2" style="display: none;">DD E1</span></div><div>Get the value from the STACK and put it in Register Pair IX</div></div>
									<div class="assembly-row-combined"><div>03E0</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the value from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>03E1</div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>Get the value from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>03E2</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="03E3H">03E3H-0457H - KEYBOARD DRIVER<span class="origrom">- "KEY"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>
									This is the keyboard driver. It scans the keyboard and converts
 the bit pattern obtained to ASCII and stores it in the A register.<br><br>
									According to the original ROM notes, this is the Keyboard 
Driver.  On exit, Register A to hold the data byte received (or 0 if 
none).  On entry, [IX] should point to the DCB, which is laid out as 
follows:</p><ul>
									<li>DCB + 0 = DCB Type</li>
									<li>DCB + 1 = Driver Address (LSB)</li>
									<li>DCB + 2 = Driver Addres (MSB)</li>
									<li>DCB + 3 = 0</li>
									<li>DCB + 4 = 0</li>
									<li>DCB + 5 = 0</li>
									<li>DCB + 6 = "K"</li>
									<li>DCB + 7 = "I"</li></ul>
								<p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>03E3-03E5<span class="origrom2" style="display: inline;">KEY</span></div><div>LD HL,4036H<span class="origrom2" style="display: inline;">LD HL,KYBT$</span><span class="opcode2" style="display: none;">21 36 40</span></div><div>Load Register Pair HL with the keyboard work area's starting address (which is 4036H).<br>Note: 4036H-403CH is the keyboard work area</div></div>
									<div class="assembly-row-combined"><div>03E6-03E8</div><div>LD BC,3801H<span class="origrom2" style="display: inline;">LD BC,KEYAD$+1</span><span class="opcode2" style="display: none;">01 01 38</span></div><div>Load Register Pair BC with the keyboard memory's starting address (which is 3801H)</div></div>
									<div class="assembly-row-combined"><div>03E9-03EA</div><div>LD D,00H<span class="opcode2" style="display: none;">16 00</span></div><div>Zero Register D, which will be used to track the keyboard code</div></div>
									<div class="assembly-row-combined" id="03EBH"><div>03EB<span class="origrom2" style="display: inline;">KEYLP</span></div><div>LD A,(BC)<span class="opcode2" style="display: none;">0A</span></div><div>Load Register A with the value at the location of the keyboard memory pointer in Register Pair BC (which is row N)</div></div>
									<div class="assembly-row-combined"><div>03EC</div><div>LD E,A<span class="opcode2" style="display: none;">5F</span></div><div>Load Register E with the keyboard memory value in Register A (8 column bits)</div></div>
									<div class="assembly-row-combined"><div>03ED</div><div>XOR (HL)<span class="opcode2" style="display: none;">AE</span></div><div>Check
 for inequality by XORing the value at the location of the keyboard work
 area pointer in Register Pair HL with the keyboard memory value in 
Register A</div></div>
									<div class="assembly-row-combined"><div>03EE</div><div>LD (HL),E<span class="opcode2" style="display: none;">73</span></div><div>Save
 the keyboard memory value (the column bits) in Register E at the 
location of the keyboard work area pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>03EF</div><div>AND E<span class="opcode2" style="display: none;">A3</span></div><div>Test
 for the active row by masking the adjusted value in Register A with the
 value at the location of the keyboard work area pointer in Register 
Pair HL</div></div>
									<div class="assembly-row-combined"><div>03F0-03F1</div><div><a href="#03FAH" class="memory-link">JR NZ,03FAH<span class="origrom2" style="display: inline;">JR NZ,KEYDWN</span></a><span class="opcode2" style="display: none;">20 08</span></div><div>Jump to 03FAH if the new key pressed is in row N</div></div>
									<div class="assembly-row-combined"><div>03F2</div><div>INC D<span class="opcode2" style="display: none;">14</span></div><div>Increment the keyboard row counter in Register D</div></div>
									<div class="assembly-row-combined"><div>03F3</div><div>INC L<span class="opcode2" style="display: none;">2C</span></div><div>Increment the keyboard work area pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>03F4-03F5</div><div>RLC C<span class="opcode2" style="display: none;">CB 01</span></div><div>Adjust the keyboard memory pointer in Register Pair BC by stepping it from 3801 to 3840 by rotating the bits left (RLC)</div></div>
									<div class="assembly-row-combined"><div>03F6-03F8</div><div><a href="#03EBH" class="memory-link">JP P,03EBH<span class="origrom2" style="display: inline;">JP P,KEYLP</span></a><span class="opcode2" style="display: none;">F2 EB 03</span></div><div>Jump
 to 03EBH if the whole of keyboard memory hasn't been checked (by 
POSITIVE bit [Bit 7] being on).  This has the effect of looping over the
 first 6 rows of the keyboard but NOT doing row 7, which has the shift 
key</div></div>
									<div class="assembly-row-combined"><div>03F9</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="03FAH">03FAH-040AH - Accept a Keyboard Downstroke and Convert it to ASCII<span class="origrom">- "KEYDWN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>03FA<span class="origrom2" style="display: inline;">KEYDWN</span></div><div>LD E,A<span class="opcode2" style="display: none;">5F</span></div><div>Save the column number from the new keypress in Register A in Register E</div></div>
									<div class="assembly-row-combined"><div>03FB</div><div>LD A,D<span class="opcode2" style="display: none;">7A</span></div><div>Load Register A with the row counter in Register D (this is going to cycle from 0 through 6)</div></div>
									<div class="assembly-row-combined"><div>03FC</div><div>RLCA<span class="opcode2" style="display: none;">07</span></div><div>Multiply the row counter in Register A by two</div></div>
									<div class="assembly-row-combined"><div>03FD</div><div>RLCA<span class="opcode2" style="display: none;">07</span></div><div>Multiply the row counter in Register A by two</div></div>
									<div class="assembly-row-combined"><div>*03FB-03FD</div><div>JP 011CH</div><div>For ROM v1.2, jump to the new keyboard debounce routine.  That routine includes the now deleted <span class="code">RCLA</span>, <span class="code">RCLA</span>instructions which had to be killed to make room for this 3 byte jump opcode</div></div>
									<div class="assembly-row-combined"><div>03FE</div><div>RLCA<span class="opcode2" style="display: none;">07</span></div><div>Multiply the row counter in Register A by two</div></div>
									<div class="assembly-row-combined"><div>03FF</div><div>LD D,A<span class="opcode2" style="display: none;">57</span></div><div>Load Register D with the row counter in Register A</div></div>
									<div class="assembly-row-combined" id="0400H"><div>0400-0401</div><div>LD C,01H<span class="opcode2" style="display: none;">0E 01</span></div><div>Load Register C with the starting column counter (as bit 0)</div></div>
									<div class="assembly-row-combined"><div>0402<span class="origrom2" style="display: inline;">KEYDLP</span></div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with the column counter in Register C (as a mask)</div></div>
									<div class="assembly-row-combined"><div>0403</div><div>AND E<span class="opcode2" style="display: none;">A3</span></div><div>Turn
 off some bits so we can check to see if the column counter in Register A
 is the same as the active column number in Register E</div></div>
									<div class="assembly-row-combined"><div>0404-0405</div><div><a href="#040BH" class="memory-link">JR NZ,040BH<span class="origrom2" style="display: inline;">JR NZ,KEYFND</span></a><span class="opcode2" style="display: none;">20 05</span></div><div>Jump to 040BH if the column counter in Register A is the same as the active column number in Register E</div></div>
									<div class="assembly-row-combined"><div>0406</div><div>INC D<span class="opcode2" style="display: none;">14</span></div><div>Increment the column number (which is held in Register D)</div></div>
									<div class="assembly-row-combined"><div>0407-0408</div><div>RLC C<span class="opcode2" style="display: none;">CB 01</span></div><div>Adjust the column counter in Register C left 1 bit to align the mask</div></div>
									<div class="assembly-row-combined"><div>0409-040A</div><div><a href="#0402H" class="memory-link">JR 0402H<span class="origrom2" style="display: inline;">JR KEYDLP</span></a><span class="opcode2" style="display: none;">18 F7</span></div><div>Loop back to 0402H until the value in Register D is adjusted for its column</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="040BH">040BH-0428H - Part of the Keyboard routine<span class="origrom">- "KEYFND"</span><br>We now have identified the key.  Next we need to see if it is shifted<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>040B-040D<span class="origrom2" style="display: inline;">KEYFND</span></div><div>LD A,(3880H)<span class="origrom2" style="display: inline;">LD A,(KEYAD$+80H)</span><span class="opcode2" style="display: none;">3A 80 38</span></div><div>Load Register A with the value of the SHIFT but from memory location 3880H</div></div>
									<div class="assembly-row-combined"><div>040E</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Load Register B with the SHIFT FLAG value in Register A</div></div>
									<div class="assembly-row-combined"><div>040F</div><div>LD A,D<span class="opcode2" style="display: none;">7A</span></div><div>Load Register A with the value in Register D (Row * 8 + column 0-7)</div></div>
									<div class="assembly-row-combined"><div>0410-0411</div><div>ADD 40H<span class="opcode2" style="display: none;">C6 40</span></div><div>Adjust the ASCII value in Register A (Row * 8 + column (0-7) + 64 decimal)</div></div>
									<div class="assembly-row-combined"><div>0412-0413</div><div>CP 60H<span class="opcode2" style="display: none;">FE 60</span></div><div>Check to see if the value in Register A is alphabetic by testing for the 4 rows (@, A-Z)</div></div>
									<div class="assembly-row-combined"><div>0414-0415</div><div><a href="#0429H" class="memory-link">JR NC,0429H<span class="origrom2" style="display: inline;">JR NC,KEYNAL</span></a><span class="opcode2" style="display: none;">30 13</span></div><div>Jump to 0429H if the value in Register A is nonalphabetic</div></div>
									<div class="assembly-row-combined"><div>0416-0417</div><div>RRC B<span class="opcode2" style="display: none;">CB 08</span></div><div>Put the SHIFT value in Register B in the carry flag (as the RRC command rotates right, and puts bit 0 into the carry bit)</div></div>
									<div class="assembly-row-combined"><div>0418-0419</div><div><a href="#044BH" class="memory-link">JR NC,044BH<span class="origrom2" style="display: inline;">JR NC,KEYRTN</span></a><span class="opcode2" style="display: none;">30 31</span></div><div>Jump if the SHIFT key wasn't pressed (i.e., the rotated right Register B's bit zero wasn't a zero)</div></div>
									<div class="assembly-row-combined"><div>041A-041B</div><div>ADD 20H<span class="opcode2" style="display: none;">C6 20</span></div><div>Adjust the value in Register A for lower case (by ADDing 20H to it)</div></div>
									<div class="assembly-row-combined"><div>041C</div><div>LD D,A<span class="opcode2" style="display: none;">57</span></div><div>Load Register D with the adjusted character in Register A</div></div>
									<div class="assembly-row-combined"><div>041D-041F</div><div>LD A,(3840H)<span class="origrom2" style="display: inline;">LD A,(KEYAD$+40H)</span><span class="opcode2" style="display: none;">3A 40 38</span></div><div>Load Register A with the value at keyboard memory row six</div></div>
									<div class="assembly-row-combined"><div>0420-0421</div><div>AND 10H<span class="origrom2" style="display: inline;">AND 0001 0000</span><span class="opcode2" style="display: none;">E6 10</span></div><div>Turn off some bits so we can check to see if the down arrow key (or ENTER) was pressed (by ANDing it against 0001 0000)</div></div>
									<div class="assembly-row-combined"><div>0422-0423</div><div><a href="#044CH" class="memory-link">JR Z,044CH<span class="origrom2" style="display: inline;">JR Z,KEYRT2</span></a><span class="opcode2" style="display: none;">28 28</span></div><div>Jump to 044CH if down arrow (or ENTER) wasn't pressed</div></div>
									<div class="assembly-row-combined"><div>0424</div><div>LD A,D<span class="opcode2" style="display: none;">7A</span></div><div>Load Register A with the character in Register D</div></div>
									<div class="assembly-row-combined"><div>0425-0426</div><div>SUB 60H<span class="opcode2" style="display: none;">D6 60</span></div><div>Adjust the value of the character in Register A down by 96, possibly to make it a CONTROL KEY</div></div>
									<div class="assembly-row-combined"><div>0427-0428</div><div><a href="#044BH" class="memory-link">JR 044BH<span class="origrom2" style="display: inline;">JR KEYRTN</span></a><span class="opcode2" style="display: none;">18 22</span></div><div>Jump to 044BH</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0429H">0429H-043CH - Part of the Keyboard routine<span class="origrom">- "KEYNAL"</span><br>If we are here, the character was not alphanumeric, so need to check for special and/or shift<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0429-042A<span class="origrom2" style="display: inline;">KEYNAL</span></div><div>SUB 70H<span class="opcode2" style="display: none;">D6 70</span></div><div>Adjust the value of the character in Register A down by 112 (for a special key, like ENTER or SPACE)</div></div>
									<div class="assembly-row-combined"><div>042B-042C</div><div><a href="#043DH" class="memory-link">JR NC,043DH<span class="origrom2" style="display: inline;">JR NC,KEYSPL</span></a><span class="opcode2" style="display: none;">30 10</span></div><div>Jump to 043DH if the character in Register A is for keyboard row six</div></div>
									<div class="assembly-row-combined"><div>042D-042E</div><div>ADD 40H<span class="opcode2" style="display: none;">C6 40</span></div><div>Readjust the value of character in Register A by adding 64 to adjust to rows 4-5</div></div>
									<div class="assembly-row-combined"><div>042F-0430</div><div>CP 3CH<span class="opcode2" style="display: none;">FE 3C</span></div><div>Check to see if the character in Register A is a 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ":", ";", or "," ,character</div></div>
									<div class="assembly-row-combined"><div>0431-0432</div><div><a href="#0435H" class="memory-link">JR C,0435H<span class="origrom2" style="display: inline;">JR C,KEYINV</span></a><span class="opcode2" style="display: none;">38 02</span></div><div>Jump to 0435H for a simple inversion if the character in Register A is one of those characters</div></div>
									<div class="assembly-row-combined"><div>0433-0434</div><div>XOR 10H<span class="origrom2" style="display: inline;">XOR 0001 0000</span><span class="opcode2" style="display: none;">EE 10</span></div><div>Adjust the character in Register A by XORing against 0001 0000 to invert bit 5</div></div>
									<div class="assembly-row-combined" id="0435H"><div>0435-0436<span class="origrom2" style="display: inline;">KEYINV</span></div><div>RRC B<span class="opcode2" style="display: none;">CB 08</span></div><div>Put the SHIFT value in Register B into the Carry flag</div></div>
									<div class="assembly-row-combined"><div>0437-0438</div><div><a href="#044BH" class="memory-link">JR NC,044BH<span class="origrom2" style="display: inline;">JR NC,KEYRTN</span></a><span class="opcode2" style="display: none;">30 12</span></div><div>Jump to 044BH if the <kbd>SHIFT</kbd> key wasn't pressed</div></div>
									<div class="assembly-row-combined"><div>0439-043A</div><div>XOR 10H<span class="opcode2" style="display: none;">EE 10</span></div><div>Adjust the character in Register A by XORing against 0001 0000 to reinvert bit 5</div></div>
									<div class="assembly-row-combined"><div>043B-043C</div><div><a href="#044BH" class="memory-link">JR 044BH<span class="origrom2" style="display: inline;">JR KEYRTN</span></a><span class="opcode2" style="display: none;">18 0E</span></div><div>Jump to 044BH to output</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="043DH">043DH-044AH - Part of the Keyboard routine<span class="origrom">- "KEYSPL"</span><br>This routine does a special key conversion via a table<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>043D<span class="origrom2" style="display: inline;">KEYSPL</span></div><div>RLCA<span class="opcode2" style="display: none;">07</span></div><div>Adjust the value in Register A to be (ROW*8 + COLUMN-48) * 2)</div></div>
									<div class="assembly-row-combined"><div>043E-043F</div><div>RRC B<span class="opcode2" style="display: none;">CB 08</span></div><div>Put the SHIFT value in Register B into the Carry flag</div></div>
									<div class="assembly-row-combined"><div>0440-0441</div><div><a href="#0443H" class="memory-link">JR NC,0443H<span class="origrom2" style="display: inline;">JR NC,KEYNSF</span></a><span class="opcode2" style="display: none;">30 01</span></div><div>Jump to 0443H if the <kbd>SHIFT</kbd> key wasn't pressed</div></div>
									<div class="assembly-row-combined"><div>0442</div><div>INC A<span class="opcode2" style="display: none;">3C</span></div><div>Increment the value in Register A to turn (ROW*8 + COLUMN-48) * 2) into (COLUMN*2+1)</div></div>
									<div class="assembly-row-combined"><div>0443-0445<span class="origrom2" style="display: inline;">KEYNSF</span></div><div>LD HL,0050H<span class="origrom2" style="display: inline;">LD HL,KEYTAB</span><span class="opcode2" style="display: none;">21 50 00</span></div><div>Load Register Pair HL with the starting address of the keyboard lookup table at 50H, which is the last row</div></div>
									<div class="assembly-row-combined"><div>0446</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the offset in Register A (which is either 43D or 442)</div></div>
									<div class="assembly-row-combined"><div>0447-0448</div><div>LD B,00H<span class="opcode2" style="display: none;">06 00</span></div><div>Zero Register B</div></div>
									<div class="assembly-row-combined"><div>0449</div><div>ADD HL,BC<span class="opcode2" style="display: none;">09</span></div><div>Add the offset in Register Pair BC to the starting address of the keyboard lookup table in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>044A</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load Register A with the ASCII value at the location of the keyboard lookup table pointer in Register Pair HL</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="043DH">044BH-044BH - Part of the Keyboard routine<span class="origrom">- "KEYRTN"</span><br>This routine will debounce the keyboard downstroke and return<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>044B<span class="origrom2" style="display: inline;">KEYRTN</span></div><div>LD D,A<span class="opcode2" style="display: none;">57</span></div><div>Load Register D with the ASCII value for the key pressed in Register A</div></div>
									<div class="assembly-row-combined" id="044CH"><div>044C-044E<span class="origrom2" style="display: inline;">KEYRT2</span></div><div>LD BC,0DACH<span class="origrom2" style="display: inline;">LD BC,3500</span><span class="opcode2" style="display: none;">01 AC 0D</span></div><div>Load Register Pair BC with the delay count (which is 3500)</div></div>
									<div class="assembly-row-combined"><div>044F-0451</div><div><a href="#0060H" class="memory-link">CALL 0060H<span class="origrom2" style="display: inline;">CALL $PAUSE</span></a><span class="opcode2" style="display: none;">CD 60 00</span></div><div>Call the delay routine at 0060H (which will delay BC times 14.65)</div></div>
									<div class="assembly-row-combined"><div>0452</div><div>LD A,D<span class="opcode2" style="display: none;">7A</span></div><div>Load Register A with the ASCII value for the key pressed (saved in Register D)</div></div>
									<div class="assembly-row-combined"><div>0453-0454</div><div>CP 01H<span class="opcode2" style="display: none;">FE 01</span></div><div>Check to see if the BREAK key was pressed</div></div>
									<div class="assembly-row-combined"><div>0455</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>Return if the BREAK key wasn't pressed</div></div>
									<div class="assembly-row-combined"><div>0456</div><div>RST 28H<span class="opcode2" style="display: none;">EF</span></div><div>If
 the BREAK key was pressed,call the DOS FUNCTION CALL routine at RST 28 
(which passes request code in A-register to DOS for processing. Returns 
for non-disk system. For disk systems, the A Register must contain a 
legitimate DOS function code. If the code is positive, the CALL is 
ignored and control returns to the caller. Note that the DOS routine 
discards the return address stored on the STACK by the RST instruction. 
After processing control will be returned to the previous address on the
 STACK)</div></div>
									<div class="assembly-row-combined"><div>044B</div><div>RET<span class="opcode2" style="display: none;">57</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0458H">0458H-058CH - DISPLAY DRIVER<span class="origrom">- "DSP"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>
									This is the video driver. On entry, the character to be 
displayed should be in the C register.  On exit, A would contain the 
character at the cursor (if called for an INPUT). This routine handles 
scrolling etc.<br><br>
									Register IX points to the DCB, so IX+0 = the DCB type, IX+1 = 
LSB of the Driver Address, IX+2 = MSB of the Driver Address, IX+3 = LSB 
of the Cursor Position, IX+4 = MSB of the Cursor Position, IX+5 = Cursor
 Character, IX+6 = "D", and IX+7="O"<br><br>
									According to the original ROM notes, this is the Display 
Driver.  On exit, Register A to hold the character read from the new 
cursor position (if the routine was called to look for that).  On entry,
 [IX] should point to the DCB, which is laid out as follows:</p><ul>
									<li>DCB + 0 = DCB Type</li>
									<li>DCB + 1 = Driver Address (LSB)</li>
									<li>DCB + 2 = Driver Addres (MSB)</li>
									<li>DCB + 3 = Cursor Position Address (LSB)</li>
									<li>DCB + 4 = Cursor Position Address (MSB)</li>
									<li>DCB + 5 = Cursor Character</li>
									<li>DCB + 6 = "D"</li>
									<li>DCB + 7 = "O"</li></ul>
								<p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0458-045A<span class="origrom2" style="display: inline;">DSP</span></div><div>LD L,(IX+03H)<span class="opcode2" style="display: none;">DD 6E 03</span></div><div>Load
 Register L with the LSB of the current cursor position at the location 
of the video device control block pointer in Register Pair IX plus three</div></div>
									<div class="assembly-row-combined"><div>045B-045D</div><div>LD H,(IX+04H)<span class="opcode2" style="display: none;">DD 66 04</span></div><div>Load
 Register H with the MSB of the current cursor position at the location 
of the video device control block pointer in Register Pair IX plus four</div></div>
									<div class="assembly-row-combined"><div>045E-045F</div><div><a href="#049AH" class="memory-link">JR C,049AH<span class="origrom2" style="display: inline;">JR C,DSPRD</span></a><span class="opcode2" style="display: none;">38 3A</span></div><div>Jump to 049AH if get last character</div></div>
									<div class="assembly-row-combined"><div>0460-0462</div><div>LD A,(IX+05H)<span class="opcode2" style="display: none;">DD 7E 05</span></div><div>Load
 Register A with the cursor on/off flag (which is stored at the location
 of the video device control block pointer in Register Pair IX plus 
five)</div></div>
									<div class="assembly-row-combined"><div>0463</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the cursor is on or off</div></div>
									<div class="assembly-row-combined"><div>0464-0465</div><div><a href="#0467H" class="memory-link">JR Z,0467H<span class="origrom2" style="display: inline;">JR Z,DSPGRP</span></a><span class="opcode2" style="display: none;">28 01</span></div><div>Jump to 0467H if the cursor is off</div></div>
									<div class="assembly-row-combined"><div>0466</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Display the character in Register A at the location of the current cursor position in Register Pair HL since the cursor is on</div></div>
									<div class="assembly-row-combined"><div>0467<span class="origrom2" style="display: inline;">DSPGRP</span></div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with the character to be displayed from Register C</div></div>
									<div class="assembly-row-combined"><div>0468-0469</div><div>CP 20H<span class="opcode2" style="display: none;">FE 20</span></div><div>Check to see if the character to be displayed in Register A is a control code</div></div>
									<div class="assembly-row-combined"><div>046A-046C</div><div><a href="#0506H" class="memory-link">JP C,0506H<span class="origrom2" style="display: inline;">JP C,DSPCTL</span></a><span class="opcode2" style="display: none;">DA 06 05</span></div><div>Since
 CP returns C set if Register A (the character to be displayed) is less 
than the test value (20H; meaning it is a control character below 
SPACE), jump to 0506H if the character to be displayed in Register A is a
 control code</div></div>
									<div class="assembly-row-combined"><div>046D-046E</div><div>CP 80H<span class="opcode2" style="display: none;">FE 80</span></div><div>Check to see if the character to be displayed in Register A is a graphic character or space compression code</div></div>
									<div class="assembly-row-combined"><div>046F-0470</div><div><a href="#04A6H" class="memory-link">JR NC,04A6H<span class="origrom2" style="display: inline;">JR NC,DSPGSC</span></a><span class="opcode2" style="display: none;">30 35</span></div><div>Since
 CP returns NC set if Register A (the character to be displayed) is 
greater than or equal to the test value (80H; meaning it is a graphic 
character or a space compression code), jump to 04A6H if the character 
to be displayed in Register A is a graphic character or space 
compression code</div></div>
									<div class="assembly-row-combined"><div>0471-0472</div><div>CP 40H<span class="opcode2" style="display: none;">FE 40</span></div><div>Check to see if the character to be displayed in Register A is an alphabetic character</div></div>
									<div class="assembly-row-combined"><div>0473-0474</div><div><a href="#047DH" class="memory-link">JR C,047DH<span class="origrom2" style="display: inline;">JR C,DSPCHR</span></a><span class="opcode2" style="display: none;">38 08</span></div><div>Since
 CP returns C set if Register A (the character to be displayed) is less 
than the test value (40H; meaning it is below the "@" - so a special 
character or a number), jump to 047DH if the character to be displayed 
in Register A is a nonalphabetic character</div></div>
									<div class="assembly-row-combined"><div>0475-0476</div><div>SUB 40H<span class="origrom2" style="display: inline;">SUB "@"</span><span class="opcode2" style="display: none;">D6 40</span></div><div>If
 we are still here, then the character in Register A is between 40H 
("@") and 7FH (the last character before the graphics).  Drop this down 
40H</div></div>
									<div class="assembly-row-combined"><div>0477-0478</div><div>CP 20H<span class="opcode2" style="display: none;">FE 20</span></div><div>Check to see if the character to be displayed in Register A is a lower case character</div></div>
									<div class="assembly-row-combined"><div>0479-047A</div><div><a href="#047DH" class="memory-link">JR C,047DH<span class="origrom2" style="display: inline;">JR C,DSPCHR</span></a><span class="opcode2" style="display: none;">38 02</span></div><div>Since
 CP returns C set if Register A (the newly subtracted character) is less
 than the test value (20H or 32), jump to 047DH since the character to 
be displayed in Register A isn't lower case</div></div>
									<div class="assembly-row-combined"><div>047B-047C</div><div>SUB 20H<span class="opcode2" style="display: none;">D6 20</span></div><div>Convert the lower case character in Register A to upper case by subtracting 32</div></div>
									<div class="assembly-row-combined" id="047DH"><div>047D-047F<span class="origrom2" style="display: inline;">DSPCHR</span></div><div><a href="#0541H" class="memory-link">CALL 0541H<span class="origrom2" style="display: inline;">CALL DSPOUT</span></a><span class="opcode2" style="display: none;">CD 41 05</span></div><div>Go to 0541H display the character in Register A (and scroll the screen if necessary)</div></div>
									<div class="assembly-row-combined" id="0480H"><div>0480<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;DSPSKP</span></div><div>LD A,H<span class="opcode2" style="display: none;">7C</span></div><div>Load Register A with the MSB of the current cursor position in Register H</div></div>
									<div class="assembly-row-combined"><div>0481-0482</div><div>AND 03H<span class="opcode2" style="display: none;">E6 03</span></div><div>Turn off some bits in Register A so that it will be in the range of video memory (3C00H-3FFFH) by ANDing it against 0000 0011</div></div>
									<div class="assembly-row-combined"><div>0483-0484</div><div>OR 3CH<span class="origrom2" style="display: inline;">OR 0011 1100<span class="opcode2" style="display: none;">F6 3C</span></span></div><div>Turn on some bits in Register A to force the MSB of the buffer to be 3C-3Fh (i.e., video memory) by ORing it against 0011 1100</div></div>
									<div class="assembly-row-combined"><div>0485</div><div>LD H,A<span class="opcode2" style="display: none;">67</span></div><div>Load Register H with the updated MSB value (which was forced to be within video memory) in Register A</div></div>
									<div class="assembly-row-combined"><div>0486</div><div>LD D,(HL)<span class="opcode2" style="display: none;">56</span></div><div>Load Register D with the value at the location of the current cursor position in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0487-0489</div><div>LD A,(IX+05H)<span class="opcode2" style="display: none;">DD 7E 05</span></div><div>Load
 Register A with the cursor on/off flag at the location of the video 
device control block pointer in Register Pair IX plus five</div></div>
									<div class="assembly-row-combined"><div>048A</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the cursor is on or off</div></div>
									<div class="assembly-row-combined"><div>048B-048C</div><div><a href="#0492H" class="memory-link">JR Z,0492H<span class="origrom2" style="display: inline;">JR Z,DSPRTN</span></a><span class="opcode2" style="display: none;">28 05</span></div><div>Jump to 0492H if the cursor is off</div></div>
									<div class="assembly-row-combined"><div>048D-048F</div><div>LD (IX+05H),D<span class="opcode2" style="display: none;">DD 72 05</span></div><div>Since
 the cursor is on, save the character being displayed in Register D as 
the cursor on/ off flag at the location of the video device control 
block pointer in Register Pair IX plus five</div></div>
									<div class="assembly-row-combined"><div>0490-0491</div><div>LD (HL),5FH<span class="origrom2" style="display: inline;">LD (HL),CURCHR</span><span class="opcode2" style="display: none;">36 5F</span></div><div>Display the cursor character (of 5FH) at the current location of the cursor in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0492-0494<span class="origrom2" style="display: inline;">DSPRTN</span></div><div>LD (IX+03H),L<span class="opcode2" style="display: none;">DD 75</span></div><div>Save
 the LSB of the current cursor position in Register L at the location of
 the video device control block in Register Pair IX plus three</div></div>
									<div class="assembly-row-combined"><div>0495-0497</div><div>LD (IX+04H),H<span class="opcode2" style="display: none;">DD 74</span></div><div>Save
 the MSB of the current cursor position in Register H at the location of
 the video device control block in Register Pair IX plus four</div></div>
									<div class="assembly-row-combined"><div>0498</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with the character that was displayed in Register C</div></div>
									<div class="assembly-row-combined"><div>0499</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="049AH">049AH - Read the character at the current position of the display<span class="origrom">- "DSPRD"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>049A-049C<span class="origrom2" style="display: inline;">DSPRD</span></div><div>LD A,(IX+05H)<span class="opcode2" style="display: none;">DD 7E 05</span></div><div>Load Register A with the cursor on/off flag</div></div>
									<div class="assembly-row-combined"><div>049D</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the cursor is on or off</div></div>
									<div class="assembly-row-combined"><div>049E</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>Return if the cursor is on and is therefore covering the character</div></div>
									<div class="assembly-row-combined"><div>049F</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>If
 the cursor is off, show the character it was hiding instead by loading 
Register A with the character at the location of the current cursor 
position in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>04A0</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="04A1H">04A1H - Go to the beginning of the line<span class="origrom">- "DSPBOL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>04A1<span class="origrom2" style="display: inline;">DSPBOL</span></div><div>LD A,L<span class="opcode2" style="display: none;">7D</span></div><div>Load Register A with the LSB of the current position in Register L</div></div>
									<div class="assembly-row-combined"><div>04A2-04A3</div><div>AND 0C0H<span class="origrom2" style="display: inline;">AND 1100 0000</span><span class="opcode2" style="display: none;">E6 C0</span></div><div>Turn
 off some bits so we can it will point to the beginning of the line by 
ANDing it against 1100 0000 to remove the lowest 6 bits (so it will be 
XX00H, XX40H, XX80H, or XXC0H).  This is the same thing as a CARRIAGE 
RETURN but without the associated LINE FEED</div></div>
									<div class="assembly-row-combined"><div>04A4</div><div>LD L,A<span class="opcode2" style="display: none;">6F</span></div><div>Load Register L with the updated value in Register A</div></div>
									<div class="assembly-row-combined"><div>04A5</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>Return with the new video buffer address stored in HL</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="04A6H">04A6H - Handle graphic characters<span class="origrom">- "DSPHRC"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>04A6-04A7<span class="origrom2" style="display: inline;">DSPGRC</span></div><div>CP C0H<span class="opcode2" style="display: none;">FE C0</span></div><div>Check to see if the character to be displayed in Register A is a space compression character</div></div>
									<div class="assembly-row-combined"><div>04A8-04A9</div><div><a href="#047DH" class="memory-link">JR C,047DH<span class="origrom2" style="display: inline;">JR C,DSPCHR</span></a><span class="opcode2" style="display: none;">38 D3</span></div><div>Since
 CP returns C set if Register A (the character to be displayed) is less 
than the test value (C0H; meaning it is below the space compression 
characters or, another way, is a graphic character), jump to 047DH if 
the character to be displayed in Register A isn't a space compression 
character (which means it is a graphic character)</div></div>
									<div class="assembly-row-combined"><div>04AA-04AB</div><div>SUB C0H<span class="opcode2" style="display: none;">D6 C0</span></div><div>Now
 we know we have a space compresison code, so adjust the value in 
Register A so that it will hold the number of spaces to be displayed</div></div>
									<div class="assembly-row-combined"><div>04AC-04AD</div><div><a href="#0480H" class="memory-link">JR Z,0480H<span class="origrom2" style="display: inline;">JR Z,DSPSKP</span></a><span class="opcode2" style="display: none;">28 D2</span></div><div>Jump to 0480H if there aren't any spaces to be displayed</div></div>
									<div class="assembly-row-combined"><div>04AE</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Now
 we know it is a space compression character and that at least one space
 is to be displayed, so load Register B with the number of spaces to be 
displayed in Register A (since the space compression codes are 
sequential from 0C0H up)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="04A6H">04AFH - Handle Space Compression characters<span class="origrom">- "DSPSPC"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="04AFH"><div>04AFH-04B0<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;DSPSPC</span></div><div>LD A,20H<span class="opcode2" style="display: none;">3E 20</span></div><div>Load Register A with a space character</div></div>
									<div class="assembly-row-combined"><div>04B1-04B3</div><div><a href="#0541H" class="memory-link">CALL 0541H<span class="origrom2" style="display: inline;">CALL DSPOUT</span></a><span class="opcode2" style="display: none;">CD 41 05</span></div><div>Gosub to 0541H to display the blank character in Register A (and scroll the screen if necessary)</div></div>
									<div class="assembly-row-combined"><div>04B4-04B5</div><div><a href="#04AFH" class="memory-link">DJNZ 04AFH<span class="origrom2" style="display: inline;">DJNZ DSPSPC</span></a><span class="opcode2" style="display: none;">10 F9</span></div><div>Loop back to 04AFH until all of the spaces have been displayed</div></div>
									<div class="assembly-row-combined"><div>04B6-04B7</div><div><a href="#0480H" class="memory-link">JR 0480H<span class="origrom2" style="display: inline;">JR DSPSKP</span></a><span class="opcode2" style="display: none;">18 C8</span></div><div>Once all the spaces have been displayed, jump to 0480H</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="04B8H">04B8H - Turn the cursor on<span class="origrom">- "DSPCON"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>04B8<span class="origrom2" style="display: inline;">DSPCON</span></div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load Register A with the character being displayed at the location of the current cursor position in Register Pair HL</div></div>
									<div class="assembly-row-combined" id="04B9H"><div>04B9-04BB<span class="origrom2" style="display: inline;">DSPCN2</span></div><div>LD (IX+05H),A<span class="opcode2" style="display: none;">DD 77 05</span></div><div>Save
 the value in Register A as the cursor on/off flag at the location of 
the video device control block pointer in Register Pair IX plus five</div></div>
									<div class="assembly-row-combined"><div>04BC</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="04BDH">04BDH - Turn the cursor off<span class="origrom">- "DSPCOF"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>04BD<span class="origrom2" style="display: inline;">DSPCOF</span></div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A to turn the cursor flag off</div></div>
									<div class="assembly-row-combined"><div>04BE-04BF</div><div><a href="#04B9H" class="memory-link">JR DSPCN2<span class="origrom2" style="display: inline;">JR 04B9H</span></a><span class="opcode2" style="display: none;">18 F9</span></div><div>Jump to 04B9H to put a 0 into (IX+05H) and RETurn</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="04C0H">04C0H - Home the cursor<span class="origrom">- "DSPHOM"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>04C0-04C2<span class="origrom2" style="display: inline;">DSPHOM</span></div><div>LD HL,3C00H<span class="origrom2" style="display: inline;">LD HL,DSPAD$</span><span class="opcode2" style="display: none;">21 00 3C</span></div><div>Load Register Pair HL with the starting address of video memory (which is 3C00H)</div></div>
									<div class="assembly-row-combined"><div>04C3-04C5</div><div>LD A,(403DH)<span class="origrom2" style="display: inline;">LD A,(CAST$)</span><span class="opcode2" style="display: none;">3A 3D 40</span></div><div>Load
 Register A with the contents of 403DH, which contains, among other 
things, the screen resolution (32 or 64 wide; Bit 3) the tape relay 
on/off instruction (Bit 2) and the positive/negative audio pulses (Bits 
0-1).<br>Note: 403DH-4040H is used by DOS</div></div>
									<div class="assembly-row-combined"><div>04C6-04C7</div><div>AND 0F7H<span class="origrom2" style="display: inline;">AND 1111 0111</span><span class="opcode2" style="display: none;">E6 F7</span></div><div>Mask Register A against 1111 0111, forcing Bit 3 to OFF to denote 64 characters per line</div></div>
									<div class="assembly-row-combined"><div>04C8-04CA</div><div>LD (403DH),A<span class="origrom2" style="display: inline;">LD (CAST$),A</span><span class="opcode2" style="display: none;">32 3D 40</span></div><div>Put the masked Register A back into 403DH</div></div>
									<div class="assembly-row-combined"><div>04CB-04CC</div><div>OUT (0FFH),A<span class="opcode2" style="display: none;">D3 FF</span></div><div>Send the value in Register A out port 255 which is the video/cassette port</div></div>
									<div class="assembly-row-combined"><div>04CD</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="04CEH">04CEH - Backspace<span class="origrom">- "DSPBSP"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>04CE<span class="origrom2" style="display: inline;">DSPBSP</span></div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement the current cursor position (i.e., backspace) in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>04CF-04D1</div><div>LD A,(CAST$)<span class="origrom2" style="display: inline;">LD A,(403DH)</span><span class="opcode2" style="display: none;">3A 3D 40</span></div><div>Load Register A with the 32/64 character per line flag (which is at 403DH).<br>Note: 403DH-4040H is used by DOS</div></div>
									<div class="assembly-row-combined"><div>04D2-04D3</div><div>AND 08H<span class="origrom2" style="display: inline;">AND 0000 1000</span><span class="opcode2" style="display: none;">E6 08</span></div><div>Turn off some bits so we can check to see if it's 32 or 64 characters per line by ANDing it against 0000 1000</div></div>
									<div class="assembly-row-combined"><div>04D4-04D5</div><div><a href="#04D7H" class="memory-link">JR Z,DSPBS2<span class="origrom2" style="display: inline;">JR Z,04D7H</span></a><span class="opcode2" style="display: none;">28 01</span></div><div>Since
 the AND leaves us with either a 0 (64 characters per line) or a 1 (32 
characters per line), jump to 04D7H if it's 64 characters per line</div></div>
									<div class="assembly-row-combined"><div>04D6</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Right
 now we know it is 32 characters per line (since we didn't jump away), 
so we need to backspace AGAIN by decrementing the current cursor 
position in Register Pair HL</div></div>
									<div class="assembly-row-combined" id="04D7H"><div>04D7-04D8<span class="origrom2" style="display: inline;">DSPBS2</span></div><div>LD (HL),20H<span class="origrom2" style="display: inline;">LD (HL)," "</span><span class="opcode2" style="display: none;">36 20</span></div><div>Display a space character at the location of current cursor position in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>04D9</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="04DAH">04DAH - Cursor Left<span class="origrom">- "DSPLFT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>04DA-04DC<span class="origrom2" style="display: inline;">DSPLFT</span></div><div>LD A,(403DH)<span class="origrom2" style="display: inline;">LD A,(CAST$)</span><span class="opcode2" style="display: none;">3A 3D 40</span></div><div>Load Register A with the 32/64 character per line flag (which is at 403DH).<br>Note: 403DH-4040H is used by DOS</div></div>
									<div class="assembly-row-combined"><div>04DD-04DE</div><div>AND 08H<span class="origrom2" style="display: inline;">AND 0000 1000</span><span class="opcode2" style="display: none;">E6 08</span></div><div>Mask Register A against 0000 1000 to isolate Bit 3 and set the flags Z and NZ based on that bit</div></div>
									<div class="assembly-row-combined"><div>04DF-04E1</div><div><a href="#04E2H" class="memory-link">CALL NZ,04E2H<span class="origrom2" style="display: inline;">CALL NZ,DSPLF2</span></a><span class="opcode2" style="display: none;">C4 E2 04</span></div><div>If
 Bit 3 was not zero then we have 32 characters per line, so GOSUB to 
04E2H.  Note: This is a little trick.  By doing a GOSUB to the next 
line, you effectively block the RET at the end of the routine from 
jumping out, and instead it jumps back here; thus running the routine 
TWICE</div></div>
									<div class="assembly-row-combined" id="04E2H"><div>04E2<span class="origrom2" style="display: inline;">DSPLF2</span></div><div>LD A,L<span class="opcode2" style="display: none;">7D</span></div><div>We are actually here regardless of what Bit 3 was.  Load Register A with the LSB of the current cursor position in Register L</div></div>
									<div class="assembly-row-combined"><div>04E3-04E4</div><div>AND 3FH<span class="origrom2" style="display: inline;">AND 0011 1111</span><span class="opcode2" style="display: none;">E6 3F</span></div><div>Mask the value in Register A by ANDing it against 0011 1111 to backspace LSB of curstor to the previous line and then ..</div></div>
									<div class="assembly-row-combined"><div>04E5</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Backspace the cursor by 1 by decrementing the current cursor position in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>04E6</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>Return if still on the same line</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="04E7H">04E7H - Cursor Down<span class="origrom">- "DSPDWN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is a space saver because if the cursor isn't on the same
 line it needs to move down, so jumping here is also jumping to a CURSOR
 DOWN routine that was simply a fall-through from a wrap around</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>04E7-04E9<span class="origrom2" style="display: inline;">DSPDWN</span></div><div>LD DE,0040H<span class="opcode2" style="display: none;">11 40 00</span></div><div>We
 know we are not on the same line anymore so load Register Pair DE with 
the length of a line on the video display (which is 64)</div></div>
									<div class="assembly-row-combined"><div>04EA</div><div>ADD HL,DE<span class="opcode2" style="display: none;">19</span></div><div>Skip
 down 1 line by adding the length of a line on the video display in 
Register Pair DE to the current cursor position in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>04EB</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="04ECH">04ECH - Cursor Right<span class="origrom">- "DSPRHT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>04EC<span class="origrom2" style="display: inline;">DSPRHT</span></div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the current cursor position in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>04ED</div><div>LD A,L<span class="opcode2" style="display: none;">7D</span></div><div>Load Register A with the LSB of the current cursor position in Register L</div></div>
									<div class="assembly-row-combined"><div>04EE-04EF</div><div>AND 3FH<span class="origrom2" style="display: inline;">AND 0011 1111</span><span class="opcode2" style="display: none;">E6 3F</span></div><div>Turn
 off some bits so we can check to see if the cursor is still on the same
 line via an overflow through ANDing it against 0011 1111</div></div>
									<div class="assembly-row-combined"><div>04F0</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>Return if the cursor is still on the same line</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="04F1H">04F1H - Cursor Up<span class="origrom">- "DSPUP"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Same trick as dealing with CURSOR DOWN if there was an overflow, this does a CURSOR UP if you back up too far</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>04F1-04F3<span class="origrom2" style="display: inline;">DSPUP</span></div><div>LD DE,0FFC0H<span class="opcode2" style="display: none;">11 C0 FF</span></div><div>Now
 we know the cursor is no longer on the same line, so we need to load 
Register Pair DE with a negative length of a line on the video display 
(which is -64)</div></div>
									<div class="assembly-row-combined"><div>04F4</div><div>ADD HL,DE<span class="opcode2" style="display: none;">19</span></div><div>Add
 the negative length of a line on the video display in Register Pair DE 
(i.e., -64) to the current cursor position in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>04F5</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="04F6H">04F6H - Set up 32-Character mode<span class="origrom">- "DSPETB"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>04F6-04F8<span class="origrom2" style="display: inline;">DSPETB</span></div><div>LD A,(403DH)<span class="origrom2" style="display: inline;">LD A,(CAST$)</span><span class="opcode2" style="display: none;">3A 3D 40</span></div><div>This
 routine is going to change the display to 32 character mode so first we
 need to load Register A with the 32/64 character per line flag stored 
at 04F6H.<br>Note: 403DH-4040H is used by DOS</div></div>
									<div class="assembly-row-combined"><div>04F9-04FA</div><div>OR 08H<span class="origrom2" style="display: inline;">OR 0000 1000</span><span class="opcode2" style="display: none;">F6 08</span></div><div>Turn on some bits in Register A to adjust the value in Register A for 32 characters per line by ORing it against 0000 1000</div></div>
									<div class="assembly-row-combined"><div>04FB-04FD</div><div>LD (403DH),A<span class="origrom2" style="display: inline;">LD (CAST$),A</span><span class="opcode2" style="display: none;">32 3D 40</span></div><div>Save the resulting value in Register A back into 403DH (the 32/64 character per line flag).<br>Note: 403DH-4040H is used by DOS</div></div>
									<div class="assembly-row-combined"><div>04FE-04FF</div><div>OUT (0FFH),A<span class="opcode2" style="display: none;">D3 FF</span></div><div>Send the value in Register A out the port 255 (the video/cassette)</div></div>
									<div class="assembly-row-combined" id="0500H"><div>0500</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the current cursor position in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0501</div><div>LD A,L<span class="opcode2" style="display: none;">7D</span></div><div>Load Register A with the LSB of the current cursor position in Register L</div></div>
									<div class="assembly-row-combined"><div>0502-0503</div><div>AND 0FEH<span class="opcode2" style="display: none;">E6 FE</span></div><div>Turn
 off some bits so we can make the LSB value (in Register A) to be an 
even value (since we are in 32 character per line mode) by ANDing it 
against 1111 1110</div></div>
									<div class="assembly-row-combined"><div>0504</div><div>LD L,A<span class="opcode2" style="display: none;">6F</span></div><div>Load Register L with the updated value in Register A</div></div>
									<div class="assembly-row-combined"><div>0505</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0506H">0506H - Process control characters<span class="origrom">- "DSPCTL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0506-0508<span class="origrom2" style="display: inline;">DSPCTL</span></div><div>LD DE,0480H<span class="origrom2" style="display: inline;">LD DE,DSPSKP</span><span class="opcode2" style="display: none;">11 80 04</span></div><div>Load Register Pair DE with the return address</div></div>
									<div class="assembly-row-combined"><div>0509</div><div>PUSH DE<span class="opcode2" style="display: none;">D5</span></div><div>Save the return address in Register Pair DE on the STACK</div></div>
									<div class="assembly-row-combined"><div>050A-050B</div><div>CP 08H<span class="opcode2" style="display: none;">FE 08</span></div><div>Check to see if the character in Register A is a backspace and erase character (i.e., 08H)</div></div>
									<div class="assembly-row-combined"><div>050C-050D</div><div><a href="#04CEH" class="memory-link">JR Z,04CEH<span class="origrom2" style="display: inline;">JR Z,DSPBSP</span></a><span class="opcode2" style="display: none;">28 C0</span></div><div>Since
 CP returns C set if Register A (the character to be displayed) is less 
than the test value (08H), jump to 04CEH as the character to be 
displayed in Register A is a backspace cursor and erase character</div></div>
									<div class="assembly-row-combined"><div>050E-050F</div><div>CP 0AH<span class="opcode2" style="display: none;">FE 0A</span></div><div>Check to see if the character in Register A is less than a line feed character</div></div>
									<div class="assembly-row-combined"><div>0510</div><div>RET C<span class="opcode2" style="display: none;">D8</span></div><div>Return if the character to be displayed in Register A is less than a line feed character so we can ignore them</div></div>
									<div class="assembly-row-combined"><div>0511-0512</div><div>CP 0EH<span class="opcode2" style="display: none;">FE 0E</span></div><div>Check to see if the character to be displayed in Register A is less than or equal to a turn on the cursor character</div></div>
									<div class="assembly-row-combined"><div>0513-0514</div><div><a href="#0564H" class="memory-link">JR C,0564H<span class="origrom2" style="display: inline;">JR C,DSPCR</span></a><span class="opcode2" style="display: none;">38 4F</span></div><div>Jump
 if the character to be displayed in Register A is less than a turn on 
the cursor character so that a carriage return will be displayed</div></div>
									<div class="assembly-row-combined"><div>0515-0516</div><div><a href="#04B8H" class="memory-link">JR Z,04B8H<span class="origrom2" style="display: inline;">JR Z,DSPCON</span></a><span class="opcode2" style="display: none;">28 A1</span></div><div>Jump if the character to be displayed in Register A is a turn on the cursor character</div></div>
									<div class="assembly-row-combined"><div>0517-0518</div><div>CP 0FH<span class="opcode2" style="display: none;">FE 0F</span></div><div>Check to see if the character in Register A is a turn off the cursor character</div></div>
									<div class="assembly-row-combined"><div>0519-051A</div><div><a href="#04BDH" class="memory-link">JR Z,04BDH<span class="origrom2" style="display: inline;">JR Z,DSPCOF</span></a><span class="opcode2" style="display: none;">28 A2</span></div><div>Jump if the character to be displayed in Register A is a turn off the cursor character</div></div>
									<div class="assembly-row-combined"><div>051B-051C</div><div>CP 17H<span class="opcode2" style="display: none;">FE 17</span></div><div>Check to see if the character to be displayed in Register A is a turn on the 32 character per line mode character</div></div>
									<div class="assembly-row-combined"><div>051D-051E</div><div><a href="#04F6H" class="memory-link">JR Z,04F6H<span class="origrom2" style="display: inline;">JR Z,DSPETB</span></a><span class="opcode2" style="display: none;">28 D7</span></div><div>Jump if the character to be displayed in Register A is a turn on the 32 character per line mode character</div></div>
									<div class="assembly-row-combined"><div>051F-0520</div><div>CP 18H<span class="opcode2" style="display: none;">FE 18</span></div><div>Check to see if the character to be displayed in Register A is a left arrow character</div></div>
									<div class="assembly-row-combined"><div>0521-0522</div><div><a href="#04DAH" class="memory-link">JR Z,04DAH<span class="origrom2" style="display: inline;">JR Z,DSPLFT</span></a><span class="opcode2" style="display: none;">28 B7</span></div><div>Jump if the character to be displayed in Register A is a left arrow character</div></div>
									<div class="assembly-row-combined"><div>0523-0524</div><div>CP 19H<span class="opcode2" style="display: none;">FE 19</span></div><div>Check to see if the character to be displayed in Register A is a right arrow character</div></div>
									<div class="assembly-row-combined"><div>0525-0526</div><div><a href="#04ECH" class="memory-link">JR Z,04ECH<span class="origrom2" style="display: inline;">JR Z,DSPRHT</span></a><span class="opcode2" style="display: none;">28 C5</span></div><div>Jump if the character to be displayed in Register A is a right arrow character</div></div>
									<div class="assembly-row-combined"><div>0527-0528</div><div>CP 1AH<span class="opcode2" style="display: none;">FE 1A</span></div><div>Check to see if the character to be displayed in Register A is a down arrow character</div></div>
									<div class="assembly-row-combined"><div>0529-052A</div><div><a href="#04E7H" class="memory-link">JR Z,04E7H<span class="origrom2" style="display: inline;">JR Z,DSPDWN</span></a><span class="opcode2" style="display: none;">28 BC</span></div><div>Jump if the character to be displayed in Register A is a down arrow character</div></div>
									<div class="assembly-row-combined"><div>052B-052C</div><div>CP 1BH<span class="opcode2" style="display: none;">FE 1B</span></div><div>Check to see if the character to be displayed in Register A is an up arrow character</div></div>
									<div class="assembly-row-combined"><div>052D-052E</div><div><a href="#04F1H" class="memory-link">JR Z,04F1H<span class="origrom2" style="display: inline;">JR Z,DSPUP</span></a><span class="opcode2" style="display: none;">28 C2</span></div><div>Jump if the character to be displayed in Register A is an up arrow character</div></div>
									<div class="assembly-row-combined"><div>052F-0530</div><div>CP 1CH<span class="opcode2" style="display: none;">FE 1C</span></div><div>Check to see if the character to be displayed in Register A is a home the cursor character</div></div>
									<div class="assembly-row-combined"><div>0531-0532</div><div><a href="#04C0H" class="memory-link">JR Z,04C0H<span class="origrom2" style="display: inline;">JR Z,DSPHOM</span></a><span class="opcode2" style="display: none;">28 8D</span></div><div>Jump if the character to be displayed in Register A is a home the cursor character</div></div>
									<div class="assembly-row-combined"><div>0533-0534</div><div>CP 1DH<span class="opcode2" style="display: none;">FE 1D</span></div><div>Check to see if the character to be displayed in Register A is a backspace to the beginning of the line character</div></div>
									<div class="assembly-row-combined"><div>0535-0537</div><div><a href="#04A1H" class="memory-link">JP Z,04A1H<span class="origrom2" style="display: inline;">JP Z,DSPBOL</span></a><span class="opcode2" style="display: none;">CA A1 04</span></div><div>Jump if the character to be displayed in Register A is a backspace to the beginning of the line character</div></div>
									<div class="assembly-row-combined"><div>0538-0539</div><div>CP 1EH<span class="opcode2" style="display: none;">FE 1E</span></div><div>Check to see if the character to be displayed in Register A is an erase to the end of the line character</div></div>
									<div class="assembly-row-combined"><div>053A-053B</div><div><a href="#0573H" class="memory-link">JR Z,0573H<span class="origrom2" style="display: inline;">JR Z,DSPEOL</span></a><span class="opcode2" style="display: none;">28 37</span></div><div>Jump if the character to be displayed in Register A is an erase to the end of the line character</div></div>
									<div class="assembly-row-combined"><div>053C-053D</div><div>CP 1FH<span class="opcode2" style="display: none;">FE 1F</span></div><div>Check to see if the character to be displayed in Register A is an erase to the end of the screen character</div></div>
									<div class="assembly-row-combined"><div>053E-053F</div><div><a href="#057CH" class="memory-link">JR Z,057CH<span class="origrom2" style="display: inline;">JR Z,DSPEOF</span></a><span class="opcode2" style="display: none;">28 3C</span></div><div>Jump if the character to be displayed in Register A is an erase to the end of the screen character</div></div>
									<div class="assembly-row-combined"><div>0540</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>Return if the character to be displayed isn't any of the above control codes</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0541H">0541H - Part of the Display routine<span class="origrom">- "DSPOUT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Output the character held in Register A and move the cursor, scrolling the screen if necessary</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0541<span class="origrom2" style="display: inline;">DSPOUT</span></div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Put the character stored in A into the memory location stored in HL</div></div>
									<div class="assembly-row-combined"><div>0542</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the current cursor position in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0543-0545</div><div>LD A,(403DH)<span class="origrom2" style="display: inline;">LD A,(CAST$)</span><span class="opcode2" style="display: none;">3A 3D 40</span></div><div>Load Register A with the 32/64 character per line flag (stored in 403DH).<br>Note: 403DH-4040H is used by DOS</div></div>
									<div class="assembly-row-combined"><div>0546-0547</div><div>AND 08H<span class="origrom2" style="display: inline;">AND 0000 1000</span><span class="opcode2" style="display: none;">E6 08</span></div><div>Turn off some bits so we can check to see if it's 32 or 64 characters per line by ANDing it against 0000 1000</div></div>
									<div class="assembly-row-combined"><div>0548-0549</div><div><a href="#054BH" class="memory-link">JR Z,054BH<span class="origrom2" style="display: inline;">JR Z,DSPOT2</span></a><span class="opcode2" style="display: none;">28 01</span></div><div>Jump to 054BH if it's 64 characters per line</div></div>
									<div class="assembly-row-combined"><div>054A</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the current cursor position in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>054B<span class="origrom2" style="display: inline;">DSPOT2</span></div><div>LD A,H<span class="opcode2" style="display: none;">7C</span></div><div>Load Register A with the MSB of the current cursor position in Register H</div></div>
									<div class="assembly-row-combined"><div>054C-054D</div><div>CP 40H<span class="opcode2" style="display: none;">FE 40</span></div><div>Check to see if the end of video memory plus one has been reached</div></div>
									<div class="assembly-row-combined"><div>054E</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>Return if the end of video memory plus one hasn't been reached</div></div>
									<div class="assembly-row-combined"><div>054F-0551</div><div>LD DE,FFC0H<span class="opcode2" style="display: none;">11 C0 FF</span></div><div>Load Register Pair DE with a negative length of a line on the video display (i.e., -64)</div></div>
									<div class="assembly-row-combined"><div>0552</div><div>ADD HL,DE<span class="opcode2" style="display: none;">19</span></div><div>Move
 the pointer back 1 line by adding the negative length of a line on the 
video display in Register Pair DE to the current cursor position in 
Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0553</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the current cursor position in Register Pair HL on the STACK</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0554H">0554H - Part of the Display routine<span class="origrom">- "DSPROL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Scroll the screen upward by one line</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0554-0556<span class="origrom2" style="display: inline;">DSPROL</span></div><div>LD DE,3C00H<span class="origrom2" style="display: inline;">LD DE,DSPAD$</span><span class="opcode2" style="display: none;">11 00 3C</span></div><div>Load Register Pair DE with the starting address of video memory</div></div>
									<div class="assembly-row-combined"><div>0557-0559</div><div>LD HL,3C40H<span class="origrom2" style="display: inline;">LD HL,DSPAD$+64</span><span class="opcode2" style="display: none;">21 40 3C</span></div><div>Load Register Pair HL with the starting address of the second line of the video memory</div></div>
									<div class="assembly-row-combined"><div>055A</div><div>PUSH BC<span class="opcode2" style="display: none;">C5</span></div><div>Save the value in Register Pair BC on the STACK</div></div>
									<div class="assembly-row-combined"><div>055B-055D</div><div>LD BC,03C0H<span class="origrom2" style="display: inline;">LD BC,1024 - 64</span><span class="opcode2" style="display: none;">01 C0 03</span></div><div>Load Register Pair BC with the length of video memory to be moved (which is 15 lines or 960 bytes)</div></div>
									<div class="assembly-row-combined"><div>055E-055F</div><div>LDIR<span class="opcode2" style="display: none;">ED B0</span></div><div>Move the last fifteen lines of video memory to the first fifteen lines of video memory to scroll 1 line</div></div>
									<div class="assembly-row-combined"><div>0560</div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>Get the value from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>0561</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Load Register Pair HL with the starting address of the sixteenth line of video memory</div></div>
									<div class="assembly-row-combined"><div>0562-0563</div><div><a href="#057DH" class="memory-link">JR 057DH<span class="origrom2" style="display: inline;">JR DSPERF</span></a><span class="opcode2" style="display: none;">18 19</span></div><div>Jump forward to 057DH to erase the last line</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0564H">0564H - Part of the Display routine<span class="origrom">- "DSPCR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Display a carriage return / line feed</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0564<span class="origrom2" style="display: inline;">DSPCR</span></div><div>LD A,L<span class="opcode2" style="display: none;">7D</span></div><div>Load Register A with the LSB of the current cursor position in Register L</div></div>
									<div class="assembly-row-combined"><div>0565-0566</div><div>AND C0H<span class="opcode2" style="display: none;">E6 C0</span></div><div>Turn off some bits in Register A so that it's the start of the current line by ANDing it with 1100 0000</div></div>
									<div class="assembly-row-combined"><div>0567</div><div>LD L,A<span class="opcode2" style="display: none;">6F</span></div><div>Load Register L with the updated value in Register A</div></div>
									<div class="assembly-row-combined"><div>0568</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the current cursor position in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0569-056B</div><div>LD DE,0040H<span class="opcode2" style="display: none;">11 40 00</span></div><div>Load Register Pair DE with the length of a line on the video display (which is 40H or 64 Decimal)</div></div>
									<div class="assembly-row-combined"><div>056C</div><div>ADD HL,DE<span class="opcode2" style="display: none;">19</span></div><div>Add the length of a line on the video display in Register Pair DE to the current cursor position in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>056D</div><div>LD A,H<span class="opcode2" style="display: none;">7C</span></div><div>Load Register A with the MSB of the current cursor position in Register H</div></div>
									<div class="assembly-row-combined"><div>056E-056F</div><div>CP 40H<span class="opcode2" style="display: none;">FE 40</span></div><div>Check to see if the end of video memory plus one has been reached (which is 40H or 64 Decimal)</div></div>
									<div class="assembly-row-combined"><div>0570-0571</div><div><a href="#0554H" class="memory-link">JR Z,0554H<span class="origrom2" style="display: inline;">JR Z,DSPROL</span></a><span class="opcode2" style="display: none;">28 E2</span></div><div>Jump to 0554H (to scroll the screen) if the end of video memory plus one has been reached</div></div>
									<div class="assembly-row-combined"><div>0572</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Throw away the entry at the top of the STACK</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0573H">0573H - Part of the Display routine<span class="origrom">- "DSPEOL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Erase to the end of the line</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0573<span class="origrom"><br>DSPEOL</span></div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the new cursor position in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0574</div><div>LD D,H<span class="opcode2" style="display: none;">54</span></div><div>Load Register D with the MSB of the current cursor position in Register H</div></div>
									<div class="assembly-row-combined"><div>0575</div><div>LD A,L<span class="opcode2" style="display: none;">7D</span></div><div>Load Register A with the LSB of the current cursor position in Register L</div></div>
									<div class="assembly-row-combined"><div>0576-0577</div><div>OR 3FH<span class="origrom2" style="display: inline;">OR 0011 1111</span><span class="opcode2" style="display: none;">F6 3F</span></div><div>Turn on some bits in Register A to isolate the screen line by masking the value in Register A by ORing it against 0011 1111</div></div>
									<div class="assembly-row-combined"><div>0578</div><div>LD E,A<span class="opcode2" style="display: none;">5F</span></div><div>Save the updated value in Register A in Register E</div></div>
									<div class="assembly-row-combined"><div>0579</div><div>INC DE<span class="opcode2" style="display: none;">13</span></div><div>Increment the adjusted cursor position in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>057A-057B</div><div><a href="#0580H" class="memory-link">JR 0580H<span class="origrom2" style="display: inline;">JR DSPERA</span></a><span class="opcode2" style="display: none;">18 04</span></div><div>Jump forward to the line blanking code of 0580H</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="057CH">057CH - Part of the Display routine<span class="origrom">- "DSPEOF"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Erase to the end of the frame<br><br>To use a ROM call to 
clear the video screen from (including) position N - where N is an 
integer between 0 and 1023 (decimal), inclusive, to the end of the 
display, Load the HL Register with the value 3C00H + N and then CALL 
057CH</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>057C<span class="origrom2" style="display: inline;">DSPEOF</span></div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the cursor position in Register Pair HL on the STACK.<br><br>Clear
 to end of frame routine. To use this routine load the HL Register Pair 
with the screen address from which you want the erasing to start. The DE
 and A registers are used</div></div>
									<div class="assembly-row-combined"><div>057D-057F<span class="origrom2" style="display: inline;">DSPERF</span></div><div>LD DE,4000H<span class="origrom2" style="display: inline;">LD DE,DSPAD$+1024</span><span class="opcode2" style="display: none;">11 00 40</span></div><div>Load Register Pair DE with the end of video memory plus one (which is 4000H)</div></div>
									<div class="assembly-row-combined"><div>0580-0581<span class="origrom2" style="display: inline;">DSPERA</span></div><div>LD (HL),20H<span class="origrom2" style="display: inline;">LD (HL)," "</span><span class="opcode2" style="display: none;">36 20</span></div><div>Display a space (which is 20H) at the video memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0582</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the video memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0583</div><div>LD A,H<span class="opcode2" style="display: none;">7C</span></div><div>Load Register A with the MSB of the video memory pointer held in Register H</div></div>
									<div class="assembly-row-combined"><div>0584</div><div>CP D<span class="opcode2" style="display: none;">BA</span></div><div>Check
 to see if the MSB of the video memory pointer in Register A is the same
 as the MSB of the ending memory pointer in Register D</div></div>
									<div class="assembly-row-combined"><div>0585-0586</div><div><a href="#0580H" class="memory-link">JR NZ,0580H<span class="origrom2" style="display: inline;">JR NZ,DSPERA</span></a><span class="opcode2" style="display: none;">20 F9</span></div><div>LOOP
 back to 0580H (display a space and move forward 1) if the MSB of the 
video memory pointer in Register A isn't the same as the MSB of the 
ending memory pointer in Register D</div></div>
									<div class="assembly-row-combined"><div>0587</div><div>LD A,L<span class="opcode2" style="display: none;">7D</span></div><div>Load Register A with the LSB of the video memory pointer in Register L</div></div>
									<div class="assembly-row-combined"><div>0588</div><div>CP E<span class="opcode2" style="display: none;">BB</span></div><div>Check
 to see if the LSB of the video memory pointer in Register A is the same
 as the LSB of the ending memory pointer in Register E</div></div>
									<div class="assembly-row-combined"><div>0589-058A</div><div><a href="#0580H" class="memory-link">JR NZ,0580H<span class="origrom2" style="display: inline;">JR NZ,DSPERA</span></a><span class="opcode2" style="display: none;">20 F5</span></div><div>LOOP
 back to 0580H (display a space and move forward 1) if the LSB of the 
video memory pointer in Register A isn't the same as the LSB of the 
ending memory pointer in Register E</div></div>
									<div class="assembly-row-combined"><div>058B</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the current cursor position from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>058C</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="058DH">058DH-0D8H - PRINTER DRIVER<span class="origrom">- "PRT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM notes, this is the Printer 
Driver.  On entry, Register C to hold the character to be sent to the 
printer, and [IX] should point to the DCB, which is laid out as follows:
									</p><ul>
										<li>DCB + 0 = DCB Type</li>
										<li>DCB + 1 = Driver Address (LSB)</li>
										<li>DCB + 2 = Driver Addres (MSB)</li>
										<li>DCB + 3 = Lines Per Page (or 0 if top-of-page)</li>
										<li>DCB + 4 = Line Counter </li>
										<li>DCB + 5 = 0</li>
										<li>DCB + 6 = "P"</li>
										<li>DCB + 7 = "R"</li>
									</ul>
								<p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>058D<span class="origrom2" style="display: inline;">PRT</span></div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with the character to be sent to the printer in Register C</div></div>
									<div class="assembly-row-combined"><div>058E</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Set the status flags and test A to see if it is zero</div></div>
									<div class="assembly-row-combined"><div>058F-0590</div><div><a href="#05D1H" class="memory-link">JR Z,05D1H<span class="origrom2" style="display: inline;">JR Z,PRTSTA</span></a><span class="opcode2" style="display: none;">28 40</span></div><div>Jump to 05D1H (get the printer status and return) if the character to be sent to the printer in Register A is equal to zero</div></div>
									<div class="assembly-row-combined"><div>0591-0592</div><div>CP 0BH<span class="opcode2" style="display: none;">FE 0B</span></div><div>Check
 to see if the character to be sent to the printer in Register A is a 
skip to the top of the form character which is CHR$(11)</div></div>
									<div class="assembly-row-combined"><div>0593-0594</div><div><a href="#059FH" class="memory-link">JR Z,059FH<span class="origrom2" style="display: inline;">JR Z,PRTVT</span></a><span class="opcode2" style="display: none;">28 0A</span></div><div>Jump
 to 059FH if the character to be sent to the printer in Register A is a 
skip to the top of the form character (a/k/a a vertical tab)</div></div>
									<div class="assembly-row-combined"><div>0595-0596</div><div>CP 0CH<span class="opcode2" style="display: none;">FE 0C</span></div><div>Check
 to see if the character to be sent to the printer in Register A is a 
conditional skip to the top of the form character which is CHR$(12)</div></div>
									<div class="assembly-row-combined"><div>0597-0598</div><div><a href="#05B4H" class="memory-link">JR NZ,05B4H<span class="origrom2" style="display: inline;">JR NZ,PRTIT</span></a><span class="opcode2" style="display: none;">20 1B</span></div><div>Jump
 to 05B4H if the character to be sent to the printer in Register A isn't
 a conditional skip to the top of the form character (a/k/a isn't a form
 feed)</div></div>
									<div class="assembly-row-combined"><div>0599</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A (which causes the null character to be printed)</div></div>
									<div class="assembly-row-combined"><div>059A-059C</div><div>OR (IX+03H)<span class="opcode2" style="display: none;">DD B6 03</span></div><div>Check
 to see if the number of lines per page at the location of the printer 
device control block pointer in Register Pair IX plus three is the same 
as the value in Register A</div></div>
									<div class="assembly-row-combined"><div>059D-059E</div><div><a href="#05B4H" class="memory-link">JR Z,05B4H<span class="origrom2" style="display: inline;">JR Z,PRTIT</span></a><span class="opcode2" style="display: none;">28 15</span></div><div>Jump to 05B4H if zero lines are to be skipped</div></div>
									<div class="assembly-row-combined"><div>059F-05A1</div><div>LD A,(IX+03H)<span class="opcode2" style="display: none;">DD 7E 03</span></div><div>Load
 Register A with the number of lines per page at the location of the 
printer device control block in Register Pair IX plus three</div></div>
									<div class="assembly-row-combined"><div>05A2-05A4<span class="origrom2" style="display: inline;">PRTVT</span></div><div>SUB (IX+04H)<span class="opcode2" style="display: none;">DD 96 04</span></div><div>Subtract
 the lines printed so far at the location of the printer device control 
block pointer in Register Pair IX plus four from the number of lines per
 page in Register A</div></div>
									<div class="assembly-row-combined"><div>05A5</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>A now has the number of lines to skip, so load B with with the number of lines to skip (since DJNZ loops based on B)</div></div>
									<div class="assembly-row-combined"><div>05A6-05A8<span class="origrom2" style="display: inline;">PRTFF</span></div><div><a href="#05D1H" class="memory-link">CALL 05D1H<span class="origrom2" style="display: inline;">CALL PRTSTA</span></a><span class="opcode2" style="display: none;">CD D1 05</span></div><div>Call
 the GET PRINTER STATUS routine at 05D1H (which returns the status of 
the line printer in the status Register As 0 if the printer is ready, 
and otherwise with a reason code if not ready)</div></div>
									<div class="assembly-row-combined"><div>05A9-05AA</div><div><a href="#05A6H" class="memory-link">JR NZ,PRTFF<span class="origrom2" style="display: inline;">JR NZ,05A6H</span></a><span class="opcode2" style="display: none;">20 FB</span></div><div>Loop back to 05A6H until the printer is ready</div></div>
									<div class="assembly-row-combined"><div>05AB-05AC</div><div>LD A,0AH<span class="opcode2" style="display: none;">3E 0A</span></div><div>Now the printer is ready and B has the number of lines to skip.  Load Register A with a line feed character which is CHR$(10)</div></div><br>
									<div class="assembly-row-combined"><div>05AD-05AF</div><div>LD (37E8H),A<span class="origrom2" style="display: inline;">LD (PRTAD$),A</span><span class="opcode2" style="display: none;">32 E8 37</span></div><div>Send the value in Register A to the printer by loading it into memory location 37E8H</div></div>
									<div class="assembly-row-combined"><div>05B0-05B1</div><div><a href="#05A6H" class="memory-link">DJNZ 05A6H<span class="origrom2" style="display: inline;">DJNZ PRTFF</span></a><span class="opcode2" style="display: none;">10 F4</span></div><div>Loop back to 05A6H until all of the lines have been skipped</div></div>
									<div class="assembly-row-combined"><div>05B2-05B3</div><div><a href="#05CCH" class="memory-link">JR PRTOP<span class="origrom2" style="display: inline;">JR 05CCH</span></a><span class="opcode2" style="display: none;">18 18</span></div><div>Now all the lines have been skipped, so jump to 05CCH to reset the line counter and return</div></div>
									<div class="assembly-row-combined"><div>05B4<span class="origrom2" style="display: inline;">PRTIT</span></div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the character to be sent to the printer in Register A on the STACK</div></div>
									<div class="assembly-row-combined"><div>05B5-05B7<span class="origrom2" style="display: inline;">PRTIT2</span></div><div><a href="#05D1H" class="memory-link">CALL 05D1H<span class="origrom2" style="display: inline;">CALL PRTSTA</span></a><span class="opcode2" style="display: none;">CD D1 05</span></div><div>Call
 the GET PRINTER STATUS (which returns the status of the line printer in
 the status Register As 0 if the printer is ready, and otherwise with a 
reason code if not ready)</div></div>
									<div class="assembly-row-combined"><div>05B8-05B9</div><div><a href="#05B5H" class="memory-link">JR NZ,05B5H<span class="origrom2" style="display: inline;">JR NZ,PRTIT2</span></a><span class="opcode2" style="display: none;">20 FB</span></div><div>Loop back to 05B5H until the printer is ready</div></div>
									<div class="assembly-row-combined"><div>05BA</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the character to be sent to the printer from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>05BB-05BD</div><div>LD (37E8H),A<span class="origrom2" style="display: inline;">LD (PRTAD$),A</span><span class="opcode2" style="display: none;">32 E8 37</span></div><div>Send the character in Register A to the printer by putting the character into 37E8H</div></div>
									<div class="assembly-row-combined"><div>05BE-05BF</div><div>CP 0DH<span class="opcode2" style="display: none;">FE 0D</span></div><div>Check to see if the character which was just sent to the printer was a carriage return</div></div>
									<div class="assembly-row-combined"><div>05C0</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>If the character sent to the printer in Register A isn't a carriage return, return out of the print routine</div></div>
									<div class="assembly-row-combined"><div>05C1-05C3</div><div>INC (IX+04H)<span class="opcode2" style="display: none;">DD 34 04</span></div><div>Now
 we know the printer just got a carriage return, so increment the number
 of lines printed so far at the location of the printer device control 
block pointer in Register Pair IX plus four</div></div>
									<div class="assembly-row-combined"><div>05C4-05C6</div><div>LD A,(IX+04H)<span class="opcode2" style="display: none;">DD 7E 04</span></div><div>Load
 Register A with the number of lines printed so far at the location of 
the printer device control block pointer in Register Pair IX plus four</div></div>
									<div class="assembly-row-combined"><div>05C7-05C9</div><div>CP (IX+03H)<span class="opcode2" style="display: none;">DD BE 03</span></div><div>Check
 to see if the number of lines printed so far in Register A is the same 
as the number of lines per page at the location of the printer device 
control block pointer in Register Pair IX plus three</div></div>
									<div class="assembly-row-combined"><div>05CA</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with the character sent to the printer in Register C</div></div>
									<div class="assembly-row-combined"><div>05CB</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>Return if the number of lines printed so far isn't the same as the number of lines per page</div></div>
									<div class="assembly-row-combined"><div>05CC-05CF<span class="origrom2" style="display: inline;">PRTOP</span></div><div>LD (IX+04H),04H<span class="opcode2" style="display: none;">DD 36 04 00</span></div><div>Zero
 the number of lines printed so far at the location of the printer 
device control block pointer in Register Pair IX plus four</div></div>
									<div class="assembly-row-combined"><div>05D0</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="05D1H">05D1H - Part of the Printer Routine<span class="origrom">- "PRTSTA"</span><br>Get printer status routine<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>
									A call to 05D1 will return the status of the line printer in 
the status Register As 0 if the printer is ready/selected, and non-zero 
if not ready, as follows:
									</p><ul>
										<li>Bit 7 = Printer Busy.  1=Busy</li>
										<li>Bit 6 = Paper Status.  1= Out of paper.</li>
										<li>Bit 5 = Printer Ready.  1 = Ready.</li>
										<li>All other bits are not used.</li>
									</ul>
								<p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>05D1-05D3</div><div>LD A,(37E8H)<span class="origrom2" style="display: inline;">LD A,(PRTAD$)</span><span class="opcode2" style="display: none;">3A E8 37</span></div><div>Get the status value from the printer (which is held in 37E8H) and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>05D4-05D5</div><div>AND F0H<span class="origrom2" style="display: inline;">AND 1111 0000</span><span class="opcode2" style="display: none;">E6 F0</span></div><div>Since only bits 7, 6, and 5 are used when checking status, mask out the rest of Register A by ANDing it against 1111 0000</div></div>
									<div class="assembly-row-combined"><div>05D6-05D7</div><div>CP 30H<span class="opcode2" style="display: none;">FE 30</span></div><div>Check
 to see if the printer is ready by comparing the ANDed value against 
0011 0000 (which isolates bits 5 and 4, so the result is either ZERO if 
they are set or anything else if they are not)</div></div>
									<div class="assembly-row-combined"><div>05D8</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="05D9H">05D9H-0673H - Part of the Keyboard Routine<span class="origrom">- "KEYIN"</span><br>Keyboard Line Handler Routine<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the most basic of the string input routines and is 
used by the two others (1BB3H and 0361H) as a subroutine. To use it, 
load HL with the required buffer address and the B Register with the 
maximum buffer length required. Keyboard input over the specified 
maximum buffer length is ignored, and after pressing the (ENTER) key it 
will return with HL containing the original buffer address and B with 
the string length.<br><br>A call to this memory location Accepts 
keyboard input and stores each character in a buffer supplied by caller.
 Input continues until either a carriage return or a BREAK is typed, or 
until the buffer is full. All edit control codes are recognized, e.g. 
TAB, BACKSPACE, etc.<br><br>On exit the registers contain: HL=Buffer 
address, B=Number of characters transmitted excluding last, C=Orginal 
buffer size, A=Last character received if a carriage return or BREAK is 
typed.  Carry Set if break key was terminator, reset otherwise.  If the 
buffer is full, the A Register will contain the buffer size.<br><br>Accepts
 keyboard input and stores each character in a buffer supplied by 
caller. Input continues until either a carriage return or a BREAK is 
typed, or until the buffer is full. All edit control codes are 
recognized, e.g. TAB, BACKSPACE, etc<br><br>To use a ROM call to accept a restricted number of keyboard characters for input (n), use:<br>
								</p><div class="code-block"><span class="code">LD HL,(40A7H)<br>LD B,n<br>CALL 05D9H</span></div>
								<br>Up to n characters will be accepted, after which the 
keyboard will simply be ignored until the ENTER (or LEFT ARROW, or 
BREAK, or CLEAR) key is pressed. These characters will be stored in 
consecutive memory cells starting at the address contained in 
40A7H-40A8H (the keyboard buffer area), with a 0DH (carriage return) 
byte at the end. Upon completion, the HL Register Pair will contain the 
address of the first character of the stored input, and the B Register 
will contain the number of characters entered. NOTE: No "?" is displayed
 as a result of the execution of the above program. If the "?" display 
is desired to prompt the typing of the input, precede the above program 
segment with:
								<div class="code-block"><span class="code">LD A,3FH<br>CALL 033AH<br>LD A,20H<br>CALL 033AH</span></div>
								<br>According to the original ROM comments, on entry, HL to 
point to the input line address in RAM and Register B to hold the 
maximum number of input characters to fetch.  On exit, Register A should
 hold the number of characters entered <p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>05D9<span class="origrom2" style="display: inline;">KEYIN</span></div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the start of the input buffer area pointer in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>05DA-05DB</div><div>LD A,0EH<span class="opcode2" style="display: none;">3E 0E</span></div><div>Load Register A with a turn on the cursor character (which is 14)</div></div>
									<div class="assembly-row-combined"><div>05DC-05DE</div><div><a href="#0033H" class="memory-link">CALL 0033H<span class="origrom2" style="display: inline;">CALL $DSP</span></a><span class="opcode2" style="display: none;">CD 33 00</span></div><div>Display
 a cursor by calling the DISPLAY A CHARACTER routine at 0033H (which 
puts the character in Register A on the video screen)</div></div>
									<div class="assembly-row-combined"><div>05DF</div><div>LD C,B<span class="opcode2" style="display: none;">48</span></div><div>Load Register C with the size of the input buffer in Register B</div></div>
									<div class="assembly-row-combined"><div>05E0-05E2<span class="origrom2" style="display: inline;">KLNNXT</span></div><div><a href="#0049H" class="memory-link">CALL 0049H<span class="origrom2" style="display: inline;">CALL $KEY</span></a><span class="opcode2" style="display: none;">CD 49 00</span></div><div>Call the "WAIT FOR KEYBOARD INPUT" routine at 0049H, so as to wait until a key is pressed.</div></div>
									<div class="assembly-row-combined"><div>05E3-05E4</div><div>CP 20H<span class="origrom2" style="display: inline;">CP " "</span><span class="opcode2" style="display: none;">FE 20</span></div><div>Check to see if the key that was pressed in Register A is greater than a <kbd>SPACE</kbd> </div></div>
									<div class="assembly-row-combined"><div>05E5-05E6</div><div><a href="#060CH" class="memory-link">JR NC,060CH<span class="origrom2" style="display: inline;">JR NC,KLNCHR</span></a><span class="opcode2" style="display: none;">30 25</span></div><div>Jump if the key that was pressed in Register A is displayable (i.e., greater than or equal to a <kbd>SPACE</kbd> )</div></div>
									<div class="assembly-row-combined"><div>05E7-05E8</div><div>CP 0DH<span class="opcode2" style="display: none;">FE 0D</span></div><div>Check to see if the key that was pressed in Register A is a <span class="code">CARRIAGE RETURN</span></div></div>
									<div class="assembly-row-combined"><div>05E9-05EB</div><div><a href="#0662H" class="memory-link">JP Z,0662H<span class="origrom2" style="display: inline;">JP Z,KLNCR</span></a><span class="opcode2" style="display: none;">CA 62 06</span></div><div>Jump if the key that was pressed in Register A is a <span class="code">CARRIAGE RETURN</span></div></div>
									<div class="assembly-row-combined"><div>05EC-05ED</div><div>CP 1FH<span class="opcode2" style="display: none;">FE 1F</span></div><div>Check to see if the key that was pressed in Register A is the <span class="code">CLEAR</span>key</div></div>
									<div class="assembly-row-combined"><div>05EE-05EF</div><div><a href="#0619H" class="memory-link">JR Z,0619H<span class="origrom2" style="display: inline;">JR Z,KLNCLR</span></a><span class="opcode2" style="display: none;">28 29</span></div><div>Jump if the key that was pressed in Register A is the <span class="code">CLEAR</span>key</div></div>
									<div class="assembly-row-combined"><div>05F0-05F1</div><div>CP 01H<span class="opcode2" style="display: none;">FE 01</span></div><div>Check to see if the key that was pressed in Register A is the <kbd>BREAK</kbd> key</div></div>
									<div class="assembly-row-combined"><div>05F2-05F3</div><div><a href="#0661H" class="memory-link">JR Z,0661H<span class="origrom2" style="display: inline;">JR Z,KLNBRK</span></a><span class="opcode2" style="display: none;">28 6D</span></div><div>Jump if the key that was pressed in Register A is the <kbd>BREAK</kbd> key</div></div>
									<div class="assembly-row-combined"><div>05F4-05F6</div><div>LD DE,05E0H<span class="origrom2" style="display: inline;">LD DE,KLNNXT</span><span class="opcode2" style="display: none;">11 E0 05</span></div><div>Load Register Pair DE with the return address of 05E0H</div></div>
									<div class="assembly-row-combined"><div>05F7</div><div>PUSH DE<span class="opcode2" style="display: none;">D5</span></div><div>Save the return address in Register Pair DE on the STACK</div></div>
									<div class="assembly-row-combined"><div>05F8-05F9</div><div>CP 08H<span class="opcode2" style="display: none;">FE 08</span></div><div>Check to see if the key that was pressed in Register A is a backspace (which is 08) the cursor and erase character</div></div>
									<div class="assembly-row-combined"><div>05FA-05FB</div><div><a href="#0630H" class="memory-link">JR Z,0630H<span class="origrom2" style="display: inline;">JR Z,KLNBSP</span></a><span class="opcode2" style="display: none;">28 34</span></div><div>Jump if the key was pressed in Register A is a backspace the cursor and erase character</div></div>
									<div class="assembly-row-combined"><div>05FC-05FD</div><div>CP 18H<span class="opcode2" style="display: none;">FE 18</span></div><div>Check to see if the key that was pressed in Register A is a backspace character</div></div>
									<div class="assembly-row-combined"><div>05FE-05FF</div><div><a href="#062BH" class="memory-link">JR Z,062BH<span class="origrom2" style="display: inline;">JR Z,KLNCAN</span></a><span class="opcode2" style="display: none;">28 2B</span></div><div>Jump if the key that was pressed in Register A is a backspace character</div></div>
									<div class="assembly-row-combined" id="0600H"><div>0600-0601</div><div>CP 09H<span class="opcode2" style="display: none;">FE 09</span></div><div>Check to see if the key that was pressed in Register A is a tab character</div></div>
									<div class="assembly-row-combined"><div>0602-0603</div><div><a href="#0646H" class="memory-link">JR Z,0646H<span class="origrom2" style="display: inline;">JR Z,KLNHT</span></a><span class="opcode2" style="display: none;">28 42</span></div><div>Jump if the key that was pressed in Register A is a tab character</div></div>
									<div class="assembly-row-combined"><div>0604-0605</div><div>CP 19H<span class="opcode2" style="display: none;">FE 19</span></div><div>Check to see if the key that was pressed in Register A is a turn on the 32 character per line mode character</div></div>
									<div class="assembly-row-combined"><div>0606-0607</div><div><a href="#0641H" class="memory-link">JR Z,0641H<span class="origrom2" style="display: inline;">JR Z,KLNETB</span></a><span class="opcode2" style="display: none;">28 39</span></div><div>Jump if the key that was pressed in Register A is a turn on the 32 character per line mode character</div></div>
									<div class="assembly-row-combined"><div>0608-0609</div><div>CP 0AH<span class="opcode2" style="display: none;">FE 0A</span></div><div>Check to see if the key that was pressed in Register A is a line feed character of CHR$(10)</div></div>
									<div class="assembly-row-combined"><div>060A</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>Return (to 05E0H) if the key that was pressed in Register A isn't a line feed character</div></div>
									<div class="assembly-row-combined"><div>060B</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Get the return address from the STACK and put it in Register Pair DE (so that it isn't 05E0H anymore)</div></div>
									<div class="assembly-row-combined"><div>060C<span class="origrom2" style="display: inline;">KLNCHR</span></div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>We
 now know that the key pressed is a printable character so save the key 
that was pressed in Register A at the location of the input buffer 
pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>060D</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Load Register A with the length of the buffer remaining in Register B</div></div>
									<div class="assembly-row-combined"><div>060E</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if there is any more of the input buffer remaining (and set status).</div></div>
									<div class="assembly-row-combined"><div>060F-0610</div><div><a href="#05E0H" class="memory-link">JR Z,05E0H<span class="origrom2" style="display: inline;">JR Z,KLNNXT</span></a><span class="opcode2" style="display: none;">28 CF</span></div><div>Jump to 05E0H if the end of the input buffer has been reached</div></div>
									<div class="assembly-row-combined"><div>0611</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Now
 we know the end of the input buffer has not been reached, so load 
Register A with the value at the location of the input buffer pointer in
 Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0612</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0613-0615</div><div><a href="#0033H" class="memory-link">CALL 0033H<span class="origrom2" style="display: inline;">CALL $DSP</span></a><span class="opcode2" style="display: none;">CD 33 00</span></div><div>Display
 the character by calling the DISPLAY A CHARACTER routine at 0033H 
(which puts the character in Register A on the video screen)</div></div>
									<div class="assembly-row-combined"><div>0616</div><div>DEC B<span class="opcode2" style="display: none;">05</span></div><div>Decrement the number of bytes remaining in the input buffer area in Register B</div></div>
									<div class="assembly-row-combined"><div>0617-0618</div><div><a href="#05E0H" class="memory-link">JR 05E0H<span class="origrom2" style="display: inline;">JR KLNNXT</span></a><span class="opcode2" style="display: none;">18 C7</span></div><div>Jump to 05E0H to get the next character</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0619H">0619H - Part of the Display routine<span class="origrom">- "KLNCLR"</span><br>Clear the screen<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0619H-061B<span class="origrom2" style="display: inline;">KLNCLR</span></div><div><a href="#01C9H" class="memory-link">CALL 01C9H<span class="origrom2" style="display: inline;">CALL CLS</span></a><span class="opcode2" style="display: none;">CD C9 01</span></div><div>Call the CLEAR SCREEN routine at 01C9H (which clears the screen, changes to 64 characters, and homes the screen).</div></div>
									<div class="assembly-row-combined"><div>061C</div><div>LD B,C<span class="opcode2" style="display: none;">41</span></div><div>Load Register B with the length of the input buffer in Register C (which resets the counter of characters transmitted)</div></div>
									<div class="assembly-row-combined"><div>061D</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get
 the starting address for the input buffer area from the STACK and put 
it in Register Pair HL (which resets the buffer address)</div></div>
									<div class="assembly-row-combined"><div>061E</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the starting address for the input buffer area in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>061F-0621</div><div><a href="#05E0H" class="memory-link">JP KLNNXT<span class="origrom2" style="display: inline;">JP 05E0H</span></a><span class="opcode2" style="display: none;">C3 E0 05</span></div><div>Jump to 05E0H (to get the next character, which is now the first character in the buffer)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0622H">0622H - Part of the Display routine<span class="origrom">- "KLNCNL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Cancel the accumulated line</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0622-0624<span class="origrom2" style="display: inline;">KLNCNL</span></div><div><a href="#0630H" class="memory-link">CALL 0630H<span class="origrom2" style="display: inline;">CALL KLNBSP</span></a><span class="opcode2" style="display: none;">CD 30 06</span></div><div>Gosub to wait for the next key and back up the input buffer pointer in Register Pair HL if necessary</div></div>
									<div class="assembly-row-combined"><div>0625</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Backup
 to the previous character (the one before the CARRIAGE RETURN) by 
decrementing the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0626</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load Register A with the character at the location of the input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0627</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the input buffer pointer in Register Pair HL to the net availabile position</div></div>
									<div class="assembly-row-combined"><div>0628-0629</div><div>CP 0AH<span class="opcode2" style="display: none;">FE 0A</span></div><div>Check to see if the character in Register A is the line feed character of CHR$(10)</div></div>
									<div class="assembly-row-combined"><div>062A</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>Return if the character in Register A is a line feed character</div></div>
									<div class="assembly-row-combined"><div>062B<span class="origrom2" style="display: inline;">KLNCAN</span></div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Now
 we know that character wasn't a line feed, so we need to test for a 
buffer full.  This loads Register A with the number of bytes remaining 
in the input buffer area in Register B</div></div>
									<div class="assembly-row-combined"><div>062C</div><div>CP C<span class="opcode2" style="display: none;">B9</span></div><div>Check
 to see if the number of characters remaining in the input buffer area 
in Register A is the same as the length of the input buffer area in 
Register C</div></div>
									<div class="assembly-row-combined"><div>062D-062E</div><div><a href="#0622H" class="memory-link">JR NZ,0622H<span class="origrom2" style="display: inline;">JR NZ,KLNCNL</span></a><span class="opcode2" style="display: none;">20 F3</span></div><div>Jump to 0622H if there is room for more characters</div></div>
									<div class="assembly-row-combined"><div>062F</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>The buffer is full!  Return</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0630H">0630H - Part of the Display routine<span class="origrom">- "KLNBSP"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Backspace one character.  On entry Register B to hold the 
number of characters received, and Register C to hold the size of the 
buffer</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0630<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;KLNBSP</span></div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Load Register A with the number of bytes remaining in the input buffer area in Register B</div></div>
									<div class="assembly-row-combined"><div>0631</div><div>CP C<span class="opcode2" style="display: none;">B9</span></div><div>Compare
 the number of bytes remaining in the input buffer (held in Register A) 
against the size of the buffer (held in Register C) to see if the buffer
 is full.</div></div>
									<div class="assembly-row-combined"><div>0632</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>Return if the input buffer area is full.</div></div>
									<div class="assembly-row-combined"><div>0633</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement the input buffer area pointer in Register Pair HL to backspace the previous character .</div></div>
									<div class="assembly-row-combined"><div>0634</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>... and then get that character into Register A.</div></div>
									<div class="assembly-row-combined"><div>0635-0636</div><div>CP 0AH<span class="opcode2" style="display: none;">FE 0A</span></div><div>Check to see if the character in Register A is the line feed character of CHR$(10)</div></div>
									<div class="assembly-row-combined"><div>0637</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the input buffer area pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0638</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>Return if the character in Register A is a line feed character</div></div>
									<div class="assembly-row-combined"><div>0639</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement the input buffer area pointer in Register Pair HL to backspace the previous character in the buffer .</div></div>
									<div class="assembly-row-combined"><div>063A-063B</div><div>LD A,08H<span class="opcode2" style="display: none;">3E 08</span></div><div>Load Register A with a backspace of CHR$(08) and then .</div></div>
									<div class="assembly-row-combined"><div>063C-063E</div><div><a href="#0033H" class="memory-link">CALL 0033H<span class="origrom2" style="display: inline;">CALL $DSP</span></a><span class="opcode2" style="display: none;">CD 33 00</span></div><div>Effectuate
 the backspace by calling the DISPLAY A CHARACTER routine at 0033H 
(which puts the character in Register A on the video screen)</div></div>
									<div class="assembly-row-combined"><div>063F</div><div>INC B<span class="opcode2" style="display: none;">04</span></div><div>Increment the number of characters remaining in the input buffer area in Register B</div></div>
									<div class="assembly-row-combined"><div>0640</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0641H">0641H - Part of the Display routine<span class="origrom">- "KLNETB"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Turn on 32 Character Mode</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0641-0642<span class="origrom2" style="display: inline;">KLNETB</span></div><div>LD A,17H<span class="origrom2" style="display: inline;">LD A,0001 0111</span><span class="opcode2" style="display: none;">3E 17</span></div><div>Load Register A with mask of 00010111 so as to turn on the 32 character per line mode character</div></div>
									<div class="assembly-row-combined"><div>0643-0645</div><div><a href="#0033H" class="memory-link">JP 0033H<span class="origrom2" style="display: inline;">JP $DSP</span></a><span class="opcode2" style="display: none;">C3 33 00</span></div><div>Call
 the DISPLAY A CHARACTER routine at 0033H (which puts the character in 
Register A on the video screen). Since that is the 32 character per line
 mode, that's what happens</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0646H">0646H - Part of the Display routine<span class="origrom">- "KLNHT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Process a horizontal tab</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0646-0648<span class="origrom2" style="display: inline;">KLNHT</span></div><div><a href="#0348H" class="memory-link">CALL DSPPOS<span class="origrom2" style="display: inline;">CALL 0348H</span></a><span class="opcode2" style="display: none;">CD 48 03</span></div><div>Go get the cursor line position and return with it in Register A</div></div>
									<div class="assembly-row-combined"><div>0649-064A</div><div>AND 07H&lt;<span class="origrom2" style="display: inline;">ADD 0000 0111</span><span class="opcode2" style="display: none;">E6 07</span></div><div>Turn off some bits so we can mask the cursor line position in Register A by ANDing it against 0000 0111</div></div>
									<div class="assembly-row-combined"><div>064B</div><div>CPL<span class="opcode2" style="display: none;">2F</span></div><div>Inverse the value in Register A</div></div>
									<div class="assembly-row-combined"><div>064C</div><div>INC A<span class="opcode2" style="display: none;">3C</span></div><div>Increment the value in Register A so that it is 1 &lt;= A &lt;= 8</div></div>
									<div class="assembly-row-combined"><div>064D-064E</div><div>ADD 08H<span class="opcode2" style="display: none;">C6 08</span></div><div>Clear the upper bits of the counter</div></div>
									<div class="assembly-row-combined"><div>064F</div><div>LD E,A<span class="opcode2" style="display: none;">5F</span></div><div>Load Register E with the number of spaces to be added in Register A</div></div>
									<div class="assembly-row-combined"><div>0650<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;KLNHTL</span></div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Load Register A with the number of bytes remaining in the input buffer area in Register B</div></div>
									<div class="assembly-row-combined"><div>0651</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the buffer is full</div></div>
									<div class="assembly-row-combined"><div>0652</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>Return if the input buffer is full</div></div>
									<div class="assembly-row-combined"><div>0653-0654</div><div>LD A,20H<span class="origrom2" style="display: inline;">LD A," "</span><span class="opcode2" style="display: none;">3E 20</span></div><div>Load Register A with a space character</div></div>
									<div class="assembly-row-combined"><div>0655</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save the space character in Register A at the location of the input buffer area pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0656</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the input buffer area pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0657</div><div>PUSH DE<span class="opcode2" style="display: none;">D5</span></div><div>Save the value in Register Pair DE on the STACK</div></div>
									<div class="assembly-row-combined"><div>0658-065A</div><div><a href="#0033H" class="memory-link">CALL 0033H<span class="origrom2" style="display: inline;">CALL $DSP</span></a><span class="opcode2" style="display: none;">CD 33 00</span></div><div>Display
 the space by calling the DISPLAY A CHARACTER routine at 0033H (which 
puts the character in Register A on the video screen)</div></div>
									<div class="assembly-row-combined"><div>065B</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Get the value from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>065C</div><div>DEC B<span class="opcode2" style="display: none;">05</span></div><div>Since you just displayed one of the spaces, decrement the number of bytes remaining in the input buffer area in Register B .</div></div>
									<div class="assembly-row-combined"><div>065D</div><div>DEC E<span class="opcode2" style="display: none;">1D</span></div><div>... and decrement the number of spaces to be added in Register E</div></div>
									<div class="assembly-row-combined"><div>065E</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>Return if the number of spaces has been added to the input buffer</div></div>
									<div class="assembly-row-combined"><div>065F-0660</div><div><a href="#0650H" class="memory-link">JR KLNHTL<span class="origrom2" style="display: inline;">JR 0650H</span></a><span class="opcode2" style="display: none;">18 EF</span></div><div>Loop back to 0650H until all the spaces have been added to the input buffer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0661H">0661H - Part of the Display routine<span class="origrom">- "KLNBRK"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Process a Carriage Return and Automatic Line Feed</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0661<span class="origrom2" style="display: inline;">KLNBRK</span></div><div>SCF<span class="opcode2" style="display: none;">37</span></div><div>Set
 the Carry flag.  This is done because the routine is going to exit with
 the CARRY flag set as an indication that BREAK was hit</div></div>
									<div class="assembly-row-combined"><div>0662<span class="origrom2" style="display: inline;">KLNCR</span></div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the value in Register Pair AF on the STACK, which saves the CARRY flag</div></div>
									<div class="assembly-row-combined"><div>0663-0664</div><div>LD A,0DH<span class="opcode2" style="display: none;">3E 0D</span></div><div>Load Register A with a carriage return character</div></div>
									<div class="assembly-row-combined"><div>0665</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save the carriage return character in Register A at the location of the input buffer area pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0666-0668</div><div><a href="#0033H" class="memory-link">CALL 0033H<span class="origrom2" style="display: inline;">CALL $DSP</span></a><span class="opcode2" style="display: none;">CD 33 00</span></div><div>Display
 the carriage return by calling the DISPLAY A CHARACTER routine at 0033H
 (which puts the character in Register A on the video screen).  Since 
that is a CARRIAGE RETURN, that's what happens</div></div>
									<div class="assembly-row-combined"><div>0669-066A</div><div>LD A,0FH<span class="opcode2" style="display: none;">3E 0F</span></div><div>Load Register A with a turn off the cursor character</div></div>
									<div class="assembly-row-combined"><div>066B-066D</div><div><a href="#0033H" class="memory-link">CALL 0033H<span class="origrom2" style="display: inline;">CALL $DSP</span></a><span class="opcode2" style="display: none;">CD 33 00</span></div><div>Turn
 off the cursor by calling the DISPLAY A CHARACTER routine at 0033H 
(which puts the character in Register A on the video screen)</div></div>
									<div class="assembly-row-combined"><div>066E</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with the length of the input (=buffer size) in Register C</div></div>
									<div class="assembly-row-combined"><div>066F</div><div>SUB B<span class="opcode2" style="display: none;">90</span></div><div>Subtract
 the number of bytes remaining in the input buffer area in Register B 
from the length of the input buffer area in Register A</div></div>
									<div class="assembly-row-combined"><div>0670</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Load Register B with the number of characters in the input buffer area in Register A</div></div>
									<div class="assembly-row-combined"><div>0671</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get
 the value from the STACK and put it in Register Pair AF.  This also 
sets the CARRY flag if BREAK and unsets it if CARRIAGE RETURN</div></div>
									<div class="assembly-row-combined"><div>0672</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the starting address of the input buffer area from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0673</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0674H">0674H-06D1H - INITIALIZATION ROUTINE<span class="origrom">- "INIT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0674-0675<span class="origrom2" style="display: inline;">INIT</span></div><div>OUT (0FFH),A<span class="opcode2" style="display: none;">D3 FF</span></div><div>Send
 the zero in Register A out the video/cassette port.  Earlier versions 
of the ROM looped back to this instruction instead of the next one, 
which pounded 0FFH!</div></div>
									<div class="assembly-row-combined"><div>0676-0678</div><div>LD HL,06D2H<span class="origrom2" style="display: inline;">LD HL,INITR</span><span class="opcode2" style="display: none;">21 D2 06</span></div><div>Load Register Pair HL with the starting address of the RST's and the video/keyboard/printer DCB's</div></div>
									<div class="assembly-row-combined"><div>0679-067B</div><div>LD DE,4000H<span class="origrom2" style="display: inline;">LD DE,RST1$</span><span class="opcode2" style="display: none;">11 00 40</span></div><div>Load Register Pair DE with the starting address of the communications region</div></div>
									<div class="assembly-row-combined"><div>067C-067E</div><div>LD BC,0036H<span class="origrom2" style="display: inline;">LD BC,INITRL</span><span class="opcode2" style="display: none;">01 36 00</span></div><div>Load Register Pair BC with the length of the ROM area to be moved (which is 54 bytes)</div></div>
									<div class="assembly-row-combined"><div>067F-0680</div><div>LDIR<span class="opcode2" style="display: none;">ED B0</span></div><div>Move the RST's and DCB's (06D2H-0707H) to the RAM vector area of 4000H-4035H</div></div>
									<div class="assembly-row-combined"><div>0681</div><div>DEC A<span class="opcode2" style="display: none;">3D</span></div><div>Decrement the value in Register A</div></div>
									<div class="assembly-row-combined"><div>0682</div><div>DEC A<span class="opcode2" style="display: none;">3D</span></div><div>Decrement the value in Register A</div></div>
									<div class="assembly-row-combined"><div>0683-0684</div><div><a href="#0674H" class="memory-link">JR NZ,0674H<span class="origrom2" style="display: inline;">JR NZ,INIT</span></a><span class="opcode2" style="display: none;">20 EF</span></div><div>Loop back to 0674H until the block move has occurred 128 times, jump to 0674H (which sends a click to the cassette port)</div></div>
									<div class="assembly-row-combined"><div>*0683-0684</div><div><a href="#0674H" class="memory-link">JR NZ,0676H</a></div><div>Loop
 back to 0676H until the block move has occurred 128 times, jump to 
0676H (which runs the routine AFTER the click, so no more click)</div></div>
									<div class="assembly-row-combined"><div>0685-0686</div><div>LD B,27H<span class="origrom2" style="display: inline;">LD B,SIZRM$</span><span class="opcode2" style="display: none;">06 27</span></div><div>Load Register B with the number of bytes of memory to be zeroed (which is 39)</div></div>
									<div class="assembly-row-combined"><div>0687<span class="origrom2" style="display: inline;">CLRAM</span></div><div>LD (DE),A<span class="opcode2" style="display: none;">12</span></div><div>Save the zero in Register A at the location of the memory pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0688</div><div>INC DE<span class="opcode2" style="display: none;">13</span></div><div>Increment the destination pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0689-068A</div><div><a href="#0687H" class="memory-link">DJNZ CLRAM<span class="origrom2" style="display: inline;">DJNZ 0687H</span></a><span class="opcode2" style="display: none;">10 FC</span></div><div>Loop back to 0687H until all of the memory locations between 4036H and 4062H have been zeroed</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="068BH">068BH - INITIALIZATION ROUTINE<span class="origrom">- "CHKMAN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Check for a manual override</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>068B-068D<span class="origrom2" style="display: inline;">CHKMAN</span></div><div>LD A,(3840H)<span class="origrom2" style="display: inline;">LD A,(KEYAD$+40H)</span><span class="opcode2" style="display: none;">3A 40 38</span></div><div>Load Register A with the location of keyboard memory for the BREAK key (which is 14400)</div></div>
									<div class="assembly-row-combined"><div>068E-068F</div><div>AND 04H<span class="origrom2" style="display: inline;">AND 0000 0100</span><span class="opcode2" style="display: none;">E6 04</span></div><div>Turn off some bits so we can check to see if the BREAK key is being pressed</div></div>
									<div class="assembly-row-combined"><div>0690-0692</div><div><a href="#0075H" class="memory-link">JP NZ,0075H<span class="origrom2" style="display: inline;">JP NZ,INIT2</span></a><span class="opcode2" style="display: none;">C2 75 00</span></div><div>Jump to 0075H if the BREAK key was pressed, and flow down if it wasn't</div></div>
									<p class="debug-note">This is the beginning of the routine which boots a diskette</p>
									<div class="assembly-row-combined"><div>0693-0695</div><div>LD SP,407DH<span class="origrom2" style="display: inline;">LD SP,TSTK$</span><span class="opcode2" style="display: none;">31 7D 40</span></div><div>Set the STACK pointer to 407DH</div></div>
									<div class="assembly-row-combined"><div>0696-0698</div><div>LD A,(37ECH)<span class="origrom2" style="display: inline;">LD A,(FDCAD$)</span><span class="opcode2" style="display: none;">3A EC 37</span></div><div>Load Register A with the status of the disk controller (which is stored in 37ECH)
<table class="data-table">
	<thead><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead>
	<tbody> <tr><td>Not<br>Ready</td><td>Protected</td><td>Head<br>Loaded</td><td>Seek<br>Error</td><td>CRC<br>Error</td><td>Track 00</td><td>Index</td><td>Busy</td></tr> </tbody>
</table>
									</div></div>
									<div class="assembly-row-combined"><div>0699</div><div>INC A<span class="opcode2" style="display: none;">3C</span></div><div>Increment the value in Register A so that we can .</div></div>
									<div class="assembly-row-combined"><div>069A-069B</div><div>CP 02H<span class="opcode2" style="display: none;">FE 02</span></div><div>... check to see if the disk controller is present</div></div>
									<div class="assembly-row-combined"><div>069C-069E</div><div><a href="#0075H" class="memory-link">JP C,0075H<span class="origrom2" style="display: inline;">JP C,INIT2</span></a><span class="opcode2" style="display: none;">DA 75 00</span></div><div>Jump to the Level II Initialization Routine at 0075H if the disk controller isn't present</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="069FH">069FH - Bootstrap from Diskette<span class="origrom">- "BOOT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>069F-06A0<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;BOOT</span></div><div>LD A,01H<span class="opcode2" style="display: none;">3E 01</span></div><div>So now we know there is a disk controller, so lets load Register A with the unit select mask for Drive :0</div></div>
									<div class="assembly-row-combined"><div>06A1-06A3</div><div>LD (37E1H),A<span class="origrom2" style="display: inline;">LD (DSEL$),A</span><span class="opcode2" style="display: none;">32 E1 37</span></div><div>Select Drive :0 and turn the motor on by loading 01H into 37E1H</div></div>
									<div class="assembly-row-combined"><div>06A4-06A6</div><div>LD HL,37ECH<span class="origrom2" style="display: inline;">LD HL,FDCAD$</span><span class="opcode2" style="display: none;">21 EC 37</span></div><div>Load Register Pair HL with the address of the disk command/status Register of 37ECH</div></div>
									<div class="assembly-row-combined"><div>06A7-06A9</div><div>LD DE,37EFH<span class="origrom2" style="display: inline;">LD DE,FDCAD$+3</span><span class="opcode2" style="display: none;">11 EF 37</span></div><div>Load Register Pair DE with the address of the disk data Register of 37EFH</div></div>
									<div class="assembly-row-combined"><div>06AA-06AB</div><div>LD (HL),03H<span class="origrom2" style="display: inline;">0000 0011</span><span class="opcode2" style="display: none;">36 03</span></div><div>Load
 the disk command/status Register (37ECH) with command 03H (RESTORE and 
POSITION TO TRACK 0).  More specifically, this sends 0000 0011 to the 
register, which is broken down as follows (left to right):  Restore 
(0000), Do NOT load head (0), Verify Off (0), 20 ms step (11)
<table class="bit-table-breakdown">
<tbody><tr class="header"><td>Bit 7</td><td>Bit 6</td><td>Bit 5</td><td>Bit 4</td><td>Bit 3</td><td>Bit 2</td><td>Bit 1</td><td>Bit 0</td><td class="spacer"></td><td>Function Description</td></tr>
<tr class="header"><td>0</td><td>0</td><td>0</td><td>0</td><td>h</td><td>V</td><td>r1</td><td>r0</td><td class="spacer"></td><td></td></tr>
<tr class="bit-row"><td class="">0</td><td class="">0</td><td class="">0</td><td class="">0</td><td class="">h</td><td class="">V</td><td class="bit-set">r1</td><td class="bit-set">r0</td><td class="spacer"></td><td><span class="active-option">Command=Restore</span><br><span class="active-option">Bit 7-4: Command Code (0000)</span><br>h: 1=Enable Head Load/Settle, <span class="active-option">0=No delay</span><br>V: 1=Verify Track 0 ID, <span class="active-option">0=No verification</span><br>r1, r0: Stepping Motor Rate (00=3ms, 01=6ms, 10=10ms, <span class="active-option">11=20ms</span>)</td></tr>
</tbody></table>
									</div></div>
									<div class="assembly-row-combined"><div>06AC-06AE</div><div>LD BC,0000H<span class="opcode2" style="display: none;">01 00 00</span></div><div>Load Register Pair BC with the delay count</div></div>
									<div class="assembly-row-combined"><div>06AF-06B1</div><div><a href="#0060H" class="memory-link">CALL 0060H<span class="origrom2" style="display: inline;">CALL $PAUSE</span></a><span class="opcode2" style="display: none;">CD 60 00</span></div><div>Call the delay routine at 0060H (which will delay BC times 14.65; about 3 seconds)</div></div>
									<div class="assembly-row-combined"><div>06B2-06B3<span class="origrom2" style="display: inline;">BOOTDL</span></div><div>BIT 0,(HL)<span class="opcode2" style="display: none;">CB 46</span></div><div>Top
 of a loop.  Check to see if the diskette controller is busy by testing 
Bit 0 of 37ECH (Floppy Disk Controller Status).  Bit 0 is the BUSY 
status bit.  Per WD, commands should only be loaded into the command 
Register when the Busy Status but is off
<table class="data-table">
	<thead><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead>
	<tbody> <tr><td>Not<br>Ready</td><td>Protected</td><td>Head<br>Loaded</td><td>Seek<br>Error</td><td>CRC<br>Error</td><td>Track 00</td><td>Index</td><td>Busy</td></tr> </tbody>
</table>
									</div></div>
									<div class="assembly-row-combined"><div>06B4-06B5</div><div><a href="#06B2H" class="memory-link">JR NZ,06B2H<span class="origrom2" style="display: inline;">JR NZ,BOOTDL</span></a><span class="opcode2" style="display: none;">20 FC</span></div><div>Loop back to that test in 06B2H until the disk is no longer busy</div></div>
									<div class="assembly-row-combined"><div>06B6</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A</div></div>
									<p class="debug-note">This routine loads Drive 0, Track 0, Sector 0 into 4200H-4455H, and then jumps to 4200H</p>
									<div class="assembly-row-combined"><div>06B7-06B9</div><div>LD (37EEH),A<span class="origrom2" style="display: inline;">LD (FDCAD$+2),A</span><span class="opcode2" style="display: none;">32 EE 37</span></div><div>Save the value in Register A in the disk sector Register (at 37EEH)</div></div>
									<div class="assembly-row-combined"><div>06BA-06BC</div><div>LD BC,4200H<span class="origrom2" style="display: inline;">LD BC,MEM$</span><span class="opcode2" style="display: none;">01 00 42</span></div><div>Load Register Pair BC with the address in memory to place the sector read (which is 4200H)</div></div>
									<div class="assembly-row-combined"><div>06BD-06BE</div><div>LD A,8CH<span class="opcode2" style="display: none;">3E 8C</span></div><div>Load
 Register A with the command to read the sector.  More specifically, 
send 10001100, which is broken down (from left to right) as Read Sector 
(100xxx00), Single Record (0), IBM Format (1), Enable HLD, HLT, and 10 
msec delay</div></div>
<table class="bit-table-breakdown">
<tbody><tr class="header"><td>Bit 7</td><td>Bit 6</td><td>Bit 5</td><td>Bit 4</td><td>Bit 3</td><td>Bit 2</td><td>Bit 1</td><td>Bit 0</td><td class="spacer"></td><td>Function Description</td></tr>
<tr class="header"><td>100</td><td></td><td></td><td>m</td><td>b</td><td>E</td><td></td><td></td><td class="spacer"></td><td></td></tr>
<tr class="bit-row"><td class="bit-set">1</td><td class="">0</td><td class="">0</td><td class="">m</td><td class="bit-set">b</td><td class="bit-set">E</td><td class="">0</td><td class="">0</td><td class="spacer"></td><td><span class="active-option">Command=Read Sector</span><br><span class="active-option">Bit 7-5: Read Command (100)</span><br>m: 1=Multiple Records, <span class="active-option">0=Single Record</span><br>b: <span class="active-option">1=IBM format</span>, 0=Non-IBM Format<br>E: <span class="active-option">1=Enable HLD, HLT, and 10ms Delay</span>, 0=Assume Head Already Engaged, no Delay<br><span class="active-option">Remainder: Unused (00)</span></td></tr>
</tbody></table>
									<div class="assembly-row-combined"><div>06BF</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Put
 the command in Register A (read the sector) in the disk command 
Register of 37ECH.  This then reads Drive 0 Track 0 Sector 0 into 
4200H-4455H</div></div>
									<div class="assembly-row-combined"><div>06C0-06C1<span class="origrom2" style="display: inline;">BOOTLP</span></div><div>BIT 1,(HL)<span class="opcode2" style="display: none;">CB 4E</span></div><div>Top of a loop to check the disk command/status Register of 37ECH to see if there is data available</div></div>
									<div class="assembly-row-combined"><div>06C2-06C3</div><div><a href="#06C0H" class="memory-link">JR Z,06C0H<span class="origrom2" style="display: inline;">JR Z,BOOTLP</span></a><span class="opcode2" style="display: none;">28 FC</span></div><div>Loop back to the prior instruction  until there is data available</div></div>
									<div class="assembly-row-combined"><div>06C4</div><div>LD A,(DE)<span class="opcode2" style="display: none;">1A</span></div><div>So
 now we know there is data available, so we load Register A with the 
byte read from the disk (i.e., the data in disk data Register of 37EFH)</div></div>
									<div class="assembly-row-combined"><div>06C5</div><div>LD (BC),A<span class="opcode2" style="display: none;">02</span></div><div>Save the value in Register A at the location of the memory pointer in Register Pair BC (4200H-4455H)</div></div>
									<div class="assembly-row-combined"><div>06C6</div><div>INC C<span class="opcode2" style="display: none;">0C</span></div><div>Increment the LSB of the memory pointer in Register C</div></div>
									<div class="assembly-row-combined"><div>06C7-06C8</div><div><a href="#06C0H" class="memory-link">JR NZ,06C0H<span class="origrom2" style="display: inline;">JR NZ,BOOTLP</span></a><span class="opcode2" style="display: none;">20 F7</span></div><div>Loop back to 06C0H until the whole 256 bytes of the sector has been read into 4200H-4455H</div></div>
									<div class="assembly-row-combined"><div>06C9-06CB</div><div><a href="https://www.trs-80.com/sub-disassem-dos-td23-sys-0.htm#4200H" class="memory-link">JP 4200H<span class="origrom2" style="display: inline;">JP MEM$</span></a><span class="opcode2" style="display: none;">C3 00 42</span></div><div>Now that the entire first sector has been read into 4200H-4455H, jump there!</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="06CCH">06CCH-06CEH - Alternative re-entry point into BASIC<span class="origrom">- "RESETR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is an alternative re-entry point into BASIC. A JP 6CCH 
is often better than a jump to 1A19H as the latter sometimes does 
strange things to any resident BASIC program</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>06CC-06CE<span class="origrom2" style="display: inline;">RESETR</span></div><div>LD BC,1A18H<span class="origrom2" style="display: inline;">LD BC,STPRDY</span><span class="opcode2" style="display: none;">01 18 1A</span></div><div>Load Register Pair BC with the starting address of the Level II BASIC READY routine (which is kept at 1A18H)</div></div>
									<div class="assembly-row-combined"><div>06CF-06D1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#19AEH" class="memory-link">JP 19AEH<span class="origrom2" style="display: inline;">JP ERESET</span></a><span class="opcode2" style="display: none;">C3 AE 19</span></div><div>Jump to 19AEH to initialize BASIC's variables and pointers</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="06D2H">06D2H-0707H - ROM STORAGE LOCATION FOR DATA TO BE MOVED TO RAM BY THE INITIALIZATION PROCESS<span class="origrom">- "INITR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>06D2<span class="origrom2" style="display: inline;">INITR</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">JP 1C96H<span class="origrom2" style="display: inline;">JP SYNCHR</span></a><span class="opcode2" style="display: none;">C3 96 1C</span></div><div>This will be 4000H - it is a jump to the RST 08H routine (COMPARE SYMBOL routine).  DOS will overwrite this value</div></div>
									<div class="assembly-row-combined"><div>06D5</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">JP 1D78H<span class="origrom2" style="display: inline;">JP CHRGTR</span></a><span class="opcode2" style="display: none;">C3 78 1D</span></div><div>This will be 4003H - it is a jump to RST 10H (get the next character).  DOS will overwrite this value</div></div>
									<div class="assembly-row-combined"><div>06D8</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">JP 1C90H<span class="origrom2" style="display: inline;">JP DCOMPR</span></a><span class="opcode2" style="display: none;">C3 90 1C</span></div><div>This will be 4006H - it is a jump to RST 18H (compare DE and HL).  DOS will overwrite this value</div></div>
									<div class="assembly-row-combined"><div>06DB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">JP 25D9H<span class="origrom2" style="display: inline;">JP GETYPR</span></a><span class="opcode2" style="display: none;">C3 D9 25</span></div><div>This will be 4009H - it is a jump to RST 20H (tests for data type).  DOS will overwrite this value</div></div>
									<div class="assembly-row-combined"><div>06DE</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>This will be 400CH - is a RETurn from RST 28H (which is a jump to 4BA2H for DOS)</div></div>
									<div class="assembly-row-combined"><div>06DF</div><div>NOP</div></div>
									<div class="assembly-row-combined"><div>06E0<span class="opcode2" style="display: none;">00</span></div><div>NOP</div></div>
									<div class="assembly-row-combined"><div>06E1</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>This will be 400FH - it is a RETurn from RST 30H (which is a jump to 44B4H for DOS)</div></div>
									<div class="assembly-row-combined"><div>06E2</div><div>NOP</div></div>
									<div class="assembly-row-combined"><div>06E3<span class="opcode2" style="display: none;">00</span></div><div>NOP</div><div>This will be 4012H - RST 38H vector DI/RET (JP 4518H for DOS)</div></div>
									<div class="assembly-row-combined"><div>06E4</div><div>EI<span class="opcode2" style="display: none;">FB</span></div><div>This is the interrupt entry point vector</div></div>
									<div class="assembly-row-combined"><div>06E5</div><div>RET</div></div>
									<div class="assembly-row-combined"><div>06E6<span class="opcode2" style="display: none;">00</span></div><div>NOP</div></div>
									<p class="debug-note">This is the keyboard DCB</p>
									<div class="assembly-row-combined"><div>06E7</div><div>01</div><div>Keyboard DCB + 0</div></div>
									<div class="assembly-row-combined"><div>06E8</div><div>03 E3</div><div>Keyboard DCB + 1 - Driver Address</div></div>
									<div class="assembly-row-combined"><div>06EA</div><div>00</div><div>Keyboard DCB + 3</div></div>
									<div class="assembly-row-combined"><div>06EB</div><div>00</div><div>Keyboard DCB + 4</div></div>
									<div class="assembly-row-combined"><div>06EC</div><div>00</div><div>Keyboard DCB + 5</div></div>
									<div class="assembly-row-combined"><div>06ED</div><div>"K"</div><div>Keyboard DCB + 6</div></div>
									<div class="assembly-row-combined"><div>06EE</div><div>"I"</div><div>Keyboard DCB + 7</div></div>
									<p class="debug-note">This is the display DCB</p>
									<div class="assembly-row-combined"><div>06EF</div><div>07</div><div>Display DCB + 0</div></div>
									<div class="assembly-row-combined"><div>06F0-06F1</div><div>58 04</div><div>Display DCB + 1,2 - Driver Address</div></div>
									<div class="assembly-row-combined"><div>06F2-06F3</div><div>00 3C</div><div>Display DCB + 3,4 - Cursor Position Address</div></div>
									<div class="assembly-row-combined"><div>06F4</div><div>0</div><div>Display DCB + 5 - Cursor Character</div></div>
									<div class="assembly-row-combined"><div>06F5</div><div>"D"</div><div>Display DCB + 6</div></div>
									<div class="assembly-row-combined"><div>06F6</div><div>"O"</div><div>Display DCB + 7</div></div>
									<p class="debug-note">This is the printer DCB</p>
									<div class="assembly-row-combined"><div>06F7</div><div>6</div><div>Printer DCB + 0</div></div>
									<div class="assembly-row-combined"><div>06F8-06F9</div><div>8D 05</div><div>Printer DCB + 1,2 - Driver Address</div></div>
									<div class="assembly-row-combined"><div>06FA</div><div>43</div><div>Printer DCB + 3 - Lines per page</div></div>
									<div class="assembly-row-combined"><div>06FB</div><div>0</div><div>Printer DCB + 4 - Line Counter</div></div>
									<div class="assembly-row-combined"><div>06FC</div><div>0</div><div>Printer DCB + 5</div></div>
									<div class="assembly-row-combined"><div>06FD</div><div>"P"</div><div>Printer DCB + 6</div></div>
									<div class="assembly-row-combined"><div>06FE</div><div>"R"</div><div>Printer DCB + 7</div></div>
									<div class="assembly-row-combined" id="0700H"><div>06FF</div><div>JP 5000H<span class="opcode2" style="display: none;">C3 00 50</span></div><div>This will be 402DH, and SYS 0 will change this to JP 4400H</div></div>
									<div class="assembly-row-combined"><div>0702</div><div>RST 00H<span class="opcode2" style="display: none;">C7</span></div><div>This will be 4030H, and SYS 0 will change this to LD A,A3H</div></div>
									<div class="assembly-row-combined"><div>0703</div><div>NOP</div></div>
									<div class="assembly-row-combined"><div>0704<span class="opcode2" style="display: none;">00</span></div><div>NOP</div><div>This will be 4032H, and SYS 0 will change this to RST 28H</div></div>
									<div class="assembly-row-combined"><div>0705</div><div>LD A,00H<span class="opcode2" style="display: none;">3E 00</span></div><div>This will be 4033H, and SYS 0 will change this to 44BBH</div></div>
									<div class="assembly-row-combined"><div>0707</div><div>RET</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="070bh-math">070BH - MATH!<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The math routines in the Level II ROM are fairly complex 
because they have to be.  The following is a brief-ish description of 
the overall intentions of the authors:<br><br>
								RAM Locations / Purpose<br><br>
								</p><table>
									<tbody><tr><td>DFACLO</td><td>4</td><td>Four lowest orders for double precision</td></tr>
									<tr><td>FACLO</td><td>3</td><td>Low order of Mantissa, Middle Order of Mantissa, High Order of Mantissa</td></tr>
									<tr><td>FAC</td><td>2</td><td>Exponent, Temporary Complement of the Sign in the MSB</td></tr>
									<tr><td>ARGLO</td><td>7</td><td>Temporary location of second argument for double precision</td></tr>
									<tr><td>ARG</td><td>1</td><td></td></tr>
									<tr><td>FBUFFR</td><td></td><td>Buffer for FOUT</td></tr>
								</tbody></table>
								<p class="bold">Floating Point Formula<br><br>
								</p><ul>
								<li>The sign is the first bit of the mantissa</li>
								<li>The mantissa is 24 bits long</li>
								<li>THe binary point is to the left of the MSB</li>
								<li>The manitssa is positive, with a one assumed to be where the sign bit is</li>
								<li>The sign of the exponent is the first bit of the exponent</li>
								<li>The exponent is stored in excess of 80H (i.e., it is a signed 8 bit number with 80H added to it)</li>
								<li>An exponent of zero means the number is zero, and all other bytes are ignored</li></ul>
								<p class="bold">In memory a number looks like this:<br><br>
								</p><ul><li>Bits 17-24 of the mantissa</li>
								<li>Bits 9-16 of the mantissa</li>
								<li>The sign is in Bit 7</li>
								<li>Bits 2-8 of the mantassa are in bits 6-0</li>
								<li>The exponent is stored as a signed number + 80H</li>
								<li>Bit 1 of the mantissa is always a 1</li></ul>
								<p class="bold">Calling Math Routines<br><br>
								</p><p>To call a ONE argument routine, the argument should be in the FAC</p>
								<p>To call a TWO argument routine, the first argument should be in BCDE and the second argument should be in the FAC</p>
								<p>Regardless of which is desired, the result will be in the FAC</p>
								<p>ROM routines with a "S" point to two argument operations 
which have (HL) pointing to the first argument instead of it being in 
BCDE.  "MOVERM" is called to get the argument into the registers.</p>
								<p>ROM routines with a "T" assume that the first argument is on 
the stack.  "POPR" is used to get the arguments into the registers.  
Note: Never CALL a "T" routine, the return address will be confused with
 a number.</p>
								<p class="bold">Stack Usage<br><br>
								</p><p>The to LO's are pushed first, and then the HO and finally
 the sign.  The lower byte of each part is in the lower memory address, 
so when the number ios POPed into the registers, the higher order byte 
will be in the higher order register of the register pair (i.e., B, D, 
and H).</p>
								<br><br><br>
								According to Vernon Hester, there are a whole lot of errors in 
ROM code for processing math.  I have no hope of finding the code so I 
will put them here:<br>
								When a number is just under specific decimal magnitudes, the ROM prints a colon instead of 10<br>
								&nbsp;&nbsp;Example: 9999999999999999 / 1D12 + 3D-13 returns :000<br>
								<p></p>
							</div>

							<h2 class="assembly-section-title" id="070BH">070BH-070FH - SINGLE PRECISION ADDITION, ACCumulator = (HL) + ACCumulator<span class="origrom">- "FADDH"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Single-precision addition (ACCumulator=(HL)+ACC) involving a 
buffer pointed to by the HL Register Pair and ACCumulator (i.e., 
4121H-4122H). This part of the program loads the BCDE registers with the
 value from the buffer, then passes control to 716H.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0708-070A<span class="origrom2" style="display: inline;">FADDH</span><span class="opcode2" style="display: none;">21 80 13</span></div><div>LD HL,1380H<span class="origrom2" style="display: inline;">LD HL,FHALF</span></div><div>Load
 Register Pair HL address of the single precision value 1/2, which is 
stored in ROM at 1380H.  This would be applicable if the entry jump was 
to this address (FADDH).  If the entry is to FADDS, then this wouldn't 
occur.</div></div>
									<div class="assembly-row-combined"><div>070B-070D<span class="origrom2" style="display: inline;">FADDS</span></div><div><a href="#09C2H" class="memory-link">CALL 09C2H<span class="origrom2" style="display: inline;">CALL MOVRM</span></a><span class="opcode2" style="display: none;">CD C2 09</span></div><div>Move
 the argument from (HL) into the registers via a call to 09C2H (which 
loads a SINGLE PRECISION value pointed to by Register Pair HL into 
Register Pairs BC and DE)</div></div>
									<div class="assembly-row-combined"><div>070E-070F</div><div><a href="#0716H" class="memory-link">JR 0716H<span class="origrom2" style="display: inline;">JR FADD</span></a><span class="opcode2" style="display: none;">18 06</span></div><div>Actually
 do the addition via a JUMP to the SINGLE PRECISION ADD routine at 0716H
 (which adds the single precision value in (BC/DE) to the single 
precision value in the ACCumulator (i.e., 4121H-4122H).  The sum is left
 in the ACCumulator</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0710H">0710H-0712H - SINGLE PRECISION SUBTRACTION, ACCumulator = (HL) - ACCumulator<span class="origrom">- "FSUBS"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Single-precision subtraction (ACC=(HL)-ACC). This loads the 
BCDE registers with the value from (HL), then passes control to 713H.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0710-0712<span class="origrom2" style="display: inline;">FSUBS</span></div><div><a href="#09C2H" class="memory-link">CALL 09C2H<span class="origrom2" style="display: inline;">CALL MOVRM</span></a><span class="opcode2" style="display: none;">CD C2 09</span></div><div>Load a SINGLE PRECISION value pointed to by Register Pair HL into Register Pairs BC and DE via a GOSUB to MOVRM</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0713H">0713H-0715H - SINGLE PRECISION SUBTRACTION, ACCumulator = BCDE - ACCumulator<span class="origrom">- "FSUB"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Single-precision subtraction (ACCumulator=BCDE-ACCumulator). 
The routine actually inverts ACCumulator (i.e., 4121H-4122H) and adds it
 to the contents of the BCDE registers which, in effect, is a 
subtraction. The result will be stored in the ACCumulator (i.e., 
4121H-4122H).<br><br>Single Precision Subtract: Subtracts the single 
precision value in (BC/DE) from the single precision value in the 
ACCumulator. The difference is left in the ACCumulator<br><br>Single-
precision subtraction (ACC=BCDE-ACC). The routine actually inverts the 
ACC and adds it to the contents of the BCDE registers which, in effect, 
is a subtraction. The result will be stored in the arithmetic work area 
(ACC)<br><br>Note: If you wanted to subtract two single precision 
numbers, store the minuend in the BCDE registers and store the 
subtrahend in 4121H-4124H and then CALL 0713H.  The result (in single 
precision format) is in 4121H-4124H in approximately 670 microseconds.<br><br></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0713-0715<span class="origrom2" style="display: inline;">FSUB</span></div><div><a href="#0982H" class="memory-link">CALL 0982H<span class="origrom2" style="display: inline;">CALL NEG</span></a><span class="opcode2" style="display: none;">CD 82 09</span></div><div>Go
 reverse the sign of the single precision value in Register Pairs BC and
 DE so that the addition routine just below can be used.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0716H">0716H-0752H - SINGLE PRECISION ADDITION, ACCumulator = BCDE + ACCumulator<span class="origrom">- "FADD"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Single-precision addition (ACCumulator=BCDE+ACC). This 
routine adds two single-precision values and stores the result in the 
ACCumulator area.<br><br>Note: If you wanted to add 2 single precision 
numbers via a ROM call, store one input into BCDE (with the exponent in B
 and the LSB in E) and the other into 4121H-4124H, and then call 0716H. 
 The single precision result will be in 4121H-4124H approximately 1.3 
milliseconds later.<br><br>Single Precision Add: Add the single 
precision value in (BC/DE) to the single precision value in the 
ACCumulator. The sum is left in the ACCumulator<br><br>Single-precision addition (ACC=BCDE+ACC). This routine adds two singleprecision values and stores the result in the ACC area<br><br>Formula: FAC:=ARG+FAC<br><br>Routine ALTERS A,B,C,D,E,H,L<br><br>If INTFSF=1 the format of floating point numbers will be:</p><ul><li>Reg B - SIGN AND BITS 1-7 OF EXPONENT</li><li>Reg C - Bit 8 of exponent ;and bits 2-8 of mantissa</li><li>Reg D - Bits 9-16 of mantissa</li><li>Reg E - Bits 17-24 of mantissa, and likewise for the ACCumulator format</li><li>Note: The exponent for intel will be 7FH</li></ul><p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0716<span class="origrom2" style="display: inline;">FADD</span></div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>First
 we need to check to see if the first argument is zero, so we load 
Register A with the exponent of the single precision value in Register B</div></div>
									<div class="assembly-row-combined"><div>0717</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Set the flags based on Register B to check to see if the single precision value in Register Pairs BC and DE is equal to zero</div></div>
									<div class="assembly-row-combined"><div>0718</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>Return
 if the single precision value in Register Pairs BC and DE is equal to 
zero because the result is already in the ACCumulator.</div></div>
									<div class="assembly-row-combined"><div>0719-071B</div><div>LD A,(4124H)<span class="origrom2" style="display: inline;">LD A,(FAC)</span><span class="opcode2" style="display: none;">3A 24 41</span></div><div>Next,
 we want to test to see if the exponent is zero, because if it is, then 
the answer is already in the registers.  First, load Register A with the
 exponent of the single precision value in the ACCumulator (i.e., 
4121H-4122H)</div></div>
									<div class="assembly-row-combined"><div>071C</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Set the flags based on the exponent (now in A) is equal to zero</div></div>
									<div class="assembly-row-combined"><div>071D-071F</div><div><a href="#09B4H" class="memory-link">JP Z,09B4H<span class="origrom2" style="display: inline;">JP Z,MOVFR</span></a><span class="opcode2" style="display: none;">CA B4 09</span></div><div>If
 the exponent is zero, then the result is already in BCDE, so CALL MOVFR
 to move the SINGLE PRECISION value in DC/DE into ACCumulator.</div></div>
									<p class="debug-note">At this point we know that we are going 
to actually do the math, so the next step is to get the smaller number 
into the registers (BCDE) so we can just shift it rith and align the 
binary points of both numbers.  If we do this, then we just add or 
subtract them bytewise.</p>
									<div class="assembly-row-combined"><div>0720</div><div>SUB B<span class="opcode2" style="display: none;">90</span></div><div>Subtract
 the value of the exponent for the single precision value in Register B 
from the value of the exponent for the single precision value in the 
ACCumulator (i.e., 4121H-4122H) in Register A so we can see which is 
smaller.  NC will be set if BCDE &lt; ACCumulator.</div></div>
									<div class="assembly-row-combined"><div>0721-0722</div><div><a href="#072FH" class="memory-link">JR NC,072FH<span class="origrom2" style="display: inline;">JR NC,FADD1</span></a><span class="opcode2" style="display: none;">30 0C</span></div><div>If
 the single precision value in Register Pairs BC and DE is smaller than 
the single precision value in the ACCumulator (i.e., 4121H-4122H), JUMP 
to FADD1 since they are in the right order.</div></div>
									<div class="assembly-row-combined"><div>0723</div><div>CPL<span class="opcode2" style="display: none;">2F</span></div><div>If
 we are here, then we want to swap the two numbers.  First, we negate 
the shift count (adjust the difference in the exponents in Register A so
 that it is positive)</div></div>
									<div class="assembly-row-combined"><div>0724</div><div>INC A<span class="opcode2" style="display: none;">3C</span></div><div>Increment the difference in the exponents in Register A so that it will be the correct positive number</div></div>
									<div class="assembly-row-combined"><div>0725</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Swap the ACCumulator and the Registers</div></div>
									<div class="assembly-row-combined"><div>0726-0728</div><div><a href="#09A4H" class="memory-link">CALL 09A4H<span class="origrom2" style="display: inline;">CALL PUSHF</span></a><span class="opcode2" style="display: none;">CD A4 09</span></div><div>Call 09A4 which moves the SINGLE PRECISION value in the ACCumulator to the STACK (stored in LSB/MSB/Exponent order)</div></div>
									<div class="assembly-row-combined"><div>0729</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Load Register Pair DE with the 16-bit value in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>072A-072C</div><div><a href="#09B4H" class="memory-link">CALL 09B4H<span class="origrom2" style="display: inline;">CALL MOVFR</span></a><span class="opcode2" style="display: none;">CD B4 09</span></div><div>Call 09B4H which moves the SINGLE PRECISION value in DC/DE into ACCumulator</div></div>
									<div class="assembly-row-combined"><div>072D</div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>Next
 we finish the swap buyt putting the old ACCumulator into the registers 
with two POPs.  First, get the 16-bit value from the STACK and put it in
 Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>072E</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Get the 16-bit value from the STACK and put it in Register Pair DE</div></div>
									<p class="debug-note" id="072FH">At this point, the smaller number is in ABCD, so we proceed with the math.</p>
									<div class="assembly-row-combined"><div>072F-0730<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;FADD1</span></div><div>CP 19H<span class="opcode2" style="display: none;">FE 19</span></div><div>The
 highest math we can do is 24 bits, so first check to make sure we are 
not going to exceed that.  To do this we check to see if the difference 
in the exponents in Register A is greater than 24</div></div>
									<div class="assembly-row-combined"><div>0731</div><div>RET NC<span class="opcode2" style="display: none;">D0</span></div><div>If the math is going to exceed 24 bits, then we need to fail and RETurn</div></div>
									<div class="assembly-row-combined"><div>0732</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the shift count (the difference in the exponents in Register A) on the STACK</div></div>
									<div class="assembly-row-combined"><div>0733-0735</div><div><a href="#09DFH" class="memory-link">CALL 09DFH<span class="origrom2" style="display: inline;">CALL UNPACK</span></a><span class="opcode2" style="display: none;">CD DF 09</span></div><div>Set the sign bits for the single precision values and return with the equality of the sign bits in Register A</div></div>
									<div class="assembly-row-combined"><div>0736</div><div>LD H,A<span class="opcode2" style="display: none;">67</span></div><div>Save the sign bits (the subtraction flag) into Register A</div></div>
									<div class="assembly-row-combined"><div>0737</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get shift count (the difference of the exponents) back from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>0738-073A</div><div><a href="#07D7H" class="memory-link">CALL 07D7H<span class="origrom2" style="display: inline;">CALL SHIFTR</span></a><span class="opcode2" style="display: none;">CD D7 07</span></div><div>Shift
 the single precision value in Register Pairs BC and DE until it lines 
up with the single precision value in the ACCumulator</div></div>
									<p class="debug-note">If the numbers have the same sign, then 
we add them.  if the signs are different, then we have to subtract them.
  we have to do this because the mantissas are positive.  judging by the
 exponents, the larger number is in the ACCumulator, so if we subtract, 
the sign of the result should be the sign of the ACCumulator; however, 
if the exponents are the same, the number in the registers could be 
bigger, so after we subtract them, we have to check if the result was 
negative.  if it was, we negate the number in the registers and 
complement the sign of the ACCumulator.  (here the ACCumulator is 
unpacked) if we have to add the numbers, the sign of the result is the 
sign of the ACCumulator.  so, in either case, when we are all done, the 
sign of the result will be the sign of the ACCumulator.</p>
									<div class="assembly-row-combined"><div>073B</div><div>OR H<span class="opcode2" style="display: none;">B4</span></div><div>Get the subtraction flag to see if the sign bits are equal</div></div>
									<div class="assembly-row-combined"><div>073C-073E</div><div>LD HL,4121H<span class="origrom2" style="display: inline;">LD HL,FACLO</span><span class="opcode2" style="display: none;">21 21 41</span></div><div>Load Register Pair HL with the starting address of ACCumulator</div></div>
									<div class="assembly-row-combined"><div>073F-0741</div><div><a href="#0754H" class="memory-link">JP P,0754H<span class="origrom2" style="display: inline;">JP P,FADD3</span></a><span class="opcode2" style="display: none;">F2 54 07</span></div><div>If the signs were differet, then we move to subtractions</div></div>
									<div class="assembly-row-combined"><div>0742-0744</div><div><a href="#07B7H" class="memory-link">CALL 07B7H<span class="origrom2" style="display: inline;">CALL FADDA</span></a><span class="opcode2" style="display: none;">CD B7 07</span></div><div>Otherwise, we add the single precision value in BCDE to the single precision value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0745-0747</div><div><a href="#0796H" class="memory-link">JP NC,0796H<span class="origrom2" style="display: inline;">JP NC,ROUND</span></a><span class="opcode2" style="display: none;">D2 96 07</span></div><div>If there was NO overflow then we will JUMP away to round</div></div>
									<div class="assembly-row-combined"><div>0748</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>If
 we're still here, then there was an overflow, but the most it can 
overflow is 1 bit, so we increment the memory pointer in Register Pair 
HL, so that it points to the exponent in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0749</div><div>INC (HL)<span class="opcode2" style="display: none;">34</span></div><div>Increment the exponent in the ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>074A-074C</div><div><a href="#07B2H" class="memory-link">JP Z,07B2H<span class="origrom2" style="display: inline;">JP Z,OVERR</span></a><span class="opcode2" style="display: none;">CA B2 07</span></div><div>Check
 for another overflow (i.e., the exponent in the ACCumulator is too 
large) in which case go to 07B2H to output an OV ERROR message</div></div>
									<div class="assembly-row-combined"><div>074D-074E</div><div>LD L,01H<span class="opcode2" style="display: none;">2E 01</span></div><div>Prepare
 to shift the result one one bit and shift the CARRY FLAG in by load 
ingRegister L with the number of bits to shift the single precision 
result in Register Pairs BC and DE</div></div>
									<div class="assembly-row-combined"><div>074F-0751</div><div><a href="#07EBH" class="memory-link">CALL 07EBH<span class="origrom2" style="display: inline;">CALL SHRADD</span></a><span class="opcode2" style="display: none;">CD EB 07</span></div><div>Go shift the single precision result in Register Pairs BC and DE</div></div>
									<div class="assembly-row-combined"><div>0752-0753</div><div><a href="#0796H" class="memory-link">JR 0796H<span class="origrom2" style="display: inline;">JR ROUND</span></a><span class="opcode2" style="display: none;">18 42</span></div><div>Finish up by rounding the results via a JUMP to 0796H</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0754H">0754H-077CH - SINGLE PRECISION MATH ROUTINE<span class="origrom">- "FADD3"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will subtract CDEB from ((HL)+0,1,2),0.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0754<span class="origrom2" style="display: inline;">FADD3</span></div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A to negate the unflow byte and subtract the numbers.</div></div>
									<div class="assembly-row-combined"><div>0755</div><div>SUB B<span class="opcode2" style="display: none;">90</span></div><div>Subtract the 8-bit value in Register B from the value in Register A</div></div>
									<div class="assembly-row-combined"><div>0756</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Save the result into Register A</div></div>
									<div class="assembly-row-combined"><div>0757</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Prepare to subtract the low order numbers.  First, load Register A with the value at the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0758</div><div>SBC A,E<span class="opcode2" style="display: none;">9B</span></div><div>Subtract the value in Register E from the value in Register A</div></div>
									<div class="assembly-row-combined"><div>0759</div><div>LD E,A<span class="opcode2" style="display: none;">5F</span></div><div>Load Register E with the result in Register A</div></div>
									<div class="assembly-row-combined"><div>075A</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the memory pointer in Register Pair HL to point to the next byte (the middle order numbers) to deal with</div></div>
									<div class="assembly-row-combined"><div>075B</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Prepare
 to subtract the middle order numbers.  First, load Register A with the 
value at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>075C</div><div>SBC A,D<span class="opcode2" style="display: none;">9A</span></div><div>Subtract the value in Register D from the value in Register A</div></div>
									<div class="assembly-row-combined"><div>075D</div><div>LD D,A<span class="opcode2" style="display: none;">57</span></div><div>Load Register D with the result in Register A</div></div>
									<div class="assembly-row-combined"><div>075E</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the memory pointer in Register Pair HL to point to the next byte (the high order numbers) to deal with</div></div>
									<div class="assembly-row-combined"><div>075F</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load Register A with the value at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0760</div><div>SBC A,C<span class="opcode2" style="display: none;">99</span></div><div>Subtract the value in Register C from the value in Register A</div></div>
									<div class="assembly-row-combined"><div>0761</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the result in Register A</div></div>
									<p class="debug-note">With that out the way, we need to make sure we have a positive mantissa (or else we will need to negate the number).</p>
									<div class="assembly-row-combined"><div>0762-0764<span class="origrom2" style="display: inline;">FADFLT</span></div><div><a href="#07C3H" class="memory-link">CALL C,07C3H<span class="origrom2" style="display: inline;">CALL C,NEGR</span></a><span class="opcode2" style="display: none;">DC C3 07</span></div><div>If
 the Carry flag is set (which is to indicate that the number was 
negative), go convert the single precision value to a positive number</div></div>
									<p class="debug-note" id="0765H">This next routine normalizes 
CDEB.  In doing so, ABCDE and HL are all modified.  This routine shifts 
the mantissa left until the MSB is a 1.</p>
									<div class="assembly-row-combined"><div>0765<span class="origrom2" style="display: inline;">NORMAL</span></div><div>LD L,B<span class="opcode2" style="display: none;">68</span></div><div>Put the lowest two bytes into (HL)</div></div>
									<div class="assembly-row-combined"><div>0766</div><div>LD H,E<span class="opcode2" style="display: none;">63</span></div><div>Load Register H with the LSB of the single precision value in Register E</div></div>
									<div class="assembly-row-combined"><div>0767</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A so that Register B can track the shift count.</div></div>
									<div class="assembly-row-combined" id="0768H"><div>0768<span class="origrom2" style="display: inline;">NORM1</span></div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Save the shift count from Register A into Register B.</div></div>
									<div class="assembly-row-combined"><div>0769</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with the MSB of the single precision value in Register C</div></div>
									<div class="assembly-row-combined"><div>076A</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the value in Register A is equal to zero</div></div>
									<div class="assembly-row-combined"><div>076B-076C</div><div><a href="#0785H" class="memory-link">JR NZ,0785H<span class="origrom2" style="display: inline;">JR NZ,NORM3</span></a><span class="opcode2" style="display: none;">20 18</span></div><div>So long as we have a non-Zero value, JUMP to shift one place</div></div>
									<div class="assembly-row-combined"><div>076D</div><div>LD C,D<span class="opcode2" style="display: none;">4A</span></div><div>Shift the NMSB into the MSB by loading Register C with the value in Register D</div></div>
									<div class="assembly-row-combined"><div>076E</div><div>LD D,H<span class="opcode2" style="display: none;">54</span></div><div>Shift the LSB into the NMSB by loading Register D with the value in Register H</div></div>
									<div class="assembly-row-combined"><div>076F</div><div>LD H,L<span class="opcode2" style="display: none;">65</span></div><div>Load Register H with the value in Register L</div></div>
									<div class="assembly-row-combined"><div>0770</div><div>LD L,A<span class="opcode2" style="display: none;">6F</span></div><div>Load Register L with the value in Register A</div></div>
									<div class="assembly-row-combined"><div>0771</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Load Register A with the new shift count (exponent counter) in Register B</div></div>
									<div class="assembly-row-combined"><div>0772-0773</div><div>SUB 08H<span class="opcode2" style="display: none;">D6 08</span></div><div>Subtract the number of bits just shifted from the new exponent counter in Register A</div></div>
									<div class="assembly-row-combined"><div>0774-0775</div><div>CP E0H<span class="opcode2" style="display: none;">FE E0</span></div><div>Check to see if we shifted 4 bytes of zeroes.  If no (NZ) we will need to shift over 8 more.</div></div>
									<div class="assembly-row-combined"><div>0776-0777</div><div><a href="#0768H" class="memory-link">JR NZ,0768H<span class="origrom2" style="display: inline;">JR NZ,NORM1</span></a><span class="opcode2" style="display: none;">20 F0</span></div><div>If we did not shift 4 bytes of ZERO'es, shift 8 more via a loop until shift is completed</div></div>
									<p class="debug-note" id="0778H">This routine will ZERO out the ACCumulator, changing only Register A in the process.  A will exit as 0.</p>
									<div class="assembly-row-combined"><div>0778<span class="origrom2" style="display: inline;">ZERO</span></div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A</div></div>
									<div class="assembly-row-combined"><div>0779-077B<span class="origrom2" style="display: inline;">ZERO0</span></div><div>LD (4124H),A<span class="origrom2" style="display: inline;">LD (FAC),A</span><span class="opcode2" style="display: none;">32 24 41</span></div><div>Make
 the ACCUmulator's exponent = whatever is in A.  If entered from above, 
then it will be 0.  This is done because Level II treats a number as 
zero if its exponent is zero.</div></div>
									<div class="assembly-row-combined"><div>077C</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>Return with a single precision value of zero in the ACCumulator</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="077DH">077DH-07A7H - SINGLE PRECISION MATH SUPPORT ROUTINE<span class="origrom">- "NORM2"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>077D<span class="origrom2" style="display: inline;">NORM2</span></div><div>DEC B<span class="opcode2" style="display: none;">05</span></div><div>Decrement the shift count (exponent counter) in Register B</div></div>
									<div class="assembly-row-combined"><div>077E</div><div>ADD HL,HL<span class="opcode2" style="display: none;">29</span></div><div>Rotate (HL) left by 1 and shift in a 0</div></div>
									<div class="assembly-row-combined"><div>077F</div><div>LD A,D<span class="opcode2" style="display: none;">7A</span></div><div>Rotate the next higher order (NMSB) left 1 as well.</div></div>
									<div class="assembly-row-combined"><div>0780</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Shift the NMSB in Register A left one bit and shift a bit from Register Pair HL if necessary</div></div>
									<div class="assembly-row-combined"><div>0781</div><div>LD D,A<span class="opcode2" style="display: none;">57</span></div><div>Save the adjusted NMSB in Register A into Register D</div></div>
									<div class="assembly-row-combined"><div>0782</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with the MSB in Register C</div></div>
									<div class="assembly-row-combined"><div>0783</div><div>ADC A,A<span class="opcode2" style="display: none;">8F</span></div><div>Shift the MSB in Register A left one bit and shift a bit from Register D if necessary.  The flags will get set as well.</div></div>
									<div class="assembly-row-combined"><div>0784</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the adjusted value in Register A</div></div>
									<div class="assembly-row-combined" id="0785H"><div>0785-0787<span class="origrom2" style="display: inline;">NORM3</span></div><div><a href="#077DH" class="memory-link">JP P,077DH<span class="origrom2" style="display: inline;">JP P,NORM2</span></a><span class="opcode2" style="display: none;">F2 7D 07</span></div><div>IF
 the P FLAG is set, then we have more normalization to do so loop until 
the most significant bit of the single precision value is equal to one</div></div>
									<p class="debug-note">If we are here, then we have a fully normalized result, so let us continue.</p>
									<div class="assembly-row-combined"><div>0788</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Load Register A with the new shift count (exponent counter) in Register B</div></div>
									<div class="assembly-row-combined"><div>0789</div><div>LD E,H<span class="opcode2" style="display: none;">5C</span></div><div>Load Register E with the LSB of the low order part of the single precision value</div></div>
									<div class="assembly-row-combined"><div>078A</div><div>LD B,L<span class="opcode2" style="display: none;">45</span></div><div>Load Register B with the MSB of the low order part of the single precision value</div></div>
									<div class="assembly-row-combined"><div>078B</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if there were any bits shifted.</div></div>
									<div class="assembly-row-combined"><div>078C-078D</div><div><a href="#0796H" class="memory-link">JR Z,0796H<span class="origrom2" style="display: inline;">JR Z,ROUND</span></a><span class="opcode2" style="display: none;">28 08</span></div><div>Jump if there weren't any bits shifted</div></div>
									<div class="assembly-row-combined"><div>078E-0790</div><div>LD HL,4124H<span class="origrom2" style="display: inline;">LD HL,FAC</span><span class="opcode2" style="display: none;">21 24 41</span></div><div>Load Register Pair HL with the address of the exponent in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0791</div><div>ADD A,(HL)<span class="opcode2" style="display: none;">86</span></div><div>Add
 the value of the original exponent at the location of the memory 
pointer in Register Pair HL to the number of bits shifted in Register A</div></div>
									<div class="assembly-row-combined"><div>0792</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save the new exponent in Register A at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0793-0794</div><div><a href="#0778H" class="memory-link">JR NC,0778H<span class="origrom2" style="display: inline;">R NC,ZERO</span></a><span class="opcode2" style="display: none;">30 E3</span></div><div>Jump
 if exponent is too small (i.e., an underflow).  This jump is to code 
which just zeroes out A, puts it into (4124H), and RETurns</div></div>
									<div class="assembly-row-combined"><div>0795</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>Return if exponent is equal to zero.  Otherwise, we will pass down to the "ROUND" routine</div></div>
									<p class="debug-note" id="0796H">The "ROUND" routine rounds the
 result in CDEB and puts the result into the ACCumulator.  All registers
 are affected.  CDE is rounded up or down based on the MSB of Register 
B.</p>
									<p class="debug-note">Vernong Hester has flagged an error in 
the rounding of math routines.  In base 10, rounding to k-digits 
examines digit k+1. If digit k+1 is 5 through 9, then digit k is 
adjusted up by one and carries to the most significant digit, if 
necessary. If digit k+1 is less than 5, then digit k is not adjusted. 
This should not get muddled with the conversion of base 2 to base 10. 
Nevertheless, four divided by nine should be: .444444 and not .444445</p>
									<div class="assembly-row-combined"><div>0796<span class="origrom2" style="display: inline;">ROUND</span></div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Load Register A with the LSB of the single precision value in Register B</div></div>
									<div class="assembly-row-combined"><div>0797-0799<span class="origrom2" style="display: inline;">ROUNDB</span></div><div>LD HL,4124H<span class="origrom2" style="display: inline;">LD HL,FAC</span><span class="opcode2" style="display: none;">21 24 41</span></div><div>Load
 Register Pair HL with the address of the exponent in the ACCumulator.  
Note:  The FDIV ROM Routine enters the routine here at ROUNDB with 
Register A set differently.</div></div>
									<div class="assembly-row-combined"><div>079A</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Set
 the status flags to enable us to see if we need if we need to round up.
  If the M FLAG is set (the most significant bit of the value in 
Register A), we will need to round up. </div></div>
									<div class="assembly-row-combined"><div>079B-079D</div><div><a href="#07A8H" class="memory-link">CALL M,07A8H<span class="origrom2" style="display: inline;">CALL M,ROUNDA</span></a><span class="opcode2" style="display: none;">FC A8 07</span></div><div>If the M FLAG is set (if the most significant bit in the value in Register A is set), GOSUB to round up</div></div>
									<div class="assembly-row-combined"><div>079E</div><div>LD B,(HL)<span class="opcode2" style="display: none;">46</span></div><div>Put the exponent (modified or not), whcih is currently held in the RAM location pointed to by HL, into Register B.</div></div>
									<div class="assembly-row-combined"><div>079F</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the memory pointer in Register Pair HL to now point to the sign</div></div>
									<div class="assembly-row-combined"><div>07A0</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load Register A with the value of the sign at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>07A1-07A2</div><div>AND 80H<span class="origrom">AND 1000 0000</span><span class="opcode2" style="display: none;">E6 80</span></div><div>Turn off some bits so we can mask the sign bit in Register A (1000 0000)</div></div>
									<div class="assembly-row-combined"><div>07A3</div><div>XOR C<span class="opcode2" style="display: none;">A9</span></div><div>Set the sign bit in Register A</div></div>
									<div class="assembly-row-combined"><div>07A4</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the sign</div></div>
									<div class="assembly-row-combined"><div>07A5-07A7</div><div><a href="#09B4H" class="memory-link">JP 09B4H<span class="origrom2" style="display: inline;">JP MOVFR</span></a><span class="opcode2" style="display: none;">C3 B4 09</span></div><div>Save the number into the ACCumulator via a JUMP to 09B4H which moves the SINGLE PRECISION value in BC/DE into ACCumulator</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="07A8H">07A8H-07B6H - SINGLE PRECISION MATH SUPPORT ROUTINE<span class="origrom">- "ROUNDA"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is a subroutine within the ROUND round.  This will add one to C/D/E.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>07A8<span class="origrom2" style="display: inline;">ROUNDA</span></div><div>INC E<span class="opcode2" style="display: none;">1C</span></div><div>Increment the LSB of the single precision value (which is stored in Register E).  Note:  This is the entry point from QUINT.</div></div>
									<div class="assembly-row-combined"><div>07A9</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>If the NZ FLAG is set, then we have no overflow, so we are done!</div></div>
									<div class="assembly-row-combined" id="07AAH"><div>07AAH</div><div>INC D<span class="opcode2" style="display: none;">14</span></div><div>Increment the NMSB of the single precision value (which is stored in Register D)</div></div>
									<div class="assembly-row-combined"><div>07AB</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>If the NZ FLAG is set, then we have no overflow, so we are done!</div></div>
									<div class="assembly-row-combined" id="07ACH"><div>07AC</div><div>INC C<span class="opcode2" style="display: none;">0C</span></div><div>Increment the MSB of the single precision value (which is stored in Register C).</div></div>
									<div class="assembly-row-combined"><div>07AD</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>If the NZ FLAG is set, then we have no overflow, so we are done!</div></div>
									<div class="assembly-row-combined" id="07AEH"><div>07AE-07AF</div><div>LD C,80<span class="opcode2" style="display: none;">0E 80</span></div><div>If
 we are still here then the number overflowed all 3 registers.  With 
this, we need to adjust the MSB of the single precision value in 
Register C and then ...</div></div>
									<div class="assembly-row-combined"><div>07B0</div><div>INC (HL)<span class="opcode2" style="display: none;">34</span></div><div>... update the exponent (which is stored in the RAM location pointed to by HL)</div></div>
									<div class="assembly-row-combined"><div>07B1</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>If
 the NZ FLAG is set, then we have no overflow, so we are done!  If that 
overflowed as well, then we are out of luck and we pass through to an 
error.</div></div>
									<p class="debug-note" id="07B2H">07B2H - ?OV ERROR entry point<span class="origrom">- "OVERR"</span></p>
									<div class="assembly-row-combined"><div>07B2H-07B3<span class="origrom2" style="display: inline;">OVERR</span></div><div>LD E,0AH<span class="origrom">LD E,ERROV</span><span class="opcode2" style="display: none;">1E 0A</span></div><div>Load Register E with an ?OV ERROR code.</div></div>
									<div class="assembly-row-combined"><div>07B4-07B6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#19A2H" class="memory-link">JP 19A2H<span class="origrom2" style="display: inline;">JP ERROR</span></a><span class="opcode2" style="display: none;">C3 A2 19</span></div><div>Go to the Level II BASIC error routine and display an OV ERROR message if the value has overflowed.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="07B7H">07B7H-07C2H SINGLE PRECISION MATH ROUTINE<span class="origrom">- "FADDA"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine adds (HL+2),)(HL+1),(HL+0) to C,D,E.  This is called by FADD and FOUT.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>07B7<span class="origrom2" style="display: inline;">FADDA</span></div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load Register A with the LSB of the single precision value in the ACCumulator (pointed to by Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>07B8</div><div>ADD A,E<span class="opcode2" style="display: none;">83</span></div><div>Add
 Register E (the LSB of the other number being added; stored in Register
 E) to the LSB of the single precision value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>07B9</div><div>LD E,A<span class="opcode2" style="display: none;">5F</span></div><div>... and put that sum into Register E</div></div>
									<div class="assembly-row-combined"><div>07BA</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Onto the middle number/NMSB.  Increment the memory pointer in Register Pair HL to point to the NMSB (ACCumulator + 1).</div></div>
									<div class="assembly-row-combined"><div>07BB</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load
 Register A with the NMSB of the single precision value in the 
ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>07BC</div><div>ADC A,D<span class="opcode2" style="display: none;">8A</span></div><div>Add the NMSB of the single precision value in Register D to the NMSB of the single precision value in Register A</div></div>
									<div class="assembly-row-combined"><div>07BD</div><div>LD D,A<span class="opcode2" style="display: none;">57</span></div><div>Load Register D with the result in Register A</div></div>
									<div class="assembly-row-combined"><div>07BE</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Onto the high order number/MSB.  Increment the memory pointer in Register Pair HL to point to the MSB (ACCumulator + 2).</div></div>
									<div class="assembly-row-combined"><div>07BF</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load
 Register A with the MSB of the single precision value in the 
ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>07C0</div><div>ADC A,C<span class="opcode2" style="display: none;">89</span></div><div>Add the MSB of the single precision value in Register C to the MSB of the single precision value in Register A</div></div>
									<div class="assembly-row-combined"><div>07C1</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the result in Register A</div></div>
									<div class="assembly-row-combined"><div>07C2</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="07C3H">07C3H-07D6H - SINGLE PRECISION MATH ROUTINE<span class="origrom">- NEGR</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine negates the number in C/D/E/B.  CALLd by FADD and QUINT.  Alters everything except Register H.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>07C3-07C5<span class="origrom2" style="display: inline;">NEGR</span></div><div>LD HL,4125H<span class="origrom2" style="display: inline;">LD HL,FAC+1</span><span class="opcode2" style="display: none;">21 25 41</span></div><div>Load Register Pair HL with the address of the sign flag storage location.</div></div>
									<div class="assembly-row-combined"><div>07C6</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load Register A with the value of the sign flag at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>07C7</div><div>CPL<span class="opcode2" style="display: none;">2F</span></div><div>Complement the sign flag in Register A</div></div>
									<div class="assembly-row-combined"><div>07C8</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save the adjusted sign flag in Register A back to (FAC+1)</div></div>
									<div class="assembly-row-combined"><div>07C9</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A.  This will allow us to zero Register L and to do negative math</div></div>
									<div class="assembly-row-combined"><div>07CA</div><div>LD L,A<span class="opcode2" style="display: none;">6F</span></div><div>Load
 Register L with a 0 (held in Register A) so that we can keep getting a 
zero back into Register A for the below math using less code.</div></div>
									<div class="assembly-row-combined"><div>07CB</div><div>SUB B<span class="opcode2" style="display: none;">90</span></div><div>NEGate the low order/LSB number by subtracting Register B from zero (held in Register A)</div></div>
									<div class="assembly-row-combined"><div>07CC</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Save that negated Register B back to Register B</div></div>
									<div class="assembly-row-combined"><div>07CD</div><div>LD A,L<span class="opcode2" style="display: none;">7D</span></div><div>Load Register A with zero</div></div>
									<div class="assembly-row-combined"><div>07CE</div><div>SBC A,E<span class="opcode2" style="display: none;">9B</span></div><div>NEGate the next highest order number by subtracting Register E from zero (held in Register A)</div></div>
									<div class="assembly-row-combined"><div>07CF</div><div>LD E,A<span class="opcode2" style="display: none;">5F</span></div><div>Save that negated Register E back to Register E</div></div>
									<div class="assembly-row-combined"><div>07D0</div><div>LD A,L<span class="opcode2" style="display: none;">7D</span></div><div>Load Register A with zero</div></div>
									<div class="assembly-row-combined"><div>07D1</div><div>SBC A,D<span class="opcode2" style="display: none;">9A</span></div><div>NEGate the next highest order number by subtracting Register D from zero (held in Register A)</div></div>
									<div class="assembly-row-combined"><div>07D2</div><div>LD D,A<span class="opcode2" style="display: none;">57</span></div><div>Save that negated Register D back to Register D</div></div>
									<div class="assembly-row-combined"><div>07D3</div><div>LD A,L<span class="opcode2" style="display: none;">7D</span></div><div>Load Register A with zero</div></div>
									<div class="assembly-row-combined"><div>07D4</div><div>SBC A,C<span class="opcode2" style="display: none;">99</span></div><div>NEGate the highest order number/MSB by subtracting Register C from zero (held in Register A)</div></div>
									<div class="assembly-row-combined"><div>07D5</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Save that negated Register C back to Register C</div></div>
									<div class="assembly-row-combined"><div>07D6</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="07D7H">07D7H-07F7H - SINGLE PRECISION MATH ROUTINE<span class="origrom">- "SHIFTR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will shift the number in C/D/E right the number 
of times held in Register A.  The general idea is to shift right 8 
places as many times as is possible within the number of times in A, and
 then jump out to shift single bits once you can't shift 8 at a time 
anymore.  Alters everything except Register H.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>07D7-07D8<span class="origrom2" style="display: inline;">SHIFTR</span></div><div>LD B,00H<span class="opcode2" style="display: none;">06 00</span></div><div>Load Register B, which will hold the overflow byte, with zero to reset the overflow byte</div></div>
									<div class="assembly-row-combined"><div>07D9-07DA<span class="origrom2" style="display: inline;">SHFTR1</span></div><div>SUB 08H<span class="opcode2" style="display: none;">D6 08</span></div><div>Top
 of a loop.  For speed, first check to see if the shift counter in 
Register A still indicates at least 8 bits have to be shifted right</div></div>
									<div class="assembly-row-combined"><div>07DB-07DC</div><div><a href="#07E4H" class="memory-link">JR C,07E4H<span class="origrom2" style="display: inline;">JR C,SHFTR2</span></a><span class="opcode2" style="display: none;">38 07</span></div><div>If
 the CARRY FLAG is set, then there isn't room to shift 8 bytes, so we 
are going to need to shift only 1 byte, by JUMPing away to SHFTR2.  This
 is the routine's exit.</div></div>
									<p class="debug-note">If we are here, then we are good to shift 8 bytes at once.  So B to E, E to D, D to C, and then Zero out C ...</p>
									<div class="assembly-row-combined"><div>07DD</div><div>LD B,E<span class="opcode2" style="display: none;">43</span></div><div>Load Register B with the LSB of the single precision value in Register E</div></div>
									<div class="assembly-row-combined"><div>07DE</div><div>LD E,D<span class="opcode2" style="display: none;">5A</span></div><div>Load Register E with the NMSB of the single precision value in Register D</div></div>
									<div class="assembly-row-combined"><div>07DF</div><div>LD D,C<span class="opcode2" style="display: none;">51</span></div><div>Load Register D with the MSB of the single precision value in Register C</div></div>
									<div class="assembly-row-combined"><div>07E0-07E1</div><div>LD C,00H<span class="opcode2" style="display: none;">0E 00</span></div><div>Load Register C with zero</div></div>
									<div class="assembly-row-combined"><div>07E2-07E3</div><div><a href="#07D9H" class="memory-link">JR 07D9H<span class="origrom2" style="display: inline;">JR SHFTR1</span></a><span class="opcode2" style="display: none;">18 F5</span></div><div>Loop back to see if we can keep shifting</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="07E4H">07E4 - SINGLE PRECISION MATH ROUTINE<span class="origrom">- "SHFTR2"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will shift the number in C/D/E right the number of times held in Register A, but one byte at a time.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>07E4-07E5<span class="origrom2" style="display: inline;">SHFTR2</span></div><div>ADD 09H<span class="opcode2" style="display: none;">C6 09</span></div><div>Adjust the shift counter in Register A to its correct value for working with individual bits instead of bytes</div></div>
									<div class="assembly-row-combined"><div>07E6</div><div>LD L,A<span class="opcode2" style="display: none;">6F</span></div><div>Load Register L with the shift counter in Register A so that L will hold the counter for shifts at the single bit level</div></div>
									<div class="assembly-row-combined"><div>07E7<span class="origrom2" style="display: inline;">SHFTR3</span></div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Top of a loop.  Clear the CARRY FLAG.</div></div>
									<div class="assembly-row-combined"><div>07E8</div><div>DEC L<span class="opcode2" style="display: none;">2D</span></div><div>Decrement the bit shift counter (held in Register L)</div></div>
									<div class="assembly-row-combined"><div>07E9</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>Return if there are no more bits to be shifted.  This is the routine's exit.</div></div>
									<div class="assembly-row-combined" id="07EAH"><div>07EA</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>If
 we are here, then there are L bits to shift.  First, load Register A 
with the High Order/MSB of the single precision value in Register C</div></div>
									<div class="assembly-row-combined" id="07EAB"><div>07EB<span class="origrom2" style="display: inline;">SHRADD</span></div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Shift
 the MSB of the single precision value in Register A one place to the 
right.  Note: FADD enters at this point withRegister A set differently. 
 RRA rotates the contents of Register A right one bit position, with Bit
 0 going to the CARRY FLAG, and the CARRY FLAG going to Bit 7.  RRA also
 can be used to divide a number in 2.</div></div>
									<div class="assembly-row-combined"><div>07EC</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Save the bit shifted MSB (held in Register A) back into Register C</div></div>
									<div class="assembly-row-combined"><div>07ED</div><div>LD A,D<span class="opcode2" style="display: none;">7A</span></div><div>Load Register A with the NMSB of the single precision value in Register D</div></div>
									<div class="assembly-row-combined"><div>07EE</div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Shift
 the NMSB of the single precision value in Register A one place to the 
right and pick up the value of the Carry flag.  RRA rotates the contents
 of Register A right one bit position, with Bit 0 going to the CARRY 
FLAG, and the CARRY FLAG going to Bit 7.  RRA also can be used to divide
 a number in 2.</div></div>
									<div class="assembly-row-combined"><div>07EF</div><div>LD D,A<span class="opcode2" style="display: none;">57</span></div><div>Save the bit shifted NMSB (held in Register A) back into Register D</div></div>
									<div class="assembly-row-combined"><div>07F0</div><div>LD A,E<span class="opcode2" style="display: none;">7B</span></div><div>Load Register A with the LSB of the single precision value in Register E</div></div>
									<div class="assembly-row-combined"><div>07F1</div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Shift
 the LSB of the single precision value in Register A one place to the 
right and pick up the value of the Carry flag.  RRA rotates the contents
 of Register A right one bit position, with Bit 0 going to the CARRY 
FLAG, and the CARRY FLAG going to Bit 7.  RRA also can be used to divide
 a number in 2.</div></div>
									<div class="assembly-row-combined"><div>07F2</div><div>LD E,A<span class="opcode2" style="display: none;">5F</span></div><div>Save the bit shifted LSB (held in Register A) back into Register D</div></div>
									<div class="assembly-row-combined"><div>07F3</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Load Register A with the overflow byte (held in Register B)</div></div>
									<div class="assembly-row-combined"><div>07F4</div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Shift
 the overflow byte one place to the right and pick up the value of the 
Carry flag.  RRA rotates the contents of Register A right one bit 
position, with Bit 0 going to the CARRY FLAG, and the CARRY FLAG going 
to Bit 7.  RRA also can be used to divide a number in 2.</div></div>
									<div class="assembly-row-combined"><div>07F5</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Save the bit shifted overflow byte (held in Register A) back into Register B</div></div>
									<div class="assembly-row-combined"><div>07F6-07F7</div><div><a href="#07E7H" class="memory-link">JR 07E7H<span class="origrom2" style="display: inline;">JR SHFTR3</span></a><span class="opcode2" style="display: none;">18 EF</span></div><div>Loop until all of the bits have been shifted.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="07F8H">07F8H-07FBH - SINGLE PRECISION CONSTANT STORAGE LOCATION<span class="origrom"><br>- "FONE"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>07F8-07FB<span class="origrom2" style="display: inline;">FONE</span></div><div>00 00 00 81<span class="opcode2" style="display: none;">00</span></div><div>A single precision constant equal to 1.0 is stored here.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="07FCH">07FCH-0808H - SINGLE PRECISION CONSTANTS STORAGE LOCATION 2<span class="origrom">- "LOGCN2"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>07FC<span class="origrom2" style="display: inline;">LOGCN2</span></div><div>03<span class="opcode2" style="display: none;">03</span></div><div>The number of single precision constants which follows is stored here</div></div>
									<div class="assembly-row-combined" id="0800H"><div>07FD-0800</div><div>AA 56 19 80<span class="opcode2" style="display: none;">AA</span></div><div>A single precision constant equal to 0.598978650 is stored here</div></div>
									<div class="assembly-row-combined"><div>0801-0804</div><div>F1 22 76 80<span class="opcode2" style="display: none;">F1</span></div><div>A single precision constant equal to 0.961470632 is stored here</div></div>
									<div class="assembly-row-combined"><div>0805-0808</div><div>45 AA 38 82<span class="opcode2" style="display: none;">45</span></div><div>A single precision constant equal to 2.88539129 is stored here</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0809H">0809H-0846H - LEVEL II BASIC <span class="code">LOG</span> routine<span class="origrom">- "LOG"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The LOG(n) routine, (ACCumulator=LOG (ACCumulator)). This 
routine finds the natural log (base E) of the single precision value in 
the ACCumulator area.<br><br>The result is returned as a single precision value in the ACCumulator<br><br>To
 use a ROM call to find LOG(n), where X is a positive single precision 
variable, store the value of n in 4121H-4124H and then CALL 0809H.  The 
result (in single precision format) is in 4121H-4124Hin approximately 19
 milliseconds.  NOTE: A fatal error occurs if the value of the input 
variable is zero or negative.<br></p>
								<p>Vernon Hester has identified a bug in the LOG() routine.  
Regardless of the base, if the argument is 1 then the logarithm is zero,
 if the argument is &gt;1 then the logarithm is positive, and if the 
argument is &gt; 0 and &lt; 1 then the logarithm is negative. However, 
if the argument is just under 1, the ROMs LOG function produces a 
positive value. e.g., 10 PRINT LOG(.99999994)</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0809-080B<span class="origrom2" style="display: inline;">LOG</span></div><div><a href="#0955H" class="memory-link">CALL 0955H<span class="origrom2" style="display: inline;">CALL SIGN</span></a><span class="opcode2" style="display: none;">CD 55 09</span></div><div>Go check the sign (or zero value) of the single precision value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>080C</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Set the flags.</div></div>
									<div class="assembly-row-combined"><div>080D-080F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E4AH" class="memory-link">JP PE,1E4AH<span class="origrom2" style="display: inline;">JP PE,FCERR</span></a><span class="opcode2" style="display: none;">EA 4A 1E</span></div><div>If
 the ACCumulator value is &lt;= ZERO then we cannot proceed so go the 
Level II BASIC error routine and display a ?FC ERROR message.  The SIGN 
routine will only return 00H, 01H, or FFH, so PE will be set if its 00H 
or FFH, but not 01H</div></div>
									<div class="assembly-row-combined"><div>0810-0812</div><div>LD HL,4124H<span class="origrom2" style="display: inline;">LD HL,FAC</span><span class="opcode2" style="display: none;">21 24 41</span></div><div>Load Register Pair HL with the address of the exponent in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0813</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load
 Register A with the exponent of the single precision value in the 
ACCumulator (held at the location of the memory pointer in Register Pair
 HL)</div></div>
									<p class="debug-note">The next two instructions are commented in the original ROM source code as: Get SQR(.5)</p>
									<div class="assembly-row-combined"><div>0814-0816</div><div>LD BC,8035H<span class="opcode2" style="display: none;">01 35 80</span></div><div>Load Register BC with the exponent and the MSB of a single precision constant (which is 32821)</div></div>
									<div class="assembly-row-combined"><div>0817-0819</div><div>LD DE,04F3H<span class="opcode2" style="display: none;">11 F3 04</span></div><div>Load
 Register DE with the NMSB and the LSB of a single precision constant 
(which is 1267). Register Pairs BC and DE are now equal to the single 
precision constant of .707107</div></div>
									<div class="assembly-row-combined"><div>081A</div><div>SUB B<span class="opcode2" style="display: none;">90</span></div><div>Remove the excess 80H (held in Register B) from the exponent of the n-value (of <span class="code">LOG (n)</span>) held in Register A</div></div>
									<div class="assembly-row-combined"><div>081B</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the modified exponent to the the STACK for later</div></div>
									<div class="assembly-row-combined"><div>081C</div><div>LD (HL),B<span class="opcode2" style="display: none;">70</span></div><div>Set the exponent to 80H</div></div>
									<p class="debug-note">The next two instructions save SQR(.5) to the STACK</p>
									<div class="assembly-row-combined"><div>081D</div><div>PUSH DE<span class="opcode2" style="display: none;">D5</span></div><div>Save the NMSB and the LSB of the single precision value in Register Pair DE on the STACK</div></div>
									<div class="assembly-row-combined"><div>081E</div><div>PUSH BC<span class="opcode2" style="display: none;">C5</span></div><div>Save the exponent and the MSB of the single value in Register Pair BC on the STACK</div></div>
									<div class="assembly-row-combined"><div>081F-0831</div><div><a href="#0716H" class="memory-link">CALL 0716H<span class="origrom2" style="display: inline;">CALL FADD</span></a><span class="opcode2" style="display: none;">CD 16 07</span></div><div>Calculate
 (F-SQR(.5))/(F+SQR(.5)) where F = the number in the ACCumulator by 
GOSUBing to FADD which will add the x-value to the single precision 
constant in Register Pairs BC and DE and return with the result in the 
ACCumulator, by calling the SINGLE PRECISION ADD routine at 0716H (which
 adds the single precision value in (BC/DE) to the single precision 
value in the ACCumulator. The sum is left in the ACCumulator)</div></div>
									<p class="debug-note">The next two instructions restore SQR(.5) from the STACK</p>
									<div class="assembly-row-combined"><div>0822</div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>Get the exponent and the MSB of the single precision value from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>0823</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Get the NMSB and the LSB of the single precision value from the STACK and put it in Register Pair DE</div></div>
									<p class="debug-note">The next two instructions get SQR(2)</p>
									<div class="assembly-row-combined"><div>0824</div><div>INC B<span class="opcode2" style="display: none;">04</span></div><div>Multiply the single precision value in Register Pairs BC and DE by two by bumping the exponent in Register B</div></div>
									<div class="assembly-row-combined"><div>0825-0827</div><div><a href="#08A2H" class="memory-link">CALL 08A2H<span class="origrom2" style="display: inline;">CALL FDIV</span></a><span class="opcode2" style="display: none;">CD A2 08</span></div><div>Go
 divide the single precision value in Register Pairs BC and DE by the 
x-value in the ACCumulator and return with the result in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0828-082A</div><div>LD HL,07F8H<span class="origrom2" style="display: inline;">LD HL,FONE</span><span class="opcode2" style="display: none;">21 F8 07</span></div><div>Load Register Pair HL with the starting address of a single precision constant (which is at 2040)</div></div>
									<div class="assembly-row-combined"><div>082B-082D</div><div><a href="#0710H" class="memory-link">CALL 0710H<span class="origrom2" style="display: inline;">CALL FSUBS</span></a><span class="opcode2" style="display: none;">CD 10 07</span></div><div>Go
 subtract the x-value in the ACCumulator from the single precision 
constant of 1. 0 at the location of the memory pointer in Register Pair 
HL and return with the result in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>082E-0830</div><div>LD HL,07FCH<span class="origrom2" style="display: inline;">LD HL,LOGCN2</span><span class="opcode2" style="display: none;">21 FC 07</span></div><div>Load
 Register Pair HL with the starting address of a storage location for 
the single precision constants of a "approximation polynomial" to be 
used.</div></div>
									<div class="assembly-row-combined"><div>0831-0833</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#149AH" class="memory-link">CALL 149AH<span class="origrom2" style="display: inline;">CALL POLYX</span></a><span class="opcode2" style="display: none;">CD 9A 14</span></div><div>Go do a series of computations and return with the result in the ACCumulator</div></div>
									<p class="debug-note">The next two instructions are commented in the original ROM source code as: Get -1/2</p>
									<div class="assembly-row-combined"><div>0834-0836</div><div>LD BC,8080H<span class="opcode2" style="display: none;">01 80 80</span></div><div>Load Register BC with the exponent and the MSB of a single precision constant</div></div>
									<div class="assembly-row-combined"><div>0837-0839</div><div>LD DE,0000H<span class="opcode2" style="display: none;">11 00 00</span></div><div>Load
 Register Pair DE with the NMSB and the LSB of a single precision. 
Register Pairs BC and DE are now equal to a single precision of -0.5</div></div>
									<div class="assembly-row-combined"><div>083A-083C</div><div><a href="#0716H" class="memory-link">CALL 0716H<span class="origrom2" style="display: inline;">CALL FADD</span></a><span class="opcode2" style="display: none;">CD 16 07</span></div><div>Add
 in the last constant via a GOSUB to FADD which will add the x-value in 
the ACCumulator to the single precision constant in Register Pairs BC 
and DE and return with the result in the ACCumulator, by calling the 
SINGLE PRECISION ADD routine at 0716H (which adds the single precision 
value in (BC/DE) to the single precision value in the ACCumulator. The 
sum is left in the ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>083D</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Retrieve the original exponent from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>083E-0840</div><div><a href="#0F89H" class="memory-link">CALL 0F89H<span class="origrom2" style="display: inline;">CALL FINLOG</span></a><span class="opcode2" style="display: none;">CD 89 0F</span></div><div>Go
 convert the value in Register A to a single precision number and add it
 to the x-value in the ACCumulator.  Return with the result in the 
ACCumulator</div></div>
									<p class="debug-note">The instructions are commented in the original ROM source code as: Get LN(2)</p>
									<div class="assembly-row-combined"><div>0841-0843<span class="origrom2" style="display: inline;">MULLN2</span></div><div>LD BC,8031H<span class="opcode2" style="display: none;">01 31 80</span></div><div>Load Register Pair BC with the exponent and the MSB of a single precision constant</div></div>
									<div class="assembly-row-combined"><div>0844-0846</div><div>LD DE,7218H<span class="opcode2" style="display: none;">11 18 72</span></div><div>Load
 Register Pair DE with the NMSB and the LSB of a single precision 
constant. Register Pairs BC and DE are now equal to a single precision 
value of 0.693147</div></div>
									<p class="debug-note">The original ROM source code had a jump 
to the muptlication routine; but to save bytes, the ROM was restructured
 to just fall into the MULTiplocation routine instead.</p>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0847H">0847H-0891H - SINGLE PRECISION MULTIPLICATION,<span class="origrom">- "FMULT"<br></span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Single-precision multiplication (ACCumulator=BCDE*ACC or ACC = ARG * FAC)).<br>Multiplies the current value in the ACCumulator by the value in (BC/DE). the product is left in the ACCumulator.<br><br>Note:
 If you wanted to multiply two single precision numbers store one 
operand in the BCDE registers, the other in 4121H-4124H CALL 0847H.  The
 result (in single precision format) is in 4121H-4124H in approximately 
2.2 milliseconds.<br><br>Single Precision Multiply Multiplies the 
current value in the ACCumulator by the value in (BC/DE). the product is
 left in the ACCumulator<br><br>This routine alters every Register. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0847-0849<span class="origrom2" style="display: inline;">FMULT</span></div><div><a href="#0955H" class="memory-link">CALL 0955H<span class="origrom2" style="display: inline;">CALL SIGN</span></a><span class="opcode2" style="display: none;">CD 55 09</span></div><div>Go check to see if the single precision value in the ACCumulator is equal to zero</div></div>
									<div class="assembly-row-combined"><div>084A</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>Return if the single precision value in the ACCumulator is equal to zero</div></div>
									<div class="assembly-row-combined" id="084BH"><div>084B-084C</div><div>LD L,00H<span class="opcode2" style="display: none;">2E 00</span></div><div>Since we don't have a zero, the next step is to add the two exponents using L as a flag, so load Register L with 0</div></div>
									<div class="assembly-row-combined"><div>084D-084F</div><div><a href="#0914H" class="memory-link">CALL 0914H<span class="origrom2" style="display: inline;">CALL MULDIV</span></a><span class="opcode2" style="display: none;">CD 14 09</span></div><div>Next we need to fix up the exponents and save the numbers in the registers for faster addition.</div></div>
									<div class="assembly-row-combined"><div>0850</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with the single precision value's High Order/MSB in Register C</div></div>
									<div class="assembly-row-combined"><div>0851-0853</div><div>LD (414FH),A<span class="origrom2" style="display: inline;">LD (FMLTT1),A</span><span class="opcode2" style="display: none;">32 4F 41</span></div><div>Save the MSB of the single precision value in Register A at memory location 414FH</div></div>
									<div class="assembly-row-combined"><div>0854</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Load Register Pair HL with the NMSB and the LSB of the single precision value in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0855-0857</div><div>LD (4150H),HL<span class="origrom2" style="display: inline;">LD (FMLTT2),HL</span><span class="opcode2" style="display: none;">22 50 41</span></div><div>Save the NMSB and the LSB of the single precision value in Register Pair HL at memory locations 4150H and 4151H</div></div>
									<div class="assembly-row-combined"><div>0858-085A</div><div>LD BC,0000H<span class="opcode2" style="display: none;">01 00 00</span></div><div>Load Register Pair BC with a zero, which we will also put into Register D and Register E</div></div>
									<div class="assembly-row-combined"><div>085B</div><div>LD D,B<span class="opcode2" style="display: none;">50</span></div><div>Load Register D with the value in Register B</div></div>
									<div class="assembly-row-combined"><div>085C</div><div>LD E,B<span class="opcode2" style="display: none;">58</span></div><div>Load Register E with the value in Register B</div></div>
									<div class="assembly-row-combined"><div>085D-085F</div><div>LD HL,0765H<span class="origrom2" style="display: inline;">LD HL,NORMAL</span><span class="opcode2" style="display: none;">21 65 07</span></div><div>Load Register Pair HL with the return address</div></div>
									<div class="assembly-row-combined"><div>0860</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the return address in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0861-0863</div><div>LD HL,0869H<span class="origrom2" style="display: inline;">LD HL,FMULT2</span><span class="opcode2" style="display: none;">21 69 08</span></div><div>Load Register Pair HL with the return address</div></div>
									<div class="assembly-row-combined"><div>0864</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the return address in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0865</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the return address in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0866-0868</div><div>LD HL,4121H<span class="origrom2" style="display: inline;">LD HL,FACLO</span><span class="opcode2" style="display: none;">21 21 41</span></div><div>Load Register Pair HL with the low order/LSB address of the single precision value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0869<span class="origrom2" style="display: inline;">FMULT2</span></div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load Register A with the byte to multiply by (on entry its the LSB of the single precision value in the ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>086A</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the memory pointer in Register Pair HL to point to the next byte of the number in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>086B</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the LSB of the single precision value in the ACCumulator in Register A is equal to zero</div></div>
									<div class="assembly-row-combined"><div>086C-086D</div><div><a href="#0892H" class="memory-link">JR Z,0892H<span class="origrom2" style="display: inline;">JR Z,FMULT3</span></a><span class="opcode2" style="display: none;">28 24</span></div><div>Jump if the LSB of the single precision value in the ACCumulator is equal to zero</div></div>
									<div class="assembly-row-combined"><div>086E</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the memory pointer to the number in the ACCumulator (tracked by Register HL) on the STACK</div></div>
									<div class="assembly-row-combined"><div>086F-0870</div><div>LD L,08H<span class="opcode2" style="display: none;">2E 08</span></div><div>Load Register L with the bit shift counter</div></div>
									<p class="debug-note">The original source code explains what is
 being done next.  The product will be formed in C/D/E/B.  This will be 
in C/H/L/B part of the time in order to use the "DAD" instruction.  At 
FMULT2, we get the next byte of the mantissa in the ACCumulator to 
multiply by, which is tracked by HL and unchanged by FMULT2.  If the 
byte is zero, we just shift the product 8 bits to the right.  This byte 
is then shifted right and saved in Register D.  The CARRY FLAG 
determines if we should add in the second factor, and, if we do, we add 
it to C/H/L. Register B is only used to determine which way we round. We
 then shift C/H/L/B right one to get ready for the next time through the
 loop. Note: The CARRY is shifted into the MSB of Register C.  Register E
 has the count to determine when we have looked at all the bits of 
Register D.</p>
									<div class="assembly-row-combined"><div>0871<span class="origrom2" style="display: inline;">FMULT4</span></div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Shift
 the LSB of the single precision value in the ACCumulator in Register A 
one place to the right.  RRA rotates the contents of Register A right 
one bit position, with Bit 0 going to the CARRY FLAG, and the CARRY FLAG
 going to Bit 7.  RRA also can be used to divide a number in 2.</div></div>
									<div class="assembly-row-combined"><div>0872</div><div>LD H,A<span class="opcode2" style="display: none;">67</span></div><div>Load Register H with the adjusted LSB in Register A</div></div>
									<div class="assembly-row-combined"><div>0873</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with the MSB of the single precision value in Register C</div></div>
									<div class="assembly-row-combined"><div>0874-0875</div><div><a href="#0881H" class="memory-link">JR NC,0881H<span class="origrom2" style="display: inline;">JR NC,FMULT5</span></a><span class="opcode2" style="display: none;">30 0B</span></div><div>If the bit was zero, don't add in any numbers and, instead, jump forward to 0881H</div></div>
									<div class="assembly-row-combined"><div>0876</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the counters (tracked in Register Pair HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>0877-0879</div><div>LD HL,(4150H)<span class="origrom2" style="display: inline;">LD HL,(FMLTT2)</span><span class="opcode2" style="display: none;">2A 50 41</span></div><div>Load Register Pair HL with the NMSB and the LSB of the original value in Register Pairs BC and DE</div></div>
									<div class="assembly-row-combined"><div>087A</div><div>ADD HL,DE<span class="opcode2" style="display: none;">19</span></div><div>Add
 the NMSB and the LSB of the total figured so far in Register Pair DE to
 the NMSB and the LSB of the original value in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>087B</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Load Register Pair DE with the adjusted total in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>087C</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the counters back from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>087D-087F</div><div>LD A,(414FH)<span class="origrom2" style="display: inline;">LD A,(FMLTT1)</span><span class="opcode2" style="display: none;">3A 4F 41</span></div><div>Load Register A with the MSB of the original value in Register Pairs BC and DE</div></div>
									<div class="assembly-row-combined"><div>0880</div><div>ADC A,C<span class="opcode2" style="display: none;">89</span></div><div>Add the MSB of the original value in Register A to the MSB of the total figured so far in Register C</div></div>
									<div class="assembly-row-combined"><div>0881<span class="origrom2" style="display: inline;">FMULT5</span></div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Shift
 the adjusted MSB of the total in Register A one place to the right.  
RRA rotates the contents of Register A right one bit position, with Bit 0
 going to the CARRY FLAG, and the CARRY FLAG going to Bit 7.  RRA also 
can be used to divide a number in 2.</div></div>
									<div class="assembly-row-combined"><div>0882</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the adjusted MSB of the total in Register A</div></div>
									<div class="assembly-row-combined"><div>0883</div><div>LD A,D<span class="opcode2" style="display: none;">7A</span></div><div>Load Register A with the NMSB of the total in Register D</div></div>
									<div class="assembly-row-combined"><div>0884</div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Shift
 the NMSB of the total in Register A one place to the right.  RRA 
rotates the contents of Register A right one bit position, with Bit 0 
going to the CARRY FLAG, and the CARRY FLAG going to Bit 7.  RRA also 
can be used to divide a number in 2.</div></div>
									<div class="assembly-row-combined"><div>0885</div><div>LD D,A<span class="opcode2" style="display: none;">57</span></div><div>Load Register D with the adjusted NMSB of the total in Register A</div></div>
									<div class="assembly-row-combined"><div>0886</div><div>LD A,E<span class="opcode2" style="display: none;">7B</span></div><div>Load Register A with the LSB of the total in Register E</div></div>
									<div class="assembly-row-combined"><div>0887</div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Shift
 the LSB of the total in Register A one place to the right.  RRA rotates
 the contents of Register A right one bit position, with Bit 0 going to 
the CARRY FLAG, and the CARRY FLAG going to Bit 7.  RRA also can be used
 to divide a number in 2.</div></div>
									<div class="assembly-row-combined"><div>0888</div><div>LD E,A<span class="opcode2" style="display: none;">5F</span></div><div>Load Register E with the adjusted LSB of the total in Register A</div></div>
									<div class="assembly-row-combined"><div>0889</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Load Register A with the value in Register B</div></div>
									<div class="assembly-row-combined"><div>088A</div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Shift
 the value in Register A one place to the right.  RRA rotates the 
contents of Register A right one bit position, with Bit 0 going to the 
CARRY FLAG, and the CARRY FLAG going to Bit 7.  RRA also can be used to 
divide a number in 2.</div></div>
									<div class="assembly-row-combined"><div>088B</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Load Register B with the adjusted value in Register A</div></div>
									<div class="assembly-row-combined"><div>088C</div><div>DEC L<span class="opcode2" style="display: none;">2D</span></div><div>Decrement the bit counter in Register L and set the flags accordingly</div></div>
									<div class="assembly-row-combined"><div>088D</div><div>LD A,H<span class="opcode2" style="display: none;">7C</span></div><div>Load Register A with the LSB of the number we are multiplying</div></div>
									<div class="assembly-row-combined"><div>088E-088F</div><div><a href="#0871H" class="memory-link">JR NZ,0871H<span class="origrom2" style="display: inline;">JR NZ,FMULT4</span></a><span class="opcode2" style="display: none;">20 E1</span></div><div>Loop until 8 bits have been shifted.</div></div>
									<div class="assembly-row-combined"><div>0890<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;POPHRT</span></div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the memory pointer to the number to multiply by from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0891</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0892H">0892H-0896H - SINGLE PRECISION MATH ROUTINE<span class="origrom">- "FMULT3"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is accomplished by a circular shift of BC/DE one byte - B is lost, C is replaced by A<br><br>This is a multiply by zero, where we just shift everything 8 bits to the right.<br><br></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0892<span class="origrom2" style="display: inline;">FMULT3</span></div><div>LD B,E<span class="opcode2" style="display: none;">43</span></div><div>Load Register B with the LSB of the single precision value in Register E</div></div>
									<div class="assembly-row-combined"><div>0893</div><div>LD E,D<span class="opcode2" style="display: none;">5A</span></div><div>Load Register E with the NMSB of the single precision value in Register D</div></div>
									<div class="assembly-row-combined"><div>0894</div><div>LD D,C<span class="opcode2" style="display: none;">51</span></div><div>Load Register D with the MSB of the single precision value in Register C</div></div>
									<div class="assembly-row-combined"><div>0895</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the value in Register A (which should be all 0's, which will now be on the left)</div></div>
									<div class="assembly-row-combined"><div>0896</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0897H">0897H-08A1H - SINGLE PRECISION MATH ROUTINE<span class="origrom"><br>- "DIV10"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine divides the ACCumulator by 10.  Every Register is used.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0897-0899<span class="origrom2" style="display: inline;">DIV10</span></div><div><a href="#09A4H" class="memory-link">CALL 09A4H<span class="origrom2" style="display: inline;">CALL PUSHF</span></a><span class="opcode2" style="display: none;">CD A4 09</span></div><div>Save
 the number via a GOSUB to 09A4 which moves the SINGLE PRECISION value 
in the ACCumulator to the STACK (stored in LSB/MSB/Exponent order)</div></div>
									<div class="assembly-row-combined"><div>089A-089C</div><div>LD HL,0DD8H<span class="origrom2" style="display: inline;">LD HL,FTEN</span><span class="opcode2" style="display: none;">21 D8 0D</span></div><div>Load Register Pair HL with the starting address of a single precision constant equal to 10</div></div>
									<div class="assembly-row-combined"><div>089D-089F</div><div><a href="#09B1H" class="memory-link">CALL 09B1H<span class="origrom2" style="display: inline;">CALL MOVFM</span></a><span class="opcode2" style="display: none;">CD B1 09</span></div><div>Move the "10" into the ACCUulator via a call to 09B1H (which moves a SINGLE PRECISION number pointed to by HL to ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>08A0<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;FDIVT</span></div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>Get the exponent and the MSB of the single precision value on the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>08A1</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Get the NMSB and the LSB of the single precision value from the STACK and put it in Register Pair DE</div></div>
									<p class="debug-note">With the numbers in their places, we now just fall into the floating division routine.</p>
								</div>
							</div>

							<h2 class="assembly-section-title" id="08A2H">08A2H-0903H - SINGLE PRECISION DIVISION<span class="origrom">- "FDIV"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Single-precision division (ACCumulator=BCDE/ACCumulator or ACC = ARG / ACC). If ACCumulator=0 a " /0 ERROR " will result.<br><br>This
 routine will divide the SINGLE PRECISION value in Register Pairs BC and
 DE by the single precision value in the ACCumulator.  The result is 
returned in the ACCumulator.  Every register is used.<br><br>To use a 
ROM call to divide two single precision numbers, store the dividend in 
registers BCDE, and the divisor in 4121H-4124H and then CALL 08A2H.  The
 result (in single precision format) is in 4121H-4124H and then 
pproximately 4.8 milliseconds.  Overflow or /0 will error out and return
 to Level II. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>08A2-08A4<span class="origrom2" style="display: inline;">FDIV</span></div><div><a href="#0955H" class="memory-link">CALL 0955H<span class="origrom2" style="display: inline;">CALL SIGN</span></a><span class="opcode2" style="display: none;">CD 55 09</span></div><div>Go check to see if the single precision value in the ACCumulator is equal to zero so as to process that error.</div></div>
									<div class="assembly-row-combined"><div>08A5-08A7</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#199AH" class="memory-link">JP Z,199AH<span class="origrom2" style="display: inline;">JP Z,DV0ERR</span></a><span class="opcode2" style="display: none;">CA 9A 19</span></div><div>If
 the SIGN routine retuns Z FLAG set, then we have a division by zero 
problem so JUMP to the Level II BASIC error routine and display an /0 
ERROR message</div></div>
									<div class="assembly-row-combined"><div>08A8-08A9</div><div>LD L,FFH<span class="opcode2" style="display: none;">2E FF</span></div><div>Load Register L with a flag for use when subtracting the two exponents.</div></div>
									<div class="assembly-row-combined"><div>08AA-08AC</div><div><a href="#0914H" class="memory-link">CALL 0914H<span class="origrom2" style="display: inline;">CALL MULDIV</span></a><span class="opcode2" style="display: none;">CD 14 09</span></div><div>Go adjust the exponent in the ACCumulator for division</div></div>
									<div class="assembly-row-combined"><div>08AD<br>08AE</div><div>INC (HL)<br>INC (HL)<span class="opcode2" style="display: none;">34</span></div><div>Add two to the exponent pointed to by (HL) to correct scaling</div></div>
									<div class="assembly-row-combined"><div>08AF</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement
 the value of the memory pointer in Register Pair HL to now point to the
 High Order/MSB of the single precision number in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>08B0</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load Register A with the MSB of the single precision value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>08B1-08B3</div><div>LD (4089H),A<span class="origrom2" style="display: inline;">LD (FDIVA+1),A</span><span class="opcode2" style="display: none;">32 89 40</span></div><div>Save the MSB of the single precision value in the ACCumulator in Register A at memory location 4089H</div></div>
									<div class="assembly-row-combined"><div>08B4</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement
 the value of the memory pointer in Register Pair HL to point to the 
Middle Order/NMSB of the single precision number in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>08B5</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load
 Register A with the NMSB of the single precision value in the 
ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>08B6-08B8</div><div>LD (4085H),A<span class="origrom2" style="display: inline;">LD (FDIVB+1),A</span><span class="opcode2" style="display: none;">32 85 40</span></div><div>Save the NMSB of the single precision value in the ACCumulator in Register A at memory location 4085H</div></div>
									<div class="assembly-row-combined"><div>08B9</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement
 the value of the memory pointer in Register Pair HL to point to the Low
 Order/LSB of the single precision number in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>08BA</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load
 Register A with the LSB of the single precision value in the 
ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>08BB-08BD</div><div>LD (4081H),A<span class="origrom2" style="display: inline;">LD (FDIVC+1),A</span><span class="opcode2" style="display: none;">32 81 40</span></div><div>Save the LSB of the single precision value in the ACCumulator in Register A at memory location 4081H</div></div>
									<p class="debug-note">At this point, the memory locations are set up, and it's time to get to work.  According to the original ROM source:<br><br>The
 numerator will be kept in Registers B/H/L.  The quotient will be formed
 in Registers C/D/E. To get a bit of the quotient, we first save 
Registers B/H/L on the stack, and then subtract the denominator that we 
saved in memory.  The CARRY FLAG will indicate whether or not Registers 
B/H/L was bigger than the denominator.  If Registers B/H/L are bigger, 
the next bit of the quotient is a one.  To get the old Registers B/H/L 
off the stack, they are POPped into the PSW.  If the denominator was 
bigger, the next bit of the quotient is zero, and we get the old 
Registers B/H/L back by POPping them off the stack.  We have to keep an 
extra bit of the quotient in FDIVG+1 in case the denominator was bigger,
 in which case Registers B/H/L will get shifted left.  If the MSB of 
Register B is one, it has to be stored somewhere, so we store it in 
FDIVG+1.  Then the next time through the loop Registers B/H/L will look 
bigger because it has an extra High Order bit in FDIVG+1.  We are done 
dividing when the MSB of Register C is a one, which occurs when we have 
calculated 24 bits of the quotient.  When we jump to ROUND, the 25th bit
 of the quotient (whcih is in the MSB of Register A) determines whether 
we round or not.  If initially the denominator is bigger than the 
numerator, the first bit of the quotient will be zero.  This means we 
will go through the divide loop 26 times, since it stops on the 25th bit
 after the first non-zero bit of the exponent.  So, this quotient will 
look shifted left one from the quotient of two numbers in which the 
numerator is bigger.  This can only occur on the first time through the 
loop, so Registers C/D/E are all zero.  So, if we finish the loop and 
Registers C/D/E are all zero, then we must decrement the exponent to 
correct for this. </p>
									<div class="assembly-row-combined"><div>08BE</div><div>LD B,C<span class="opcode2" style="display: none;">41</span></div><div>First,
 we need to get the number into B/H/L.  First, load Register B with the 
MSB of the single precision dividend (held in in Register C)</div></div>
									<div class="assembly-row-combined"><div>08BF</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Then, get the NMSB and LSB of the dividend from DE into Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>08C0</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Next, we need to zero out C, D, E, and the Highest Order</div></div>
									<div class="assembly-row-combined"><div>08C1</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Zero the MSB of the total by loading Register C with the value in Register A</div></div>
									<div class="assembly-row-combined"><div>08C2</div><div>LD D,A<span class="opcode2" style="display: none;">57</span></div><div>Zero the NMSB of the total by loading Register D with the value in Register A</div></div>
									<div class="assembly-row-combined"><div>08C3</div><div>LD E,A<span class="opcode2" style="display: none;">5F</span></div><div>Zero the LSB of the total by loading Register E with the value in Register A</div></div>
									<div class="assembly-row-combined"><div>08C4-08C6</div><div>LD (408CH),A<span class="origrom2" style="display: inline;">LD (FDIVG+1),A</span><span class="opcode2" style="display: none;">32 8C 40</span></div><div>Zero memory location 408CH (which is holding the highest order)</div></div>
									<div class="assembly-row-combined"><div>08C7<span class="origrom2" style="display: inline;">FDIV1</span></div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the NMSB and LSB of the single precision dividend (held in Register Pair HL) on the STACK</div></div>
									<div class="assembly-row-combined"><div>08C8</div><div>PUSH BC<span class="opcode2" style="display: none;">C5</span></div><div>Save the MSB of the dividend in Register B on the STACK</div></div>
									<div class="assembly-row-combined"><div>08C9</div><div>LD A,L<span class="opcode2" style="display: none;">7D</span></div><div>Next
 we will need to subtract the number that was in the ACCumulator, so 
load Register A with the LSB of the dividend in Register L</div></div>
									<div class="assembly-row-combined"><div>08CA-08CC</div><div><a href="https://www.trs-80.com/sub-disassem-dos-td23-sys-0.htm#4080H" class="memory-link">CALL 4080H<span class="origrom2" style="display: inline;">CALL FDIVC</span></a><span class="opcode2" style="display: none;">CD 80 40</span></div><div>Go
 to the Level II BASIC division routine.  Note: Per the original ROM 
source code, this division routine was moved to RAM for speed; it didn't
 HAVE to be moved!</div></div>
									<div class="assembly-row-combined"><div>08CD-08CE</div><div>SBC 00H<span class="opcode2" style="display: none;">DE 00</span></div><div>Subtract the CARRY FLAG from it</div></div>
									<div class="assembly-row-combined"><div>08CF</div><div>CCF<span class="opcode2" style="display: none;">3F</span></div><div>Set the CARRY FLAG to correspond to the next quotient bit</div></div>
									<div class="assembly-row-combined"><div>08D0-08D1</div><div><a href="#08D9H" class="memory-link">JR NC,08D9H<span class="origrom2" style="display: inline;">JR NC,FDIV2</span></a><span class="opcode2" style="display: none;">30 07</span></div><div>If
 we subtracted too much then the NC flag will be set, in which case we 
need to get the old number back!  To do this, JUMP down to 08D9H (which 
is a mid-instruction Z-80 trick)</div></div>
									<div class="assembly-row-combined"><div>08D2-08D4</div><div>LD (408CH),A<span class="origrom2" style="display: inline;">LD (FDIVG+1),A</span><span class="opcode2" style="display: none;">32 8C 40</span></div><div>Update the highest order number held at FDIVG+1</div></div>
									<div class="assembly-row-combined"><div>08D5</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>We want to clear the previous number off the stack since the subtraction didn't cause an error</div></div>
									<div class="assembly-row-combined"><div>08D6</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>And again</div></div>
									<div class="assembly-row-combined"><div>08D7</div><div>SCF<span class="opcode2" style="display: none;">37</span></div><div>Set the CARRY FLAG so that the next bit in the quotient is a 1 to indicate that the subtraction was good</div></div>
									<div class="assembly-row-combined"><div>08D8</div><div>D2<span class="opcode2" style="display: none;">D2 C1 E1</span></div><div>Z-80 Trick - See <a href="#0134H" class="memory-link">the note at 0134H</a>for an explanation</div></div>
									<div class="assembly-row-combined"><div>08D9<span class="origrom2" style="display: inline;">FDIV2</span></div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>If
 we JUMP here, then the subtraction was too much and we need to get the 
old number from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>08DA</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>... and get the old number back into Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>08DB</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>We want to see if we are done by testing Register C, so load Register A with the MSB of the total in Register C</div></div>
									<div class="assembly-row-combined"><div>08DC<br>08DD</div><div>INC A<br>DEC A<span class="opcode2" style="display: none;">3C</span></div><div>Increment and then Decrement the MSB of the total in Register A.  This will set the SIGN FLAG without affecting the CARRY FLAG</div></div>
									<div class="assembly-row-combined"><div>08DE</div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Shift
 the CARRY into the MSB (held in Register A).  RRA rotates the contents 
of Register A right one bit position, with Bit 0 going to the CARRY 
FLAG, and the CARRY FLAG going to Bit 7.  RRA also can be used to divide
 a number in 2.</div></div>
									<div class="assembly-row-combined"><div>08DF-08E1</div><div><a href="#0797H" class="memory-link">JP M,0797H<span class="origrom2" style="display: inline;">JP M,ROUNDB</span></a><span class="opcode2" style="display: none;">FA 97 07</span></div><div>If we are done, JUMP back to ROUNDB</div></div>
									<div class="assembly-row-combined"><div>08E2</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>If we are here, then we aren't done.  First, we need to get the old CARRY FLAG back via a RLA</div></div>
									<div class="assembly-row-combined"><div>08E3</div><div>LD A,E<span class="opcode2" style="display: none;">7B</span></div><div>Next, we are going to rotate EVERYTHING left 1 bit.  Load Register A with the LSB of the total in Register E</div></div>
									<div class="assembly-row-combined"><div>08E4</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Rotate the next bit of the quotient in</div></div>
									<div class="assembly-row-combined"><div>08E5</div><div>LD E,A<span class="opcode2" style="display: none;">5F</span></div><div>Load Register E with the adjusted LSB of the total in Register A</div></div>
									<div class="assembly-row-combined"><div>08E6</div><div>LD A,D<span class="opcode2" style="display: none;">7A</span></div><div>Load Register A with the NMSB of the total in Register D</div></div>
									<div class="assembly-row-combined"><div>08E7</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Rotate the next bit of the quotient in</div></div>
									<div class="assembly-row-combined"><div>08E8</div><div>LD D,A<span class="opcode2" style="display: none;">57</span></div><div>Load Register D with the adjusted NMSB of the total in Register A</div></div>
									<div class="assembly-row-combined"><div>08E9</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with the MSB of the total in Register C</div></div>
									<div class="assembly-row-combined"><div>08EA</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Rotate the next bit of the quotient in</div></div>
									<div class="assembly-row-combined"><div>08EB</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the adjusted MSB of the total in Register A</div></div>
									<div class="assembly-row-combined"><div>08EC</div><div>ADD HL,HL<span class="opcode2" style="display: none;">29</span></div><div>Almost done!  Rotate a zero into the right end of the number</div></div>
									<div class="assembly-row-combined"><div>08ED</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Next, rotate the High Order/MSB of the dividend in Register B</div></div>
									<div class="assembly-row-combined"><div>08EE</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Rotate the next bit of the quotient in</div></div>
									<div class="assembly-row-combined"><div>08EF</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Load Register B with the adjusted MSB of the dividend in Register A</div></div>
									<div class="assembly-row-combined"><div>08F0-08F2</div><div>LD A,(408CH)<span class="origrom2" style="display: inline;">LD A,(FDIVG+1)</span><span class="opcode2" style="display: none;">3A 8C 40</span></div><div>Next, rotate the HIGHEST order.  Load Register A with the value at memory location 408CH</div></div>
									<div class="assembly-row-combined"><div>08F3</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Rotate the next bit of the quotient in</div></div>
									<div class="assembly-row-combined"><div>08F4-08F6</div><div>LD (408CH),A<span class="origrom2" style="display: inline;">LD (FDIVG+1),A</span><span class="opcode2" style="display: none;">32 8C 40</span></div><div>Save the adjusted value in Register A at memory location 408CH</div></div>
									<div class="assembly-row-combined"><div>08F7</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Next
 we need to add one to the exponent if the first subtraction didn't 
work.  To do so, first load Register A with the MSB of the total in 
Register C</div></div>
									<div class="assembly-row-combined"><div>08F8</div><div>OR D<span class="opcode2" style="display: none;">B2</span></div><div>Combine the NMSB of the total in Register D with the value in Register A</div></div>
									<div class="assembly-row-combined"><div>08F9</div><div>OR E<span class="opcode2" style="display: none;">B3</span></div><div>Combine the LSB of the total in Register E with the value in Register A</div></div>
									<div class="assembly-row-combined"><div>08FA-08FB</div><div><a href="#08C7H" class="memory-link">JR NZ,08C7H<span class="origrom2" style="display: inline;">JR NZ,FDIV1</span></a><span class="opcode2" style="display: none;">20 CB</span></div><div>Jump back to 08C7H if the total isn't equal to zero</div></div>
									<div class="assembly-row-combined"><div>08FC</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the NMSB and the LSB of the dividend in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>08FD-08FF</div><div>LD HL,4124H<span class="origrom2" style="display: inline;">LD HL,FAC</span><span class="opcode2" style="display: none;">21 24 41</span></div><div>Load Register Pair HL with the address of the exponent in the ACCumulator</div></div>
									<div class="assembly-row-combined" id="0900H"><div>0900</div><div>DEC (HL)<span class="opcode2" style="display: none;">35</span></div><div>Decrement the exponent in the ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0901</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the NMSB and the LSB of the dividend from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0902-0903</div><div><a href="#08C7H" class="memory-link">JR NZ,08C7H<span class="origrom2" style="display: inline;">JR NZ,FDIV1</span></a><span class="opcode2" style="display: none;">20 C3</span></div><div>Keep dividing if there was no overflow by JUMPING back to 08C7H if the exponent in the ACCumulator isn't equal to zero</div></div>
									<div class="assembly-row-combined"><div>0904-0906</div><div><a href="#07B2H" class="memory-link">JP 07B2H<span class="origrom2" style="display: inline;">JP OVERR</span></a><span class="opcode2" style="display: none;">C3 B2 07</span></div><div>Display an <span class="code">?OV ERROR</span>.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0907H">0907H-0913H - DOUBLE PRECISION MATH ROUTINE<span class="origrom">- "MULDVS"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine is to check for special cases and to add 
exponents for the FMULT and FDIV routines.  Registers A, B, H and L are 
modified.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0907-0908<span class="origrom2" style="display: inline;">MULDVS</span></div><div>LD A,FFH<span class="opcode2" style="display: none;">3E FF</span></div><div>This
 is the entry point from the DDIV routine.  With this, we need to set up
 to subtract exponents.  To do this we load Register A with an 
appropriate bit mask</div></div>
									<div class="assembly-row-combined"><div>0909</div><div>LD L,0AFH<span class="opcode2" style="display: none;">2E AF</span></div><div>Z-80 Trick.  If we are passing through, the Register L will change, but the XOR in 090A will not trigger.</div></div>
									<div class="assembly-row-combined"><div>090A<span class="origrom2" style="display: inline;">MULDVA</span></div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>This
 is the entry point from the DMULT routine.  With this, we need to set 
up to ADD exponents.  To do this we load Register A with an appropriate 
bit mask</div></div>
									<div class="assembly-row-combined"><div>090B-090D</div><div>LD HL,412DH<span class="origrom2" style="display: inline;">LD HL,ARG-1</span><span class="opcode2" style="display: none;">21 2D 41</span></div><div>Load Register Pair HL with the address of the SIGN and the High/Order MSB in ARG (a/k/a REG 2) (a/k/a ARG)</div></div>
									<div class="assembly-row-combined"><div>090E</div><div>LD C,(HL)<span class="opcode2" style="display: none;">4E</span></div><div>Load Register C with the High Order/MSB and the sign of the value in ARG (a/k/a REG 2) for unpacking</div></div>
									<div class="assembly-row-combined"><div>090F</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the value of the memory pointer in Register Pair HL to now point to the exponent</div></div>
									<div class="assembly-row-combined"><div>0910</div><div>XOR (HL)<span class="opcode2" style="display: none;">AE</span></div><div>Get the exponent by XORing the mask in Register A (which varied based on where this routine was entered from)</div></div>
									<div class="assembly-row-combined"><div>0911</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Save the adjusted exponent into Register B for processing below</div></div>
									<div class="assembly-row-combined"><div>0912-0913</div><div>LD L,00H<span class="opcode2" style="display: none;">2E 00</span></div><div>Load
 Register L with a 00H which will indicate that the below routine needs 
to ADD the exponents and then pass through to the MULDIV routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0914H">0914H-0930H - SINGLE PRECISION MATH ROUTINE<span class="origrom">- "MULDIV"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0914<span class="origrom2" style="display: inline;">MULDIV</span></div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>First we should test to make sure that the number isn't zero, so Load Register A with the exponent in Register B</div></div>
									<div class="assembly-row-combined"><div>0915</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the exponent in Register A is equal to zero</div></div>
									<div class="assembly-row-combined"><div>0916-0917</div><div><a href="#0937H" class="memory-link">JR Z,0937H<span class="origrom2" style="display: inline;">JR Z,MULDV2</span></a><span class="opcode2" style="display: none;">28 1F</span></div><div>If
 the exponent in Register A is equal to zero then we just need to ZERO 
out the ACCumulator and we are done.  Do that by JUMPing to 0937H </div></div>
									<div class="assembly-row-combined"><div>0918</div><div>LD A,L<span class="opcode2" style="display: none;">7D</span></div><div>Next,
 we need to determine if we are ADDing or SUBtracting, which is held in 
Register L.  So load Register A with the bit mask in Register L</div></div>
									<div class="assembly-row-combined"><div>0919-091B</div><div>LD HL,4124H<span class="origrom2" style="display: inline;">LD HL,FAC</span><span class="opcode2" style="display: none;">21 24 41</span></div><div>Load Register Pair HL with the address of the exponent in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>091C</div><div>XOR (HL)<span class="opcode2" style="display: none;">AE</span></div><div>Combine
 the value of the exponent at the location of  the memory pointer in 
Register Pair HL with the bit mask in Register A (formerly of Register 
L)</div></div>
									<div class="assembly-row-combined"><div>091D</div><div>ADD A,B<span class="opcode2" style="display: none;">80</span></div><div>Add the value of the exponent in Register B to the value of the exponent in Register A</div></div>
									<div class="assembly-row-combined"><div>091E</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Load Register B with the combined exponents (currently held in Register A)</div></div>
									<div class="assembly-row-combined"><div>091F</div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Shift
 the value of the combined exponents in Register A one place to the 
right so that we can check for an overflow.  RRA rotates the contents of
 Register A right one bit position, with Bit 0 going to the CARRY FLAG, 
and the CARRY FLAG going to Bit 7.  RRA also can be used to divide a 
number in 2.</div></div>
									<div class="assembly-row-combined"><div>0920</div><div>XOR B<span class="opcode2" style="display: none;">A8</span></div><div>Check
 to see if the Carry flag was set by combining the two exponents.  This 
will cause an overflow if the sign is the same as the carry.</div></div>
									<div class="assembly-row-combined"><div>0921</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Load Register A with the combined/summed exponents value in Register B</div></div>
									<div class="assembly-row-combined"><div>0922-0924</div><div><a href="#0936H" class="memory-link">JP P,0936H<span class="origrom2" style="display: inline;">JP P,MULDV1</span></a><span class="opcode2" style="display: none;">F2 36 09</span></div><div>If we have an overflow, Jump away to 0936H</div></div>
									<div class="assembly-row-combined"><div>0925-0926</div><div>ADD 80H<span class="opcode2" style="display: none;">C6 80</span></div><div>If we don't have an overflow, then we need to make an exponent in excess of 80H (and turn on bit 8)</div></div>
									<div class="assembly-row-combined"><div>0927</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save
 the value of the combined exponent in Register A as the exponent in the
 ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0928-092A</div><div><a href="#0890H" class="memory-link">JP Z,0890H<span class="origrom2" style="display: inline;">JP Z,POPHRT</span></a><span class="opcode2" style="display: none;">CA 90 08</span></div><div>If the ADD 80H triggered a ZERO FLAG, then we have an underflow!  Jump to POPHRT to put the numbers back and RETurn</div></div>
									<div class="assembly-row-combined"><div>092B-092D</div><div><a href="#09DFH" class="memory-link">CALL 09DFH<span class="origrom2" style="display: inline;">CALL UNPACK</span></a><span class="opcode2" style="display: none;">CD DF 09</span></div><div>Unpack
 the arguments by a GODUB to UNPACK, which will turn on the sign bit of 
the MSB in the ACCumulator and Register B and save the sign bits</div></div>
									<div class="assembly-row-combined"><div>092E</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save the new sign (held in Register A) to the ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>092F<span class="origrom2" style="display: inline;">DCXHRT</span></div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement the memory pointer in Register Pair HL so that it points to the exponent in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0930</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer, with the HIGH ORDER/MSB in Register A</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0931H">0931H-093DH - SINGLE PRECISION MATH ROUTINE<span class="origrom">- "MLDVEX"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine is called from EXP.  If jumped here will checks if ACC=0. If so, the Z flag will be set</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0931-0933<span class="origrom2" style="display: inline;">MLDVEX</span></div><div><a href="#0955H" class="memory-link">CALL 0955H<span class="origrom2" style="display: inline;">CALL SIGN</span></a><span class="opcode2" style="display: none;">CD 55 09</span></div><div>Go check the value of the sign bit for the value in the ACCumulator and choose UNDERFLOW if negative</div></div>
									<div class="assembly-row-combined"><div>0934</div><div>CPL<span class="opcode2" style="display: none;">2F</span></div><div>Pick OVERFLOW if it was positive</div></div>
									<div class="assembly-row-combined"><div>0935</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the value from the STACK and put it in Register HL</div></div>
									<div class="assembly-row-combined"><div>0936<span class="origrom2" style="display: inline;">MULDV1</span></div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Weneed to test to see if the error was an OVERFLOW or an UNDERFLOW, so set the flags according to the value of the sign bit test</div></div>
									<div class="assembly-row-combined" id="0937H"><div>0937<span class="origrom2" style="display: inline;">MULDV2</span></div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Clean the old RETurn address off the stack</div></div>
									<div class="assembly-row-combined"><div>0938-093A</div><div><a href="#0778H" class="memory-link">JP P,0778H<span class="origrom2" style="display: inline;">JP P,ZERO</span></a><span class="opcode2" style="display: none;">F2 78 07</span></div><div>If the value in the ACCumulator is negative, JUMP to 0778H to handle the underflow</div></div>
									<div class="assembly-row-combined"><div>093B-093D</div><div><a href="#07B2H" class="memory-link">JP 07B2H<span class="origrom2" style="display: inline;">JP OVERR</span></a><span class="opcode2" style="display: none;">C3 B2 07</span></div><div>If its not negative, jump to 07B2H to throw an error because we have an overflow</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="093EH">093EH-0954H - SINGLE PRECISION MATH ROUTINE<span class="origrom">- "MUL10"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine multiplies the ACCumulator by 10.  Every register is modified.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>093E-0940<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;MUL10</span></div><div><a href="#09BFH" class="memory-link">CALL 09BFH<span class="origrom2" style="display: inline;">CALL MOVRF</span></a><span class="opcode2" style="display: none;">CD BF 09</span></div><div>Call 09BF which loads the SINGLE PRECISION value in the ACCumulator into Register Pair BC/DE</div></div>
									<div class="assembly-row-combined"><div>0941</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Load Register A with the value of the exponent (from Register B)</div></div>
									<div class="assembly-row-combined"><div>0942</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the exponent in Register A is equal to zero, because if the exponent is 0 then so is the number!</div></div>
									<div class="assembly-row-combined"><div>0943</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>If the single precision value in Register Pairs BC and DE is equal to zero, then RETurn</div></div>
									<div class="assembly-row-combined" id="0944H"><div>0944-0945</div><div>ADD 02H<span class="opcode2" style="display: none;">C6 02</span></div><div>Multiply the value of the exponent in Register A by four (by adding 2 to the exponent)</div></div>
									<div class="assembly-row-combined"><div>0946-0948</div><div><a href="#07B2H" class="memory-link">JP C,07B2H<span class="origrom2" style="display: inline;">JP C,OVERR</span></a><span class="opcode2" style="display: none;">DA B2 07</span></div><div>Display an <span class="code">?OV ERROR</span>if the adjusted exponent in Register A is too large</div></div>
									<div class="assembly-row-combined"><div>0949</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Put the exponent back into Register B</div></div>
									<div class="assembly-row-combined"><div>094A-094C</div><div><a href="#0716H" class="memory-link">CALL 0716H<span class="origrom2" style="display: inline;">CALL FADD</span></a><span class="opcode2" style="display: none;">CD 16 07</span></div><div>Multiply
 the number by 5 by adding the original value in the ACCumulator to the 
adjusted value in Register Pairs BC and DE and return with the original 
result in the ACCumulator by calling the SINGLE PRECISION ADD routine at
 0716H (which adds the single precision value in (BC/DE) to the single 
precision value in the ACCumulator. The sum is left in the ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>094D-094F</div><div>LD HL,4124H<span class="origrom2" style="display: inline;">LD HL,FAC</span><span class="opcode2" style="display: none;">21 24 41</span></div><div>Prepare
 to add 1 to the expenent (to thus multiply it by 2, which is then 10 
times the original number).  First, load Register Pair HL with the 
address of the exponent in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0950</div><div>INC (HL)<span class="opcode2" style="display: none;">34</span></div><div>Increment
 the value of the exponent in the ACCumulator at the location of the 
memory pointer in Register Pair HL.  ACCumulator now holds the original 
value times ten</div></div>
									<div class="assembly-row-combined"><div>0951</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>Return if the new value in the ACCumulator is in an acceptable range</div></div>
									<div class="assembly-row-combined"><div>0952-0954</div><div><a href="#07B2H" class="memory-link">JP 07B2H<span class="origrom2" style="display: inline;">JP OVERR</span></a><span class="opcode2" style="display: none;">C3 B2 07</span></div><div>Display an <span class="code">?OV ERROR</span>if the value of the exponent at the location of the memory pointer in Register Pair HL is too large</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0955H">0955H-0963H - SINGLE PRECISION MATH ROUTINE<span class="origrom">- "SIGN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Puts the SIGN of the ACCumulator into Register A.  Only 
Register A is modified by this routine; the ACCumulator is left 
untouched.<br><br>To take advantage of the RST instructions to save 
bytes, FSIGN is defined to be an RST.  "FSIGN" is equivalent to "call 
sign" the first few instructions of SIGN (the ones before SIGNC) are 
done in the 8 bytes at the RST location. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0955-0957<span class="origrom2" style="display: inline;">SIGN</span></div><div>LD A,(4124H)<span class="origrom2" style="display: inline;">LD A,(FAC)</span><span class="opcode2" style="display: none;">3A 24 41</span></div><div>Prepare
 to check to see if the number in the ACCumulator is ZERO by loading 
Register A with the value of the exponent in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0958</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the exponent in Register A is equal to zero</div></div>
									<div class="assembly-row-combined"><div>0959</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>Return if the single precision value in the ACCumulator is equal to zero</div></div>
									<div class="assembly-row-combined" id="095AH"><div>095A-095C<span class="origrom2" style="display: inline;">SIGNC</span></div><div>LD A,(4123H)<span class="origrom2" style="display: inline;">LD A,(FAC-1)</span><span class="opcode2" style="display: none;">3A 23 41</span></div><div>Load Register A with the SIGN of the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>095D-095E</div><div>CP 2FH<span class="opcode2" style="display: none;">FE 2F</span></div><div>Z-80 Trick.  If passing through, this will check the value of Register A and skip the next CPL instruction.</div></div>
									<div class="assembly-row-combined"><div>095E<span class="origrom2" style="display: inline;">FCOMPS</span></div><div>CPL<span class="opcode2" style="display: none;">2F</span></div><div>Complement the sign.  This is ignored if passing through and proceesed only if specifically jumped to.</div></div>
									<div class="assembly-row-combined"><div>095F<span class="origrom2" style="display: inline;">ICOMPS</span></div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Put the value of the sign bit in Register A into the CARRY FLAG</div></div>
									<div class="assembly-row-combined"><div>0960<span class="origrom2" style="display: inline;">SIGNS</span></div><div>SBC A,A<span class="opcode2" style="display: none;">9F</span></div><div>If
 the CARRY FLAG is 0 (i.e., POSITIVE), then make Register A = 0.  If the
 CARRY FLAG is 1 (i.e., NEGATIVE), make Register A = FFH</div></div>
									<div class="assembly-row-combined"><div>0961</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>If the CARRY FLAG was 1, then the number is negative, and we want to RETurn</div></div>
									<div class="assembly-row-combined" id="0962H"><div>0962<span class="origrom2" style="display: inline;">INRART</span></div><div>INC A<span class="opcode2" style="display: none;">3C</span></div><div>Increment
 the value in Register A so that Register A will be equal to 1 if the 
single precision value in the ACCumulator is positive</div></div>
									<div class="assembly-row-combined"><div>0963</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0964H">0964H-0976H - SINGLE PRECISION MATH ROUTINE<span class="origrom">- "FLOAT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<p class="debug-note">This routine will take a signed integer 
held in Register A and turn it into a floating point number.  All 
registers are modified.</p>
									<div class="assembly-row-combined"><div>0964-0965<span class="origrom2" style="display: inline;">FLOAT</span></div><div>LD B,88H<span class="opcode2" style="display: none;">06 88</span></div><div>Load Register B with an exponent for an integer value</div></div>
									<div class="assembly-row-combined"><div>0966-0968</div><div>LD DE,0000H<span class="opcode2" style="display: none;">11 00 00</span></div><div>Load Register Pair DE with zero</div></div>
									<p class="debug-note">This routine will float the singed number in B/A/D/E.  All registers are modified.</p>
									<div class="assembly-row-combined" id="0969H"><div>0969-096B<span class="origrom2" style="display: inline;">FLOATR</span></div><div>LD HL,4124H<span class="origrom2" style="display: inline;">LD HL,FAC</span><span class="opcode2" style="display: none;">21 24 41</span></div><div>Load Register Pair HL with the address of the exponent in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>096C</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the High Order/MSB of the integer value</div></div>
									<div class="assembly-row-combined"><div>096D</div><div>LD (HL),B<span class="opcode2" style="display: none;">70</span></div><div>Save the exponent in Register B into the ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>096E-096F</div><div>LD B,00H<span class="opcode2" style="display: none;">06 00</span></div><div>Load Register B with zero to zero the overflow byte</div></div>
									<div class="assembly-row-combined"><div>0970</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the memory pointer in Register Pair HL to now point to the sign of the number in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0971-0972</div><div>LD (HL),80H<span class="opcode2" style="display: none;">36 80</span></div><div>Assume a positive number by putting an 80H there</div></div>
									<div class="assembly-row-combined"><div>0973</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Shift the value of the sign bit into the CARRY FLAG</div></div>
									<div class="assembly-row-combined"><div>0974-0976</div><div><a href="#0762H" class="memory-link">JP 0762H<span class="origrom2" style="display: inline;">JP FADFLT</span></a><span class="opcode2" style="display: none;">C3 62 07</span></div><div>Jump to 0762H to float the number</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0977H">0977H-0989H - LEVEL II BASIC <span class="code">ABS()</span> routine<span class="origrom">- "ABS"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p><span class="code">ABS</span> routine 
(ACCumulator=ABS(ACCumulator)) input and output can be integer, 
single-precision or double-precision, depending on what is placed in the
 NTF (NTF=2, 4 or 8).<br>A call to 0977H converts the value in Working 
Register Area 1 (the ACCumulator) to its positive equivalent. The result
 is left in the ACCumulator. If a negative integer greater than 2** 15 
is encountered, it is converted to a single precision value. The data 
type or mode flag (40AFH) will be updated to reflect any change in mode.
  All registers are modified.<br><br>NOTE: To use a ROM call to find 
ABS(X),store the value of X in 4121H-4122H (integer), in 4121H-4124H 
(single precision), or in 411DH and then H (double precision), and store
 the variable type (2, 4, or 8, respectively) in 40AFH.  Then CALL 
0977H.  The result (in the same format as the input variable) is in the 
same locations in which the input variable was stored. If the input was 
an integer, the result is also in the HL Register Pair.<br><br>ABS 
routine (ACC=ABS(ACC)) input and output can be integer, single-precision
 or double-precision, depending on what is placed in the NTF (NTF=2, 4 
or 8). (For a definition of NTF, see Part 2.)<br><br>Absolute Value: 
Converts the value in Working Register Area 1 (ACCumulator) to its 
positive equivalent. The result is left in the ACCumulator. If a 
negative integer greater than 2**15 is encountered, it is converted to a
 single precision value. The data type or mode flag (40AF) will be 
updated to reflect any change in mode </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0977-0979<span class="origrom2" style="display: inline;">ABS</span></div><div><a href="#0994H" class="memory-link">CALL 0994H<span class="origrom2" style="display: inline;">CALL VSIGN</span></a><span class="opcode2" style="display: none;">CD 94 09</span></div><div>GOSUB to VSIGN to get the SGN of the ACCumulator into Register A</div></div>
									<div class="assembly-row-combined"><div>097A</div><div>RET P<span class="opcode2" style="display: none;">F0</span></div><div>If that sign is POSITIVE, then I guess we are done, so just RETurn</div></div>
									<p class="debug-note">This routine will negate any value in the ACCumulator.  Every Register is affected.</p>
									<div class="assembly-row-combined" id="097BH"><div>097B<span class="origrom2" style="display: inline;">VNEG</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H<span class="origrom2" style="display: inline;">GETYPE</span></a><span class="opcode2" style="display: none;">E7</span></div><div>We
 need to check the value of the current number type flag, so we call the
 TEST DATA MODE routine at RST 20H which determines the type of the 
current value in the ACCumulator and returns a combination of STATUS 
flags and unique numeric values in the register A according to the data 
mode flag (40AFH).
									The results are returned as follows:<br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table>
									</div></div>
									<div class="assembly-row-combined"><div>097C-097E</div><div><a href="#0C5BH" class="memory-link">JP M,0C5BH<span class="origrom2" style="display: inline;">JP M,INEG</span></a><span class="opcode2" style="display: none;">FA 5B 0C</span></div><div>If that test showed INTEGER, JUMP to 0C5BH to negate an integer</div></div>
									<div class="assembly-row-combined"><div>097F-0981</div><div><a href="#0AF6H" class="memory-link">JP Z,0AF6H<span class="origrom2" style="display: inline;">JP Z,TMERR</span></a><span class="opcode2" style="display: none;">CA F6 0A</span></div><div>If that test showed STRING, Display a <span class="code">?TM ERROR</span> message</div></div>
									<p class="debug-note">This routine will negate the single or double precision number in the ACCumulator.  Registers A, H, and L are affected.</p><li>To use this routine, the number must already be PACKed.<p></p>
									<div class="assembly-row-combined"><div>0982-0984<span class="origrom2" style="display: inline;">NEG</span></div><div>LD HL,4123H<span class="origrom2" style="display: inline;">LD HL,FAC-1</span><span class="opcode2" style="display: none;">21 23 41</span></div><div>Load Register Pair HL with the address of the MSB (which holds the SIGN bit) in the ACCumulator.</div></div>
									<div class="assembly-row-combined"><div>0985</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load
 Register A with the MSB (which holds the SIGN bit) in the ACCumulator 
at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0986-0987</div><div>XOR 80H<span class="origrom">XOR 1000 0000</span><span class="opcode2" style="display: none;">EE 80</span></div><div>Complement
 the sign bit in the MSB in Register A.  Since we know the number is 
negative, this is really just switching it to positive.</div></div>
									<div class="assembly-row-combined"><div>0988</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save
 the adjusted MSB (which holds the SIGN bit) in Register A in the 
ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0989</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</li></div>
							</div>

							<h2 class="assembly-section-title" id="098AH">098AH-0993H - LEVEL II BASIC <span class="code">SGN()</span> routine<span class="origrom">- "SGN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p><span class="code">SGN</span>function 
(ACCumulator=SGN(ACCumulator)). After execution, NTF=2 and 
ACCumulator=-l, 0 or 1 depending on sign and value of ACC before 
execution.  Registers A, H, and L are affected.<br><br>NOTE: To use a 
ROM call to find SGN(X), store the value of X in 4121H-4122H (integer), 
in 4121H-4124H (single precision), or in, s-4124H (double precision) and
 then store the variable type (2, 4, or 8, respectively) in 40AFH and 
then CALL 098AH.  The result (in integer format) is in 4121H-4122H and 
in the HL Register Pair.<br><br>SGN function (ACC=SGN(ACC)). After 
execution, NTF=2 and ACC=-l, 0 or 1 depending on sign and value of ACC 
be fore execution. 0994 This routine checks the sign of the ACC. NTF 
must be set. After execution A register=00 if ACC=0, A=01 if ACC &gt; 0 
or A=FFH if A &lt; 1. The Flags are also valid </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>098A-098C<span class="origrom2" style="display: inline;">SGN</span></div><div><a href="#0994H" class="memory-link">CALL 0994H<span class="origrom2" style="display: inline;">CALL VSIGN</span></a><span class="opcode2" style="display: none;">CD 94 09</span></div><div>Get the sign of the ACCumulator into Register A</div></div>
									<p class="debug-note" id="098DH">This routine will convert a signed number (held in Register A) into an integer.</p>
									<div class="assembly-row-combined"><div>098D<span class="origrom2" style="display: inline;">CONIA</span></div><div>LD L,A<span class="opcode2" style="display: none;">6F</span></div><div>Load Register L with the result of the sign test in Register A</div></div>
									<div class="assembly-row-combined"><div>098E</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Shift the sign bit in Register A into the Carry flag</div></div>
									<div class="assembly-row-combined"><div>098F</div><div>SBC A,A<span class="opcode2" style="display: none;">9F</span></div><div>Adjust
 the value in Register A so that it will be equal to zero if the current
 value in the ACCumulator is positive and equal to -1 if the current 
value in the ACCumulator is negative</div></div>
									<div class="assembly-row-combined"><div>0990</div><div>LD H,A<span class="opcode2" style="display: none;">67</span></div><div>Save the adjusted value in Register A in Register H</div></div>
									<div class="assembly-row-combined"><div>0991-0993</div><div><a href="#0A9AH" class="memory-link">JP 0A9AH<span class="origrom2" style="display: inline;">JP MAKINT</span></a><span class="opcode2" style="display: none;">C3 9A 0A</span></div><div>Jump to 0A9AH to return the result and set the VALTYP</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0994H">0994H-09A3H - LEVEL II BASIC MATH ROUTINE<span class="origrom">- "VSIGN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine checks the sign of the ACCumulator. NTF must be 
set. After execution A register=00 if ACCumulator=0, A=01 if ACC &gt; 0 
or A=FFH if A &lt; 1. The Flags are also valid.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0994<span class="origrom2" style="display: inline;">VSIGN</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H<span class="origrom2" style="display: inline;">GETYPE</span></a><span class="opcode2" style="display: none;">E7</span></div><div>We
 need to check the value of the current number type flag, so we call the
 TEST DATA MODE routine at RST 20H which determines the type of the 
current value in the ACCumulator and returns a combination of STATUS 
flags and unique numeric values in the register A according to the data 
mode flag (40AFH).  The results are returned as follows:<br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>0995-0997</div><div><a href="#0AF6H" class="memory-link">JP Z,0AF6H<span class="origrom2" style="display: inline;">JP Z,TMERR</span></a><span class="opcode2" style="display: none;">CA F6 0A</span></div><div>If that test showed STRING, Display a <span class="code">?TM ERROR</span>message</div></div>
									<div class="assembly-row-combined"><div>0998-099A</div><div><a href="#0955H" class="memory-link">JP P,0955H<span class="origrom2" style="display: inline;">JP P,SIGN</span></a><span class="opcode2" style="display: none;">F2 55 09</span></div><div>Since
 P means string, single precision, or double precision; and if it was a 
string it would have jumped already, this line says jump to 0955H if the
 current value in the ACCumulator is single precision or double 
precision, as those are processed the same way</div></div>
									<div class="assembly-row-combined"><div>099B-099D</div><div>LD HL,(4121H)<span class="origrom2" style="display: inline;">LD HL,(FACLO)</span><span class="opcode2" style="display: none;">2A 21 41</span></div><div>At this point, we know we have an integer.  Load Register Pair HL with the integer value in the ACCumulator</div></div>
									<p class="debug-note" id="099EH">This routine finds the sign of the value held at (HL).  Only Register A is altered.</p>
									<div class="assembly-row-combined"><div>099E<span class="origrom2" style="display: inline;">ISIGN</span></div><div>LD A,H<span class="opcode2" style="display: none;">7C</span></div><div>Load Register A with the MSB (which holds the SIGN bit) of the integer value in Register H</div></div>
									<div class="assembly-row-combined"><div>099F</div><div>OR L<span class="opcode2" style="display: none;">B5</span></div><div>Check to see if the integer value in the ACCumulator is equal to zero</div></div>
									<div class="assembly-row-combined"><div>09A0</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>Return if the integer value in the ACCumulator is equal to zero</div></div>
									<div class="assembly-row-combined" id="09A1H"><div>09A1</div><div>LD A,H<span class="opcode2" style="display: none;">7C</span></div><div>If
 its not zero, then the sign of the number is the same as the sign of 
Register H so load Register A with the MSB (which holds the SIGN bit) of
 the integer value in Register H</div></div>
									<div class="assembly-row-combined"><div>09A2-09A3</div><div><a href="#095FH" class="memory-link">JR 095FH<span class="origrom2" style="display: inline;">JR ICOMPS</span></a><span class="opcode2" style="display: none;">18 BB</span></div><div>Jump to 095FH to set Register A accordingly</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="09A4H">09A4H-09B0H - SINGLE PRECISION MATH ROUTINE<span class="origrom">- "PUSHF"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Move ACCumulator To STACK: Moves the single precision value 
in the ACCumulator to the STACK. It is stored in LSB/MSB/Exponent order.
 Registers D and E are affected.  Note, the mode flag is not tested by 
the move routine, it is simply assumed that ACCumulator contains a 
single precision value<br><br>Loads Single-precision value from ACC to 
STACK ((SP)=ACC). To retrieve this value, POP BC followed by POP DE. A, 
BC and HL are unchanged by this function.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>09A4<span class="origrom2" style="display: inline;">PUSHF</span></div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Preserve (HL) by swapping HL and DE</div></div>
									<div class="assembly-row-combined"><div>09A5-09A7</div><div>LD HL,(4121H)<span class="origrom2" style="display: inline;">LD HL,(FACLO)</span><span class="opcode2" style="display: none;">2A 21 41</span></div><div>Load Register Pair HL with the LSB and the NMSB of the single precision value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>09A8</div><div>EX (SP),HL<span class="opcode2" style="display: none;">E3</span></div><div>Swap
 (SP) and HL so that the return address is now in HL and the NMSB and 
the LSB of the single precision value are now at the top of the STACK</div></div>
									<div class="assembly-row-combined"><div>09A9</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the return address in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>09AA-09AC</div><div>LD HL,(4123H)<span class="origrom2" style="display: inline;">LD HL,(FAC-1)</span><span class="opcode2" style="display: none;">2A 23 41</span></div><div>Load Register Pair HL with the exponent and the High Order/MSB of the single precision value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>09AD</div><div>EX (SP),HL<span class="opcode2" style="display: none;">E3</span></div><div>Swap
 (SP) and HL so that the return address is now in HL and the MSB of the 
single precision value is now at the top of the STACK</div></div>
									<div class="assembly-row-combined"><div>09AE</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the return address in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>09AF</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Restore the original Register Pair HL from DE</div></div>
									<div class="assembly-row-combined"><div>09B0</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="09B1H">09B1H-09BEH - SINGLE PRECISION MATH ROUTINE<span class="origrom">- "MOVFM"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine moves a number from memory (pointed to by HL) 
into the ACCumulator --- (ACCumulator=(HL)).  All registers except 
Register A are affected, with HL = HL + 4 on exit.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>09B1-09B3<span class="origrom2" style="display: inline;">MOVFM</span></div><div><a href="#09C2H" class="memory-link">CALL 09C2H<span class="origrom2" style="display: inline;">CALL MOVRM</span></a><span class="opcode2" style="display: none;">CD C2 09</span></div><div>Load
 the SINGLE PRECISION value pointed to by Register Pair HL into Register
 Pairs BC/DE via a CALL to 09C2H  Then fall into the MOVFR routine.</div></div>
									<p class="debug-note" id="09B4H">This routine loads the ACC with the contents of the BC and DE Register Pairs. (ACC=BCDE). Only Registers D and E are modified.<br><br>Move
 SP Value In BC/DC Into ACCumulator: Moves the single precision value in
 BC/DE into ACCumulator. HL is destroyed BC/DE is left intact. Note - 
the mode flag is not updated!</p>
									<div class="assembly-row-combined"><div>09B4<span class="origrom2" style="display: inline;">MOVFR</span></div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Load Register Pair HL with the NMSB and the LSB of the single precision value in Register Pair DE.</div></div>
									<div class="assembly-row-combined"><div>09B5-09B7</div><div>LD (4121H),HL<span class="origrom2" style="display: inline;">LD (FACLO),HL</span><span class="opcode2" style="display: none;">22 21 41</span></div><div>Save the NMSB and the LSB of the single precision value into the ACCumulator (at the locations pointed to by Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>09B8</div><div>LD H,B<span class="opcode2" style="display: none;">60</span></div><div>Let HL = BC (so the High Orders/MSB + Exponent) ... part 1 ...</div></div>
									<div class="assembly-row-combined"><div>09B9</div><div>LD L,C<span class="opcode2" style="display: none;">59</span></div><div>... part 2</div></div>
									<div class="assembly-row-combined"><div>09BA-09BC</div><div>LD (4123H),HL<span class="origrom2" style="display: inline;">LD (FAC-1),HL</span><span class="opcode2" style="display: none;">22 23 41</span></div><div>Save the exponent and the MSB of the single precision value into the ACCumulator pointed to by Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>09BD</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Restore the original HL from DE</div></div>
									<div class="assembly-row-combined"><div>09BE</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="09BFH">09BFH-09CAH - SINGLE PRECISION MATH ROUTINE<span class="origrom">- "MOVRF"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item" id="09C2H">
								<p>This routine is the opposite of the 09B4H routine. It loads 
four bytes from ACCumulator (single-precision) into the BC/DE Register 
Pairs.  Only Register A is unchanged.<br><br>
								Loads A SP Value From ACCumulator Into BC/DE: Loads a single 
precision value from ACCumulator into BC/DE. Note, the mode flag is not 
tested by the move routine. It is up to the caller to insure that 
ACCumulator actually contains a single precision value<br><br>This 
routine is the opposite of the 9B4H routine. It loads four bytes from 
the ACC (single-precision) into the BC and DE Register Pairs. 
(BCDE=ACC). A is unchanged</p>
								<p>Load A SP Value Into BC/DE: Loads a single precision value pointed to by HL into BC/DE. Uses all registers<br><br>On Exit, HL = HL + 4<br><br>This
 routine will load the BCDE Register Pairs with four bytes from the 
location pointed to by HL. (BCDE=(HL)). With these types of data 
movements, the E Register is loaded with the LSB and the B register. 
with the MSB<br><br></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>09BF<span class="origrom2" style="display: inline;">?????</span></div><div>LD HL,4121H<span class="opcode2" style="display: none;">21 21 41</span></div><div>Load Register Pair HL with the address of the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>09C2<span class="origrom2" style="display: inline;">MOVRM</span></div><div>LD E,(HL)<span class="opcode2" style="display: none;">5E</span></div><div>Load
 Register E with the LSB of the single precision value in the 
ACCumulator at the location of the memory pointer in Register Pair HL.<br><br>This
 routine will load the BCDE Register Pairs with four bytes from the 
location pointed to by HL. (BCDE=(HL)). With these types of data 
movements, the E Register is loaded with the LSB and the B register. 
with the MSB</div></div>
									<div class="assembly-row-combined"><div>09C3</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the value of the memory pointer in Register Pair HL to point to the middle order/NMSB number</div></div>
									<div class="assembly-row-combined"><div>09C4<span class="origrom2" style="display: inline;">GETBCD</span></div><div>LD D,(HL)<span class="opcode2" style="display: none;">56</span></div><div>Load
 Register D with the NMSB of the single precision value in the 
ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>09C5</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the value of the memory pointer in Register Pair HL to point to the high order/MSB number</div></div>
									<div class="assembly-row-combined"><div>09C6</div><div>LD C,(HL)<span class="opcode2" style="display: none;">4E</span></div><div>Load
 Register C with the MSB of the single precision value in the 
ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>09C7</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the value of the memory pointer in Register Pair HL to point to the exponent</div></div>
									<div class="assembly-row-combined"><div>09C8</div><div>LD B,(HL)<span class="opcode2" style="display: none;">46</span></div><div>Load
 Register B with the exponent of the single precision value in the 
ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>09C9<span class="origrom2" style="display: inline;">INXHRT</span></div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the value of the memory pointer in Register Pair HL so that it points to the beginning of the next number</div></div>
									<div class="assembly-row-combined"><div>09CA</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="09CBH">09CBH-09D1H - SINGLE PRECISION MATH ROUTINE<span class="origrom">- "MOVMF"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine is the opposite of the 09B1H routine. It loads 
the number from the ACCumulator to the memory location pointed to by HL.
 ((HL)=ACC).  Modifies all Registers except for Register C</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>09CB-09CD<span class="origrom2" style="display: inline;">MOVMF</span></div><div>LD DE,4121H<span class="origrom2" style="display: inline;">LD DE,FACLO</span><span class="opcode2" style="display: none;">11 21 41</span></div><div>Load
 Register Pair DE with the starting address for a single precision value
 in the ACCumulator.  Then pass throgh to the following routine.</div></div>
									<p class="debug-note" id="09CEH">Data move routine. This moves 
four bytes from the location pointed to by DE into the location pointed 
to by HL. ((HL)=(DE)).  Modifies all Registers except for Register C</p>
									<div class="assembly-row-combined"><div>09CE-09CF<span class="origrom2" style="display: inline;">MOVE</span></div><div>LD B,04H<span class="opcode2" style="display: none;">06 04</span></div><div>Load Register B with the number of bytes to be moved for a single precision value so that B will act as a counter.</div></div>
									<div class="assembly-row-combined"><div>09D0-09D1</div><div><a href="#09D7H" class="memory-link">JR 09D7H<span class="origrom2" style="display: inline;">JR MOVE1</span></a><span class="opcode2" style="display: none;">18 05</span></div><div>Jump
 to 09D7H (which is the GENERAL PURPOSE MOVE routine and moves the 
contents of the B Register Bytes from the address in DE to the address 
in HL)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="09D2H">09D2H-09DEH - MOVE VALUE POINTED TO BY HL TO THE LOCATION POINTED TO BY DE<span class="origrom">- "MOVVFM"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the VARIABLE MOVE routine which moves the number of 
bytes specified in the variable type flag (40AFH) from the address in DE
 to the address in HL.  Uses A, B, DE and HL.<br><br>Data move routine. 
The location pointed to by DE is loaded with bytes from the location 
pointed to by HL. The number of bytes moved is determined by the value 
in the NTF. ((DE)=(HL))</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>09D2<span class="origrom2" style="display: inline;">MOVVFM</span></div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Exchange the value in Register Pair HL with the value in Register Pair DE, and then fall through to the VMOVE routine.</div></div>
									<p class="debug-note" id="09D3H">This routine is similar to 9D2H above. The only difference is that it moves data in the opposite direction. ((HL) = (DE))</p>
									<div class="assembly-row-combined"><div>09D3-09D5<span class="origrom2" style="display: inline;">VMOVE</span></div><div>LD A,(40AFH)<span class="origrom2" style="display: inline;">LD A,(VALTYP)</span><span class="opcode2" style="display: none;">3A AF 40</span></div><div>Load
 Register A with the current value of the number type flag (which is in 
40AFH).  This, not coincidentally, is also the length of the number 
being worked on!</div></div>
									<div class="assembly-row-combined"><div>09D6</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Load Register B with the number of bytes to be moved in Register A.</div></div>
									<p class="debug-note" id="09D7H">This routine is the same as 
9D6H except that the number of bytes shifted is determined by the value 
in the B Register ((HL)=(DE))<br>Moves contents of B-register bytes from the address in DE to the address given in HL. Uses all registers except C</p>
									<div class="assembly-row-combined"><div>09D7<span class="origrom2" style="display: inline;">MOVE1</span></div><div>LD A,(DE)<span class="opcode2" style="display: none;">1A</span></div><div>Top
 of a loop to move (DE)'s content into (HL).  First, load Register A 
with the value at the location of the memory pointer in Register Pair 
DE.<br><br>This routine is the same as 9D6H except that the number of 
bytes shifted is determined by the value in the B Register ((HL)=(DE)).<br>This
 is the GENERAL PURPOSE MOVE routine and moves the contents of the B 
Register Bytes from the address in DE to the address in HL)</div></div>
									<div class="assembly-row-combined"><div>09D8</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>and then Save the value in Register A at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>09D9</div><div>INC DE<span class="opcode2" style="display: none;">13</span></div><div>Increment the value of the memory pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>09DA</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the value of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>09DB</div><div>DEC B<span class="opcode2" style="display: none;">05</span></div><div>Decrement the value of the byte counter in Register B</div></div>
									<div class="assembly-row-combined"><div>09DC-09DD</div><div><a href="#09D7H" class="memory-link">JR NZ,09D7H<span class="origrom2" style="display: inline;">JR NZ,MOVE1</span></a><span class="opcode2" style="display: none;">20 F9</span></div><div>Loop until all of the bytes have been moved.</div></div>
									<div class="assembly-row-combined"><div>09DE</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="09DFH">09DFH-09F3H - SINGLE PRECISION MATH ROUTINE<span class="origrom">- "UNPACK"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine "UNPACKS" the ACCumulator and the Registers.  Registers A, C, H, and L are altered.<br><br>When
 the number in the ACCumulator is unpacked, the assumed one in the 
mantissa is restored, and the complement of the sign is placed in 
ACCumulator+1.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>09DF-09E1<span class="origrom2" style="display: inline;">UNPACK</span></div><div>LD HL,4123H<span class="origrom2" style="display: inline;">LD HL,FAC-1</span><span class="opcode2" style="display: none;">21 23 41</span></div><div>Load Register Pair HL with the address of the MSB (including the SIGN) of the value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>09E2</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load
 Register A with the MSB (and SIGN) of the value in the ACCumulator at 
the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>09E3</div><div>RLCA<span class="opcode2" style="display: none;">07</span></div><div>Duplicate the sign into the CARRY and the LSB</div></div>
									<div class="assembly-row-combined"><div>09E4</div><div>SCF<span class="opcode2" style="display: none;">37</span></div><div>Set the Carry flag to restore the hidden "1" for the mantissa</div></div>
									<div class="assembly-row-combined"><div>09E5</div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Turn
 off the sign bit in Register A by moving the value of the Carry flag 
into Register A and moving the previous value of the sign bit from bit 0
 of Register A into the Carry flag.  RRA rotates the contents of 
Register A right one bit position, with Bit 0 going to the CARRY FLAG, 
and the CARRY FLAG going to Bit 7.  RRA also can be used to divide a 
number in 2.</div></div>
									<div class="assembly-row-combined"><div>09E6</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save the adjusted High Order/MSB+Sign in Register A in the ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>09E7</div><div>CCF<span class="opcode2" style="display: none;">3F</span></div><div>Invert the value of the sign bit in the Carry flag</div></div>
									<div class="assembly-row-combined"><div>09E8</div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Move
 the inverted sign bit from the Carry flag into Register A.  RRA rotates
 the contents of Register A right one bit position, with Bit 0 going to 
the CARRY FLAG, and the CARRY FLAG going to Bit 7.  RRA also can be used
 to divide a number in 2.</div></div>
									<div class="assembly-row-combined"><div>09E9<br></div><div>INC HL<br>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the value of the memory pointer in Register Pair HL twice to now point to the temporary sign byte</div></div>
									<div class="assembly-row-combined"><div>09EB</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save the complemented sign (in Register A) to the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>09EC</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with the MSB+SIGN of the single precision value in Register C</div></div>
									<div class="assembly-row-combined"><div>09ED</div><div>RLCA<span class="opcode2" style="display: none;">07</span></div><div>Duplicate the sign in both the CARRY FLAG and the LSB</div></div>
									<div class="assembly-row-combined"><div>09EE</div><div>SCF<span class="opcode2" style="display: none;">37</span></div><div>Set the Carry flag to restore the hidden "1" for the mantissa</div></div>
									<div class="assembly-row-combined"><div>09EF</div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Restore
 the High Order (MSB+Sign) in A.  RRA rotates the contents of Register A
 right one bit position, with Bit 0 going to the CARRY FLAG, and the 
CARRY FLAG going to Bit 7.  RRA also can be used to divide a number in 
2.</div></div>
									<div class="assembly-row-combined"><div>09F0</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the adjusted High Order (MSB+Sign) in Register A</div></div>
									<div class="assembly-row-combined"><div>09F1</div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Move
 the value of the sign bit from the Carry flag into Register A.  RRA 
rotates the contents of Register A right one bit position, with Bit 0 
going to the CARRY FLAG, and the CARRY FLAG going to Bit 7.  RRA also 
can be used to divide a number in 2.</div></div>
									<div class="assembly-row-combined"><div>09F2</div><div>XOR (HL)<span class="opcode2" style="display: none;">AE</span></div><div>Combine the value of the sign bit of the ACCUMULATOR and the SIGN BIT of the Registers</div></div>
									<div class="assembly-row-combined"><div>09F3</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="09F4H">09F4H-09FBH - LEVEL II BASIC MATH ROUTINE<span class="origrom">- "VMOVFA"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine moves a number of bytes (the number depending on
 the value stored in the VALTYPE) from (HL) to the ACCumulator.  All 
Registers except C are affected.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>09F4-09F6<span class="origrom2" style="display: inline;">VMOVFA</span></div><div>LD HL,4127H<span class="origrom2" style="display: inline;">LD HL,ARGLO</span><span class="opcode2" style="display: none;">21 27 41</span></div><div>This
 is the entry point from the DADD routine.  To facilitate, we need to 
set HL to point to ARG (a/k/a REG 2)) instead of the ACCumulator</div></div>
									<div class="assembly-row-combined" id="09F7H"><div>09F7-09F9<span class="origrom2" style="display: inline;">VMOVFM</span></div><div>LD DE,09D2H<span class="origrom2" style="display: inline;">LD DE,MOVVFM</span><span class="opcode2" style="display: none;">11 D2 09</span></div><div>Load Register Pair DE with the return address of the routine that does an exchange and then falls into the MOVE1 routine.</div></div>
									<div class="assembly-row-combined"><div>09FA-09FB</div><div><a href="#0A02H" class="memory-link">JR 0A02H<span class="origrom2" style="display: inline;">JR VMVVFM</span></a><span class="opcode2" style="display: none;">18 06</span></div><div>Jump to 0A02</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="09FCH">09FCH-0A0BH - LEVEL II BASIC MATH ROUTINE<span class="origrom">- "VMOVAF"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the opposite of 9F4H.  This routine moves a number of
 bytes (the number depending on the value stored in the VALTYPE) from 
the ACCumulator to (HL).  All Registers except C are affected.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="09FCH"><div>09FC-09FE<span class="origrom2" style="display: inline;">VMOVAF</span></div><div>LD HL,4127H<span class="origrom2" style="display: inline;">LD HL,ARGLO</span><span class="opcode2" style="display: none;">21 27 41</span></div><div>Entered
 here from FIN, DMUL10, and DDIV10.  They require that Register Pair  HL
 to point to ARG (a/k/a REG 2) instead of the ACCumulator</div></div>
									<div class="assembly-row-combined" id="09FFH"><div id="0A00H">09FF-0A01<span class="origrom2" style="display: inline;">VMOVMF</span></div><div>LD DE,09D3H<span class="origrom2" style="display: inline;">LD DE,VMOVE</span><span class="opcode2" style="display: none;">11 D3 09</span></div><div>When entered from here, we need to load Register Pair DE with the return address of the MOVE routine.</div></div>
									<div class="assembly-row-combined" id="0A02H"><div>0A02<span class="origrom2" style="display: inline;">VMVVFM</span></div><div>PUSH DE<span class="opcode2" style="display: none;">D5</span></div><div>When entered here, save Register Pair DE (which, if passed through, is a return address) on the STACK</div></div>
									<div class="assembly-row-combined" id="0A03H"><div>0A03-0A05<span class="origrom2" style="display: inline;">VDFACS</span></div><div>LD DE,4121H<span class="origrom2" style="display: inline;">LD DE,FACLO</span><span class="opcode2" style="display: none;">11 21 41</span></div><div>Entered
 here from INT, STR, and SNG.  In that case, we must load Register Pair 
DE with the starting address for a single precision value in the 
ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0A06</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H<span class="origrom2" style="display: inline;">GETYPE</span></a><span class="opcode2" style="display: none;">E7</span></div><div>We
 need to check the value of the current number type flag, so we call the
 TEST DATA MODE routine at RST 20H which determines the type of the 
current value in the ACCumulator and returns a combination of STATUS 
flags and unique numeric values in the register A according to the data 
mode flag (40AFH).  The results are returned as follows:<br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>0A07</div><div>RET C<span class="opcode2" style="display: none;">D8</span></div><div>If that test is anything other than double precision, return out of this subroutine to the address which was fed in</div></div>
									<div class="assembly-row-combined" id="0A08H"><div>0A08-0A0A</div><div>LD DE,411DH<span class="origrom2" style="display: inline;">LD DE,DFACLO</span><span class="opcode2" style="display: none;">11 1D 41</span></div><div>If
 we are here, then we have a double precision number, so set Register 
Pair DE to point to the the LSB of a double precision number.</div></div>
									<div class="assembly-row-combined"><div>0A0B</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to the place we set up to return to</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0A0CH">0A0CH-0A25H - SINGLE PRECISION COMPARE<span class="origrom">- "FCOMP"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source code, this routine will 
compare two single precision numbers.  On Exit, A=1 if ARG &lt; 
ACCumulator, A=0 if ARG=Accmulator, and A=-1 if ARG &gt; ACCumulator.  
This routine exits with the CARRY FLAG on.  Alters Registers A, H, and 
L.<br><br>Single-precision compare. Compares ACCumulator with the 
contents of BCDE registers. After execution of this routine, the A 
Register will contain: A=0 if ACCumulator=BCDE, A=1 if ACC&gt;BCDE or 
A=FFH if ACC&lt;BCDE.<br><br>Single Precision Comparison:  Algebraically
 compares the single precision value in (BC/DE) to the single precision 
value ACCumulator. The result of the comparison is returned in the A and
 status as: IF (BC/DE) &gt; ACCumulator A = -1,  IF (BC/DE) &lt; 
ACCumulator A = +1,  IF (BC/DE) = ACCumulator A = 0<br><br>NOTE: To use a
 ROM call to compare two single precision numbers, store the first input
 in registers BCDE, the second input in 4121H-4124H and then CALL 0A0CH.
  If the numbers are equal, the Z (zero) flag will be set. If they are 
not equal, the Z flag will be turned off. If the first input number is 
the smaller, the S (sign) and C (carry) flags will also be turned off. 
If the second input number is the smaller, the S and C flags will both 
be set.<br><br></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0A0C<span class="origrom2" style="display: inline;">FCOMP</span></div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>First we need to check to see if ARG is zero, so load Register A with the value of the exponent in Register B</div></div>
									<div class="assembly-row-combined"><div>0A0D</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Set the flags based on Register A</div></div>
									<div class="assembly-row-combined"><div>0A0E-0A10</div><div><a href="#0955H" class="memory-link">JP Z,0955H<span class="origrom2" style="display: inline;">JP Z,SIGN</span></a><span class="opcode2" style="display: none;">CA 55 09</span></div><div>If the exponent in Register A is equal to zero, then JUMP to SIGN</div></div>
									<div class="assembly-row-combined"><div>0A11-0A13</div><div>LD HL,095EH<span class="origrom2" style="display: inline;">LD HL,FCOMPS</span><span class="opcode2" style="display: none;">21 5E 09</span></div><div>Set up the destination address to use on a RETurn by first loading  Register Pair HL with the address to the FCOMPS routine</div></div>
									<div class="assembly-row-combined"><div>0A14</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the return address in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0A15-0A17</div><div><a href="#0955H" class="memory-link">CALL 0955H<span class="origrom2" style="display: inline;">CALL SIGN</span></a><span class="opcode2" style="display: none;">CD 55 09</span></div><div>Check to see if the ACCumulator is zero via a GOSUB to SIGN</div></div>
									<div class="assembly-row-combined"><div>0A18</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>If
 the ACCumulator is ZERO, then the result is simply the NEGative of ARG,
 so, to prepare for that, load Register A with the MSB of the single 
precision value in Register C</div></div>
									<div class="assembly-row-combined"><div>0A19</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>If the ACCumulator was zero, RETurn with Register A holding Register C</div></div>
									<div class="assembly-row-combined" id="0A10H"><div>0A1A-0A1C</div><div>LD HL,4123H<span class="origrom2" style="display: inline;">LD HL,FAC-1</span><span class="opcode2" style="display: none;">21 23 41</span></div><div>Load Register Pair HL with the address of the MSB+SIGN in Register A</div></div>
									<div class="assembly-row-combined"><div>0A1D</div><div>XOR (HL)<span class="opcode2" style="display: none;">AE</span></div><div>Check to see if the signs of the ACCumulator and the ARG are the same via a XOR</div></div>
									<div class="assembly-row-combined"><div>0A1E</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>If
 they are different, then the result of that XOR will be the sign of the
 number in ARG, so load  Register A with the MSB+SIGN of Register C</div></div>
									<div class="assembly-row-combined"><div>0A1F</div><div>RET M<span class="opcode2" style="display: none;">F8</span></div><div>If the signs are different, RETurn</div></div>
									<div class="assembly-row-combined"><div>0A20-0A22</div><div><a href="#0A26H" class="memory-link">CALL 0A26H<span class="origrom2" style="display: inline;">CALL FCOMP2</span></a><span class="opcode2" style="display: none;">CD 26 0A</span></div><div>Now that we have resolved the signs, JUMP to FCOMP2 to check the rest of the numbers</div></div>
									<div class="assembly-row-combined"><div>0A23<span class="origrom2" style="display: inline;">FCOMPD</span></div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>If
 are are here, then the numbers are different, so the next step is to 
change the signs if both numbers are negative.  To do this, first move 
the value of the Carry flag from the comparison into Register A.  RRA 
rotates the contents of Register A right one bit position, with Bit 0 
going to the CARRY FLAG, and the CARRY FLAG going to Bit 7.  RRA also 
can be used to divide a number in 2.</div></div>
									<div class="assembly-row-combined"><div>0A24</div><div>XOR C<span class="opcode2" style="display: none;">A9</span></div><div>Combine the value of the MSB/SIGN of the single precision value in Register C with the value in Register A</div></div>
									<div class="assembly-row-combined" id="0A25H"><div>0A25</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>With Register A now set, RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0A26H">0A26H-0A38H - Part of the SINGLE PRECISION COMPARISON ROUTINE<span class="origrom">- "FCOMP2"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0A26</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment
 the value of the memory pointer in Register Pair HL so that it points 
to the exponent of the single precision number in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0A27</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Load Register A with the value of the exponent for the single precision value held in ARG (stored in Register B)</div></div>
									<div class="assembly-row-combined"><div>0A28</div><div>CP (HL)<span class="opcode2" style="display: none;">BE</span></div><div>Check
 to see if the exponent for the single precision value in the 
ACCumulator at the location of the memory pointer in Register Pair HL is
 the same as the value of the exponent for the single precision value in
 Register A</div></div>
									<div class="assembly-row-combined"><div>0A29</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>If
 the value of the exponent for the single precision number in the 
ACCumulator isn't the same as the value of the exponent for the single 
precision number in ARG (held in  Register A), RETurn</div></div>
									<div class="assembly-row-combined" id="0A2AH"><div>0A2A</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement
 the value of the memory pointer in Register Pair HL so it now will 
point to the HIGH ORDER/MSB of the single precision number in the 
ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0A2B</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with the HIGH ORDER/MSB of the single precision number in ARG (stored in Register C)</div></div>
									<div class="assembly-row-combined"><div>0A2C</div><div>CP (HL)<span class="opcode2" style="display: none;">BE</span></div><div>Check
 to see if the HIGH ORDER/MSB for the single precision value in the 
ACCumulator at the location of the memory pointer in Register Pair HL is
 the same as the value of the MSB for the single precision value in 
Register A</div></div>
									<div class="assembly-row-combined"><div>0A2D</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>If
 the value of the HIGH ORDER/MSB for the single precision number in the 
ACCumulator isn't the same as the value of the HIGH ORDER/MSB for the 
single precision number in ARG (held in  Register A), RETurn</div></div>
									<div class="assembly-row-combined" id="0A2EH"><div>0A2E</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement
 the value of the memory pointer in Register Pair HL so it now will 
point to the  MIDDLE ORDER/NMSB of the single precision number in the 
ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0A2F</div><div>LD A,D<span class="opcode2" style="display: none;">7A</span></div><div>Load Register A with the MIDDLE ORDER/NMSB of the single precision number in ARG (stored in Register D)</div></div>
									<div class="assembly-row-combined"><div>0A30</div><div>CP (HL)<span class="opcode2" style="display: none;">BE</span></div><div>Check
 to see if the MIDDLE ORDER/NMSB for the single precision value in the 
ACCumulator at the location of the memory pointer in Register Pair HL is
 the same as the value of the MIDDLE ORDER/NMSB for the single precision
 value in Register A</div></div>
									<div class="assembly-row-combined"><div>0A31</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>If
 the value of the MIDDLE ORDER/NMSB for the single precision number in 
the ACCumulator isn't the same as the value of the  MIDDLE ORDER/NMSB 
for the single precision number in ARG (held in  Register A), RETurn</div></div>
									<div class="assembly-row-combined" id="0A32H"><div>0A32</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement
 the value of the memory pointer in Register Pair HL so it now will 
point to the LOW ORDER/LSB of the single precision number in the 
ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0A33</div><div>LD A,E<span class="opcode2" style="display: none;">7B</span></div><div>Load Register A with the LOW ORDER/LSB of the single precision number in ARG (stored in Register E)</div></div>
									<div class="assembly-row-combined"><div>0A34</div><div>SUB (HL)<span class="opcode2" style="display: none;">96</span></div><div>Use
 subtraction to check to see if the LOW ORDER/LSB for the single 
precision value in the ACCumulator at the location of the memory pointer
 in Register Pair HL is the same as the value of the LOW ORDER/LSB for 
the single precision value in Register A.  We use subtraction so that if
 the numbers are the same then Register A will be filled with the 0 
response.</div></div>
									<div class="assembly-row-combined"><div>0A35</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>Return if the value of the LSB in the ACCumulator isn't the same as the value of the LSB in Register A</div></div>
									<div class="assembly-row-combined" id="0A36H"><div>0A36</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>If we are here then the numbers are the same so we need to get the extra data off of the STACK</div></div>
									<div class="assembly-row-combined"><div>0A37</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Clear the stack</div></div>
									<div class="assembly-row-combined"><div>0A3B</div><div>RET<span class="opcode2" style="display: none;">7C</span></div><div>All done, so RET to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0A39H">0A39H-0A48H - INTEGER COMPARISON ROUTINE<span class="origrom"> - "ICOMP"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source code, this routine will 
compare two integers.  On Exit, A=1 if (DE) &lt; (HL), A=0 if (DE)=(HL),
 and A=-1 if (DE) &gt; (HL).  Alters only Register A.<br><br>Integer 
compare. Compares HL with DE. After execution, A=0 if HL=DE, A=1 if 
HL&gt;DE or A=FFH if HL&lt;DE. The S and Z flags are valid.<br><br>NOTE:
 To use a ROM call to compare two integers, store the first input in DE,
 the second in HL and then CALL 0A39H.  If the numbers are equal, the Z 
(zero) flag will be set. If they are not equal, the Z flag will be 
turned off. If the first input number is the smaller, the S (sign) and C
 (carry) flags will also be turned off. If the second input number is 
the smaller, the S and C flags will both be set.<br><br>Compares HL with DE. After execution, A=0 if HL=DE, A=1 if HL&gt;DE or A=FFH if HL&lt;DE. The S and Z flags are valid<br><br>Algebraically
 compares two integer values in DE and HL. The contents of DE and HL are
 left intact. The result of the comparison is left in the A Register and
 status register: If DE &gt; HL A = -1, IF DE &lt; HL A = +1, IF DE = HL
 A = 0<br><br></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0A39<span class="origrom2" style="display: inline;">ICOMP</span></div><div>LD A,D<span class="opcode2" style="display: none;">7A</span></div><div>First we test the signs, so load Register A with the SIGN of the integer value in Register D</div></div>
									<div class="assembly-row-combined"><div>0A3A</div><div>XOR H<span class="opcode2" style="display: none;">AC</span></div><div>Check
 to see if the sign bit for the MSB of the integer value in Register H 
is the same as the sign bit for the  SIGN for the integer value in 
Register A</div></div>
									<div class="assembly-row-combined"><div>0A3B</div><div>LD A,H<span class="opcode2" style="display: none;">7C</span></div><div>If
 the signs are NOT the same, then the result is the sign of (HL), so put
 the SIGN of the number in (HL) into the response register of  Register 
A.</div></div>
									<div class="assembly-row-combined"><div>0A3C-0A3E</div><div><a href="#095FH" class="memory-link">JP M,095FH<span class="origrom2" style="display: inline;">JP M,ICOMPS</span></a><span class="opcode2" style="display: none;">FA 5F 09</span></div><div>If the sign bits are NOT the same, JUMP to ICOMPS to check the numbers</div></div>
									<div class="assembly-row-combined"><div>0A3F</div><div>CP D<span class="opcode2" style="display: none;">BA</span></div><div>If
 we are here, then the signs are the same, so now check to see if the 
HIGH ORDER/MSB for the integer value in Register D is the same as the 
HIGH ORDER/MSB for the integer value in Register A</div></div>
									<div class="assembly-row-combined"><div>0A40-0A42</div><div><a href="#0960H" class="memory-link">JP NZ,0960H<span class="origrom2" style="display: inline;">JP NZ,SIGNS</span></a><span class="opcode2" style="display: none;">C2 60 09</span></div><div>if
 the HIGH ORDER/MSB for the integer value in Register D isn't the same 
as the HIGH ORDER/MSB for the integer value in Register A, JUMP to SIGNS
 to set up the appropriate response in Register A</div></div>
									<div class="assembly-row-combined"><div>0A33</div><div>LD A,L<span class="opcode2" style="display: none;">7B</span></div><div>Load Register A with the LOW ORDER/LSB of the single precision number in ARG (stored in Register E)</div></div>
									<div class="assembly-row-combined"><div>0A44</div><div>SUB E<span class="opcode2" style="display: none;">93</span></div><div>Use
 subtraction to check to see if the LOW ORDER/LSB for the integer value 
in Register E is the same as the LOW ORDER/LSB for the integer value in 
Register A</div></div>
									<div class="assembly-row-combined"><div>0A45-0A47</div><div><a href="#0960H" class="memory-link">JP NZ,0960H<span class="origrom2" style="display: inline;">JP NZ,SIGNS</span></a><span class="opcode2" style="display: none;">C2 60 09</span></div><div>If
 the LSB for the integer value in Register E isn't the same as the LSB 
for the integer value in Register A, JUMP to SIGNS to set up the 
appropriate response in Register A</div></div>
									<div class="assembly-row-combined"><div>0A48</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>If we are here, then two things.  First, they are the same.  Second, A is zero.  So RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0A49H">0A49H-0A77H - DOUBLE PRECISION COMPARISON ROUTINE<span class="origrom">- "DCOMPD"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source code, this routine will 
compare two double precision numbers.  On Exit, A=1 if ARG &lt; 
ACCumulator, A=0 if ARG=Accmulator, and A=-1 if ARG &gt; ACCumulator.  
Every register is affected.<br><br>Double-precision compare. Compares 
ACCumulator with the ARG (a/k/a REG 2). After execution the A Register 
will contain: A=0 if ACCumulator=ARG (a/k/a REG 2), A=1 if ACC &gt; ARG 
(a/k/a REG 2) or A=FFH if ACC &lt; ARG (a/k/a REG 2). S and Z flags are 
valid. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0A49-0A4B<span class="origrom2" style="display: inline;">DCOMPD</span></div><div>LD HL,4127H<span class="origrom2" style="display: inline;">LD HL,ARGLO</span><span class="opcode2" style="display: none;">21 27 41</span></div><div>Load
 Register Pair HL with the starting address of ARG (a/k/a REG 2).  If 
entering here, then (DE) already needs to be set with the pointer to 
ARG.<br>Note: 4127H-412EH holds ARG (a/k/a REG 2)</div></div>
									<div class="assembly-row-combined"><div>0A4C-0A4E</div><div><a href="#09D3H" class="memory-link">CALL 09D3H<span class="origrom2" style="display: inline;">CALL VMOVE</span></a><span class="opcode2" style="display: none;">CD D3 09</span></div><div>Go move the double precision value pointed to by Register Pair DE to ARG (a/k/a REG 2)</div></div>
									<div class="assembly-row-combined" id="0A4FH"><div>0A4F-0A51<span class="origrom2" style="display: inline;">XDCOMP</span></div><div>LD DE,412EH<span class="origrom2" style="display: inline;">LD DE,ARG</span><span class="opcode2" style="display: none;">11 2E 41</span></div><div>Load Register Pair DE with the address of the exponent in ARG (a/k/a REG 2)</div></div>
									<div class="assembly-row-combined"><div>0A52</div><div>LD A,(DE)<span class="opcode2" style="display: none;">1A</span></div><div>Load
 Register A with the exponent for the double precision value in ARG 
(a/k/a REG 2) at the location of the memory pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0A53</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the double precision value in ARG (a/k/a REG 2) is equal to zero</div></div>
									<div class="assembly-row-combined"><div>0A54-0A56</div><div><a href="#0955H" class="memory-link">JP Z,0955H<span class="origrom2" style="display: inline;">JP Z,SIGN</span></a><span class="opcode2" style="display: none;">CA 55 09</span></div><div>If
 the double precision value in ARG (a/k/a REG 2) is equal to zero, then 
we are done, so JUMP to SIGN to set up Register A with the appropriate 
response.</div></div>
									<div class="assembly-row-combined"><div>0A57-0A59</div><div>LD HL,095EH<span class="origrom2" style="display: inline;">LD HL,FCOMPS</span><span class="opcode2" style="display: none;">21 5E 09</span></div><div>Load Register Pair HL with a return address to the FCOMPS routine</div></div>
									<div class="assembly-row-combined"><div>0A5A</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the return address in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0A5B-0A5D</div><div><a href="#0955H" class="memory-link">CALL 0955H<span class="origrom2" style="display: inline;">CALL SIGN</span></a><span class="opcode2" style="display: none;">CD 55 09</span></div><div>Go check to see if the double precision value in the ACCumulator is equal to zero</div></div>
									<div class="assembly-row-combined"><div>0A5E</div><div>DEC DE<span class="opcode2" style="display: none;">1B</span></div><div>Decrement
 the value of the memory pointer in Register Pair DE so that DE now 
points to the MSB+SIGN of the number in ARG (a/k/a REG 2)</div></div>
									<div class="assembly-row-combined"><div>0A5F</div><div>LD A,(DE)<span class="opcode2" style="display: none;">1A</span></div><div>Load
 Register A with the  MSB+SIGN of the double precision value in ARG 
(a/k/a REG 2) at the location of the memory pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0A60</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Presetve the MSB+SIGN of the double precision value in ARG (a/k/a REG 2) into Register C</div></div>
									<div class="assembly-row-combined"><div>0A61</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>If the number in the ACCumulator = 0, then the sign of the result is the sign of ARG, so RETurn wto FCOMPS</div></div>
									<div class="assembly-row-combined" id="0A62H"><div>0A62-0A64</div><div>LD HL,4123H<span class="origrom2" style="display: inline;">LD HL,FAC-1</span><span class="opcode2" style="display: none;">21 23 41</span></div><div>Load Register Pair HL with the address of the SIGN of the double precision value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0A65</div><div>XOR (HL)<span class="opcode2" style="display: none;">AE</span></div><div>Check
 to see if the sign bit the double precision value in the ACCumulator at
 the location of the memory pointer in Register Pair HL is the same as 
the sign bit of the double precision value in ARG (a/k/a REG 2) in 
Register A</div></div>
									<div class="assembly-row-combined"><div>0A66</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>In case they are the same, get the sign from C into Register A.</div></div>
									<div class="assembly-row-combined"><div>0A67</div><div>RET M<span class="opcode2" style="display: none;">F8</span></div><div>If they are NOT the same, RETurn to FCOMPS to set set Register A</div></div>
									<div class="assembly-row-combined" id="0A68H"><div>0A68</div><div>INC DE<span class="opcode2" style="display: none;">13</span></div><div>Increment the value of the memory pointer in Register Pair DE so that DE now points to the exponent of ARG</div></div>
									<div class="assembly-row-combined"><div>0A69</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the value of the memory pointer in Register Pair HL so that HL now points to the exponent of the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0A6A-OA6B</div><div>LD B,08H<span class="opcode2" style="display: none;">06 08</span></div><div>Load Register B with the number of bytes to be compared, as B will act as a counter</div></div>
									<div class="assembly-row-combined"><div>0A6C<span class="origrom2" style="display: inline;">DCOMP1</span></div><div>LD A,(DE)<span class="opcode2" style="display: none;">1A</span></div><div>Load Register A with a byte from the double precision number in ARG (pointed to by Register Pair DE)</div></div>
									<div class="assembly-row-combined"><div>0A6D</div><div>SUB (HL)<span class="opcode2" style="display: none;">96</span></div><div>Use subtraction to compare that byte from ARG with the correspondible byte from the ACCumulator (pointed to by Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>0A6E-0A70</div><div><a href="#0A23H" class="memory-link">JP NZ,0A23H<span class="origrom2" style="display: inline;">JP NZ,FCOMPD</span></a><span class="opcode2" style="display: none;">C2 23 0A</span></div><div>If the NZ is set, then the numbers are different o JUMP to FCOMPD to set up Register A</div></div>
									<div class="assembly-row-combined"><div>0A71</div><div>DEC DE<span class="opcode2" style="display: none;">1B</span></div><div>If
 we are here, then they are the same, so we need to move to the next 
byte of ARG (so decrement the value of the memory pointer in Register 
Pair DE)</div></div>
									<div class="assembly-row-combined"><div>0A72</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>and the next byte of the ACCumulator (so decrement the value of the memory pointer in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>0A73</div><div>DEC B<span class="opcode2" style="display: none;">05</span></div><div>and to decrease the byte counter (so Decrement the number of bytes remaining to be compared in Register B)</div></div>
									<div class="assembly-row-combined"><div>0A74-0A75</div><div><a href="#0A6CH" class="memory-link">JR NZ,0A6CH<span class="origrom2" style="display: inline;">JR NZ,DCOMP1</span></a><span class="opcode2" style="display: none;">20 F6</span></div><div>The DEC of B will set the flags.  If B is NOT ZERO, then Loop back to DCOMP1 until all of the bytes have been compared</div></div>
									<div class="assembly-row-combined"><div>0A76</div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>If
 we are here, then the numbers are the same, so we need to clean the 
RETurn to FCOMPS off the stack, as that is not where we want to RETurn 
to</div></div>
									<div class="assembly-row-combined"><div>0A77</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to the actual CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0A78H">0A78H-0A7EH - DOUBLE PRECISION COMPARE<span class="origrom">- "DCOMP"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source code, this routine will 
compare two double precision numbers, but is the opposite of the ICOMP, 
FCOMP, and XDCOMP routines.  This one swaps ARC and ACC, so on Exit, A=1
 if ARG &gt; ACCumulator, A=0 if ARG=Accmulator, and A=-1 if ARG &lt; 
ACCumulator.  Every register is affected.<br><br>Double-precision 
compare. This compare is the opposite of the A4FH compare. It compares 
the ARG (a/k/a REG 2) with the ACC. (Remember that a compare is actually
 a subtraction that is never executed therefore a compare can be done in
 two ways with the same values. (A-B and B-A)). The results are the same
 as the A4FH routine.<br><br>Double Precision Compare: Compares the 
double precision value in the ACCumulator to the value in ARG (a/k/a REG
 2). Both Register areas are left intact. The result of the comparison 
is left in the A and status registers as: IF ACCumulator &gt; ARG (a/k/a
 REG 2) A = -1,  IF ACCumulator &lt; ARG (a/k/a REG 2) A = +1,  IF 
ACCumulator = ARG (a/k/a REG 2) A = 0<br><br>NOTE: To use a ROM call to 
compare two double precision number, store the first input in 
411DH-4124H, and store the second input in 4127H-412EH and then CALL 
0A78H.  If the numbers are equal, the Z (zero) flag will be set. If they
 are not equal, the Z flag will be turned off. If the first input number
 is the smaller, the S (sign) and C (carry) flags will also be turned 
off. If the second input number is the smaller, the S and C flags will 
both be set. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0A78-0A7A<span class="origrom2" style="display: inline;">DCOMP</span></div><div><a href="#0A4FH" class="memory-link">CALL 0A4FH<span class="origrom2" style="display: inline;">CALL XDCOMP</span></a><span class="opcode2" style="display: none;">CD 4F 0A</span></div><div>GOSUB to  compare the double precision value in ARG (a/k/a REG 2) to the double precision value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0A7B-0A7D</div><div><a href="#095EH" class="memory-link">JP NZ,095EH<span class="origrom2" style="display: inline;">JP NZ,FCOMPS</span></a><span class="opcode2" style="display: none;">C2 5E 09</span></div><div>If
 the double precision value in the ACCumulator and the double precision 
value in ARG (a/k/a REG 2) aren't the same then JUMP to FCOMPS to negate
 the answer and set up the CARRY FLAG for the DOCMP routine</div></div>
									<div class="assembly-row-combined"><div>0A7E</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0A7FH">0A7FH-0AB0H - LEVEL II BASIC <span class="code">CINT</span> routine<span class="origrom">- "FRCINT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p><span class="code">CINT</span> routine. Takes a value from 
ACC, converts it to an integer value and puts it back into the ACC. On 
completion, the HL Register Pair contains the LSB of the integer value, 
and the NTF contains 2 (Integer=2). If NTF=3 (string) a TM ERROR will be
 generated and control will be passed to BASIC.  Every register is 
affected.  No rounding is performed<br><br>NOTE: To use a ROM call to call the <span class="code">CINT</span>
 routine, store the single precision input variable in 4121H-4124H and 
then call to 0A8AH and bypass all the foregoing.  After the call, the 
integer result would be in 4121H-4122H and in the HL Register Pair.  Too
 big a number will generate a <span class="code">?OV Error</span>. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0A7F<span class="origrom2" style="display: inline;">FRCINT</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H<span class="origrom2" style="display: inline;">GETYPE</span></a><span class="opcode2" style="display: none;">E7</span></div><div>We
 need to check the value of the current number type flag, so we call the
 TEST DATA MODE routine at RST 20H which determines the type of the 
current value in the ACCumulator and returns a combination of STATUS 
flags and unique numeric values in the register A according to the data 
mode flag (40AFH).  The results are returned as follows:<br><br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>0A80-0A82</div><div>LD HL,(4121H)<span class="origrom2" style="display: inline;">LD HL,(FACLO)</span><span class="opcode2" style="display: none;">2A 21 41</span></div><div>Just
 in acse we already have an integer, Load Register Pair HL with the 
integer value in the ACCumulator (which is stored at FACLO and FACLO+1)</div></div>
									<div class="assembly-row-combined"><div>0A83</div><div>RET M<span class="opcode2" style="display: none;">F8</span></div><div>If that test showed we have an INTEGER, then return out of this subroutine.</div></div>
									<div class="assembly-row-combined"><div>0A84-0A86</div><div><a href="#0AF6H" class="memory-link">JP Z,0AF6H<span class="origrom2" style="display: inline;">JP Z,TMERR</span></a><span class="opcode2" style="display: none;">CA F6 0A</span></div><div>If that test showed we have a STRING, Display a <span class="code">?TM ERROR</span>message</div></div>
									<p class="debug-note">This line is the problem in Bug 5A on the
 ROM bug list.  If double-precision (NC flag set based on type), call 
the subroutine at 0AB9H (a sign/compare or CSNG entry point), which 
converts double to single-precision with rounding to nearest (standard 
IEEE-like behavior in TRS-80 floating-point, adding 0.5 in mantissa 
before truncating lower bits.  This rounding happens before truncation, 
causing values like 2.9999999# to become 3.0 in single-precision, and 
then INT(3.0) = 3.  For single-precision or integer inputs, no call is 
made, and direct truncation occurs (correct behavior).  To fix the bug, 
the next instruction should really be 00H 00H 00H</p>
									<div class="assembly-row-combined"><div>0A87-0A89</div><div><a href="#0AB9H" class="memory-link">CALL NC,0AB9H<span class="origrom2" style="display: inline;">CALL NC,CONSD</span></a><span class="opcode2" style="display: none;">D4 B9 0A</span></div><div>If that test shows we have DOUBLE PRECISION, call 0AB9H to convert the number to single precision.</div></div>
									<div class="assembly-row-combined"><div>0A8A-0A8C</div><div>LD HL,07B2H<span class="origrom2" style="display: inline;">LD HL,OVERR</span><span class="opcode2" style="display: none;">21 B2 07</span></div><div>Just in case the number is too big, pre-load HL with the RETurn address to the ?OV ERROR routine</div></div>
									<div class="assembly-row-combined"><div>0A8D</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the return address in Register Pair HL on the STACK and fall into the "CONIS" routine to continue.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0A8EH">0A8EH - LEVEL II BASIC CONVERSION ROUTINE<span class="origrom">- "CONIS"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will convert a single precision number to an integer.  Every register is affected.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0A8E-0A90<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;CONIS</span></div><div>LD A,(4124H)<span class="origrom2" style="display: inline;">LD A,(FAC)</span><span class="opcode2" style="display: none;">3A 24 41</span></div><div>Load Register A with the exponent for the single precision value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0A91-0A92</div><div>CP 90H<span class="opcode2" style="display: none;">FE 90</span></div><div>Check
 to see if the exponent for the single precision value in the 
ACCumulator in Register A indicates more than 16 bits of precision</div></div>
									<div class="assembly-row-combined"><div>0A93-0A94</div><div><a href="#0AA3H" class="memory-link">JR NC,0AA3H<span class="origrom2" style="display: inline;">JR NC,CONIS2</span></a><span class="opcode2" style="display: none;">30 0E</span></div><div>If
 the exponent for the single precision value in the ACCumulator in 
Register A indicates more than 16 bits of precision, JUMP to CONIS2 to 
make sure that the reason it is "too big" isn't because it is -32768</div></div>
									<div class="assembly-row-combined"><div>0A95-0A97</div><div><a href="#0AFBH" class="memory-link">CALL 0AFBH<span class="origrom2" style="display: inline;">CALL QINT</span></a><span class="opcode2" style="display: none;">CD FB 0A</span></div><div>If
 we are here then the number isn't too big, so GOSUB to QINT to  convert
 the single precision value in the ACCumulator to an integer and return 
with the integer value in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0A98</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Load Register Pair HL with the integer value that was put into  Register Pair DE by QINT</div></div>
									<div class="assembly-row-combined"><div>0A99<span class="origrom2" style="display: inline;">CONIS1</span></div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Get the error address  from the STACK and put it in Register Pair DE</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0A9AH">0A9AH - LEVEL II BASIC CONVERSION ROUTINE<span class="origrom">- "MAKINT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the routine that returns the value in the HL Register
 Pair to the BASIC program that called it. In effect it moves the 
content of HL into the ACCumulator so it is ACCumulator = (HL) with 
VALTYPE set accordingly</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="0A9AH"><div>0A9A-0A9C<span class="origrom2" style="display: inline;">MAKINT</span></div><div>LD (4121H),HL<span class="origrom2" style="display: inline;">LD (FACLO),HL</span><span class="opcode2" style="display: none;">22 21 41</span></div><div>Save the integer value in Register Pair HL as the current value in the ACCumulator.</div></div>
									<div class="assembly-row-combined"><div>0A9D-0A9E<span class="origrom2" style="display: inline;">VALINT</span></div><div>LD A,02H<span class="opcode2" style="display: none;">3E 02</span></div><div>Load Register A with an integer number type flag.</div></div>
									<div class="assembly-row-combined"><div>0A9F-0AA1<span class="origrom2" style="display: inline;">CONISD</span></div><div>LD (40AFH),A<span class="origrom2" style="display: inline;">LD (VALTYP),A</span><span class="opcode2" style="display: none;">32 AF 40</span></div><div>Save the integer number type flag in Register A as the current value of the number type flag.<br>Note: 40AFH holds Current number type flag.  This is the entry point from the CONDS routine</div></div>
									<div class="assembly-row-combined"><div>0AA2</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0AA3H">0AA3H - LEVEL II BASIC CONVERSION ROUTINE<span class="origrom">- "CONIS2"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0AA3-0AA5<span class="origrom2" style="display: inline;">CONIS2</span></div><div>LD BC,9080H<span class="opcode2" style="display: none;">01 80 90</span></div><div>This
 routine's purpose is to check to see if a number from the FIN routine 
is -32768.  First, load up the register paird BCDE with 9080H/0000H for 
purposes of using FCOMP to test</div></div>
									<div class="assembly-row-combined"><div>0AA6-0AA8</div><div>LD DE,0000H<span class="opcode2" style="display: none;">11 00 00</span></div><div>Load
 Register Pair DE with the NMSB and the LSB of a single precision value.
 Register Pairs BC and DE now hold a single precision value equal to 
-32768</div></div>
									<div class="assembly-row-combined"><div>0AA9-0AAB</div><div><a href="#0A0CH" class="memory-link">CALL 0A0CH<span class="origrom2" style="display: inline;">CALL FCOMP</span></a><span class="opcode2" style="display: none;">CD 0C 0A</span></div><div>Call the SINGLE PRECISION COMPARISON routine at 0A0CH.<br><br><span class="nobottomborder bold">NOTE:</span>The routine at 0A0CH algebraically compares the single precision value in BC/DE to the single precision value ACCumulator.<br>The results are stored in A as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Register A</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator = BCDE</td><td style="border: 1px solid black; padding: 8px;">00</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator &gt; BCDE</td><td style="border: 1px solid black; padding: 8px;">01</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator &lt; BCDE</td><td style="border: 1px solid black; padding: 8px;">FF</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>0AAC</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>If FCOMP returns a NZ, then there was an error and the number could NOT be converted into an integer.  In this case, display an <span class="code">?OV ERROR</span></div></div>
									<div class="assembly-row-combined"><div>0AAD</div><div>LD H,C<span class="opcode2" style="display: none;">61</span></div><div>If
 we are here, then the value is -32768, so we need to put that into 
(HL).  First, load Register H with the MSB of the single precision value
 in Register C</div></div>
									<div class="assembly-row-combined"><div>0AAE</div><div>LD L,D<span class="opcode2" style="display: none;">6A</span></div><div>Load Register L with the NMSB of the single precision value in Register D</div></div>
									<div class="assembly-row-combined"><div>0AAF-0AB0</div><div><a href="#0A99H" class="memory-link">JR 0A99H<span class="origrom2" style="display: inline;">JR CONIS1</span></a><span class="opcode2" style="display: none;">18 E8</span></div><div>Jump to 0A99H to store (HL) into the ACCumulator and set the VALTYPE accordingly.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0AB1H">0AB1H-0ACBH - LEVEL II BASIC <span class="code">CSNG</span> routine<span class="origrom">- "FRCSNG"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Force the number in the ACCumulator to be a single-precision number.  Every register is affected.<br><br><span class="code">CSNG</span> routine. Takes value from ACC and converts it to single-precision. The result is put in ACC and NTF contains 4.<br><br>CSNG routine. Takes value from ACC and converts it to single-precision. The result is put in ACC and NTF contains 4<br><br>Integer
 To Single: The contents of ACCumulator are converted from integer or 
double precision to single precision. All registers are used<br><br></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0AB1<span class="origrom2" style="display: inline;">FRCSNG</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H<span class="origrom2" style="display: inline;">GETYPE</span></a><span class="opcode2" style="display: none;">E7</span></div><div>We
 need to check the value of the current number type flag, so we call the
 TEST DATA MODE routine at RST 20H which determines the type of the 
current value in the ACCumulator and returns a combination of STATUS 
flags and unique numeric values in the register A according to the data 
mode flag (40AFH).  The results are returned as follows:<br><br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>0AB2</div><div>RET PO<span class="opcode2" style="display: none;">E0</span></div><div>IF PO is set, then we have SINGLE PRECISION number already, so nothing to do!  RETurn out of this subroutine</div></div>
									<div class="assembly-row-combined"><div>0AB3-0AB5</div><div><a href="#0ACCH" class="memory-link">JP M,0ACCH<span class="origrom2" style="display: inline;">JP M,CONSI</span></a><span class="opcode2" style="display: none;">FA CC 0A</span></div><div>If that test shows we have an INTEGER, jump to 0ACCH to convert it</div></div>
									<div class="assembly-row-combined"><div>0AB6-0AB8</div><div><a href="#0AF6H" class="memory-link">JP Z,0AF6H<span class="origrom2" style="display: inline;">JP Z,TMERR</span></a><span class="opcode2" style="display: none;">CA F6 0A</span></div><div>If that test shows we have a STRING, display a <span class="code">?TM ERROR</span>.  Otherwise, fall into the DOUBLE PRECISION routine, located just after to avoid a JUMP to it.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0AB9H">0AB9 - LEVEL II BASIC NUMBER CONVERSION ROUTINE<span class="origrom">- "CONSD"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Convert a double-prevision number to single-precision.  Every register is affected.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0AB9-0ABB<span class="origrom2" style="display: inline;">CONSD</span></div><div><a href="#09BFH" class="memory-link">CALL 09BFH<span class="origrom2" style="display: inline;">CALL MOVRF</span></a><span class="opcode2" style="display: none;">CD BF 09</span></div><div>Move
 the HIGH ORDER/MSB's into the registers via a call to MOVRF which loads
 the SINGLE PRECISION value in the ACCumulator (which is currently the 
most significant four bytes of the double precision value in the 
ACCumulator) into Register Pair BC/DE</div></div>
									<div class="assembly-row-combined"><div>0ABC-0ABE</div><div><a href="#0AEFH" class="memory-link">CALL 0AEFH<span class="origrom2" style="display: inline;">CALL VALSNG</span></a><span class="opcode2" style="display: none;">CD EF 0A</span></div><div>Go set the current number type flag to single precision.</div></div>
									<div class="assembly-row-combined"><div>0ABF</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Next we need to see if the number is zero, so load Register A with the exponent of the double precision value in Register B</div></div>
									<div class="assembly-row-combined"><div>0AC0</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the exponent in the ACCumulator is equal to zero</div></div>
									<div class="assembly-row-combined"><div>0AC1</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>If the exponent is zero, then the number is zero, so RETurn</div></div>
									<div class="assembly-row-combined"><div>0AC2-0AC4</div><div><a href="#09DFH" class="memory-link">CALL 09DFH<span class="origrom2" style="display: inline;">CALL UNPACK</span></a><span class="opcode2" style="display: none;">CD DF 09</span></div><div>We
 now know the number isn't zero, so we need to unpack the number via a 
CALL to UNPACK which will turn on the most significant bit of the single
 precision value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0AC5-0AC7</div><div>LD HL,4120H<span class="origrom2" style="display: inline;">LD HL,FACLO-1</span><span class="opcode2" style="display: none;">21 20 41</span></div><div>Load
 Register Pair HL with the address of the first byte below a 
single-prevision value (i.e., chop off the MSB of a double double 
precision value)</div></div>
									<div class="assembly-row-combined"><div>0AC8</div><div>LD B,(HL)<span class="opcode2" style="display: none;">46</span></div><div>Loaded Register B with the chopped number, as that is where the ROUND routine expects the number to be</div></div>
									<div class="assembly-row-combined"><div>0AC9-0ACB</div><div><a href="#0796H" class="memory-link">JP 0796H<span class="origrom2" style="display: inline;">JP ROUND</span></a><span class="opcode2" style="display: none;">C3 96 07</span></div><div>Jump to 0796H to round the chopped number up and RETurn</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0ACCH">0ACCH-0ADAH  -LEVEL II BASIC NUMBER CONVERSION ROUTINE<span class="origrom">- "CONSI"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Convert Integer to Single Precision.  Every register is affected.<br><br>Note:
 If you wanted to convert integer to single precision via a ROM call, 
you would store the integer input variable in 4121H-4122H and then call 
to 0ACCH.  The result (as a single precision number) will be in 
4121H-4124H. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0ACC-0ACE<span class="origrom2" style="display: inline;">CONSI</span></div><div>LD HL,(4121H)<span class="origrom2" style="display: inline;">LD HL,(FACLO)</span><span class="opcode2" style="display: none;">2A 21 41</span></div><div>Load Register Pair HL with the integer value from the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0ACF-0AD1<span class="origrom2" style="display: inline;">CONSIH</span></div><div><a href="#0AEFH" class="memory-link">CALL 0AEFH<span class="origrom2" style="display: inline;">CALL VALSNG</span></a><span class="opcode2" style="display: none;">CD EF 0A</span></div><div>Go set the current number type flag to single precision</div></div>
									<div class="assembly-row-combined"><div>0AD2</div><div>LD A,H<span class="opcode2" style="display: none;">7C</span></div><div>Now
 we need to prepare the registers for the FLOATR routine.  First, load 
Register A with the MSB of the integer value in Register H</div></div>
									<div class="assembly-row-combined"><div>0AD3</div><div>LD D,L<span class="opcode2" style="display: none;">55</span></div><div>Load Register D with the LSB of the integer value in Register L</div></div>
									<div class="assembly-row-combined"><div>0AD4-0AD5</div><div>LD E,00H<span class="opcode2" style="display: none;">1E 00</span></div><div>Zero Register E</div></div>
									<div class="assembly-row-combined"><div>0AD6-0AD7</div><div>LD B,90H<span class="opcode2" style="display: none;">06 90</span></div><div>Load Register B with the initial maximum exponent</div></div>
									<div class="assembly-row-combined"><div>0AD8-0ADA</div><div><a href="#0969H" class="memory-link">JP 0969H<span class="origrom2" style="display: inline;">JP FLOATR</span></a><span class="opcode2" style="display: none;">C3 69 09</span></div><div>Jump to 0969H to float the integer into single precision</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0ADBH">0ADBH-0AEDH - LEVEL II BASIC CDBL ROUTINE<span class="origrom">- "FRCDBL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p><span class="code">CDBL</span> routine. Takes a value from 
ACCumulator (regardless of integer or single precision) and convert it 
to double-precision. The result will be in ACC and NTF will be 8.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0ADB<span class="origrom2" style="display: inline;">FRCDBL</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H<span class="origrom2" style="display: inline;">GETYPE</span></a><span class="opcode2" style="display: none;">E7</span></div><div>We
 need to check the value of the current number type flag, so we call the
 TEST DATA MODE routine at RST 20H which determines the type of the 
current value in the ACCumulator and returns a combination of STATUS 
flags and unique numeric values in the register A according to the data 
mode flag (40AFH).  The results are returned as follows:<br><br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>0ADC</div><div>RET NC<span class="opcode2" style="display: none;">D0</span></div><div>If that test shows we have already a DOUBLE PRECISION number, then we are done, so RETurn out of the subroutine</div></div>
									<div class="assembly-row-combined"><div>0ADD-0ADF</div><div><a href="#0AF6H" class="memory-link">JP Z,0AF6H<span class="origrom2" style="display: inline;">JP Z,TMERR</span></a><span class="opcode2" style="display: none;">CA F6 0A</span></div><div>If that test shows we have a STRING, Display a TM ERROR message.</div></div>
									<div class="assembly-row-combined"><div>0AE0-0AE2</div><div><a href="#0ACCH" class="memory-link">CALL M,0ACCH<span class="origrom2" style="display: inline;">CALL M,CONSI</span></a><span class="opcode2" style="display: none;">FC CC 0A</span></div><div>If
 that test shows we have an INTEGER, then go to 0ACCH to convert that 
integer to SINGLE PRECISION and then fall into the CONDS routine to 
convert a single precision number into double precision.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0AE3H">0AE3H - LEVEL II BASIC CDBL ROUTINE<span class="origrom">- "CONDS"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Convert a single precision number to double precisions.  Modifies Registers A, H, and L.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0AE3-0AE5<span class="origrom2" style="display: inline;">CONDS</span></div><div>LD HL,0000H<span class="opcode2" style="display: none;">21 00 00</span></div><div>Load Register Pair HL with zero so we can zero out the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0AE6-0AE8</div><div>LD (411DH),HL<span class="origrom2" style="display: inline;">LD (DFACLO),HL</span><span class="opcode2" style="display: none;">22 1D 41</span></div><div>Zero out the first and second bytes of the double precision number in the ACCumulator.<br>Note: 411DH-4124H holds ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0AE9-0AEB</div><div>LD (411FH),HL<span class="origrom2" style="display: inline;">LD (DFACLO+2),HL</span><span class="opcode2" style="display: none;">22 1F 41</span></div><div>Zero out the third and fourth bytes of the double precision number in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0AEC-0AED<span class="origrom2" style="display: inline;">VALDBL</span></div><div>LD A,08H<span class="opcode2" style="display: none;">3E 08</span></div><div>Load Register A with a double precision number type flag</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0AEEH">0AEEH-0AF3H - LEVEL II BASIC MATH ROUTINE<span class="origrom">- "VALSNG"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0AEE</div><div>LD BC,043EH<span class="opcode2" style="display: none;">01 3E 04</span></div><div>Z-80 Trick.  If passing through to this routine, BC will be modified but the next instruction will be skipped.</div></div>
									<div class="assembly-row-combined"><div>0AEF-0AF0<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;VALSNG</span></div><div>LD A,04H<br><span class="opcode2" style="display: none;">3E 04</span></div><div>Load Register A with a single precision number type flag (of 4)</div></div>
									<div class="assembly-row-combined"><div>0AF1-0AF3</div><div><a href="#0A9FH" class="memory-link">JP 0A9FH<span class="origrom2" style="display: inline;">JP CONISD</span></a><span class="opcode2" style="display: none;">C3 9F 0A</span></div><div>However
 we got here, Register A now holds the desired VALTYPE, so jump away to 
0A9FH to save the value in Register A as the VALTYPE and RETurn</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0AF4H">0AF4H-0AFAH - LEVEL II BASIC MATH ROUTINE<span class="origrom">- "CHKSTR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will force the ACCUmlator to be a STRING.  Only Register A is modified.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0AF4<span class="origrom2" style="display: inline;">CHKSTR</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H<span class="origrom2" style="display: inline;">GETYPE</span></a><span class="opcode2" style="display: none;">E7</span></div><div>We
 need to check the value of the current number type flag, so we call the
 TEST DATA MODE routine at RST 20H which determines the type of the 
current value in the ACCumulator and returns a combination of STATUS 
flags and unique numeric values in the register A according to the data 
mode flag (40AFH).  The results are returned as follows:<br><br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>0AF5</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>If
 that test shows we already have a STRING then we are done, so RETturn 
out of the subroutine.  Otherwise, fall into the ?TM ERROR routine, 
placed here to save bytes and avoid a JUMP.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0AF6H">0AF6 - ?TM Error Routine<span class="origrom">- "TMERR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0AF6-0AF7<span class="origrom2" style="display: inline;">TMERR</span></div><div>LD E,18H<span class="opcode2" style="display: none;">1E 18</span></div><div>Load Register E with a ?TM ERROR code.<br><br>This is the entry point for the TM ERROR</div></div>
									<div class="assembly-row-combined"><div>0AF8-0AFA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#19A2H" class="memory-link">JP 19A2H<span class="origrom2" style="display: inline;">JP ERROR</span></a><span class="opcode2" style="display: none;">C3 A2 19</span></div><div>Display a TM ERROR message if the current value in the ACCumulator isn't a string</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0AFBH">0AFBH-0B1EH - LEVEL II BASIC MATH ROUTINE<span class="origrom">- "QINT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine is a quick "Greatest Integer" function.  Registers A-E are affected.<br><br>The result of INT(ACCumulator) is left in C/D/E as a signed number<br><br>This
 routine assumes that the number in the ACCumulator is less than 
8,388,608 (i.e., 2^23) and that the exponent of the ACCumulator is held 
in Register A on entry.<br><br>This routine can also be used to reset 
the BC and DE Register Pairs if the A Register contains 0. (XOR A before
 calling this routine). </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0AFB<span class="origrom2" style="display: inline;">QINT</span></div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Load
 Register B with the exponent of the single precision number in Register
 A.  If a XOR A was executed before calling this routine, then the 
following will zero all of the registers.</div></div>
									<div class="assembly-row-combined"><div>0AFC</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the exponent of the single precision number in Register A</div></div>
									<div class="assembly-row-combined"><div>0AFD</div><div>LD D,A<span class="opcode2" style="display: none;">57</span></div><div>Load Register D with the exponent of the single precision number in Register A</div></div>
									<div class="assembly-row-combined"><div>0AFE</div><div>LD E,A<span class="opcode2" style="display: none;">5F</span></div><div>Load Register E with the exponent of the single precision number in Register A</div></div>
									<div class="assembly-row-combined"><div>0AFF</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the single precision number in the ACCumulator is equal to zero</div></div>
									<div class="assembly-row-combined" id="0B00H"><div>0B00</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>If
 Register A was 0 on entry (meaning that the exponent of the number is 
0), then RETurn the same way but with C/D/E = 0, as any number whose 
exponent is 0 is 0.</div></div>
									<p class="debug-note">The original ROM source code has this to say about the next set of instructions:<br><br>
 The hard case in QINT is negative non-integers.  To handle this, if the
 number is negative, we regard the 3-byte mantissa as a 3-byte integer 
and subtract one.  Then all the fractional bits are shifted out by 
shifting the mantissa right.  Then, if the number was negative, we add 
one.<br><br> So, if we had a negative integer, all the bits to the right
 of the binary point were zero and the net effect is we have the 
original number in C/D/E.<br><br> If the number was a negative 
non-integer, there is at least one non-zero bit to the right of the 
binary point and the net effect is that we get the absolute value of 
int(fac) in C/D/E.  C/D/E is then negated if the original number was 
negative so the result will be signed. </p>
									<div class="assembly-row-combined"><div>0B01</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the value in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0B02-0B04</div><div><a href="#09BFH" class="memory-link">CALL 09BFH<span class="origrom2" style="display: inline;">CALL MOVRF</span></a><span class="opcode2" style="display: none;">CD BF 09</span></div><div>Call 09BF which loads the SINGLE PRECISION value in the ACCumulator into Register Pair BC/DE</div></div>
									<div class="assembly-row-combined"><div>0B05-0B07</div><div><a href="#09DFH" class="memory-link">CALL 09DFH<span class="origrom2" style="display: inline;">CALL UNPACK</span></a><span class="opcode2" style="display: none;">CD DF 09</span></div><div>Go turn on the sign bit of the single precision value in Register Pairs BC and DE</div></div>
									<div class="assembly-row-combined"><div>0B08</div><div>XOR (HL)<span class="opcode2" style="display: none;">AE</span></div><div>Set the sign bit according to the sign of the value at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0B09</div><div>LD H,A<span class="opcode2" style="display: none;">67</span></div><div>Preserve the sign of the numbers into Register H</div></div>
									<div class="assembly-row-combined"><div>0B0A-0B0C</div><div><a href="#0B1FH" class="memory-link">CALL M,0B1FH<span class="origrom2" style="display: inline;">CALL M,QINTA</span></a><span class="opcode2" style="display: none;">FC 1F 0B</span></div><div>If the number was negative, we need to substract 1 from the LOW ORDER/LSB and to do that we GOSUB to QINTA</div></div>
									<div class="assembly-row-combined"><div>0B0D-0B0E</div><div>LD A,98H<span class="opcode2" style="display: none;">3E 98</span></div><div>Next
 we need to see how many number of bits we need to shift to change the 
number to an integer, so start that calculation by loading Register A 
with the maximum exponent</div></div>
									<div class="assembly-row-combined"><div>0B0F</div><div>SUB B<span class="opcode2" style="display: none;">90</span></div><div>and then subtract the exponent in Register B from the exponent in Register A</div></div>
									<div class="assembly-row-combined"><div>0B10-0B12</div><div><a href="#07D7H" class="memory-link">CALL 07D7H<span class="origrom2" style="display: inline;">CALL SHIFTR</span></a><span class="opcode2" style="display: none;">CD D7 07</span></div><div>Shift the single precision value in Register Pairs BC and DE to get rid of any fractional bits via a GOSUB to SHIFTR.</div></div>
									<div class="assembly-row-combined"><div>0B13</div><div>LD A,H<span class="opcode2" style="display: none;">7C</span></div><div>Restore the SIGN back into  Register A from  Register H</div></div>
									<div class="assembly-row-combined"><div>0B14</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Put the sign bit into the Carry flag so that it won't get changed.</div></div>
									<div class="assembly-row-combined"><div>0B15-0B17</div><div><a href="#07A8H" class="memory-link">CALL C,07A8H<span class="origrom2" style="display: inline;">CALL C,ROUNDA</span></a><span class="opcode2" style="display: none;">DC A8 07</span></div><div>If
 the original number was negative (and thus the CARRY FLAG is set), 
GOSUB to ROUNDA to bump the value in Register Pairs BC and DE by 1 </div></div>
									<div class="assembly-row-combined"><div>0B18-0B19</div><div>LD B,00H<span class="opcode2" style="display: none;">06 00</span></div><div>Clear our Register B</div></div>
									<div class="assembly-row-combined"><div>0B1A-0B1C</div><div><a href="#07C3H" class="memory-link">CALL C,07C3H<span class="origrom2" style="display: inline;">CALL C,NEGR</span></a><span class="opcode2" style="display: none;">DC C3 07</span></div><div>If the original number was negative, we need to negate the number because we need a signed mantissa</div></div>
									<div class="assembly-row-combined"><div>0B1D</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Restore HL from the STACK where it was saved at the top of this routine</div></div>
									<div class="assembly-row-combined"><div>0B1E</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0BlFH">0BlFH-0B25H - LEVEL II BASIC MATH ROUTINE<span class="origrom">- "QINTA"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0B1F<span class="origrom2" style="display: inline;">QINTA</span></div><div>DEC DE<span class="opcode2" style="display: none;">1B</span></div><div>Decrement C/D/E by 1</div></div>
									<div class="assembly-row-combined"><div>0B20</div><div>LD A,D<span class="opcode2" style="display: none;">7A</span></div><div>Now
 we need to see if we need to carry that further and subtract one from 
C, so load Register A with the value of the NMSB for the single 
precision value which is held in Register D</div></div>
									<div class="assembly-row-combined"><div>0B21</div><div>AND E<span class="opcode2" style="display: none;">A3</span></div><div>Combine the LSB of the single precision value in Register E with the NMSB of the single precision value in Register A</div></div>
									<div class="assembly-row-combined"><div>0B22</div><div>INC A<span class="opcode2" style="display: none;">3C</span></div><div>Increment the combined value in Register A</div></div>
									<div class="assembly-row-combined"><div>0B23</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>If both D and E were -1 (i.e., DE was FFFFH) then RETurn</div></div>
									<div class="assembly-row-combined"><div>0B24<span class="origrom2" style="display: inline;">DCXBRT</span></div><div>DEC BC<span class="opcode2" style="display: none;">0B</span></div><div>Decrement
 the value of the exponent and the MSB of the single precision value in 
Register Pair BC.  A note in the original ROM source said that this was 
put in specifically at the request of Bill Gates and that Register C 
would never be ZERO, so DEC BC and DEC C would be functionally 
equivalent.</div></div>
									<div class="assembly-row-combined"><div>0B25</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0B26H">0B26H-0B58H - LEVEL II BASIC <span class="code">FIX</span> routine<br><span class="origrom">- "FIX"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the <span class="code">FIX(n)</span> routine.  It returns SGN(n)*INT(ABS(n))<br><br>Takes
 a value from ACC and converts it to an integer value. The result will 
be in ACC. NTF will be 2 if value is smaller than 32767 else it will be 
4. An error will be generated if NTF=3 (string).<br>A call to 0B26H 
unconditionally truncates the fractional part of a floating point number
 in the ACCumulator. The result is stored in the ACCumulator and the 
type flag is set to integer.<br><br>Note: If you wanted to call the <span class="code">FIX</span>
 routine via a ROM call, you would store the single-precision input 
variable in 4121H-4124H, then put a 4 into 40AFH to flag as single 
precision, and then call to 0B26H.  If the result can be an integer, it 
will be in 4121H-4122H and in the HL Register Pair.  If single 
precision, the result will be in 4121H-4124H.  If double precision, in 
411DH-4124H.  In all cases 40AFH will have the data mode flag as 2, 4, 
or 8, accordingly.<br><br>FIX routine. Takes a value from ACC and 
converts it to an integer value. The result will be in ACC. NTF will be 2
 if value is smaller than 32767 else it will be 4. An error will be 
generated if NTF=3 (string)<br><br>Floating To Integer: Unconditionally 
truncates the fractional part of a floating point number in the 
ACCumulator. The result is stored in the ACCumulator and the type flag 
is set to integer </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0B26<span class="origrom2" style="display: inline;">FIX</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H<span class="origrom2" style="display: inline;">GETYPE</span></a><span class="opcode2" style="display: none;">E7</span></div><div>We
 need to check the value of the current number type flag, so we call the
 TEST DATA MODE routine at RST 20H which determines the type of the 
current value in the ACCumulator and returns a combination of STATUS 
flags and unique numeric values in the register A according to the data 
mode flag (40AFH).  The results are returned as follows:<br><br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>0B27</div><div>RET M<span class="opcode2" style="display: none;">F8</span></div><div>If that test shows we have an INTEGER then we are all done, so RETurn to the caller</div></div>
									<div class="assembly-row-combined"><div>0B28-0B2A</div><div><a href="#0955H" class="memory-link">CALL 0955H<span class="origrom2" style="display: inline;">CALL SIGN</span></a><span class="opcode2" style="display: none;">CD 55 09</span></div><div>Go check the sign of the current value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0B2B-0B2D</div><div><a href="#0B37H" class="memory-link">JP P,0B37H<span class="origrom2" style="display: inline;">JP P,VINT</span></a><span class="opcode2" style="display: none;">F2 37 0B</span></div><div>If
 the current value in the ACCumulator is positive, then we only need to 
do a regular INT(n), so JUMP to 0B37H (which returns the integer portion
 of a floating point number. If the value is positive, the integer 
portion is returned. If the value is negative with a fractional part, it
 is rounded up before truncation. The integer portion is left in the 
ACCumulator. The mode flag is updated.)</div></div>
									<div class="assembly-row-combined"><div>0B2E-0B30</div><div><a href="#0982H" class="memory-link">CALL 0982H<span class="origrom2" style="display: inline;">CALL NEG</span></a><span class="opcode2" style="display: none;">CD 82 09</span></div><div>If
 we are here then the number was negative, and we need it to be 
positive, so GOSUB the NEG routine to convert the current value in the 
ACCumulator to positive</div></div>
									<div class="assembly-row-combined"><div>0B31-0B33</div><div><a href="#0B37H" class="memory-link">CALL 0B37H<span class="origrom2" style="display: inline;">CALL VINT</span></a><span class="opcode2" style="display: none;">CD 37 0B</span></div><div>Now
 that ACCumulator is positive, GOSUB to do a regular INT(n), so JUMP to 
0B37H (which returns the integer portion of a floating point number. If 
the value is positive, the integer portion is returned. If the value is 
negative with a fractional part, it is rounded up before truncation. The
 integer portion is left in the ACCumulator. The mode flag is updated.)</div></div>
									<div class="assembly-row-combined"><div>0B34-0B36</div><div><a href="#097BH" class="memory-link">JP 097BH<span class="origrom2" style="display: inline;">JP VNEG</span></a><span class="opcode2" style="display: none;">C3 7B 09</span></div><div>Since
 it was negative, we now need to make it negative again so JUMP to 097BH
 to re-NEGate the number and RETurn to the caller of this routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0B37H">0B37H - LEVEL II BASIC <span class="code">INT(</span> routine<span class="origrom">- "VINT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Return Integer: Returns the integer portion of a floating 
point number. Every flag is affected.  If the value is positive, the 
integer portion is returned. If the value is negative with a fractional 
part, it is rounded up before truncation. The integer portion is left in
 the ACCumulator<br><br>Note: If you wanted to call the <span class="code">INT</span>
 routine via a ROM call, you would store the single precision input 
variable in 4121H-4124H, put a 4 into 40AFH (to flag as single 
precision), and then call 0B3DH and bypass all the foregoing.  After the
 call, the integer result would be in 4121H-4122H and in the HL Register
 Pair IF the absolute value of the input did not exceed 32767.  
Otherwise it will be in 4121H-4124H in single precision format, and 40AF
 will be a 2 for integer or 4 for single precision </p>
								<p>According to Vernon Hester, there is are a number of bugs in this routine.<br>First,
 INT(value) should produce a result equal to or less than value. 
However, if the value is double-precision (by definition), the ROM 
rounds value to single-precision first, then performs the INT function. 
e.g., PRINT INT(2.9999999) produces 3 instead of 2.<br>Next, INT(value) should never overflow. However, if the value is double-precision 32767.9999#, the ROM overflows.<br>Next,
 INT(value) should produce a result equal to or less than value. 
However, if the value is double-precision equal to ?2"n+2"(n-7) where n 
is an integer &gt;14, the ROM produces an incorrect value. e.g., PRINT 
INT(?44800#) produces ?45056 </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0B37<span class="origrom2" style="display: inline;">VINT</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H<span class="origrom2" style="display: inline;">GETYPE</span></a><span class="opcode2" style="display: none;">E7</span></div><div>We
 need to check the value of the current number type flag, so we call the
 TEST DATA MODE routine at RST 20H which determines the type of the 
current value in the ACCumulator and returns a combination of STATUS 
flags and unique numeric values in the register A according to the data 
mode flag (40AFH).  The results are returned as follows:<br><br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>0B38</div><div>RET M<span class="opcode2" style="display: none;">F8</span></div><div>If that test shows we have an INTEGER then we are done, so RETurn to CALLer.</div></div>
									<div class="assembly-row-combined"><div>0B39-0B3A</div><div><a href="#0B59H" class="memory-link">JR NC,0B59H<span class="origrom2" style="display: inline;">JR NC,DINT</span></a><span class="opcode2" style="display: none;">30 1E</span></div><div>If the NC FLAG is set, then we have a double density number, so JUMP to DINT to handle the conversion.</div></div>
									<div class="assembly-row-combined"><div>0B3B-0B3C</div><div><a href="#0AF6H" class="memory-link">JR Z,0AF6H<span class="origrom2" style="display: inline;">JP Z,TMERR</span></a><span class="opcode2" style="display: none;">28 B9</span></div><div>Display a <span class="code">?TM ERROR</span>if the current value in the ACCumulator isa string</div></div>
									<div class="assembly-row-combined"><div>0B3D-0B3F</div><div><a href="#0A8EH" class="memory-link">CALL 0A8EH<span class="origrom2" style="display: inline;">CALL CONIS</span></a><span class="opcode2" style="display: none;">CD 8E 0A</span></div><div>Now
 we try to use the CONIS routine to convert the single precision value 
in the ACCumulator to an integer.  If we can't we will return here to 
give a single precision result instead.</div></div>
									<div class="assembly-row-combined"><div>0B40-0B42<span class="origrom2" style="display: inline;">INT</span></div><div>LD HL,4124H<span class="origrom2" style="display: inline;">LD HL,FAC</span><span class="opcode2" style="display: none;">21 24 41</span></div><div>Load Register Pair HL with the address of the exponent in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0B43</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load
 Register A with the value of the exponent in the ACCumulator (held at 
the location of the memory pointer in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>0B44-0B45</div><div>CP 98H<span class="opcode2" style="display: none;">FE 98</span></div><div>Check
 to see if there are fractional bits used by the current value in the 
ACCumulator.  If are none, then the NC CARRY flag will be set.</div></div>
									<div class="assembly-row-combined"><div>0B46-0B48</div><div>LD A,(4121H)<span class="origrom2" style="display: inline;">LD A,(FACLO)</span><span class="opcode2" style="display: none;">3A 21 41</span></div><div>Load Register A with the LSB of the single precision number in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0B49</div><div>RET NC<span class="opcode2" style="display: none;">D0</span></div><div>If
 there are no fractional bits, then we are done, so RETurn with Register
 A holding the single precision value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0B4A</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load Register A with the exponent of the single precision number in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0B4B-0B4D</div><div><a href="#0AFBH" class="memory-link">CALL 0AFBH<span class="origrom2" style="display: inline;">CALL QINT</span></a><span class="opcode2" style="display: none;">CD FB 0A</span></div><div>If
 we are here, then there were fractional bits, so GOSUB to QINT to 
convert the single precision number in the ACCumulator to an integer</div></div>
									<div class="assembly-row-combined"><div>0B4E-0B4F</div><div>LD (HL),98H<span class="opcode2" style="display: none;">36 98</span></div><div>Adjust the exponent to be a correct one post-normalization</div></div>
									<div class="assembly-row-combined"><div>0B50</div><div>LD A,E<span class="opcode2" style="display: none;">7B</span></div><div>Load Register A with the LSB of the integer value in Register E</div></div>
									<div class="assembly-row-combined"><div>0B51</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the LSB of the integer value in Register A on the STACK</div></div>
									<div class="assembly-row-combined"><div>0B52</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>If the number was negative then we need to negate it, so first load Register A with the value in Register C</div></div>
									<div class="assembly-row-combined"><div>0B53</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Move the sign bit in Register A into the CARRY FLAG</div></div>
									<div class="assembly-row-combined"><div>0B54-0B56</div><div><a href="#0762H" class="memory-link">CALL 0762H<span class="origrom2" style="display: inline;">CALL FADFLT</span></a><span class="opcode2" style="display: none;">CD 62 07</span></div><div>GOSUB to FADLT to re-float the number</div></div>
									<div class="assembly-row-combined"><div>0B57</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the LSB of the single precision value from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>0B58</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0B59H">0B59H-0B9DH - LEVEL II BASIC MATH ROUTINE<span class="origrom">- "DINT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Greated Integer function for double-precision numbers.  All registers are affected.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0B59-0B5B<span class="origrom2" style="display: inline;">DINT</span></div><div>LD HL,4124H<span class="origrom2" style="display: inline;">LD HL,FAC</span><span class="opcode2" style="display: none;">21 24 41</span></div><div>Load Register Pair HL with the address of the exponent in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0B5C</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load
 Register A with the value of the exponent for the double precision 
number in the ACCumulator (stored at the location of the memory pointer 
in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>0B5D-0B5E</div><div>CP 90H<span class="opcode2" style="display: none;">FE 90</span></div><div>Check to see if the double precision number in the ACCumulator uses more or less than 16 bits of precision</div></div>
									<div class="assembly-row-combined"><div>0B5F-0B61</div><div><a href="#0A7FH" class="memory-link">JP C,0A7FH<span class="origrom2" style="display: inline;">JP C,FRCINT</span></a><span class="opcode2" style="display: none;">DA 7F 0A</span></div><div>If
 the double precision value in the ACCumulator uses less than 16 bits of
 precision, then we can use the FRCINT routine to do it, so JUMP to the 
CONVERT TO INTEGER routine at 0A7F (where the contents of ACCumulator 
are converted from single or double precision to integer and stored in 
HL)</div></div>
									<div class="assembly-row-combined"><div>0B62-0B63</div><div><a href="#0B78H" class="memory-link">JR NZ,0B78H<span class="origrom2" style="display: inline;">JR NZ,DINT2</span></a><span class="opcode2" style="display: none;">20 14</span></div><div>If the NZ flag was set, we still need to make sure we didn't have the special case number of -32768, so JUMP to DINT2</div></div>
									<div class="assembly-row-combined"><div>0B64</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>If
 we're here then we have to do it the hard way.  First, load Register C 
with the exponent for the double precision number in Register A</div></div>
									<div class="assembly-row-combined"><div>0B65</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement
 the value of the memory pointer in Register Pair HL to point to the 
HIGH ORDER (MSB+SIGN) portion of the double precision number</div></div>
									<div class="assembly-row-combined"><div>0B66</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load
 Register A with the HIGH ORDER (MSB+SIGN) of the double precision value
 in the ACCumulator at the location of the memory pointer in Register 
Pair HL</div></div>
									<div class="assembly-row-combined"><div>0B67-0B68</div><div>XOR 80H<span class="origrom">XOR 1000 0000</span><span class="opcode2" style="display: none;">EE 80</span></div><div>Complement the value of the sign bit in Register A (which is 1000 0000)</div></div>
									<div class="assembly-row-combined"><div>0B69-0B6A</div><div>LD B,06H<span class="opcode2" style="display: none;">06 06</span></div><div>Next we need to check to see if the rest of the number is ZERO, so load Register B with the number of bytes to be checked</div></div>
									<div class="assembly-row-combined"><div>0B6B<span class="origrom2" style="display: inline;">DINT1</span></div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Top of a loop.  Decrement the value of the memory pointer in Register Pair HL to point to the next byte of the number</div></div>
									<div class="assembly-row-combined"><div>0B6C</div><div>OR (HL)<span class="opcode2" style="display: none;">B6</span></div><div>Combine
 the value at the location of the memory pointer in Register HL with the
 value in Register A.  If any of the bits are non-zero, then A will then
 be non-zero</div></div>
									<div class="assembly-row-combined"><div>0B6D</div><div>DEC B<span class="opcode2" style="display: none;">05</span></div><div>Decrement the byte counter in Register B</div></div>
									<div class="assembly-row-combined"><div>0B6E-0B6F</div><div><a href="#0B6BH" class="memory-link">JR NZ,0B6BH<span class="origrom2" style="display: inline;">JR NZ,DINT1</span></a><span class="opcode2" style="display: none;">20 FB</span></div><div>Loop until all of the bytes have been checked.</div></div>
									<div class="assembly-row-combined"><div>0B70</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>The above loop kept ORing A with bits, so now we need to see what A actually holds, so set the flag.</div></div>
									<div class="assembly-row-combined"><div>0B71-0B73</div><div>LD HL,8000H<span class="opcode2" style="display: none;">21 00 80</span></div><div>Just in case, put -32768 into Register Pair HL.  Note that -32768 is negative 0 in double precision</div></div>
									<div class="assembly-row-combined"><div>0B74-0B76</div><div><a href="#0A9AH" class="memory-link">JP Z,0A9AH<span class="origrom2" style="display: inline;">JP Z,MAKINT</span></a><span class="opcode2" style="display: none;">CA 9A 0A</span></div><div>If the P flag is set, then Register A was zero (-32768), so JUMP to 0A9AH to deal with it</div></div>
									<div class="assembly-row-combined"><div>0B77</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Register
 A wasn't zero, so let's keep calcuating.  Load Register A with the 
exponent for the double precision value in Register C</div></div>
									<div class="assembly-row-combined"><div>0B78-0B79<span class="origrom2" style="display: inline;">DINT2</span></div><div>CP B8H<span class="opcode2" style="display: none;">FE B8</span></div><div>Check to see if there are fractional bits in for the double precision value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0B7A</div><div>RET NC<span class="opcode2" style="display: none;">D0</span></div><div>If the NO CARRY FLAG is set, then there are no fractional bits so we already have an integer!  With this, RETurn</div></div>
									<div class="assembly-row-combined"><div>0B7B<span class="origrom2" style="display: inline;">DINTFO</span><span class="origrom"><br>&nbsp;‚Ü≥&nbsp;"DINTFO"</span></div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save
 the exponent in Register A on the STACK.  This is the entry point from 
FOUT, and if that's the case, the CARRY FLAG will be set.</div></div>
									<div class="assembly-row-combined"><div>0B7C-0B7E</div><div><a href="#09BFH" class="memory-link">CALL 09BFH<span class="origrom2" style="display: inline;">CALL MOVRF</span></a><span class="opcode2" style="display: none;">CD BF 09</span></div><div>Gosub
 to 09BF which loads the HIGH ORDER (the most significant four bytes) of
 the double precision value in the ACCumulator into Register Pair BC/DE</div></div>
									<div class="assembly-row-combined"><div>0B7F-0B81</div><div><a href="#09DFH" class="memory-link">CALL 09DFH<span class="origrom2" style="display: inline;">CALL UNPACK</span></a><span class="opcode2" style="display: none;">CD DF 09</span></div><div>Gosub to 09DFH to turn on the sign bit and return with the value of the sign</div></div>
									<div class="assembly-row-combined"><div>0B82</div><div>XOR (HL)<span class="opcode2" style="display: none;">AE</span></div><div>Get the sign back by XORing A against (HL)</div></div>
									<div class="assembly-row-combined"><div>0B83</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement the value of the memory pointer in Register Pair HL to point to the exponent of the double-precision number</div></div>
									<div class="assembly-row-combined"><div>0B84-0B85</div><div>LD (HL),B8H<span class="opcode2" style="display: none;">36 B8</span></div><div>Save an exponent at the location of the memory pointer in Register HL for post-normalization</div></div>
									<div class="assembly-row-combined"><div>0B86</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the value of the sign test in Register A on the STACK</div></div>
									<div class="assembly-row-combined"><div>0B87-0B89</div><div><a href="#0BA0H" class="memory-link">CALL M,0BA0H<span class="origrom2" style="display: inline;">CALL M,DINTA</span></a><span class="opcode2" style="display: none;">FC A0 0B</span></div><div>If
 the number was negative, then the M FLAG will be set, in which case 
GOSUB to DINTA to subtract 1 from the LSB of the ACCumulato</div></div>
									<div class="assembly-row-combined"><div>0B8A-0B8C</div><div>LD HL,4123H<span class="origrom2" style="display: inline;">LD HL,FAC-1</span><span class="opcode2" style="display: none;">21 23 41</span></div><div>Load Register Pair HL with the address of the HIGH ORDER/MSB in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0B8D-0B8E</div><div>LD A,B8H<span class="opcode2" style="display: none;">3E B8</span></div><div>Next we need to see how many bits we need to shift, so start off with Register A being the the maximum value of an exponent</div></div>
									<div class="assembly-row-combined"><div>0B8F</div><div>SUB B<span class="opcode2" style="display: none;">90</span></div><div>Subtract the value of the exponent at the location of the memory pointer in Register Pair HL from the value in Register A</div></div>
									<div class="assembly-row-combined"><div>0B90-0B92</div><div><a href="#0D69H" class="memory-link">CALL 0D69H<span class="origrom2" style="display: inline;">CALL DSHFTR</span></a><span class="opcode2" style="display: none;">CD 69 0D</span></div><div>Shift the ACCumulator bits B times</div></div>
									<div class="assembly-row-combined"><div>0B93</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the value of the sign test from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>0B94-0B96</div><div><a href="#0D20H" class="memory-link">CALL M,0D20H<span class="origrom2" style="display: inline;">CALL M,DROUNA</span></a><span class="opcode2" style="display: none;">FC 20 0D</span></div><div>If the sign is negative, GOSUB to DROUNA to add 1 to the value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0B97</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A so we can put a zero into the extra LOW ORDER byte, so that when we normalize it, we shift in zeroes</div></div>
									<div class="assembly-row-combined"><div>0B98-0B9A</div><div>LD (411CH),A<span class="origrom2" style="display: inline;">LD (DFACLO-1),A</span><span class="opcode2" style="display: none;">32 1C 41</span></div><div>Put a ZERO into the starting address of ACCumulator minus one</div></div>
									<div class="assembly-row-combined"><div>0B9B</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get
 the value of the original exponent test from the STACK and put it in 
Register Pair AF.  This also will restore the CARRY FLAG if we entered 
here FOUT to indicate that we should NOT re-float the number</div></div>
									<div class="assembly-row-combined"><div>0B9C</div><div>RET NC<span class="opcode2" style="display: none;">D0</span></div><div>IF called from FOUT, then RETurn to skip re-floating the number.</div></div>
									<div class="assembly-row-combined"><div>0B9D-0B9F</div><div><a href="#0CD8H" class="memory-link">JP 0CD8H<span class="origrom2" style="display: inline;">JP DNORML</span></a><span class="opcode2" style="display: none;">C3 D8 0C</span></div><div>Jump to 0CD8H to re-float ("normalize") the number</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0BA0H">0BA0H-0BA9H - LEVEL II BASIC MATH ROUTINE<span class="origrom">- "DINTA"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0BA0-0BA2<span class="origrom2" style="display: inline;">DINTA</span></div><div>LD HL,411DH<span class="origrom2" style="display: inline;">LD HL,DFACLO</span><span class="opcode2" style="display: none;">21 1D 41</span></div><div>If we enter from DINTA, our purpose is to subtract 1 from the ACCumulator, so we point HL to the LSB of the ACCumulator.</div></div>
									<div class="assembly-row-combined"><div>0BA3<span class="origrom2" style="display: inline;">DINTA1</span></div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Regardless of how we enter this routine, the purpose now is to subtract 1 from (HL).  To do that, first get the value into A</div></div>
									<div class="assembly-row-combined"><div>0BA4</div><div>DEC (HL)<span class="opcode2" style="display: none;">35</span></div><div>Decrement the value at the location of the memory pointer in Register Pair HL by 1</div></div>
									<div class="assembly-row-combined"><div>0BA5</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>We really only want to continue if the byte uCheck to see if the byte used to be ZERO, so test the byte</div></div>
									<div class="assembly-row-combined"><div>0BA6</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the value of the memory pointer in Register Pair HL to point to the next byte</div></div>
									<div class="assembly-row-combined"><div>0BA7-0BA8</div><div><a href="#0BA3H" class="memory-link">JR Z,0BA3H<span class="origrom2" style="display: inline;">JR Z,DINTA1</span></a><span class="opcode2" style="display: none;">28 FA</span></div><div>Loop until the value at the location of the memory pointer in Register Pair HL is equal to a nonzero value</div></div>
									<div class="assembly-row-combined"><div>0BA9</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0BAAH">0BAAH-0BC6H - LEVEL II BASIC MATH ROUTINE<span class="origrom">- "UMULT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the integer multiply routine for multiplying 
dimensioned array.  It will calculate DE = BC * DE.  If there is an 
overflow, a ?BS ERROR will get thrown.  Every register except HL is 
affected.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0BAA<span class="origrom2" style="display: inline;">UMULT</span></div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the value in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0BAB-0BAD</div><div>LD HL,0000H<span class="opcode2" style="display: none;">21 00 00</span></div><div>Load Register Pair HL with zero to zero the product registers</div></div>
									<div class="assembly-row-combined"><div>0BAE<br>0BAF</div><div>LD A,B<br>OR C<span class="opcode2" style="display: none;">78 B1</span></div><div>First
 let's see if (BC) is zero by loading Register A with the MSB of the 
integer value in Register B and then ORing the LSB held in Register C</div></div>
									<div class="assembly-row-combined"><div>0BB0-0BB1</div><div><a href="#0BC4H" class="memory-link">JR Z,0BC4H<span class="origrom2" style="display: inline;">JR Z,MULRET</span></a><span class="opcode2" style="display: none;">28 12</span></div><div>If BC is already zero, then just return, since HL is already zero</div></div>
									<div class="assembly-row-combined"><div>0BB2-0BB3</div><div>LD A,10H<span class="opcode2" style="display: none;">3E 10</span></div><div>Load Register A with the counter value (which is 16)</div></div>
									<div class="assembly-row-combined"><div>0BB4<span class="origrom2" style="display: inline;">UMULT1</span></div><div>ADD HL,HL<span class="opcode2" style="display: none;">29</span></div><div>Top of a loop.  Multiply the result in Register Pair HL by two</div></div>
									<div class="assembly-row-combined"><div>0BB5-0BB7</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#273DH" class="memory-link">JP C,273DH<span class="origrom2" style="display: inline;">JP C,BSERR</span></a><span class="opcode2" style="display: none;">DA 3D 27</span></div><div>If the CARRY FLAG was set, then we have an overflow, which we handle by displaying  a ?BS ERROR message</div></div>
									<div class="assembly-row-combined"><div>0BB8</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Save the product so far into Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0BB9</div><div>ADD HL,HL<span class="opcode2" style="display: none;">29</span></div><div>Multiply the integer value in Register Pair HL by two</div></div>
									<div class="assembly-row-combined"><div>0BBA</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Swap DE and HL so DE now holds HL * 4 and HL holds HL * 2</div></div>
									<div class="assembly-row-combined"><div>0BBB-0BBC</div><div><a href="#0BC1H" class="memory-link">JR NC,0BC1H<span class="origrom2" style="display: inline;">JR NC,UMULT2</span></a><span class="opcode2" style="display: none;">30 04</span></div><div>If the HIGH ORDER/MSB from the HL addition was 1, then we need to add in (BC) so JUMP  to UMULT2 to do that</div></div>
									<div class="assembly-row-combined"><div>0BBD</div><div>ADD HL,BC<span class="opcode2" style="display: none;">09</span></div><div>Add the integer value in Register Pair BC to the result in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0BBE-0BC0</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#273DH" class="memory-link">JP C,273DH<span class="origrom2" style="display: inline;">JP C,BSERR</span></a><span class="opcode2" style="display: none;">DA 3D 27</span></div><div>Display a BS ERROR message if the result in Register Pair HL has overflowed</div></div>
									<div class="assembly-row-combined"><div>0BC1<span class="origrom2" style="display: inline;">UMULT2</span></div><div>DEC A<span class="opcode2" style="display: none;">3D</span></div><div>Decrement the counter in Register A</div></div>
									<div class="assembly-row-combined"><div>0BC2-0BC3</div><div><a href="#0BB4H" class="memory-link">JR NZ,0BB4H</a><span class="opcode2" style="display: none;">20 F0</span></div><div>Loop until the multiplication has been completed.</div></div>
									<div class="assembly-row-combined"><div>0BC2-0BC3</div><div><a href="#0BB4H" class="memory-link">JR NZ,0BB4H<span class="origrom2" style="display: inline;">JR NZ,UMULT1</span></a><span class="opcode2" style="display: none;">20 F0</span></div><div>Loop until the multiplication has been completed.</div></div>
									<div class="assembly-row-combined"><div>0BC4<span class="origrom2" style="display: inline;">MULRET</span></div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Swap so that the return result is in DE.  We don't care about HL because ...</div></div>
									<div class="assembly-row-combined"><div>0BC5</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>... restore the original HL from the STACK</div></div>
									<div class="assembly-row-combined"><div>0BC6</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
									<p class="debug-note">The next bunch of routines are the 
integer arithmetic routines.  According to the original ROM source code,
 the conventions are. </p><ul> <li>Integer variables are 2 byte signed numbers, with the LSB coming first</li> <li>For one argument functions, the argument is in (HL) and the results are put into (HL)</li> <li>For
 two argument operations, the first argument is in (DE), the second in 
(HL), and the restuls are left in the ACCumulator and, if there was no 
overflow, (HL).  If there was an overflow, then the arguments are 
converted to single precision.</li> <li>When integers are stored in the ACCumulator, they are stored at FACLO+0 and FACLO+1, with VALTYPE=2</li> </ul><p></p>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0BC7H">0BC7H-0BD1H - INTEGER SUBTRACTION<span class="origrom">- "ISUB"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Integer subtract. (ACCumulator=DE-HL) The result is returned 
in both ACCumulator and, if there was no overflow, the HL Register Pair.<br>Subtracts
 the value in DE from the value in HL. The difference is left in the HL 
Register Pair. DE is preserved. In the event of underflow, both values 
are converted to single precision and the subtraction is repeated. The 
result is left in the ACCumulator and the mode flag is updated 
accordingly.<br><br>Note: If you wanted to subtract 2 integers via a ROM
 call, store one into DE and the subtrahend in HL (i.e., to do 26-17, DE
 gets 26), and then call 0BC7H.  The integer result will be stored in 
4121H-4122H approximately 210 microseconds later, and 40AFH will be set 
to 2 (to flag it as an integer).  If there is an overflow, it will be 
converted to single precision (with 40AFH being a 4 in that case) and 
will be stored in 4121H-4124H.<br><br>Every register is affected.<br><br>Integer
 Subtraction: Subtracts the value in DE from the value in HL. The 
difference is left in the HL Register Pair. DE is preserved. In the 
event of underflow, both values are converted to single precision and 
the subtraction is repeated. The result is left in the ACCumulator and 
the mode flag is updated accordingly </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0BC7<span class="origrom2" style="display: inline;">ISUB</span></div><div>LD A,H<span class="opcode2" style="display: none;">7C</span></div><div>The
 first thing we need to do is to extend the sign of (HL) into Register 
B.  That's the next 4 instructions.  First, load Register A with the 
MSB+SIGN of the integer value in Register H</div></div>
									<div class="assembly-row-combined"><div>0BC8</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Rotate the value of the sign bit into the CARRY FLAG</div></div>
									<div class="assembly-row-combined"><div>0BC9</div><div>SBC A,A<span class="opcode2" style="display: none;">9F</span></div><div>Adjust Register A according to the value of the sign bit</div></div>
									<div class="assembly-row-combined"><div>0BCA</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Load Register B with the result of the sign test</div></div>
									<div class="assembly-row-combined"><div>0BCB-0BCD</div><div><a href="#0C51H" class="memory-link">CALL 0C51H<span class="origrom2" style="display: inline;">CALL INEGHL</span></a><span class="opcode2" style="display: none;">CD 51 0C</span></div><div>Negate (HL) via a GOSUB to INEGHL</div></div>
									<div class="assembly-row-combined"><div>0BCE</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with zero</div></div>
									<div class="assembly-row-combined"><div>0BCF</div><div>SBC A,B<span class="opcode2" style="display: none;">98</span></div><div>Negate the sign</div></div>
									<div class="assembly-row-combined"><div>0BD0-0BD1</div><div><a href="#0BD5H" class="memory-link">JR 0BD5H<span class="origrom2" style="display: inline;">JR IADDS</span></a><span class="opcode2" style="display: none;">18 03</span></div><div>Jump to 0BD5H to add the numbers</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0BD2H">0BD2H-0BF1H - INTEGER ADDITION<span class="origrom">- "IADD"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Integer addition (ACCumulator=DE+HL), where ACCumulator = 
4121H-4122H. After execution NTF=2, or 4 if overflow has occurred, in 
which case the result in the ACCumulator will be single-precision. The 
result is returned in both ACCumulator and the HL Register Pair.<br><br>Adds
 the integer value in DE to the integer in HL. The sum is left in HL and
 the orginal contents of DE are preserved. If overflow occurs (sum 
exceeds 2**15), both values are converted to single precision and then 
added. The result would be left in the ACCumulator and the mode flag 
would be updated.<br><br>Every register is affected.<br><br>Note: If you
 wanted to add 2 integers via a ROM call, store one input into DE and 
the other into HL, and then call 0BD2H.  The result will be in 
4121H-4122H and in HL, with a 2 in 40AFH, and will take about 130 
microseconds.  If there is an overflow, the result will be converted to 
Single Precision and put into 4121H-4124H (with a 4 in 40AFH). </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0BD2<span class="origrom2" style="display: inline;">IADD</span></div><div>LD A,H<span class="opcode2" style="display: none;">7C</span></div><div>The
 first thing we need to do is to extend the sign of (HL) into Register 
B.  That's the next 4 instructions.  First, load Register A with the 
MSB+SIGN of the integer value in Register H</div></div>
									<div class="assembly-row-combined"><div>0BD3</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Rotate the value of the sign bit into the CARRY FLAG</div></div>
									<div class="assembly-row-combined"><div>0BD4</div><div>SBC A,A<span class="opcode2" style="display: none;">9F</span></div><div>Adjust Register A according to the value of the sign bit</div></div>
									<div class="assembly-row-combined"><div>0BD5<span class="origrom2" style="display: inline;">IADDS</span></div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Load Register B with the result of the sign test</div></div>
									<div class="assembly-row-combined"><div>0BD6</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the second argument (held in Register Pair HL) to the the STACK in case we have an overflow</div></div>
									<div class="assembly-row-combined"><div>0BD7</div><div>LD A,D<span class="opcode2" style="display: none;">7A</span></div><div>The
 next 4 instructions extend the sign of (DE) into Register A.  First, 
load Register A with the MSB+SIGN of the integer value in Register Pair 
DE</div></div>
									<div class="assembly-row-combined"><div>0BD8</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Rotate the value of the sign bit into the CARRY FLAG</div></div>
									<div class="assembly-row-combined"><div>0BD9</div><div>SBC A,A<span class="opcode2" style="display: none;">9F</span></div><div>Adjust Register A according to the value of the sign bit</div></div>
									<div class="assembly-row-combined"><div>0BDA</div><div>ADD HL,DE<span class="opcode2" style="display: none;">19</span></div><div>Add the two LSBs, result in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0BDB</div><div>ADC A,B<span class="opcode2" style="display: none;">88</span></div><div>Add
 the extra HIGH ORDER (held in Register B) to the value of the sign test
 for the integer value in Register Pair DE in Register A</div></div>
									<div class="assembly-row-combined"><div>0BDC</div><div>RRCA<span class="opcode2" style="display: none;">0F</span></div><div>The
 next 2 instructions are to see if the LSB of A is different from the 
MSB of H, in which ase an overflow occurred.  So, put the value of the 
Carry flag in Register A</div></div>
									<div class="assembly-row-combined"><div>0BDD</div><div>XOR H<span class="opcode2" style="display: none;">AC</span></div><div>Combine the value of the sign bit for the result in Register H with the value in Register A</div></div>
									<div class="assembly-row-combined"><div>0BDE-0BE0</div><div><a href="#0A99H" class="memory-link">JP P,0A99H<span class="origrom2" style="display: inline;">JP P,CONIS1</span></a><span class="opcode2" style="display: none;">F2 99 0A</span></div><div>If
 the P FLAG is set, then we had no overflow.  In this case, we need to 
restore the original (HL) from the stack and we are done.  So JUMP to 
CONIS1 to do all that AND put (HL) into the ACCumulator as well.</div></div>
									<div class="assembly-row-combined"><div>0BE1</div><div>PUSH BC<span class="opcode2" style="display: none;">C5</span></div><div>If we are here then we have an overflow.  First, save the extended sign of (HL) (held in Register B) to the STACK</div></div>
									<div class="assembly-row-combined"><div>0BE2</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Load Register Pair HL with the integer value in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0BE3-0BE5</div><div><a href="#0ACFH" class="memory-link">CALL 0ACFH<span class="origrom2" style="display: inline;">CALL CONSIH</span></a><span class="opcode2" style="display: none;">CD CF 0A</span></div><div>Go float the Register value in Register Pair HL to single precision and return with the result in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0BE6</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the sign of (HL) from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>0BE7</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the old  (HL) back from the STACK</div></div>
									<div class="assembly-row-combined"><div>0BE8-0BEA</div><div><a href="#09A4H" class="memory-link">CALL 09A4H<span class="origrom2" style="display: inline;">CALL PUSHF</span></a><span class="opcode2" style="display: none;">CD A4 09</span></div><div>Call 09A4 which moves the SINGLE PRECISION value in the ACCumulator to the STACK (stored in LSB/MSB/Exponent order)</div></div>
									<div class="assembly-row-combined"><div>0BEB</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Load Register Pair DE with the integer value in Register Pair HL, as FLOATR needs DE to hold the value</div></div>
									<div class="assembly-row-combined"><div>0BEC-0BEE</div><div><a href="#0C6BH" class="memory-link">CALL 0C6BH<span class="origrom2" style="display: inline;">CALL INEGAD</span></a><span class="opcode2" style="display: none;">CD 6B 0C</span></div><div>Go float  the integer value in Register Pair DE to single precision and return with the result in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0BEF-0BF1</div><div><a href="#0F8FH" class="memory-link">JP 0F8FH<span class="origrom2" style="display: inline;">JP FADDT</span></a><span class="opcode2" style="display: none;">C3 8F 0F</span></div><div>At this point the basic values are good enough to be added via single precision, so JUMP to FADDT to do that</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0BF2H">0BF2H-0C1EH - INTEGER MULTIPLICATION<span class="origrom">- "IMULT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Integer multiply. (ACCumulator (and HL) =DE*HL).  Multiplies 
HL by DE. The product is left in HL and DE is preserved. If overflow 
occurs, both values are converted to single precision and the operation 
is restarted. The product would be left in the ACCumulator.<br><br>Note:
 If you wanted to multiply two integers, store one input in DE, the 
other in HL CALL 0BF2H.  The result is in 4121H-4122H and in HL, with a 2
 in 40AFH (but in an overflow the result is converted to single 
precision format and stored in 4121H-4124H, with a 4 in 40AFH. Process 
takes approximately 900 microseconds.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0BF2<span class="origrom2" style="display: inline;">IMULT</span></div><div>LD A,H<span class="opcode2" style="display: none;">7C</span></div><div>Load Register A with the MSB of the integer value in Register H</div></div>
									<div class="assembly-row-combined"><div>0BF3</div><div>OR L<span class="opcode2" style="display: none;">B5</span></div><div>Combine the LSB of the integer value in Register L with the MSB of the integer value in Register A</div></div>
									<div class="assembly-row-combined"><div>0BF4-0BF6</div><div><a href="#0A9AH" class="memory-link">JP Z,0A9AH<span class="origrom2" style="display: inline;">JP Z,MAKINT</span></a><span class="opcode2" style="display: none;">CA 9A 0A</span></div><div>If the ZERO flag is set, then HL is zero, and if so, just return</div></div>
									<div class="assembly-row-combined"><div>0BF7</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>In case of an overflow, we are going to need our original arguments.  Save the integer value in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0BF8</div><div>PUSH DE<span class="opcode2" style="display: none;">D5</span></div><div>Save the integer value in Register Pair DE on the STACK</div></div>
									<div class="assembly-row-combined"><div>0BF9-0BFB</div><div><a href="#0C45H" class="memory-link">CALL 0C45H<span class="origrom2" style="display: inline;">CALL IMULDV</span></a><span class="opcode2" style="display: none;">CD 45 0C</span></div><div>Go convert any negative integer values to positive and return with Register B set according to the value of the sign bits</div></div>
									<div class="assembly-row-combined"><div>0BFC</div><div>PUSH BC<span class="opcode2" style="display: none;">C5</span></div><div>Save the value of the sign bit test in Register B on the STACK</div></div>
									<div class="assembly-row-combined"><div>0BFD<br>0BFE</div><div>LD B,H<br>LD C,L<span class="opcode2" style="display: none;">44</span></div><div>Copy the second argument from HL into BC</div></div>
									<div class="assembly-row-combined" id="0C00H"><div>0BFF-0C01</div><div>LD HL,0000H<span class="opcode2" style="display: none;">21 00 00</span></div><div>Start Register Pair HL at zero, as the result will go into HL</div></div>
									<div class="assembly-row-combined"><div>0C02-0C03</div><div>LD A,10H<span class="opcode2" style="display: none;">3E 10</span></div><div>Load Register A with the counter value (which is 16)</div></div>
									<div class="assembly-row-combined"><div>0C04<span class="origrom2" style="display: inline;">IMULT1</span></div><div>ADD HL,HL<span class="opcode2" style="display: none;">29</span></div><div>Multiply the result in Register Pair HL by two</div></div>
									<div class="assembly-row-combined"><div>0C05-0C06</div><div><a href="#0C26H" class="memory-link">JR C,0C26H<span class="origrom2" style="display: inline;">JR C,IMULT5</span></a><span class="opcode2" style="display: none;">38 1F</span></div><div>If that caused an overflow, then JUMP to IMULT5</div></div>
									<p class="debug-note">The next 6 instruction are to roate the 
first argument left one to see if we need to add BC to it or not.  If 
the NC FLAG is set, then we don't add in BC.  Otherwise we do.</p>
									<div class="assembly-row-combined"><div>0C07</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Exchange the integer value in Register Pair DE with the integer result in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0C08</div><div>ADD HL,HL<span class="opcode2" style="display: none;">29</span></div><div>Multiply the integer value in Register Pair HL by two</div></div>
									<div class="assembly-row-combined"><div>0C09</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Exchange the integer result in Register Pair DE with the integer value in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0C0A-0C0B</div><div><a href="#0C10H" class="memory-link">JR NC,0C10H<span class="origrom2" style="display: inline;">JR NC,IMULT2</span></a><span class="opcode2" style="display: none;">30 04</span></div><div>If the NC FLAG is set, then skip the next instructions which add in BC</div></div>
									<div class="assembly-row-combined"><div>0C0C</div><div>ADD HL,BC<span class="opcode2" style="display: none;">09</span></div><div>Add the integer value in Register Pair BC to the integer result in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0C0D-0C0F</div><div><a href="#0C26H" class="memory-link">JP C,0C26H<span class="origrom2" style="display: inline;">JP C,IMULT5</span></a><span class="opcode2" style="display: none;">DA 26 0C</span></div><div>If we have overflowed by adding in BC, then JUMP to IMULT5</div></div>
									<div class="assembly-row-combined"><div>0C10<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;IMULT2</span></div><div>DEC A<span class="opcode2" style="display: none;">3D</span></div><div>Decrement the value of the counter in Register A</div></div>
									<div class="assembly-row-combined"><div>0C11-0C12</div><div><a href="#0C04H" class="memory-link">JR NZ,0C04H<span class="origrom2" style="display: inline;">JR NZ,IMULT1</span></a><span class="opcode2" style="display: none;">20 F1</span></div><div>Loop until the multiplication has been completed.</div></div>
									<div class="assembly-row-combined"><div>0C13</div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>At
 this point we are done, so we need to finish up.  First, get the value 
of the sign test from the STACK and put it in Register B</div></div>
									<div class="assembly-row-combined"><div>0C14</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Get the original FIRST argument from the STACK and put it in Register Pair DE</div></div>
									<p class="debug-note">This is the entry from IDIV.  The next instructions test to see if the result is =&gt; 32768 or is -32768.</p>
									<div class="assembly-row-combined"><div>0C15<span class="origrom2" style="display: inline;">IMLDIV</span></div><div>LD A,H<span class="opcode2" style="display: none;">7C</span></div><div>Load Register A with the MSB of the result in Register H</div></div>
									<div class="assembly-row-combined"><div>0C16</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Test Register H</div></div>
									<div class="assembly-row-combined"><div>0C17-0C19</div><div><a href="#0C1FH" class="memory-link">JP M,0C1FH<span class="origrom2" style="display: inline;">JP M,IMULT3</span></a><span class="opcode2" style="display: none;">FA 1F 0C</span></div><div>If the M FLAG is set, then the result is =gt; 32768, so JUMP to IMULT3 to make sure it isn't -32768.</div></div>
									<div class="assembly-row-combined"><div>0C1A</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>If we are here, then the number is OK, so get the SECOND argument off the stack and into Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0C1B</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Load Register A with the value of the sign test in Register B</div></div>
									<div class="assembly-row-combined"><div>0C1C-0C1E</div><div><a href="#0C4DH" class="memory-link">JP 0C4DH<span class="origrom2" style="display: inline;">JP INEGA</span></a><span class="opcode2" style="display: none;">C3 4D 0C</span></div><div>Jump to 0C4DH to NEGate the number, if needed and RETurn</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0C1FH">0C1FH-0C34H - LEVEL II BASIC MATH ROUTINE<span class="origrom">- "IMULT3"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0C1F-0C20<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;IMULT3</span></div><div>XOR 80H<span class="opcode2" style="display: none;">EE 80</span></div><div>Clear the sign bit for the MSB of the integer value in Register A which is 1000 0000</div></div>
									<div class="assembly-row-combined"><div>0C21</div><div>OR L<span class="opcode2" style="display: none;">B5</span></div><div>Combine the value of the LSB for the integer value in Register L with the adjusted MSB of the integer value in Register A</div></div>
									<div class="assembly-row-combined"><div>0C22-0C23</div><div><a href="#0C37H" class="memory-link">JR Z,0C37H<span class="origrom2" style="display: inline;">JR Z,IMULT4</span></a><span class="opcode2" style="display: none;">28 13</span></div><div>If the Z FLAG is set, then the result is 32768, so JUMP to IMULT4</div></div>
									<div class="assembly-row-combined"><div>0C24</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>If we are hre, then it is &gt; 32768 giving us an overflow, so Load Register Pair HL with the integer value in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0C25-0C28</div><div>LD BC,E1C1H<span class="opcode2" style="display: none;">01 C1 E1</span></div><div>Z-80 Trick - See <a href="#0134H" class="memory-link">the note at 0134H</a>for an explanation</div></div>
									<div class="assembly-row-combined"><div>0C26<span class="origrom2" style="display: inline;">IMULT5</span></div><div>POP BC<span class="opcode2" style="display: none;">CF</span></div><div>Get the value of the sign test from the STACK and put it in Register B</div></div>
									<div class="assembly-row-combined"><div>0C27</div><div>POP HL<span class="opcode2" style="display: none;">0A</span></div><div>Get the original FIRST argument from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0C28-0C2A</div><div><a href="#0ACFH" class="memory-link">CALL 0ACFH<span class="origrom2" style="display: inline;">CALL CONSIH</span></a><span class="opcode2" style="display: none;">CD CF 0A</span></div><div>Go float the FIRST argument (held in in Register Pair HL) to single precision and return with the result in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0C2B</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the original SECOND argument  from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0C2C-0C2E</div><div><a href="#09A4H" class="memory-link">CALL 09A4H<span class="origrom2" style="display: inline;">CALL PUSHF</span></a><span class="opcode2" style="display: none;">CD A4 09</span></div><div>Save
 the floated FIRST agument via a GOSUB to  09A4 which moves the SINGLE 
PRECISION value in the ACCumulator to the STACK (stored in 
LSB/MSB/Exponent order)</div></div>
									<div class="assembly-row-combined"><div>0C2F-0C31</div><div><a href="#0ACFH" class="memory-link">CALL 0ACFH<span class="origrom2" style="display: inline;">CALL CONSIH</span></a><span class="opcode2" style="display: none;">CD CF 0A</span></div><div>Go float the SECOND argument (held in in Register Pair HL) to single precision and return with the result in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0C32<span class="origrom2" style="display: inline;">FMULTT</span></div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>Get the FIRST argument off the stack and put it in Register Pair BC.  POLYX jumps here.</div></div>
									<div class="assembly-row-combined"><div>0C33</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Get the NMSB and the LSB of the single precision value from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0C34-0C36</div><div><a href="#0847H" class="memory-link">JP 0847H<span class="origrom2" style="display: inline;">JP FMULT</span></a><span class="opcode2" style="display: none;">C3 47 08</span></div><div>Multiply
 the arguments via regular old FMULT -  the SINGLE PRECISION MULTIPLY 
routine at 0847H (which multiplies the current value in the ACCumulator 
by the value in (BC/DE). The product is left in the ACCumulator</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0C37H">0C37H-0C44H - LEVEL II BASIC MATH ROUTINE<span class="origrom">- "IMULT4"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0C37<span class="origrom2" style="display: inline;">IMULT4</span></div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>We need to see if the result is +/- 32768.  First, load Register A with the result of the sign test in Register B</div></div>
									<div class="assembly-row-combined"><div>0C38</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check  the result</div></div>
									<div class="assembly-row-combined"><div>0C39</div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>Discard the original SECOND argument from the STACK</div></div>
									<div class="assembly-row-combined"><div>0C3A-0CJC</div><div><a href="#0A9AH" class="memory-link">JP M,0A9AH<span class="origrom2" style="display: inline;">JP M,MAKINT</span></a><span class="opcode2" style="display: none;">FA 9A 0A</span></div><div>Jump if the result is supposed to be negative</div></div>
									<div class="assembly-row-combined"><div>0C3D</div><div>PUSH DE<span class="opcode2" style="display: none;">D5</span></div><div>If we are here, then the result is positive.  Save the remainder for MOD to the STACK</div></div>
									<div class="assembly-row-combined"><div>0C3E-0C40</div><div><a href="#0ACFH" class="memory-link">CALL 0ACFH<span class="origrom2" style="display: inline;">CALL CONSIH</span></a><span class="opcode2" style="display: none;">CD CF 0A</span></div><div>Go float -32768 and return with the result in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0C41</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Get the MOD's remainder from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0C42-0C44</div><div><a href="#0982H" class="memory-link">JP 0982H<span class="origrom2" style="display: inline;">JP NEG</span></a><span class="opcode2" style="display: none;">C3 82 09</span></div><div>Jump to 0982H to turn -32768 into 32768 and finish up</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0C45H">0C45H-0C5AH - LEVEL II BASIC MATH ROUTINE<span class="origrom">- "IMULDV"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the integer division routine HL = DE / HL.  The 
remainder will be left in DE and the quotient will be left in HL.  Every
 register is affected.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0C45<span class="origrom2" style="display: inline;">IMULDV</span></div><div>LD A,H<span class="opcode2" style="display: none;">7C</span></div><div>Load Register A with the MSB+SIGN of the integer value in Register H</div></div>
									<div class="assembly-row-combined"><div>0C46</div><div>XOR D<span class="opcode2" style="display: none;">AA</span></div><div>Combine the MSB of the integer value in Register D with the MSB+SIGN of the integer value in Register A</div></div>
									<div class="assembly-row-combined"><div>0C47</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Save the result of the combined signs in Register A into Register B</div></div>
									<div class="assembly-row-combined"><div>0C48-0C4A</div><div><a href="#0C4CH" class="memory-link">CALL 0C4CH<span class="origrom2" style="display: inline;">CALL INEGH</span></a><span class="opcode2" style="display: none;">CD 4C 0C</span></div><div>If necessary, NEGate the SECOND argument (i.e., the value in Register Pair HL) to positive</div></div>
									<div class="assembly-row-combined"><div>0C4B</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Presetve the contents of Register DE into Register Pair HL, and fall through to the negation routine below.</div></div>
									<div class="assembly-row-combined"><div>0C4C<span class="origrom2" style="display: inline;">INEGH</span></div><div>LD A,H<span class="opcode2" style="display: none;">7C</span></div><div>Load Register A with the MSB+SIGN of the integer value in Register H</div></div>
									<div class="assembly-row-combined"><div>0C4D<span class="origrom2" style="display: inline;">INEGA</span></div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Set the condition codes so we can see the sign of HL</div></div>
									<div class="assembly-row-combined"><div>0C4E-0C50</div><div><a href="#0A9AH" class="memory-link">JP P,0A9AH<span class="origrom2" style="display: inline;">JP P,MAKINT</span></a><span class="opcode2" style="display: none;">F2 9A 0A</span></div><div>If
 the P FLAG is set, then the integer value in Register Pair HL is 
positive and we don't need to NEGate it.  So we JUMP to MAKINT to save 
the result into the ACCumulator for when the operators come back tt this
 routine.</div></div>
									<p class="debug-note">Negate HL routine. This routine changes 
the sign of the HL Register Pair and stores it in the ACC. 
(HL=ACCumulator=-HL) The result is returned in both the HL Register Pair
 and the ACC.</p>
									<div class="assembly-row-combined"><div>0C51<span class="origrom2" style="display: inline;">INEGHL</span></div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A.<br></div></div>
									<div class="assembly-row-combined"><div>0C52</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the ZERO held in  Register A</div></div>
									<div class="assembly-row-combined"><div>0C53</div><div>SUB L<span class="opcode2" style="display: none;">95</span></div><div>Subtract the LSB of the integer value in Register L from the ZERO in Register A</div></div>
									<div class="assembly-row-combined"><div>0C54</div><div>LD L,A<span class="opcode2" style="display: none;">6F</span></div><div>Save the adjusted value in Register A in Register L</div></div>
									<div class="assembly-row-combined"><div>0C55</div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with a ZERO</div></div>
									<div class="assembly-row-combined"><div>0C56</div><div>SBC A,H<span class="opcode2" style="display: none;">9C</span></div><div>Subtract the HIGH ORDER (MSB+SIGN) of the integer value in Register H from the value in Register A</div></div>
									<div class="assembly-row-combined"><div>0C57</div><div>LD H,A<span class="opcode2" style="display: none;">67</span></div><div>Save the adjusted value in Register A into Register H</div></div>
									<div class="assembly-row-combined"><div>0C58-0C5A</div><div><a href="#0A9AH" class="memory-link">JP 0A9AH<span class="origrom2" style="display: inline;">JP MAKINT</span></a><span class="opcode2" style="display: none;">C3 9A 0A</span></div><div>Jump to 0A9AH to save the result into the ACCumulator for when the operations jump back here.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0C5BH">0C5BH-0C6FH - LEVEL II BASIC MATH ROUTINE<span class="origrom">- "INEG"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Integer Negation Routine.  All registers are altered.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0C5B-0C5D<span class="origrom2" style="display: inline;">INEG</span></div><div>LD HL,(4121H)<span class="origrom2" style="display: inline;">LD HL,(FACLO)</span><span class="opcode2" style="display: none;">2A 21 41</span></div><div>Load Register Pair HL with the integer value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0C5E-0C60</div><div><a href="#0C51H" class="memory-link">CALL 0C51H<span class="origrom2" style="display: inline;">CALL INEGHL</span></a><span class="opcode2" style="display: none;">CD 51 0C</span></div><div>Go convert the integer value in Register Pair HL to positive if it's negative</div></div>
									<div class="assembly-row-combined"><div>0C61</div><div>LD A,H<span class="opcode2" style="display: none;">7C</span></div><div>Load Register A with the HIGH ORDER (i.e., MSB+SIGN) of the integer value in Register H</div></div>
									<div class="assembly-row-combined"><div>0C62-0C63</div><div>XOR 80H<span class="origrom">XOR 1000 0000</span><span class="opcode2" style="display: none;">EE 80</span></div><div>Invert the value of the sign bit in Register A which is 1000 0000 so that we can check for the special case of -32768</div></div>
									<div class="assembly-row-combined"><div>0C64</div><div>OR L<span class="opcode2" style="display: none;">B5</span></div><div>Combine the LSB of the integer value in Register L with the adjusted MSB of the integer value in Register A</div></div>
									<div class="assembly-row-combined"><div>0C65</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>Return if the integer value in the ACCumulator isn't equal to -32768</div></div>
									<div class="assembly-row-combined" id="0C66H"><div>0C66<span class="origrom2" style="display: inline;">INEG2</span></div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>If
 we are here, the magic -32768 was found, so we need to float it.  
First, load Register Pair DE with the integer value in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0C67-0C69</div><div><a href="#0AEFH" class="memory-link">CALL 0AEFH<span class="origrom2" style="display: inline;">CALL VALSNG</span></a><span class="opcode2" style="display: none;">CD EF 0A</span></div><div>Go set the number type flag to single precision.</div></div>
									<div class="assembly-row-combined"><div>0C6A</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A, which we will use for the HIGH ORDER</div></div>
									<div class="assembly-row-combined"><div>0C6B-0C6C<span class="origrom2" style="display: inline;">INEGAD</span></div><div>LD B,98H<span class="opcode2" style="display: none;">06 98</span></div><div>Load Register B with an exponent.  IADD jumps here.</div></div>
									<div class="assembly-row-combined"><div>0C6D-0C6F</div><div><a href="#0969H" class="memory-link">JP 0969H<span class="origrom2" style="display: inline;">JP FLOATR</span></a><span class="opcode2" style="display: none;">C3 69 09</span></div><div>Float the number via a JUMP to  0969H</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="double-precision">DOUBLE PRECISION ROUTINES<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The next bunch of routines are the double precision 
arithmetic routines.  According to the original ROM source code, the 
conventions are.</p><ul><li>Double prevision numbers are 8 bytes long:  
The first 4 bytes are 32 low order bits of precision and the last 4 
bytes are are in the same format as single precision numbers.  The 
lowest order byte comes first in RAM.</li><li>For one argument gunctions:  The argument is in the ACCumulator, and the results is put there too.</li><li>For
 two argument operations, the first argument is in the ACCumulator and 
the second argument is in ARG-7,-6,-5,-4,-3,-2,-1,-0.  ARGLO=ARG-7.  The
 result is left in the ACCumulator.</li><li>Note that the order of the numbers is reversed from integers and single precisions values</li></ul><p></p>
							</div>

							<h2 class="assembly-section-title" id="0C70H">0C70H-0C76H - DOUBLE PRECISION SUBTRACTION<span class="origrom">- "DSUB"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Double-precision subtraction (ACCumulator = ACCumulator - ARG).<br>Subtracts
 the double precision value in ARG (a/k/a REG 2) from the value in the 
ACCumulator. The difference is left in the ACCumulator.<br><br>Note: If 
you wanted to subtract two double precision numbers, store the minuend 
in 411DH-4124H and the subtrahend in 4127H-412EH, and CALL 0C70H.  The 
result (in double precision format) is in 411DH-4124H in approximately 
1.3 milliseconds.</p>
								<p>Vernon Hester has flagged a bug.  Double-precision 
subtraction should produce an difference accurate to 16 digits. However,
 the difference resulting from doubleprecision subtraction is erroneous 
when the smaller operand's value is significantly less than the larger 
operand's value<br>&nbsp;&nbsp;Example: In the code <span class="code">Y# = .20# : X# = 1D16 : J# = X# - Y# : PRINT J# - X#</span>J# is incorrect and J#-X# shows a positive result when it is negative. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0C70-0C72<span class="origrom2" style="display: inline;">DSUB</span></div><div>LD HL,412DH<span class="origrom2" style="display: inline;">LD HL,ARG-1</span><span class="opcode2" style="display: none;">21 2D 41</span></div><div>Since
 addition is easier than subtraction, first we need to negate the SECOND
 argument by first loading Register Pair HL with the address of the MSB 
in ARG (a/k/a REG 2)</div></div>
									<div class="assembly-row-combined"><div>0C73</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load
 Register A with the HIGH ORDER (i.e., MSB+SIGN) of the double precision
 value in ARG (a/k/a REG 2) at the location of the memory pointer in 
Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0C74-0C75</div><div>XOR 80H<span class="origrom">XOR 1000 0000</span><span class="opcode2" style="display: none;">EE 80</span></div><div>Invert the value of the sign bit for the MSB of the double precision value in Register A which is 1000 0000</div></div>
									<div class="assembly-row-combined"><div>0C76</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save
 the adjusted HIGH ORDER (i.e., MSB+SIGN) of the double precision value 
in Register A in ARG (a/k/a REG 2) at the location of the memory pointer
 in Register Pair HL.  To save RAM we now fall into the DADD addition 
routine.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0C77H">0C77H-0CCEH -DOUBLE PRECISION ADDITION<span class="origrom">- "DADD"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Double-precision addition (ACCumulator=ACCumulator+ARG (a/k/a REG 2)).<br>Adds
 the double precision value in ARG (a/k/a REG 2) to the value in the 
ACCumulator. Sum is left in the ACCumulator.  All registers are 
affected.<br><br>Note: If you wanted to add 2 double precision numbers 
via a ROM call, store one input into 411DH-4124H and the other in 
4127H-412EH.  Then call 0C77H.  The double precision result will be 
stored in 411DH-4124H approximately 1.3 milliseconds later.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0C77-0C79<span class="origrom2" style="display: inline;">DADD</span></div><div>LD HL,412EH<span class="origrom2" style="display: inline;">LD HL,ARG</span><span class="opcode2" style="display: none;">21 2E 41</span></div><div>Load Register Pair HL with the address of the exponent in the FIRST argument held at ARG (a/k/a REG 2)</div></div>
									<div class="assembly-row-combined"><div>0C7A</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Prepare
 to test that for ZERO by first loading  Register A with the exponent of
 the double precision value in ARG (a/k/a REG 2) at the location of the 
memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0C7B</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the double precision value in ARG (a/k/a REG 2) is equal to zero</div></div>
									<div class="assembly-row-combined"><div>0C7C</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>Return
 if the double precision value in ARG (a/k/a REG 2) is equal to zero, 
since that means that the ACCumulator (i.e., the FIRST argument) is 
actually the sum</div></div>
									<div class="assembly-row-combined"><div>0C7D</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Preserve the exponent for the double precision value in Register A into Register C</div></div>
									<div class="assembly-row-combined"><div>0C7E</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement the value of the memory pointer in Register Pair HL to now point to the HIGH ORDER (i.e., MSB + SIGN) for unpacking </div></div>
									<div class="assembly-row-combined"><div>0C7F</div><div>LD C,(HL)<span class="opcode2" style="display: none;">4E</span></div><div>Load
 Register C with the value of the HIGH ORDER (i.e., MSB + SIGN) of the 
double precision value in ARG (a/k/a REG 2) at the location of the 
memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0C80-0C82</div><div>LD DE,4124H<span class="origrom2" style="display: inline;">LD DE,FAC</span><span class="opcode2" style="display: none;">11 24 41</span></div><div>Load Register Pair DE with the address of the exponent of the SECOND argument (held in the ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>0C83</div><div>LD A,(DE)<span class="opcode2" style="display: none;">1A</span></div><div>Fetch
 the value of the exponent of the double precision value in the 
ACCumulator at the location of the memory pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0C84</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Set the flags to see  if the double precision value in the ACCumulator is equal to zero</div></div>
									<div class="assembly-row-combined"><div>0C85-0C87</div><div><a href="#09F4H" class="memory-link">JP Z,09F4H<span class="origrom2" style="display: inline;">JP Z,MOVFA</span></a><span class="opcode2" style="display: none;">CA F4 09</span></div><div>If
 the exponent is zero, then the number is zero, so we are once again 
adding 0 to a number.  In this case, the non-zero number is in the wrong
 reghister, so JUMP to VMOVFA to move ARG to the ACCumulator and exit.</div></div>
									<div class="assembly-row-combined"><div>0C88</div><div>SUB B<span class="opcode2" style="display: none;">90</span></div><div>Now
 we know we do not have any zero's, so we next need to get the shift 
count by subtracting the exponents.  First, subtract the value of the 
exponent for the double precision value in ARG (a/k/a REG 2) in Register
 B from the value of the exponent for the double precision value in the 
ACCumulator in Register A</div></div>
									<div class="assembly-row-combined"><div>0C89-0C8A</div><div><a href="#0CA1H" class="memory-link">JR NC,0CA1H<span class="origrom2" style="display: inline;">JR NC,DADD2</span></a><span class="opcode2" style="display: none;">30 16</span></div><div>If the NC FLAG is set, then the we need to put the smaller number into the ACCumulator, so JUMP to DADD2 to do that</div></div>
									<div class="assembly-row-combined"><div>0C8B</div><div>CPL<span class="opcode2" style="display: none;">2F</span></div><div>Negate the shift count held in Register A</div></div>
									<div class="assembly-row-combined"><div>0C8C</div><div>INC A<span class="opcode2" style="display: none;">3C</span></div><div>Increment the value of the difference for the exponents in Register A so that Register A will hold the positive difference</div></div>
									<div class="assembly-row-combined"><div>0C8D</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the shift count (i.e., the difference for the exponents, held in Register A) to the STACK</div></div>
									<p class="debug-note">Next we are going to switch ARG and the ACCumulator.</p>
									<div class="assembly-row-combined"><div>0C8E-0C8F</div><div>LD C,08H<span class="opcode2" style="display: none;">0E 08</span></div><div>Load Register C with a  counter value which is 8</div></div>
									<div class="assembly-row-combined"><div>0C90</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment
 the value of the memory pointer in Register Pair HL so that it will be 
pointing to the exponent of the double precision value in ARG (a/k/a REG
 2)</div></div>
									<div class="assembly-row-combined"><div>0C91</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the value of the memory pointer in Register Pair HL (which is pointing to ARG) on the STACK</div></div>
									<div class="assembly-row-combined"><div>0C92<span class="origrom2" style="display: inline;">DADD1</span></div><div>LD A,(DE)<span class="opcode2" style="display: none;">1A</span></div><div>Top of a loop.  Load Register A with the value of the ACCumulator pointed to by  Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0C93</div><div>LD B,(HL)<span class="opcode2" style="display: none;">46</span></div><div>Load Register B with the value of ARG (a/k/a REG 2) pointed to by  Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0C94</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save the ACCumulator value into the corresponding ARG (a/k/a REG 2) byte.</div></div>
									<div class="assembly-row-combined"><div>0C95</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Load Register A with the ARG byte (held in Register B)</div></div>
									<div class="assembly-row-combined"><div>0C96</div><div>LD (DE),A<span class="opcode2" style="display: none;">12</span></div><div>Save the ARG byte (held  in Register A) into the corresopnding ACCumulator byte (pointed to by Register Pair DE)</div></div>
									<div class="assembly-row-combined"><div>0C97</div><div>DEC DE<span class="opcode2" style="display: none;">1B</span></div><div>Decrement the value of the memory pointer in Register Pair DE to the next lower byte of the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0C98</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement the value of the memory pointer in Register Pair HL to the next lower byte in ARG</div></div>
									<div class="assembly-row-combined"><div>0C99</div><div>DEC C<span class="opcode2" style="display: none;">0D</span></div><div>Decrement the value of the counter in Register C</div></div>
									<div class="assembly-row-combined"><div>0C9A-0C9B</div><div><a href="#0C92H" class="memory-link">JR NZ,0C92H<span class="origrom2" style="display: inline;">JR NZ,DADD1</span></a><span class="opcode2" style="display: none;">20 F6</span></div><div>Loop until the double precision values in the ACCumulator and ARG (a/k/a REG 2) have been exchanged</div></div>
									<div class="assembly-row-combined"><div>0C9C</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the HIGH ORDER back from the stack into  Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0C9D</div><div>LD B,(HL)<span class="opcode2" style="display: none;">46</span></div><div>Fetch the exponent for the double precision value in ARG (a/k/a REG 2) pointed to by Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0C9E</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement the value of the memory pointer in Register Pair HL to now point to the HIGH ORDER (MSB + SIGN)</div></div>
									<div class="assembly-row-combined"><div>0C9F</div><div>LD C,(HL)<span class="opcode2" style="display: none;">4E</span></div><div>Load
 Register C with the value of the MSB+SIGN for the double precision 
value in ARG (a/k/a REG 2) at the location of the memory pointer in 
Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0CA0</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the shift count (i.e., difference for the exponents) back into Register A</div></div>
									<div class="assembly-row-combined"><div>0CA1-0CA2<span class="origrom2" style="display: inline;">DADD2</span></div><div>CP 39H<span class="opcode2" style="display: none;">FE 39</span></div><div>Check to see if the difference between the two exponents is greater than 56 bits</div></div>
									<div class="assembly-row-combined"><div>0CA3</div><div>RET NC<span class="opcode2" style="display: none;">D0</span></div><div>Return if the difference between the two exponents is greater than 56 bits.</div></div>
									<div class="assembly-row-combined"><div>0CA4</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the shift count (i.e., difference for the exponents) from Register A onto the STACK</div></div>
									<div class="assembly-row-combined"><div>0CA5-0CA7</div><div><a href="#09DFH" class="memory-link">CALL 09DFH<span class="origrom2" style="display: inline;">CALL UNPACK</span></a><span class="opcode2" style="display: none;">CD DF 09</span></div><div>Go turn on the sign bits for the double precision numbers.</div></div>
									<div class="assembly-row-combined"><div>0CA8</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the value of the memory pointer in Register Pair HL to now point to ARGLO-1</div></div>
									<div class="assembly-row-combined"><div>0CA9-0CAA</div><div>LD (HL),00H<span class="opcode2" style="display: none;">36 00</span></div><div>Zero the temporary LSB (held at the location of the memory pointer in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>0CAB</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Preserve the sign test into Register B</div></div>
									<div class="assembly-row-combined"><div>0CAC</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Restore the shift count (i.e., difference for the exponents) from the STACK into Register A</div></div>
									<div class="assembly-row-combined"><div>0CAD-0CAF</div><div>LD HL,412DH<span class="origrom2" style="display: inline;">LD HL,ARG-1</span><span class="opcode2" style="display: none;">21 2D 41</span></div><div>Load Register Pair HL with the address of the HIGH ORDER in ARG (a/k/a REG 2)</div></div>
									<div class="assembly-row-combined"><div>0CB0-0CB2</div><div><a href="#0D69H" class="memory-link">CALL 0D69H<span class="origrom2" style="display: inline;">CALL DSHFTR</span></a><span class="opcode2" style="display: none;">CD 69 0D</span></div><div>Go shift the double precision value in ARG (a/k/a REG 2) until it lines up with the double precision value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0CB3-0CB5</div><div>LD A,(4126H)<span class="origrom2" style="display: inline;">LD A,(ARGLO-1)</span><span class="opcode2" style="display: none;">3A 26 41</span></div><div>We next need to transfer the OVERFLOW byte from ARG to ACCumulator, so first put it in Register A</div></div>
									<div class="assembly-row-combined"><div>0CB6-0CB8</div><div>LD (411CH),A<span class="origrom2" style="display: inline;">LD (DFACLO-1),A</span><span class="opcode2" style="display: none;">32 1C 41</span></div><div>Save the value in Register A to ARG</div></div>
									<div class="assembly-row-combined"><div>0CB9</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Load Register A with the value of the sign test in Register B</div></div>
									<div class="assembly-row-combined"><div>0CBA</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the signs are equal.</div></div>
									<div class="assembly-row-combined"><div>0CBB-0CBD</div><div><a href="#0CCFH" class="memory-link">JP P,0CCFH<span class="origrom2" style="display: inline;">JP P,DADD3</span></a><span class="opcode2" style="display: none;">F2 CF 0C</span></div><div>If the P FLAG is set, then the signs of the numbers are different, so JUMP to DADD3 to subtract the values</div></div>
									<div class="assembly-row-combined"><div>0CBE-0CC0</div><div><a href="#0D33H" class="memory-link">CALL 0D33H<span class="origrom2" style="display: inline;">CALL DADDAA</span></a><span class="opcode2" style="display: none;">CD 33 0D</span></div><div>Otherwise (i.e., the signs are the same) GOSUB to DADDAA to add the numbers</div></div>
									<div class="assembly-row-combined"><div>0CC1-0CC3</div><div><a href="#0D0EH" class="memory-link">JP NC,0D0EH<span class="origrom2" style="display: inline;">JP NC,DROUND</span></a><span class="opcode2" style="display: none;">D2 0E 0D</span></div><div>If that didn't trigger a NC FLAG, then JUMP to 0D0EH to ROUND the result and continue on.</div></div>
									<div class="assembly-row-combined"><div>0CC4</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>If that DID trigger the NC FLAG, then put the pointer to the exponent of the ACCumulator into HL</div></div>
									<div class="assembly-row-combined"><div>0CC5</div><div>INC (HL)<span class="opcode2" style="display: none;">34</span></div><div>Add one to the exponent (since we had an overflow)</div></div>
									<div class="assembly-row-combined"><div>0CC6-0CC8</div><div><a href="#07B2H" class="memory-link">JP Z,07B2H<span class="origrom2" style="display: inline;">JP Z,OVERR</span></a><span class="opcode2" style="display: none;">CA B2 07</span></div><div>Check for OVERFLOW because of that too!  If the Z FLAG is set, then display an <span class="code">?OV ERROR</span>if the exponent for the double precision result in the ACCumulator is too large</div></div>
									<div class="assembly-row-combined"><div>0CC9-0CCB</div><div><a href="#0D90H" class="memory-link">CALL 0D90H<span class="origrom2" style="display: inline;">CALL DSHFRB</span></a><span class="opcode2" style="display: none;">CD 90 0D</span></div><div>If
 we still have no overflow, then we need to shift the number right one 
so as to shift in the CARRY FLAG.  To do this we GOSUB to DSHFRB</div></div>
									<div class="assembly-row-combined"><div>0CCC-0CCE</div><div><a href="#0D0EH" class="memory-link">JP 0D0EH<span class="origrom2" style="display: inline;">JP DROUND</span></a><span class="opcode2" style="display: none;">C3 0E 0D</span></div><div>JUMP to 0D0EH to ROUND the result and continue on.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0CCFH">0CCFH-0D1FH - DOUBLE PRECISION MATH ROUTINE<span class="origrom">- "DADD3"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0CCF-0CD1<span class="origrom2" style="display: inline;">DADD3</span></div><div><a href="#0D45H" class="memory-link">CALL 0D45H<span class="origrom2" style="display: inline;">CALL DADDAS</span></a><span class="opcode2" style="display: none;">CD 45 0D</span></div><div>Go subtract the double precision values.</div></div>
									<div class="assembly-row-combined"><div>0CD2-0CD4</div><div>LD HL,4125H<span class="origrom2" style="display: inline;">LD HL,FAC+1</span><span class="opcode2" style="display: none;">21 25 41</span></div><div>Right
 now HL isn't pointing where we need it to point for a call to DNEGR, so
 load Register Pair HL with the address of the sign, and then, to save 
RAM, fall through into DNORML.</div></div>
									<div class="assembly-row-combined"><div>0CD5-0CD7</div><div><a href="#0D57H" class="memory-link">CALL C,0D57H<span class="origrom2" style="display: inline;">CALL C,DNEGR</span></a><span class="opcode2" style="display: none;">DC 57 0D</span></div><div>Go complement the result in the ACCumulator if the Carry flag is set</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0CD8H">0CD8H - DOUBLE PRECISION MATH ROUTINE<span class="origrom">- "DNORML" and "DNORM1"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0CD8<span class="origrom2" style="display: inline;">DNORML</span></div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A, which will act as a byte shift counter</div></div>
									<div class="assembly-row-combined" id="0CD9H"><div>0CD9<span class="origrom2" style="display: inline;">DNORM1</span></div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Preserve the shift counter into Register  Register B</div></div>
									<div class="assembly-row-combined"><div>0CDA-0CDC</div><div>LD A,(4123H)<span class="origrom2" style="display: inline;">LD A,(FAC-1)</span><span class="opcode2" style="display: none;">3A 23 41</span></div><div>Load Register A with the value of the HIGH ORDER (i.e., MSB+SIGN) of the double precision result in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0CDD</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if we can shift 8 numbers to the left</div></div>
									<div class="assembly-row-combined"><div>0CDE-0CDF</div><div><a href="#0CFEH" class="memory-link">JR NZ,0CFEH<span class="origrom2" style="display: inline;">JR NZ,DNORM5</span></a><span class="opcode2" style="display: none;">20 1E</span></div><div>If the NZ FLAG is set, then we cannot shift 8 numbers left, so we need to JUMP to see if the number is already normalized.</div></div>
									<div class="assembly-row-combined"><div>0CE0-0CE2</div><div>LD HL,411CH<span class="origrom2" style="display: inline;">LD HL,DFACLO-1</span><span class="opcode2" style="display: none;">21 1C 41</span></div><div>If
 we are here then we CAN shift 8 numbers left, so first load Register 
Pair HL with the starting address of ACCumulator minus one.</div></div>
									<div class="assembly-row-combined"><div>0CE3-0CE4</div><div>LD C,08H<span class="opcode2" style="display: none;">0E 08</span></div><div>Load Register C with the number of bytes to be shifted (i.e., 8)</div></div>
									<div class="assembly-row-combined"><div>0CE5<span class="origrom2" style="display: inline;">DNORM2</span></div><div>LD D,(HL)<span class="opcode2" style="display: none;">56</span></div><div>Top of a loop.  Load Register D with a byte from the ACCumulator (pointed to by Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>0CE6</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save
 the value in Register A to the newly vacated location at the memory 
pointer in Register Pair HL.  Note that on the FIRST loop, this is a 
zero.</div></div>
									<div class="assembly-row-combined"><div>0CE7</div><div>LD A,D<span class="opcode2" style="display: none;">7A</span></div><div>Put the current byte from the ACCumulator (preserved in D) into Register A for writing on the next iteration</div></div>
									<div class="assembly-row-combined"><div>0CE8</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the value of the memory pointer in registerpair HL.</div></div>
									<div class="assembly-row-combined"><div>0CE9</div><div>DEC C<span class="opcode2" style="display: none;">0D</span></div><div>Decrement the number of bytes to be shifted in Register C</div></div>
									<div class="assembly-row-combined"><div>0CEA-0CEB</div><div><a href="#0CE5H" class="memory-link">JR NZ,0CE5H<span class="origrom2" style="display: inline;">JR NZ,DNORM2</span></a><span class="opcode2" style="display: none;">20 F9</span></div><div>Loop until all of the bytes in the double precision value have been shifted.</div></div>
									<div class="assembly-row-combined"><div>0CEC</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Now
 that we did an 8 byte shift, we need to subtract 8  from the shift 
counter.  First, load Register A with the number of bits shifted in 
Register B</div></div>
									<div class="assembly-row-combined"><div>0CED-0CEE</div><div>SUB 08H<span class="opcode2" style="display: none;">D6 08</span></div><div>Subtract the number of bits just shifted from the shift counter in Register A</div></div>
									<div class="assembly-row-combined"><div>0CEF-0CF0</div><div>CP C0H<span class="opcode2" style="display: none;">FE C0</span></div><div>Check to see if the whole of the double precision value has been shifted.</div></div>
									<div class="assembly-row-combined"><div>0CF1-0CF2</div><div><a href="#0CD9H" class="memory-link">JR NZ,0CD9H<span class="origrom2" style="display: inline;">JR NZ,DNORM1</span></a><span class="opcode2" style="display: none;">20 E6</span></div><div>If the whole of the double precision value hasn't been shifted, JUMP back to DNORM1 to shift some more</div></div>
									<div class="assembly-row-combined"><div>0CF3-0CF5</div><div><a href="#0778H" class="memory-link">JP 0778H<span class="origrom2" style="display: inline;">JP ZERO</span></a><span class="opcode2" style="display: none;">C3 78 07</span></div><div>If we are here, then we have shifted all the bytes so JUMP to ZERO</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0CF6H">0CF6H - Part of the "DNORML" and "DNORM1" Routine<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0CF6<span class="origrom2" style="display: inline;">DNORM3</span></div><div>DEC B<span class="opcode2" style="display: none;">05</span></div><div>Decrement the shift counter held in Register B</div></div>
									<div class="assembly-row-combined"><div>0CF7-0CF9</div><div>LD HL,411CH<span class="origrom2" style="display: inline;">LD HL,DFACLO-1</span><span class="opcode2" style="display: none;">21 1C 41</span></div><div>Load Register Pair HL with the starting address of ACCumulator minus one.</div></div>
									<div class="assembly-row-combined"><div>0CFA-0CFC</div><div><a href="#0D97H" class="memory-link">CALL 0D97H<span class="origrom2" style="display: inline;">CALL DSHFLC</span></a><span class="opcode2" style="display: none;">CD 97 0D</span></div><div>Shift the double precision value in the ACCumulator once to the left</div></div>
									<div class="assembly-row-combined"><div>0CFD</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the number has been normalized yet</div></div>
									<div class="assembly-row-combined" id="0D00H"><div>0CFE-0D00<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;DNORM5</span></div><div><a href="#0CF6H" class="memory-link">JP P,0CF6H<span class="origrom2" style="display: inline;">JP P,DNORM3</span></a><span class="opcode2" style="display: none;">F2 F6 0C</span></div><div>If the P FLAG is set, then we are not yet normalized, so LOOP back to DNORM3 and keep shifting</div></div>
									<div class="assembly-row-combined"><div>0D01</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Load Register A with the value of the shift counter from Register B</div></div>
									<div class="assembly-row-combined"><div>0D02</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the shift counter in Register A is equal to zero</div></div>
									<div class="assembly-row-combined"><div>0D03-0D04</div><div><a href="#0D0EH" class="memory-link">JR Z,0D0EH<span class="origrom2" style="display: inline;">JR Z,DROUND</span></a><span class="opcode2" style="display: none;">28 09</span></div><div>If the shift counter is zero, then proceed to round the number and finish up by JUMPing to DROUND</div></div>
									<div class="assembly-row-combined"><div>0D05-0D07</div><div>LD HL,4124H<span class="origrom2" style="display: inline;">LD HL,FAC</span><span class="opcode2" style="display: none;">21 24 41</span></div><div>Load Register Pair HL with the address of the exponent in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0D08</div><div>ADD A,(HL)<span class="opcode2" style="display: none;">86</span></div><div>Add
 the value of the exponent for the double precision value in the 
ACCumulator at the location of the memory pointer in Register Pair HL to
 the value of the shift counter in Register A</div></div>
									<div class="assembly-row-combined"><div>0D09</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save
 the adjusted exponent for the double precision value in Register A at 
the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0D0A-0D0C</div><div><a href="#0778H" class="memory-link">JP NC,0778H<span class="origrom2" style="display: inline;">P NC,ZERO</span></a><span class="opcode2" style="display: none;">D2 78 07</span></div><div>If the NC FLAG was triggered, then we have an UNDERFLOW, so JUMP to ZERO</div></div>
									<div class="assembly-row-combined"><div>0D0D</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>If the Z FLAG is set, then the result is already zero and we are done, so FALL into the DROUND routine and round the result.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0D0EH">0D0EH - DOUBLE PRECISION MATH ROUTINE<span class="origrom">- "DROUND" and "DROUNB"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will round the ACCumulator.  Registers A, B, H, and L are affected.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0D0E-0D10<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;DROUND</span></div><div>LD A,(411CH)<span class="origrom2" style="display: inline;">LD A,(DFACLO-1)</span><span class="opcode2" style="display: none;">3A 1C 41</span></div><div>Load Register A with the value of the rounding byte at the location of the starting address of ACCumulator minus one.</div></div>
									<div class="assembly-row-combined"><div>0D11<span class="origrom2" style="display: inline;">DROUNB</span></div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if there is a bit to be shifted into the double precision value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0D12-0D14</div><div><a href="#0D20H" class="memory-link">CALL M,0D20H<span class="origrom2" style="display: inline;">CALL M,DROUNA</span></a><span class="opcode2" style="display: none;">FC 20 0D</span></div><div>Go move the bit into the double precision value if necessary.</div></div>
									<div class="assembly-row-combined"><div>0D15-0D17</div><div>LD HL,4125H<span class="origrom2" style="display: inline;">LD HL,FAC+1</span><span class="opcode2" style="display: none;">21 25 41</span></div><div>Load Register Pair HL with the address of the unpacked sign for the result.</div></div>
									<div class="assembly-row-combined"><div>0D18</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load Register A with the value of the sign for the result at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0D19-0D1A</div><div>AND 80H<span class="origrom">AND 1000 0000</span><span class="opcode2" style="display: none;">E6 80</span></div><div>Turn off some bits so we can mask the value of the sign for the result in Register A which is 1000 0000 to isolate the sign bit.</div></div>
									<div class="assembly-row-combined"><div>0D1B<br>0D1C</div><div>DEC HL<br>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement
 the value of the memory pointer in Register Pair HL twice so that it 
points to HIGH ORDER (MSB) byte in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0D1D</div><div>XOR (HL)<span class="opcode2" style="display: none;">AE</span></div><div>Pack the SIGN and the MSB together</div></div>
									<div class="assembly-row-combined"><div>0D1E</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save the packed sign and MSB combination byte to the ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0D1F</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0D20H">0D20H-0D32H - DOUBLE PRECISION MATH support routine<span class="origrom">- "DROUNA"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0D20-0D22<span class="origrom2" style="display: inline;">DROUNA</span></div><div>LD HL,411DH<span class="origrom2" style="display: inline;">LD HL,DFACLO</span><span class="opcode2" style="display: none;">21 1D 41</span></div><div>Set up HL to point to the LSB of the the ACCumulator.<br>Note: 411DH-4124H holds ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0D23-0D24</div><div>LD B,07H<span class="opcode2" style="display: none;">06 07</span></div><div>Load Register B with the number of bytes to be bumped for the double precision value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0D25<span class="origrom2" style="display: inline;">DRON1</span></div><div>INC (HL)<span class="opcode2" style="display: none;">34</span></div><div>Top of a loop.  Increment a byte of the ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0D26</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>Return if the value at the location of the memory pointer in Register Pair HL isn't equal to zero</div></div>
									<div class="assembly-row-combined"><div>0D27</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the value of the memory pointer in Register Pair HL to point to the next highest order in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0D28</div><div>DEC B<span class="opcode2" style="display: none;">05</span></div><div>Decrement the value of the byte counter in Register B</div></div>
									<div class="assembly-row-combined"><div>0D29-0D2A</div><div><a href="#0D25H" class="memory-link">JR NZ,0D25H<span class="origrom2" style="display: inline;">JR NZ,DRONA1</span></a><span class="opcode2" style="display: none;">20 FA</span></div><div>Loop until all of the necessary bytes have been bumped.</div></div>
									<div class="assembly-row-combined"><div>0D2B</div><div>INC (HL)<span class="opcode2" style="display: none;">34</span></div><div>We
 have bumped all the bytes, so now we need to increment the value of the
 exponent at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0D2C-0D2E</div><div><a href="#07B2H" class="memory-link">JP Z,07B2H<span class="origrom2" style="display: inline;">JP Z,OVERR</span></a><span class="opcode2" style="display: none;">CA B2 07</span></div><div>Check
 for overflow.  If the Z FLAG is set, then JUMP to the Level II BASIC 
error routine and display an OV ERROR message if the exponent for the 
double precision value in the ACCumulator is too large</div></div>
									<div class="assembly-row-combined"><div>0D2F</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement the value of the memory pointer in Register Pair HL to point to the HIGH ORDER</div></div>
									<div class="assembly-row-combined"><div>0D30-0D31</div><div>LD (HL),80H<span class="opcode2" style="display: none;">36 80</span></div><div>Save a new MSB+SIGN at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0D32</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0D33H">0D33H-0D44H - DOUBLE PRECISION MATH ROUTINE<span class="origrom">- "DADDAA" and "DADDA"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0D33-0D35<span class="origrom2" style="display: inline;">DADDAA</span></div><div>LD HL,4127H<span class="origrom2" style="display: inline;">LD HL,ARGLO</span><span class="opcode2" style="display: none;">21 27 41</span></div><div>DADD enters here, so we need to set both HL and DE.  In that case, set HL to point to ARG (a/k/a REG 2).<br>Note: 4127H-412EH holds ARG (a/k/a REG 2)</div></div>
									<div class="assembly-row-combined"><div>0D36-0D38<span class="origrom2" style="display: inline;">DADDFO</span></div><div>LD DE,411DH<span class="origrom2" style="display: inline;">LD DE,DFACLO</span><span class="opcode2" style="display: none;">11 1D 41</span></div><div>FOUT enters here, and DADD passes through to here.  Load Register Pair DE with the starting address of ACCumulator.<br>Note: 411DH-4124H holds ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0D39-0D3A<span class="origrom2" style="display: inline;">DADDS</span></div><div>LD C,07H<span class="opcode2" style="display: none;">0E 07</span></div><div>Load Register C with the number of bytes to be added</div></div>
									<div class="assembly-row-combined"><div>0D3B</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Clear the Carry flag</div></div>
									<div class="assembly-row-combined"><div>0D3C<span class="origrom2" style="display: inline;">DADDLS</span></div><div>LD A,(DE)<span class="opcode2" style="display: none;">1A</span></div><div>Top of a loop.  Load Register A with the value in the ACCumulator at the location of the memory pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0D3D</div><div>ADC A,(HL)<span class="opcode2" style="display: none;">8E</span></div><div>Add the value in ARG (a/k/a REG 2) at the location of the memory value in Register A</div></div>
									<div class="assembly-row-combined"><div>0D3E</div><div>LD (DE),A<span class="opcode2" style="display: none;">12</span></div><div>Save the result of that addition into the ACCumulator at the location of the memory pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0D3F</div><div>INC DE<span class="opcode2" style="display: none;">13</span></div><div>Increment the value of the memory pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0D40</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the value of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0D41</div><div>DEC C<span class="opcode2" style="display: none;">0D</span></div><div>Decrement the number of bytes to be added in Register C</div></div>
									<div class="assembly-row-combined"><div>0D42-0D43</div><div><a href="#0D3CH" class="memory-link">JR NZ,0D3CH<span class="origrom2" style="display: inline;">JR NZ,DADDLS</span></a><span class="opcode2" style="display: none;">20 F8</span></div><div>Loop until all of the bytes for the double precision values have been added.</div></div>
									<div class="assembly-row-combined"><div>0D44</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0D45H">0D45H-0D56H - DOUBLE PRECISION MATH ROUTINE<span class="origrom">- "DADDAS"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine subtracts numbers in the pure version.  This needs to be done in two subroutines since the ROM cannot be modified.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0D45-0D47<span class="origrom2" style="display: inline;">DADDAS</span></div><div>LD HL,4127H<span class="origrom">LD HL,ARGLO</span><span class="opcode2" style="display: none;">21 27 41</span></div><div>DADD
 enters here, so we need to set both HL and DE.  In that case, set 
Register Pair HL with the starting address of ARG (a/k/a REG 2).<br>Note: 4127H-412EH holds ARG (a/k/a REG 2)</div></div>
									<div class="assembly-row-combined"><div>0D48-0D4A<span class="origrom2" style="display: inline;">DADDFS</span></div><div>LD DE,411DH<span class="origrom2" style="display: inline;">LD DE,DFACLO</span><span class="opcode2" style="display: none;">11 1D 41</span></div><div>FOUT enters here, and DADD passes through to here.  Load Register Pair DE with the starting address of ACCumulator.<br>Note: 411DH-4124H holds ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0D4B-0D4C<span class="origrom2" style="display: inline;">DADDSS</span></div><div>LD C,07H<span class="opcode2" style="display: none;">0E 07</span></div><div>Load Register C with the number of bytes to be subtracted</div></div>
									<div class="assembly-row-combined"><div>0D4D</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Clear the Carry flag</div></div>
									<div class="assembly-row-combined"><div>0D4E<span class="origrom2" style="display: inline;">DADDLS</span></div><div>LD A,(DE)<span class="opcode2" style="display: none;">1A</span></div><div>Top of a loop.  Load Register A with the value in the ACCumulator at the location of the memory pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0D4F</div><div>SBC A,(HL)<span class="opcode2" style="display: none;">9E</span></div><div>Subtract the value in ARG (a/k/a REG 2) at the location of the memory pointer in Register Pair HL from the value in Register A</div></div>
									<div class="assembly-row-combined"><div>0D50</div><div>LD (DE),A<span class="opcode2" style="display: none;">12</span></div><div>Save the result in Register A in the ACCumulator at the location of the memory pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0D51</div><div>INC DE<span class="opcode2" style="display: none;">13</span></div><div>Increment the value of the memory pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0D52</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the value of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0D53</div><div>DEC C<span class="opcode2" style="display: none;">0D</span></div><div>Decrement the number of bytes to be subtracted for the double precision values in Register C</div></div>
									<div class="assembly-row-combined"><div>0D54-0D55</div><div><a href="#0D4EH" class="memory-link">JR NZ,0D4EH<span class="origrom2" style="display: inline;">JR NZ,DADDLS</span></a><span class="opcode2" style="display: none;">20 F8</span></div><div>Loop until all of the bytes for the double precision values have been subtracted</div></div>
									<div class="assembly-row-combined"><div>0D56</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0D57H">0D57H-0D68H - DOUBLE PRECISION MATH ROUTINE<span class="origrom">- "DNEGR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will negate the signed number held in the 
ACCumulator.  Registers A, B, C, H, and L are affected.  This routine is
 called by DADD and DINT.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0D57<span class="origrom2" style="display: inline;">DNEGR</span></div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Load Register A with the value of the sign from the ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0D58</div><div>CPL<span class="opcode2" style="display: none;">2F</span></div><div>Complement the value of the sign in Register A</div></div>
									<div class="assembly-row-combined"><div>0D59</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save the value of the sign in Register A at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0D5A-0D5C</div><div>LD HL,411CH<span class="origrom2" style="display: inline;">LD HL,DFACLO-1</span><span class="opcode2" style="display: none;">21 1C 41</span></div><div>Load Register Pair HL with the starting address of ACCumulator minus one.</div></div>
									<div class="assembly-row-combined"><div>0D5D-0D5E</div><div>LD B,08H<span class="opcode2" style="display: none;">06 08</span></div><div>Load Register B with the number of bytes to be reversed</div></div>
									<div class="assembly-row-combined"><div>0D5F</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A and clear the CARRY FLAG</div></div>
									<div class="assembly-row-combined"><div>0D60</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the ZERO</div></div>
									<div class="assembly-row-combined"><div>0D61<span class="origrom2" style="display: inline;">DNEGR1</span></div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Top of a loop.  Load Register A with the value in Register C</div></div>
									<div class="assembly-row-combined"><div>0D62</div><div>SBC A,(HL)<span class="opcode2" style="display: none;">9E</span></div><div>NEGate a byte to the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0D63</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save the NEGated value in Register A back to the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0D64</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the value of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0D65</div><div>DEC B<span class="opcode2" style="display: none;">05</span></div><div>Decrement the number of bytes to be reversed in Register B</div></div>
									<div class="assembly-row-combined"><div>0D66-0D67</div><div><a href="#0D61H" class="memory-link">JR NZ,0D61H<span class="origrom2" style="display: inline;">JR NZ,DNEGR1</span></a><span class="opcode2" style="display: none;">20 F9</span></div><div>Loop until all of the bytes for the double precision  number in the ACCumulator have been reversed</div></div>
									<div class="assembly-row-combined"><div>0D68</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0D69H">0D69H-0D8FH - DOUBLE PRECISION MATH ROUTINE<span class="origrom">- "DSHFTR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine wwill shift the double precision value held in the ACCumulator to the right once.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0D69<span class="origrom2" style="display: inline;">DSHFTR</span></div><div>LD (HL),C<span class="opcode2" style="display: none;">71</span></div><div>Save the unpacked MSB of the double precision value in Register C at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0D6A</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the value of the memory pointer in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0D6B-0D6C<span class="origrom2" style="display: inline;">DSHFR1</span></div><div>SUB 08H<span class="opcode2" style="display: none;">D6 08</span></div><div>Subtract 8 from the number of bits to be shifted from the number of bits to be shifted in Register A</div></div>
									<div class="assembly-row-combined"><div>0D6D-0D6E</div><div><a href="#0D7DH" class="memory-link">JR C,0D7DH<span class="origrom2" style="display: inline;">JR C,DSHFR3</span></a><span class="opcode2" style="display: none;">38 0E</span></div><div>If
 we can shift 8 bits at once (which is then shifting a byte at a time) 
the NC FLAG will be set.  If not, the CARRY FLAG will be sent and we 
need to JUMP to DSHFR3 to do it one byte at a time.</div></div>
									<div class="assembly-row-combined"><div>0D6F</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the value of the memory pointer from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0D70<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;DSHFRM</span></div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the value of the memory pointer in Register Pair HL on the STACK.  This is the entry point from DMULT.</div></div>
									<div class="assembly-row-combined"><div>0D71-0D73</div><div>LD DE,0800H<span class="opcode2" style="display: none;">11 00 08</span></div><div>This LD command shifts a zero into the HIGH ORDER byte and sets up a counter</div></div>
									<div class="assembly-row-combined"><div>0D74<span class="origrom2" style="display: inline;">DSHFR2</span></div><div>LD C,(HL)<span class="opcode2" style="display: none;">4E</span></div><div>Top of a loop.  Preserve a byte of the ACCumulator into Register C</div></div>
									<div class="assembly-row-combined"><div>0D75</div><div>LD (HL),E<span class="opcode2" style="display: none;">73</span></div><div>Overwrite that location with the last byte (held in Register E)</div></div>
									<div class="assembly-row-combined"><div>0D76</div><div>LD E,C<span class="opcode2" style="display: none;">59</span></div><div>Load Register E with the value in Register C so that THIS is the byte to write next.</div></div>
									<div class="assembly-row-combined"><div>0D77</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement the value of the memory pointer in Register Pair HL to point to the next lower order byte</div></div>
									<div class="assembly-row-combined"><div>0D78</div><div>DEC D<span class="opcode2" style="display: none;">15</span></div><div>Decrement the number of bits shifted in Register D</div></div>
									<div class="assembly-row-combined"><div>0D79-0D7A</div><div><a href="#0D74H" class="memory-link">JR NZ,0D74H<span class="origrom2" style="display: inline;">JR NZ,DSHFR2</span></a><span class="opcode2" style="display: none;">20 F9</span></div><div>Loop until all of the bits have been shifted</div></div>
									<div class="assembly-row-combined"><div>0D7B-0D7C</div><div><a href="#0D6BH" class="memory-link">JR 0D6BH<span class="origrom2" style="display: inline;">JR DSHFR1</span></a><span class="opcode2" style="display: none;">18 EE</span></div><div>LOOP back to the top to see we can shift another 8 bits.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0D7DH">0D69H-0D8FH - DOUBLE PRECISION MATH ROUTINE<span class="origrom">- "DSHFR3"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0D7D-0D7E<span class="origrom2" style="display: inline;">DSHFR3</span></div><div>ADD 09H<span class="opcode2" style="display: none;">C6 09</span></div><div>At this point, we cannot shift 8 bytes at once and need to do them individually.  First, set a corrected shift counter</div></div>
									<div class="assembly-row-combined"><div>0D7F</div><div>LD D,A<span class="opcode2" style="display: none;">57</span></div><div>Preserve the adjusted shift counter into Register D</div></div>
									<div class="assembly-row-combined"><div>0D80<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;DSHFR4</span></div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Clear the CARRY FLAG</div></div>
									<div class="assembly-row-combined"><div>0D81</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Restore the pointer to the HIGH ORDER byte into Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0D82</div><div>DEC D<span class="opcode2" style="display: none;">15</span></div><div>Decrement the number of bits to be shifted in Register D</div></div>
									<div class="assembly-row-combined"><div>0D83</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>Return if all of the bits have been shifted.</div></div>
									<div class="assembly-row-combined"><div>0D84<span class="origrom2" style="display: inline;">DSHFRA</span></div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>If all the bits have not been shifted, first save the pointer to the LOW ORDER byte.  This is the entry from DADD and DMULT.</div></div>
									<div class="assembly-row-combined"><div>0D85-0D86</div><div>LD E,08H<span class="opcode2" style="display: none;">1E 08</span></div><div>Load Register E with the counter of the number of bytes to be shifted</div></div>
									<div class="assembly-row-combined"><div>0D87<span class="origrom2" style="display: inline;">DSHFR5</span></div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Top of a loop.  Load Register A with a byte from the ACCumulator pointed to by HL</div></div>
									<div class="assembly-row-combined"><div>0D88</div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Shift
 the value in Register A.  RRA rotates the contents of Register A right 
one bit position, with Bit 0 going to the CARRY FLAG, and the CARRY FLAG
 going to Bit 7.  RRA also can be used to divide a number in 2.</div></div>
									<div class="assembly-row-combined"><div>0D89</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Put the rotated byte back</div></div>
									<div class="assembly-row-combined"><div>0D8A</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement the value of the memory pointer in Register Pair HL so we deal with the next lower order byte</div></div>
									<div class="assembly-row-combined"><div>0D8B</div><div>DEC E<span class="opcode2" style="display: none;">1D</span></div><div>Decrement the number of bytes to be shifted in Register E</div></div>
									<div class="assembly-row-combined"><div>0D8C-0D8D</div><div><a href="#0D87H" class="memory-link">JR NZ,0D87H<span class="origrom2" style="display: inline;">JR NZ,DSHFR5</span></a><span class="opcode2" style="display: none;">20 F9</span></div><div>Loop until all of the bits have been shifted</div></div>
									<div class="assembly-row-combined"><div>0D8E-0D8F</div><div><a href="#0D80H" class="memory-link">JR 0D80H<span class="origrom2" style="display: inline;">JR DSHFR4</span></a><span class="opcode2" style="display: none;">18 F0</span></div><div>Loop until all of the bits have been shifted.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0D90H">0D90H-0D96H - DOUBLE PRECISION MATH ROUTINE<span class="origrom">- "DSHFRB"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the entry from DADD and DMULT.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0D90-0D92<span class="origrom2" style="display: inline;">DSHFRB</span></div><div>LD HL,4123H<span class="origrom2" style="display: inline;">LD HL,FAC-1</span><span class="opcode2" style="display: none;">21 23 41</span></div><div>Load Register Pair HL with the address of the HIGH PRDER (MSB) of the double precision value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0D93-0D94</div><div>LD D,01H<span class="opcode2" style="display: none;">16 01</span></div><div>Load Register D with the number of bits to be shifted</div></div>
									<div class="assembly-row-combined"><div>0D95-0D96</div><div><a href="#0D84H" class="memory-link">JR 0D84H<span class="origrom2" style="display: inline;">JR DSHFRA</span></a><span class="opcode2" style="display: none;">18 ED</span></div><div>Jump to 0D84H to shift HL D bits to the right</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0D97H">0D97H-0DA0H - DOUBLE PRECISION MATH ROUTINE<span class="origrom">- "DSHFLC"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will rotate the ACCumulator left one.  Register A, C, H, and L are affected.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0D97-0D98<span class="origrom2" style="display: inline;">DSHFLC</span></div><div>LD C,08H<span class="opcode2" style="display: none;">0E 08</span></div><div>Load Register C with the number of bytes to be shifted</div></div>
									<div class="assembly-row-combined"><div>0D99<span class="origrom2" style="display: inline;">DSHFTL</span></div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Top of a loop.  Load Register A with a byte from the ACCumulator pointed to by HL</div></div>
									<div class="assembly-row-combined"><div>0D9A</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Rotate that byte left one bit</div></div>
									<div class="assembly-row-combined"><div>0D9B</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save the shifted byte (held in Register A) back to the ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0D9C</div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the value of the memory pointer in Register Pair HL to point to the next higher order byte</div></div>
									<div class="assembly-row-combined"><div>0D9D</div><div>DEC C<span class="opcode2" style="display: none;">0D</span></div><div>Decrement the byte counter in Register C</div></div>
									<div class="assembly-row-combined"><div>0D9E-0D9F</div><div><a href="#0D99H" class="memory-link">JR NZ,0D99H<span class="origrom2" style="display: inline;">JR NZ,DSHFTL</span></a><span class="opcode2" style="display: none;">20 F9</span></div><div>Loop until all of the bytes have been shifted</div></div>
									<div class="assembly-row-combined"><div>0DA0</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0DA1H">0DA1H-0DD3H - DOUBLE PRECISION MULTIPLICATION<span class="origrom">- "DMULT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Double-precision multiplication (ACCumulator=ACC*ARG (a/k/a REG 2)).<br>Multiplies
 the double precision value in the ACCumulator by the value in ARG 
(a/k/a REG 2). The product is left in the ACCumulator.<br><br>Note: If 
you wanted to multiply two double precision numbers store one operand in
 411DH-4124H, and store the other in 4127H-412EH and then CALL 0DA1H.  
The result (in double precision format) is in 411DH-4124H in 
approximately 22 milliseconds.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0DA1-0DA3<span class="origrom2" style="display: inline;">DMULT</span></div><div><a href="#0955H" class="memory-link">CALL 0955H<span class="origrom2" style="display: inline;">CALL SIGN</span></a><span class="opcode2" style="display: none;">CD 55 09</span></div><div>As
 always, we first start by checking to see if we are operating with any 
ZEROes.  First, go check to see if the value in the ACCumulator is equal
 to zero</div></div>
									<div class="assembly-row-combined"><div>0DA4</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>If
 the double precision value in the ACCumulator is equal to zero then we 
already have our answer (i.e., 0) in the ACCumulator, so RETurn</div></div>
									<div class="assembly-row-combined"><div>0DA5-0DA7</div><div><a href="#090AH" class="memory-link">CALL 090AH<span class="origrom2" style="display: inline;">CALL MULDVA</span></a><span class="opcode2" style="display: none;">CD 0A 09</span></div><div>Add the exponents and take care of processing the signs of the numbers via a GOSUB to MULDVA</div></div>
									<div class="assembly-row-combined"><div>0DA8-0DAA</div><div><a href="#0E39H" class="memory-link">CALL 0E39H<span class="origrom2" style="display: inline;">CALL DMULDV</span></a><span class="opcode2" style="display: none;">CD 39 0E</span></div><div>Zero
 out the ACCumulator and put the move the double precision value in the 
ACCumulator to a temporary work area via a GOSUB to DMULDV</div></div>
									<div class="assembly-row-combined"><div>0DAB</div><div>LD (HL),C<span class="opcode2" style="display: none;">71</span></div><div>Put the unpacked HIGH ORDER byte (pointed to by Register Pair HL in ARG) into Register C</div></div>
									<div class="assembly-row-combined"><div>0DAC</div><div>INC DE<span class="opcode2" style="display: none;">13</span></div><div>Increment Register Pair DE so that it points to the LSB of the double precision value in ARG</div></div>
									<div class="assembly-row-combined"><div>0DAD-0DAE</div><div>LD B,07H<span class="opcode2" style="display: none;">06 07</span></div><div>Load Register B with the number of bytes to be figured</div></div>
									<div class="assembly-row-combined"><div>0DAF<span class="origrom2" style="display: inline;">DMULT2</span></div><div>LD A,(DE)<span class="opcode2" style="display: none;">1A</span></div><div>Top of a big loop.  Fetch a byte of ARG (at the location pointed to by DE) to multiply by into Register A</div></div>
									<div class="assembly-row-combined"><div>0DB0</div><div>INC DE<span class="opcode2" style="display: none;">13</span></div><div>Increment the value of the memory pointer in Register Pair DE to point to the next higher byte.</div></div>
									<div class="assembly-row-combined"><div>0DB1</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the value in Register A is equal to zero</div></div>
									<div class="assembly-row-combined"><div>0DB2</div><div>PUSH DE<span class="opcode2" style="display: none;">D5</span></div><div>Save the value of the memory pointer to ARG (held in Register Pair DE) to the STACK</div></div>
									<div class="assembly-row-combined"><div>0DB3-0DB4</div><div><a href="#0DCCH" class="memory-link">JR Z,0DCCH<span class="origrom2" style="display: inline;">JR Z,DMULT5</span></a><span class="opcode2" style="display: none;">28 17</span></div><div>If Register A is zero, then we are multiplying by ZERO, so JUMP to DMULT5</div></div>
									<div class="assembly-row-combined"><div>0DB5-0DB6</div><div>LD C,08H<span class="opcode2" style="display: none;">0E 08</span></div><div>Otherwise, we need to set up for another loop for bit rotation.  First, load Register C with the numberof bits to be shifted</div></div>
									<div class="assembly-row-combined"><div>0DB7<span class="origrom2" style="display: inline;">DMULT3</span></div><div>PUSH BC<span class="opcode2" style="display: none;">C5</span></div><div>Top of a loop.  Save the counters (held in Register Pair BC) to the STACK</div></div>
									<div class="assembly-row-combined"><div>0DB8</div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>Shift
 the multiplier value (held in Register A) one place to the right.  RRA 
rotates the contents of Register A right one bit position, with Bit 0 
going to the CARRY FLAG, and the CARRY FLAG going to Bit 7.  RRA also 
can be used to divide a number in 2.</div></div>
									<div class="assembly-row-combined"><div>0DB9</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Preserve the shifted multiplier byte into Register B</div></div>
									<div class="assembly-row-combined"><div>0DBA-0DBC</div><div><a href="#0D33H" class="memory-link">CALL C,0D33H<span class="origrom2" style="display: inline;">CALL C,DADDAA</span></a><span class="opcode2" style="display: none;">DC 33 0D</span></div><div>If
 the bit of the multiplier that got shifted into the CARRY FLAG was a 1,
 we need to add in the old ACCumulator value via a GOSUB to DADDAA which
 adds the value in ARG (a/k/a REG 2) to the total in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0DBD-0DBF</div><div><a href="#0D90H" class="memory-link">CALL 0D90H<span class="origrom2" style="display: inline;">CALL DSHFRB</span></a><span class="opcode2" style="display: none;">CD 90 0D</span></div><div>Rotate the production right one bit via a GOSUB to DSHFRB which shifts the value of the total in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0DC0</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Restore the shifted multiplier byte (held in Register B) back into Register A</div></div>
									<div class="assembly-row-combined"><div>0DC1</div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>Restore the counters from the STACK into Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>0DC2</div><div>DEC C<span class="opcode2" style="display: none;">0D</span></div><div>Decrement the number of bits to be shifted from the ARG (tracked in Register C)</div></div>
									<div class="assembly-row-combined"><div>0DC3-0DC4</div><div><a href="#0DB7H" class="memory-link">JR NZ,0DB7H<span class="origrom2" style="display: inline;">JR NZ,DMULT3</span></a><span class="opcode2" style="display: none;">20 F2</span></div><div>If
 we have not hit 0 on the counter, LOOP back to 0DB7H to multiply by the
 next bit of the multiplier until all of the bits have been shifted</div></div>
									<div class="assembly-row-combined"><div>0DC5<span class="origrom2" style="display: inline;">DMULT4</span></div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>If
 we are here, then we finished rotating that one byte.  Top of a loop.  
First, get the pointer to ARG back from the STACK and put it in Register
 Pair DE</div></div>
									<div class="assembly-row-combined"><div>0DC6</div><div>DEC B<span class="opcode2" style="display: none;">05</span></div><div>Decrement the number of bytes to be figured (tracked in Register B)</div></div>
									<div class="assembly-row-combined"><div>0DC7-0DC8</div><div><a href="#0DAFH" class="memory-link">JR NZ,0DAFH<span class="origrom2" style="display: inline;">JR NZ,DMULT2</span></a><span class="opcode2" style="display: none;">20 E6</span></div><div>Loop back to 0DAFH to multiply by the next higher order byte in ARG until all of the bytes in ARG have been figured</div></div>
									<div class="assembly-row-combined"><div>0DC9-0DCB</div><div><a href="#0CD8H" class="memory-link">JP 0CD8H<span class="origrom2" style="display: inline;">JP DNORML</span></a><span class="opcode2" style="display: none;">C3 D8 0C</span></div><div>If
 we are here then we are done (first, all the bits in each number were 
rotated, then that was done by all the bytes).  Jump to 0CD8H to 
normalize and round the result.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0DCCH">0DCCH - DOUBLE PRECISION MULTIPLICATION Support Routine<span class="origrom">- "DMULT5"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine handles multiplying by zero.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0DCC-0DCE<span class="origrom2" style="display: inline;">DMULT5</span></div><div>LD HL,4123H<span class="origrom2" style="display: inline;">LD HL,FAC-1</span><span class="opcode2" style="display: none;">21 23 41</span></div><div>Load Register Pair HL with the address of the HIGH ORDER/MSB of the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0DCF-0DD1</div><div><a href="#0D70H" class="memory-link">CALL 0D70H<span class="origrom2" style="display: inline;">CALL DSHFRM</span></a><span class="opcode2" style="display: none;">CD 70 0D</span></div><div>Go shift the double precision total in the ACCumulator right one byte</div></div>
									<div class="assembly-row-combined"><div>0DD2-0DD3</div><div><a href="#0DC5H" class="memory-link">JR 0DC5H<span class="origrom2" style="display: inline;">JR DMULT4</span></a><span class="opcode2" style="display: none;">18 F1</span></div><div>Jump back into DMULT at the point where we finalize the number</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0DD4H">0DD4H-0DDBH - DOUBLE PRECISION CONSTANT STORAGE AREA<span class="origrom">- "DTEN" and "FTEN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0DD4-0DDB<span class="origrom2" style="display: inline;">DTEN</span></div><div>00 00 00 00 00 00 20 84<span class="opcode2" style="display: none;">00</span></div><div>A double precision constant equal to 10 is stored here.  Note: 0DD8 is also a reference point.</div></div>
									<div class="assembly-row-combined"><div>0DD8-0DDB<span class="origrom2" style="display: inline;">FTEN</span></div><div>00 00 20 84<span class="opcode2" style="display: none;">00</span></div><div>A double precision constant equal to 10.0 is stored here.  Note: 0DD8 is also a reference point.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0DDCH">0DDCH-0DE4H - DOUBLE PRECISION MATH ROUTINE<span class="origrom">- "DDIV10"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Double precision divide routine.  Divides the ACCumulator by 10.  All registers are affected.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0DDC-0DDE<span class="origrom2" style="display: inline;">DDIV10</span></div><div>LD DE,0DD4H<span class="origrom2" style="display: inline;">LD DE,DTEN</span><span class="opcode2" style="display: none;">11 D4 0D</span></div><div>Load Register Pair DE with the starting address of the double precision constant for 10</div></div>
									<div class="assembly-row-combined"><div>0DDF-0DE1</div><div>LD HL,4127H<span class="origrom2" style="display: inline;">LD HL,ARGLO</span><span class="opcode2" style="display: none;">21 27 41</span></div><div>Load Register Pair HL with the starting address of ARG (a/k/a REG 2).<br>Note: 4127H-412EH holds ARG (a/k/a REG 2)</div></div>
									<div class="assembly-row-combined"><div>0DE2-0DE4</div><div><a href="#09D3H" class="memory-link">CALL 09D3H<span class="origrom2" style="display: inline;">CALL VMOVE</span></a><span class="opcode2" style="display: none;">CD D3 09</span></div><div>GOSUB to VMOVE to move the 10 into ARG and then fall through to the DDIV routine to divide by 10.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0DE5H">0DE5H-0E38H - DOUBLE PRECISION DIVISION<span class="origrom">- "DDIV"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Double-precision division (ACCumulator=ACC / ARG).<br><br>Divides
 the double precision value in the ACCumulator by the value in ARG 
(a/k/a REG 2). The quotient is left in the ACCumulator. All registers 
are affected<br>To use a ROM call to divide two double precision 
numbers, store the dividend in 411DH-4124H, and the divisor in 
4127H-412EH and then  CALL 0DE5H.  The result (in double precision 
format) is in 411DH-4124H and then pproximately 42 milliseconds.  
Overflow or /0 will error out and return to Level II. </p>
								<div class="assembly-table">
									<p class="debug-note">According to Vernon Hester, there is a 
bug this routine.  Double-precision division should return a zero 
quotient when the dividend is zero. However, when the dividend is zero 
and the divisor is less than .25#, the ROM's double-precision division 
produces an non-zero quotient. e.g., PRINT 0 / .24# produces a quotient 
of 1.171859195766034D-38. If the divisor is 2.938735877055719D-39 then 
the quotient is .5</p>
									<p class="debug-note">Another bug is that double-precision 
division should perform correctly for absolute values that are from 
2.938735877055719D-39 to 1.701411834604692D+38. If the divisor is the 
minimum magnitude or the minimum magnitude times 2, then 
double-precision division errors.<br> <span class="code">10 Z# = 1 / (2^125 + 2^125) * .25 'This values Z# with 2.938735877055719D-39</span><br> <span class="code">20 PRINT 1 / Z# 'displays 2.938735877055719D-39 instead of overflow</span> </p>
									<div class="assembly-row-combined"><div>0DE5-0DE7<span class="origrom2" style="display: inline;">DDIV</span></div><div>LD A,(412EH)<span class="origrom2" style="display: inline;">LD A,(ARG)</span><span class="opcode2" style="display: none;">3A 2E 41</span></div><div>As
 always, start by checking to see if we are dealing with a ZERO.  First,
 load Register A with the value of the exponent for the double precision
 value in ARG (a/k/a REG 2)</div></div>
									<div class="assembly-row-combined"><div>0DE8</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the double precision value in ARG (a/k/a REG 2) is equal to zero</div></div>
									<div class="assembly-row-combined"><div>0DE9-0DEB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#199AH" class="memory-link">JP Z,199AH<span class="origrom2" style="display: inline;">JP Z,DV0ERR</span></a><span class="opcode2" style="display: none;">CA 9A 19</span></div><div>Display a ?/0 ERROR message if the double precision value in ARG (a/k/a REG 2) is equal to zero</div></div>
									<div class="assembly-row-combined"><div>0DEC-0DEE</div><div><a href="#0907H" class="memory-link">CALL 0907H<span class="origrom2" style="display: inline;">CALL MULDVS</span></a><span class="opcode2" style="display: none;">CD 07 09</span></div><div>Subtract the exponents and check the signs via a GOSUB to MULDVS</div></div>
									<div class="assembly-row-combined"><div>0DEF<br>0DF0</div><div>INC (HL)<br>INC (HL)<span class="opcode2" style="display: none;">34</span></div><div>Increment the value of the exponent in the ACCumulator TWICE to correct the scaling</div></div>
									<div class="assembly-row-combined"><div>0DF1-0DF3</div><div><a href="#0E39H" class="memory-link">CALL 0E39H<span class="origrom2" style="display: inline;">CALL DMULDV</span></a><span class="opcode2" style="display: none;">CD 39 0E</span></div><div>Zero the ACCumulator and move the double precision value from ACCumulator into ARG (a/k/a REG 2)</div></div>
									<div class="assembly-row-combined"><div>0DF4-0DF6</div><div>LD HL,4151H<span class="origrom2" style="display: inline;">LD HL,FBUFFR+34</span><span class="opcode2" style="display: none;">21 51 41</span></div><div>Load Register Pair HL with the address of the extra HIGH ORDER byte we will use in ARG</div></div>
									<div class="assembly-row-combined"><div>0DF7</div><div>LD (HL),C<span class="opcode2" style="display: none;">71</span></div><div>Zero the that byte</div></div>
									<div class="assembly-row-combined"><div>0DF8</div><div>LD B,C<span class="opcode2" style="display: none;">41</span></div><div>Zero Register B, which will be the flag that tells us when start dividing</div></div>
									<div class="assembly-row-combined"><div>0DF9-0DFB<span class="origrom2" style="display: inline;">DDIV1</span></div><div>LD DE,414AH<span class="origrom2" style="display: inline;">LD DE,FBUFFR+27</span><span class="opcode2" style="display: none;">11 4A 41</span></div><div>Top of a large loop.  First, get the pointer to the end of the BUFFR into Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0DFC-0DFE</div><div>LD HL,4127H<span class="origrom2" style="display: inline;">LD HL,ARGLO</span><span class="opcode2" style="display: none;">21 27 41</span></div><div>Load Register Pair HL with the address of the END of the double precision value in ARG (a/k/a REG 2)</div></div>
									<div class="assembly-row-combined" id="=&quot;0E00H&quot;"><div>0DFF-0E01</div><div><a href="#0D4BH" class="memory-link">CALL 0D4BH<span class="origrom2" style="display: inline;">CALL DADDSS</span></a><span class="opcode2" style="display: none;">CD 4B 0D</span></div><div>Go subtract the those two double precision values</div></div>
									<div class="assembly-row-combined"><div>0E02</div><div>LD A,(DE)<span class="opcode2" style="display: none;">1A</span></div><div>Prepare
 to subtract from the extra HIGH ORDER byte by first loading Register A 
with the value at the location of the memory pointer in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0E03</div><div>SBC A,C<span class="opcode2" style="display: none;">99</span></div><div>Subtract the value in Register C from the value in Register A</div></div>
									<div class="assembly-row-combined"><div>0E04</div><div>CCF<span class="opcode2" style="display: none;">3F</span></div><div>If
 the subtraction was good then the CARRY FLAG will be set, so complement
 the value of the CARRY FLAG so that NC FLAG will mean good</div></div>
									<div class="assembly-row-combined"><div>0E05-0E06</div><div><a href="#0E12H" class="memory-link">JR C,0E12H<span class="origrom2" style="display: inline;">JR C,DDIV2</span></a><span class="opcode2" style="display: none;">38 0B</span></div><div>If
 the subtraction was bad, meaning that the double precision value in ARG
 (a/k/a REG 2) is greater than the double precision value in FBUFFER, 
then JUMP to DDIV2</div></div>
									<div class="assembly-row-combined"><div>0E07-0E09</div><div>LD DE,414AH<span class="origrom2" style="display: inline;">LD DE,FBUFFR+27</span><span class="opcode2" style="display: none;">11 4A 41</span></div><div>Put the pointer to the end of the BUFFR into Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0E0A-0E0C</div><div>LD HL,4127H<span class="origrom2" style="display: inline;">LD HL,ARGLO</span><span class="opcode2" style="display: none;">21 27 41</span></div><div>Load Register Pair HL with the address of the END of the double precision value in ARG (a/k/a REG 2)</div></div>
									<div class="assembly-row-combined"><div>0E0D-0E0F</div><div><a href="#0D39H" class="memory-link">CALL 0D39H<span class="origrom2" style="display: inline;">CALL DADDS</span></a><span class="opcode2" style="display: none;">CD 39 0D</span></div><div>Go add the double precision value in ARG (a/k/a REG 2) to the double precision value in FBUFFR</div></div>
									<div class="assembly-row-combined"><div>0E10</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Clear the CARRY FLAG for the Z-80 trick in the next instruction.</div></div>
									<div class="assembly-row-combined"><div>0E11-0E13</div><div><a href="#0412H" class="memory-link">JP C,0412H</a><span class="opcode2" style="display: none;">DA 12 04</span></div><div>Z-80
 TRICK.  Since the CARRY was just cleared, this cannot ever execute and 
it won't even see the next instruction.  It is designed to allow for 
passing through but not running the next 2 instructions.</div></div>
									<div class="assembly-row-combined"><div>0E12<span class="origrom2" style="display: inline;">DDIV2</span></div><div>LD (DE),A<span class="opcode2" style="display: none;">12</span></div><div>If this line is executed (i.e., JUMPed to, but not passed down to), put the new highest order byte into Register A</div></div>
									<div class="assembly-row-combined"><div>0E13</div><div>INC B<span class="opcode2" style="display: none;">04</span></div><div>If
 this line is executed (i.e., JUMPed to, but not passed down to), 
increment the flag in Register B to show that we can do the division</div></div>
									<div class="assembly-row-combined"><div>0E14-0E16</div><div>LD A,(4123H)<span class="origrom2" style="display: inline;">LD A,(FAC-1)</span><span class="opcode2" style="display: none;">3A 23 41</span></div><div>Prepare the check to see if we are finished dividing.  First, getch the byte at FAC-1</div></div>
									<div class="assembly-row-combined"><div>0E17<br>0E18</div><div>INC A<br>DEC A<span class="opcode2" style="display: none;">3C</span></div><div>INCrement and DECrement Register A so that the SIGN FLAG will be set without chaning the status of the CARRY FLAG</div></div>
									<div class="assembly-row-combined"><div>0E19</div><div>RRA<span class="opcode2" style="display: none;">1F</span></div><div>In
 preparation for DROUNB, put the CARRY FLAG into the MSB via a RRA 
rotation.  RRA rotates the contents of Register A right one bit 
position, with Bit 0 going to the CARRY FLAG, and the CARRY FLAG going 
to Bit 7.  RRA also can be used to divide a number in 2.</div></div>
									<div class="assembly-row-combined"><div>0E1A-0E1C</div><div><a href="#0D11H" class="memory-link">JP M,0D11H<span class="origrom2" style="display: inline;">JP M,DROUNB</span></a><span class="opcode2" style="display: none;">FA 11 0D</span></div><div>If the M FLAG is set, then we are done and have 57 bits of accuracy, so JUMP to DROUNB to finish up.</div></div>
									<div class="assembly-row-combined"><div>0E1D</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Restore the CARRY BIT to where it belongs</div></div>
									<div class="assembly-row-combined"><div>0E1E-0E20</div><div>LD HL,411DH<span class="origrom2" style="display: inline;">LD HL,DFACLO</span><span class="opcode2" style="display: none;">21 1D 41</span></div><div>Load Register Pair HL with the starting address of the LOW ORDER/LSB byte of the double precision result in the ACCumulator.<br>Note: 411DH-4124H holds ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0E21-0E22</div><div>LD C,07H<span class="opcode2" style="display: none;">0E 07</span></div><div>Load Register C with the number of bytes to be shifted</div></div>
									<div class="assembly-row-combined"><div>0E23-0E25</div><div><a href="#0D99H" class="memory-link">CALL 0D99H<span class="origrom2" style="display: inline;">CALL DSHFTL</span></a><span class="opcode2" style="display: none;">CD 99 0D</span></div><div>GOSUB to DSHFTL to shit in the next bit in the quotient (held in the ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>0E26-0E28</div><div>LD HL,414AH<span class="origrom2" style="display: inline;">LD HL,FBUFFR+27</span><span class="opcode2" style="display: none;">21 4A 41</span></div><div>Load Register Pair HL with the pointo the LOW ORDER byte in FBUFFR</div></div>
									<div class="assembly-row-combined"><div>0E29R-0E2BH</div><div><a href="#0D97H" class="memory-link">CALL 0D97H<span class="origrom2" style="display: inline;">CALL DSHFLC</span></a><span class="opcode2" style="display: none;">CD 97 0D</span></div><div>Go shift the double precision value dividend (in FBUFFR) one to the left</div></div>
									<div class="assembly-row-combined"><div>0E2C</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>Test
 to see if this was the first time by first loading Register A with the 
value of the counter in Register B.  Note that B will get changed on the
 first or second subtraction</div></div>
									<div class="assembly-row-combined"><div>0E2D</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Set the flags based on Register B</div></div>
									<div class="assembly-row-combined"><div>0E2E-0E2F</div><div><a href="#0DF9H" class="memory-link">JR NZ,0DF9H<span class="origrom2" style="display: inline;">JR NZ,DDIV1</span></a><span class="opcode2" style="display: none;">20 C9</span></div><div>If Register B is not ZERO, then we have more to go so LOOP back up to DDIV1</div></div>
									<div class="assembly-row-combined"><div>0E30-0E32</div><div>LD HL,4124H<span class="origrom2" style="display: inline;">LD HL,FAC</span><span class="opcode2" style="display: none;">21 24 41</span></div><div>If
 we are here, then this was the first iteration, so we need to subtract 
one from the exponent to correct scaling.  To do that, first load 
Register Pair HL with the address of the exponent for the double 
precision result in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0E33</div><div>DEC (HL)<span class="opcode2" style="display: none;">35</span></div><div>Decrement
 the value of the exponent for the double precision result in the 
ACCumulator at the location of the memory pointer in Register Pair HL.  
If (HL) is reduced to zero then we have a problem!</div></div>
									<div class="assembly-row-combined"><div>0E34-0E35</div><div><a href="#0DF9H" class="memory-link">JR NZ,0DF9H<span class="origrom2" style="display: inline;">JR NZ,DDIV1</span></a><span class="opcode2" style="display: none;">20 C3</span></div><div>Continue dividing so long as we don't have an overflow by LOOPING back to DDIV</div></div>
									<div class="assembly-row-combined"><div>0E36-0E38</div><div><a href="#07B2H" class="memory-link">JP 07B2H<span class="origrom2" style="display: inline;">JP OVERR</span></a><span class="opcode2" style="display: none;">C3 B2 07</span></div><div>Display an <span class="code">?OV ERROR</span>if the exponent for the result in the ACCumulator is too small</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0E39H">0E39H-0E4CH - DOUBLE PRECISION MATH ROUTINE<span class="origrom">- "DMULDV"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will transfer the double prevision number held 
in the ACCumulator to FBUFFR for the DMULT and DDIV routines.  All 
registers are affected.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0E39<span class="origrom2" style="display: inline;">DMULDV</span></div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>We
 need to put the unpacked HIGH ORDER back into ARG, so first load 
Register A with the HIGH ORDER of the double precision value in ARG 
(a/k/a REG 2) in Register C</div></div>
									<div class="assembly-row-combined"><div>0E3A-0E3C</div><div>LD (412DH),A<span class="origrom2" style="display: inline;">LD (ARG-1),A</span><span class="opcode2" style="display: none;">32 2D 41</span></div><div>Save the MSB of the double precision value in ARG (a/k/a REG 2) in Register A</div></div>
									<div class="assembly-row-combined"><div>0E3D</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement the value of the memory pointer in Register Pair HL to now point to the HIGH ORDER of the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0E3E-0E40</div><div>LD DE,4150H<span class="origrom2" style="display: inline;">LD DE,FMLTT2</span><span class="opcode2" style="display: none;">11 50 41</span></div><div>Load Register Pair DE with the end of FBUFFR</div></div>
									<div class="assembly-row-combined"><div>0E41-0E43</div><div>LD BC,0700H<span class="opcode2" style="display: none;">01 00 07</span></div><div>Load Register B with the number of bytes to be moved (which is 7) and put a zero into Register C</div></div>
									<div class="assembly-row-combined"><div>0E44<span class="origrom2" style="display: inline;">DMLDV1</span></div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Top of a loop.  Fetch a byte from the ACCumulator  (tracked by Register Pair HL) into Register A</div></div>
									<div class="assembly-row-combined"><div>0E45</div><div>LD (DE),A<span class="opcode2" style="display: none;">12</span></div><div>Save that byte into FBUFFR (tracked by Register Pair DE)</div></div>
									<div class="assembly-row-combined"><div>0E46</div><div>LD (HL),C<span class="opcode2" style="display: none;">71</span></div><div>Zero out that location in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0E47</div><div>DEC DE<span class="opcode2" style="display: none;">1B</span></div><div>Decrement the value of the memory pointer to FBUFFR (tracked by Register Pair DE)</div></div>
									<div class="assembly-row-combined"><div>0E48</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement the value of the memory pointer to the ACCumulator (tracked by Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>0E49</div><div>DEC B<span class="opcode2" style="display: none;">05</span></div><div>Decrement the value of the byte counter in Register B to see if we are done</div></div>
									<div class="assembly-row-combined"><div>0E4A-0E4B</div><div><a href="#0E44H" class="memory-link">JR NZ,0E44H<span class="origrom2" style="display: inline;">JR NZ,DMLDV1</span></a><span class="opcode2" style="display: none;">20 F8</span></div><div>Loop until the double precision value has been moved from the ACCumulator to FBUFFR</div></div>
									<div class="assembly-row-combined"><div>0E4C</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0E4DH">0E4DH-0E64H - LEVEL II BASIC MATH ROUTINE<span class="origrom">- "DMUL10"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine multiplies the current double-precision value by
 10 by adding it to itself.  First the current value is moved to a saved
 location, and then DP add routine adds the current value to that saved 
value.  All registers are affected</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0E4D-0E4F<span class="origrom2" style="display: inline;">DMUL10</span></div><div><a href="#09FCH" class="memory-link">CALL 09FCH<span class="origrom2" style="display: inline;">CALL VMOVAF</span></a><span class="opcode2" style="display: none;">CD FC 09</span></div><div>Go move the value in the ACCumulator to ARG (a/k/a REG 2)</div></div>
									<div class="assembly-row-combined"><div>0E50</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Since VMOVAF exits with DE pointing to ACCumulator + 1 we need to swap those so that HL points to the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0E51</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>As
 always, the first thing we need to do is see if we are deadling with a 
0.  First, decrement the value of the memory pointer in Register Pair HL
 to point to the exponent of the number in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0E52</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Fetch the exponent from the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0E53</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Check to see if the value in the ACCumulator is equal to zero</div></div>
									<div class="assembly-row-combined"><div>0E54</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>Return if the value in the ACCumulator is equal to zero</div></div>
									<div class="assembly-row-combined"><div>0E55-0E56</div><div>ADD 02H<span class="opcode2" style="display: none;">C6 02</span></div><div>Add two to the exponent which is the same as multiplying the ACCumulator by 4</div></div>
									<div class="assembly-row-combined"><div>0E57-0E59</div><div><a href="#07B2H" class="memory-link">JP C,07B2H<span class="origrom2" style="display: inline;">JP C,OVERR</span></a><span class="opcode2" style="display: none;">DA B2 07</span></div><div>Display an <span class="code">?OV ERROR</span>if the adjusted exponent in Register A is too large</div></div>
									<div class="assembly-row-combined"><div>0E5A</div><div>LD (HL),A<span class="opcode2" style="display: none;">77</span></div><div>Save the adjusted exponent back into the ACCumulator at the location of the memory pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0E5B</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save pointer to the ACCumulator onto the STACK</div></div>
									<div class="assembly-row-combined"><div>0E5C-0E5E</div><div><a href="#0C77H" class="memory-link">CALL 0C77H<span class="origrom2" style="display: inline;">CALL DADD</span></a><span class="opcode2" style="display: none;">CD 77 0C</span></div><div>Add
 in that number one more time (so now it is time 5) by GOSUBing to the 
DOUBLE PRECISION ADD function (whcih adds the double precision value in 
ARG (a/k/a REG 2) to the value in the ACCumulator.  Result is left in 
the ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>0E5F</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the memory pointer to the ACCumulator from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0E60</div><div>INC (HL)<span class="opcode2" style="display: none;">34</span></div><div>Add 1 to the exponent, thus doubling the number.</div></div>
									<div class="assembly-row-combined"><div>0E61</div><div>RET NZ<span class="opcode2" style="display: none;">C0</span></div><div>Return if overflow didn't occur.</div></div>
									<div class="assembly-row-combined"><div>0E62-0E64</div><div><a href="#07B2H" class="memory-link">JP 07B2H<span class="origrom2" style="display: inline;">JP OVERR</span></a><span class="opcode2" style="display: none;">C3 B2 07</span></div><div>Display an <span class="code">?OV ERROR</span>if the exponent in the ACCumulator at the location of the memory pointer in Register Pair HL is too large</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0E65H">0E65H-0F88H - ASCII to Double Precision Converter<span class="origrom">- "FINDBL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine converts an ASCII string (pointed to by HL) to a
 double-precision value and stores it in the ACCumulator. The NTF is 
fixed accordingly. The string must be terminated with a <span class="code">,</span>or
 zero byte. Note that the ARG (a/k/a REG 2) is destroyed in the process 
and that HL will point to the delimiter at the end of the string. The 
string formats must follow the same rules as in BASIC.  All registers 
are affected<br><br>On entry (HL) must point to the first character in 
the string buffer, with the first character being in A.  On exit, the 
the double precision number is left in the ACCumulator.<br><br>In 
processing, the digits are packed into the ACCumulator as an integer, 
with tracking for the decimal point.  C=80H if we have not seen a 
decimal point, and 00H if we have.  Register B holds the number of 
digits after the decimal point.<br><br>At the end, Register B and the 
exponent (held in Register E) are used to determine how many times we 
multiply or divide the number by 10 to get the correct number. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0E65-0E67<span class="origrom2" style="display: inline;">FINDBL</span></div><div><a href="#0778H" class="memory-link">CALL 0778H<span class="origrom2" style="display: inline;">CALL ZERO</span></a><span class="opcode2" style="display: none;">CD 78 07</span></div><div>GOSUB to ZERO to zero the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0E68-0E6A</div><div><a href="#0AECH" class="memory-link">CALL 0AECH<span class="origrom2" style="display: inline;">CALL VALDBL</span></a><span class="opcode2" style="display: none;">CD EC 0A</span></div><div>GOSUB to VALDBL to force the VALTYP to to double precision</div></div>
									<div class="assembly-row-combined"><div>0E6B</div><div>OR 0AFH<br>F6 AF<span class="opcode2" style="display: none;">F6 AF</span></div><div>Part
 of a Z-80 Trick.  If passing through, the next instruction of XOR A 
will not execute.  This is done so that if passing through, the XOR A 
doesn't cause us to CALL MAKINT.  If the next instruction is JUMPed to, 
and executes, MAKINT will be CALLed</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0E6CH">0E6CH - ASCII to Binary Converter<span class="origrom">- "FIN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>A call to 0E6CH converts the ASCII string pointed to by HL to
 binary. If the value is less than 2** 16 and does not contain a decimal
 point or an E or D descriptor (exponent), the string will be converted 
to its integer equivalent. If the string contains a decimal point or an 
E, or D descriptor or if it exceeds 2** 16 it will be converted to 
single or double precision. The binary value will be left in the 
ACCumulator and the mode flag will be to the proper value.<br><br>Evaluate
 a numeric string that begins at the address pointed to by the HL 
Register Pair, store it in ACCUM and set the NTF. This routine stops as 
soon as it encounters a character that is not part of the number (it 
will return a value of zero if no valid numeric characters are found). 
It will accept signed values in Integer, Real or Scientific Notation. 
Number returned will be in integer format if possible, else single 
precision unless the string has over seven digits (not including 
exponent), in which case number will be returned as double precision.<br><br>This
 routine will convert the ASCII string pointed to by register pair HL to
 binary. The result will be returned in the ACCumulator, and the number 
type flag will be updated accordingly. The routine will convert the 
ASCII string to the least amount of precision required.<br><br>Note: If 
you wanted to do this conversion via a ROM call, first have the 
characters assembled in consecutive memory locations, with either a 
comma or a 00H at the end.  Load HL with the address of the first 
character.  Call 0E6CH.  If the output can be an integer, it will be in 
4121H-4122H (with 40AFH being a 2).  If the output has to be single 
precision, it will be in 4121H-4124H (with 40AFH being a 4).  If the 
output has to be double precision, it will be in 411DH-4124H (with 40AFH
 being an 8). </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0E6C<span class="origrom2" style="display: inline;">FIN</span></div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A for the purpose of triggering the GOSUB to MAKINT at 0E73H</div></div>
									<div class="assembly-row-combined"><div>0E6D<span class="origrom2" style="display: inline;">FINCHR</span></div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Load Register Pair DE with the pointer to the current BASIC line being interpreted</div></div>
									<div class="assembly-row-combined"><div>0E6E-0E70</div><div>LD BC,00FFH<span class="opcode2" style="display: none;">01 FF 00</span></div><div>Load Register Pair BC with a zero and a negative one.  Register B will track the decimal point location and C will be a flag.</div></div>
									<div class="assembly-row-combined"><div>0E71</div><div>LD H,B<span class="opcode2" style="display: none;">60</span></div><div>Load Register H with zero</div></div>
									<div class="assembly-row-combined"><div>0E72</div><div>LD L,B<span class="opcode2" style="display: none;">68</span></div><div>Load Register L with zero.  Now HL is zero.</div></div>
									<div class="assembly-row-combined"><div>0E73-0E75</div><div><a href="#0A9AH" class="memory-link">CALL Z,0A9AH<span class="origrom2" style="display: inline;">CALL Z,MAKINT</span></a><span class="opcode2" style="display: none;">CC 9A 0A</span></div><div>A CALL to MAKINT will clear the ACCumulator and force VALTYP into Integer</div></div>
									<div class="assembly-row-combined"><div>0E76</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Restore the pointer to the BASIC line being interpreted into HL and zero out Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0E77</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Retrieve the first character at at the location of the current input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0E78-0E79</div><div>CP 2DH<span class="origrom2" style="display: inline;">CP "-"</span><span class="opcode2" style="display: none;">FE 2D</span></div><div>Check to see if the character at the current position in the string being interpreted is a <span class="code">-</span></div></div>
									<div class="assembly-row-combined"><div>0E7A</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the sign in Register Pair AF on the STACK</div></div>
									<div class="assembly-row-combined"><div>0E7B-0E7D</div><div><a href="#0E83H" class="memory-link">JP Z,0E83H<span class="origrom2" style="display: inline;">JP Z,FINC</span></a><span class="opcode2" style="display: none;">CA 83 0E</span></div><div>If the character at the current position in the string being interpreted is a <span class="code">-</span>then JUMP to FINC to ignore it</div></div>
									<div class="assembly-row-combined"><div>0E7E-0E7F</div><div>CP 2BH<span class="origrom2" style="display: inline;">CP "+"</span><span class="opcode2" style="display: none;">FE 2B</span></div><div>Check to see if the character at the current position in the string being interpreted is a <span class="code">+</span></div></div>
									<div class="assembly-row-combined"><div>0E80-0E81</div><div><a href="#0E83H" class="memory-link">JR Z,0E83H<span class="origrom2" style="display: inline;">JR Z,FINC</span></a><span class="opcode2" style="display: none;">28 01</span></div><div>If the character at the current position in the string being interpreted is a <span class="code">+</span>then JUMP to FINC to process it</div></div>
									<div class="assembly-row-combined"><div>0E82</div><div>DEC HL<span class="opcode2" style="display: none;">2B</span></div><div>Decrement
 the value of the current input buffer pointer in Register Pair HL to 
point to the first character in the string being interpreted</div></div>
									<div class="assembly-row-combined"><div>0E83<span class="origrom2" style="display: inline;">FINC</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H<span class="origrom2" style="display: inline;">CHRGET</span></a><span class="opcode2" style="display: none;">D7</span></div><div>Since
 we need to bump the current input buffer pointer in Register Pair HL 
until it points to the next character, call the EXAMINE NEXT SYMBOL 
routine at RST 10H (which Loads the next character from the string 
pointed to by the HL Register set into the A-Register And clears the 
CARRY flag if it is alphabetic, or sets it if is alphanumeric. Blanks 
and control codes 09 and OB are ignored causing the following character 
to be loaded and tested. The HL Register will be incremented before 
loading any character therfore on the first call the HL Register should 
contain the string address minus one. The string must be terminated by a
 byte of zeros)</div></div>
									<div class="assembly-row-combined"><div>0E84-0E86</div><div><a href="#0F29H" class="memory-link">JP C,0F29H<span class="origrom2" style="display: inline;">JP C,FINDIG</span></a><span class="opcode2" style="display: none;">DA 29 0F</span></div><div>If the character at the location of the current input buffer pointer in Register A is numeric then JUMP to FINDIG</div></div>
									<div class="assembly-row-combined"><div>0E87-0E88</div><div>CP 2EH<span class="origrom2" style="display: inline;">CP "."</span><span class="opcode2" style="display: none;">FE 2E</span></div><div>Check to see if the character at the location of the current input buffer pointer in Register A is a <span class="code">.</span></div></div>
									<div class="assembly-row-combined"><div>0E89-0E8B</div><div><a href="#0EE4H" class="memory-link">JP Z,0EE4H<span class="origrom2" style="display: inline;">JP Z,FINDP</span></a><span class="opcode2" style="display: none;">CA E4 0E</span></div><div>Jump if the character at the location of the current input buffer pointer in Register A is a <span class="code">.</span></div></div>
									<div class="assembly-row-combined"><div>0E8C-0E8D</div><div>CP 45H<span class="origrom2" style="display: inline;">CP "E"</span><span class="opcode2" style="display: none;">FE 45</span></div><div>Check to see if the character at the location of the current input buffer pointer in Register A is an <span class="code">E</span>(which is a single precision exponent)</div></div>
									<div class="assembly-row-combined"><div>0E8E-0E8F</div><div><a href="#0EA4H" class="memory-link">JR Z,0EA4H<span class="origrom2" style="display: inline;">JR Z,FINEX</span></a><span class="opcode2" style="display: none;">28 14</span></div><div>Jump if the character at the location of the current input buffer pointer in Register A is an <span class="code">E</span></div></div>
									<div class="assembly-row-combined"><div>0E90-0E91</div><div>CP 25H<span class="origrom2" style="display: inline;">CP "%"</span><span class="opcode2" style="display: none;">FE 25</span></div><div>Check to see if the character at the location of the current input buffer pointer in Register A is a <span class="code">%</span></div></div>
									<div class="assembly-row-combined"><div>0E92-0E94</div><div><a href="#0EEEH" class="memory-link">JP Z,0EEEH<span class="origrom2" style="display: inline;">JP Z,FININT</span></a><span class="opcode2" style="display: none;">CA EE 0E</span></div><div>Jump
 to FININT (since this HAS to be an integer) if the character at the 
location of the current input buffer pointer in Register A is a <span class="code">%</span></div></div>
									<div class="assembly-row-combined"><div>0E95-0E96</div><div>CP 23H<span class="origrom2" style="display: inline;">CP "#"</span><span class="opcode2" style="display: none;">FE 23</span></div><div>Check to see if the character at the location of the current input buffer pointer in Register A is a <span class="code">#</span></div></div>
									<div class="assembly-row-combined"><div>0E97-0E99</div><div><a href="#0EF5H" class="memory-link">JP Z,0EF5H<span class="origrom2" style="display: inline;">JP Z,FINDBF</span></a><span class="opcode2" style="display: none;">CA F5 0E</span></div><div>Jump
 to FINDBF (since this needs to be forced into double precision) if the 
character at the location of the current input buffer pointer in 
Register A is a <span class="code">#</span></div></div>
									<div class="assembly-row-combined"><div>0E9A-0E9B</div><div>CP 21H<span class="origrom2" style="display: inline;">CP "!"</span><span class="opcode2" style="display: none;">FE 21</span></div><div>Check to see if the character at the location of the current input buffer pointer in Register A is a <span class="code">!</span></div></div>
									<div class="assembly-row-combined"><div>0E9C-0E9E</div><div><a href="#0EF6H" class="memory-link">JP Z,0EF6H<span class="origrom2" style="display: inline;">JP Z,FINSNF</span></a><span class="opcode2" style="display: none;">CA F6 0E</span></div><div>Jump
 to FINSNF (since this needs to be forced into single precision) if the 
character at the location of the current input buffer pointer in 
Register A is a <span class="code">!</span></div></div>
									<div class="assembly-row-combined"><div>0E9F-0EA0</div><div>CP 44H<span class="origrom2" style="display: inline;">CP "D"</span><span class="opcode2" style="display: none;">FE 44</span></div><div>Check to see if the character at the location of the current input buffer pointer in Register A is a <span class="code">D</span></div></div>
									<div class="assembly-row-combined"><div>0EA1-0EA2</div><div><a href="#0EC7H" class="memory-link">JR NZ,0EC7H<span class="origrom2" style="display: inline;">JR NZ,FINE</span></a><span class="opcode2" style="display: none;">20 24</span></div><div>If the character ISN'T a <span class="code">D</span>, then we must be finished with the number, so JUMP to FINE</div></div>
									<div class="assembly-row-combined"><div>0EA3<span class="origrom2" style="display: inline;">FINEX1</span></div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Set the flags according to the value of the character at the location of the current input buffer pointer in Register A</div></div>
									<div class="assembly-row-combined"><div>0EA4-0EA6<span class="origrom2" style="display: inline;">FINEX</span></div><div><a href="#0EFBH" class="memory-link">CALL 0EFBH<span class="origrom2" style="display: inline;">CALL FINFRC</span></a><span class="opcode2" style="display: none;">CD FB 0E</span></div><div>Convert the current value in the ACCumulator to either single precision or double precision</div></div>
									<div class="assembly-row-combined"><div>0EA7</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the current input buffer pointer to the string being processed (tracked in Register Pair HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>0EA8-0EAA</div><div>LD HL,0EBDH<span class="origrom2" style="display: inline;">LD HL,FINEC</span><span class="opcode2" style="display: none;">21 BD 0E</span></div><div>Load Register Pair HL with the return address to the FINEC routine</div></div>
									<div class="assembly-row-combined"><div>0EAB</div><div>EX (SP),HL<span class="opcode2" style="display: none;">E3</span></div><div>Swap
 (SP) and HL, so that the return address goes into Register Pair HL and 
the current input buffer pointer to the text string goes to the top of 
the STACK</div></div>
									<div class="assembly-row-combined"><div>0EAC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H<span class="origrom2" style="display: inline;">CHRGET</span></a><span class="opcode2" style="display: none;">D7</span></div><div>Next
 we need the first character of the exponent.  Since we need to bump the
 current input buffer pointer in Register Pair HL until it points to the
 next character, call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>0EAD</div><div>DEC D<span class="opcode2" style="display: none;">15</span></div><div>Decrement the value in Register D to turn the sign of the exponent to NEGATIVE</div></div>
									<div class="assembly-row-combined"><div>0EAE-0EAF</div><div>CP 0CEH<span class="origrom2" style="display: inline;">CP "-"</span><span class="opcode2" style="display: none;">FE CE</span></div><div>Check to see if the character at the location of the current input buffer pointer in Register A is a <span class="code">-</span>token</div></div>
									<div class="assembly-row-combined"><div>0EB0</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>If the character at the location of the current input buffer pointer in Register A is a minus sign token then RET</div></div>
									<div class="assembly-row-combined"><div>0EB1-0EB2</div><div>CP 2DH<span class="origrom2" style="display: inline;">CP "-"</span><span class="opcode2" style="display: none;">FE 2D</span></div><div>Check to see if the character at the location of the current input buffer pointer in Register A is a <span class="code">-</span>sign (not token)</div></div>
									<div class="assembly-row-combined"><div>0EB3</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>If the character at the location of the current input buffer pointer in Register A is a minus sign then RET</div></div>
									<div class="assembly-row-combined"><div>0EB4</div><div>INC D<span class="opcode2" style="display: none;">14</span></div><div>If
 we are here then the exponent is still positive, so increment the value
 in Register D to re-set that flag, as we are now going to process the 
notations for positive</div></div>
									<div class="assembly-row-combined"><div>0EB5-0EB6</div><div>CP 0CDH<span class="origrom2" style="display: inline;">CP "+"</span><span class="opcode2" style="display: none;">FE CD</span></div><div>Check to see if the character at the location of the current input buffer pointer in Register A is a <span class="code">+</span>token (0CDH)</div></div>
									<div class="assembly-row-combined"><div>0EB7</div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>Return if the character at the location of the current input buffer pointer in Register A is a <span class="code">+</span>token (CDH)</div></div>
									<div class="assembly-row-combined"><div>0EB8-0EB9</div><div>CP 2BH<span class="origrom2" style="display: inline;">CP "+"</span><span class="opcode2" style="display: none;">FE 2B</span></div><div>Check to see if the character at the location of the current input buffer pointer in Register A is a <span class="code">+</span></div></div>
									<div class="assembly-row-combined"><div>0EBB</div><div>RET Z<span class="opcode2" style="display: none;">2B</span></div><div>Return if the character at the location of the current input buffer pointer in Register A is a <span class="code">+</span></div></div>
									<div class="assembly-row-combined"><div>0EBA</div><div>DEC HL<span class="opcode2" style="display: none;">C8</span></div><div>If
 we are still here then the first character wasn't a sign, so we are 
going to need to check it for a digit.  Since CHARGET INC's HL, we need 
to DEC HL</div></div>
									<div class="assembly-row-combined"><div>0EBC</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Discard the FINCE return address as we no longer need it ... we are now passing right to it!</div></div>
									<div class="assembly-row-combined" id="0EBDH"><div>0EBC<span class="origrom2" style="display: inline;">FINEC</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H<span class="origrom2" style="display: inline;">CHRGET</span></a><span class="opcode2" style="display: none;">F1</span></div><div>Since
 we need to bump the current input buffer pointer in Register Pair HL 
until it points to the next character, call the EXAMINE NEXT SYMBOL 
routine at RST 10H.<br><br>The RST 10H routine parses the characters 
starting at HL+1 for the first non-SPACE,non-09H,non-0BH character it 
finds.  On exit, Register A will hold that character, and the C FLAG is 
set if its alphabetic, and NC FLAG if its alphanumeric.  All strings 
must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>0EBE-0EC0</div><div><a href="#0F94H" class="memory-link">JP C,0F94H<span class="origrom2" style="display: inline;">JP C,FINEDG</span></a><span class="opcode2" style="display: none;">DA 94 0F</span></div><div>If
 the character at the location of the input buffer pointer in Register A
 is numeric, then JUMP to FINEDG to pack the digit into the exponent</div></div>
									<div class="assembly-row-combined"><div>0EC1</div><div>INC D<span class="opcode2" style="display: none;">14</span></div><div>If
 we didn't JUMP away to FINEDG, then we didn't get a digit, so we need 
to adjust the sign of the exponent again ... to positive by INCrementing
 the value in Register D</div></div>
									<div class="assembly-row-combined"><div>0EC2-0EC3</div><div><a href="#0EC7H" class="memory-link">JR NZ,0EC7H<span class="origrom2" style="display: inline;">JR NZ,FINE</span></a><span class="opcode2" style="display: none;">20 03</span></div><div>So long as the exponent isn't a ZERO, JUMP to FINE to skip over the handling of a negative exponent</div></div>
									<div class="assembly-row-combined"><div>0EC4</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>If we are here, then the exponent is negative.  Zero Register A</div></div>
									<div class="assembly-row-combined"><div>0EC5</div><div>SUB E<span class="opcode2" style="display: none;">93</span></div><div>NEGate the value of the exponent in Register E (i.e., A = 0 - E)</div></div>
									<div class="assembly-row-combined"><div>0EC6</div><div>LD E,A<span class="opcode2" style="display: none;">5F</span></div><div>Load Register E with the negated version of itself</div></div>
									<div class="assembly-row-combined"><div>0EC7<span class="origrom2" style="display: inline;">FINE</span></div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the current input buffer pointer to the string being converted (tracked in Register Pair HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>0EC8</div><div>LD A,E<span class="opcode2" style="display: none;">7B</span></div><div>Load Register A with the value of the exponent in Register E</div></div>
									<div class="assembly-row-combined"><div>0EC9</div><div>SUB B<span class="opcode2" style="display: none;">90</span></div><div>Subtract the value in Register B from the exponent in Register A to get the number of times we have to multiply or divide by 10</div></div>
									<p class="debug-note" id="0ECAH">This "FINE2" routine will multiply or divide by 10 the correct number of times.  If A=0 the number is an integer.</p>
									<div class="assembly-row-combined"><div>0ECA-0ECC<span class="origrom2" style="display: inline;">FINE2</span></div><div><a href="#0F0AH" class="memory-link">CALL P,0F0AH<span class="origrom2" style="display: inline;">CALL P,FINMLT</span></a><span class="opcode2" style="display: none;">F4 0A 0F</span></div><div>If the P FLAG is set, then we need to multiply.  So multiply the current value by ten</div></div>
									<div class="assembly-row-combined"><div>0ECD-0ECF</div><div><a href="#0F18H" class="memory-link">CALL M,0F18H<span class="origrom2" style="display: inline;">CALL M,FINDIV</span></a><span class="opcode2" style="display: none;">FC 18 0F</span></div><div>If the M FLAG is set, then we need to divide.  So multiply the current value by ten</div></div>
									<div class="assembly-row-combined"><div>0ED0-0ED1</div><div><a href="#0ECAH" class="memory-link">JR NZ,0ECAH<span class="origrom2" style="display: inline;">JR NZ,FINE2</span></a><span class="opcode2" style="display: none;">20 F8</span></div><div>Whichever
 of those two routines applied, if they returned a NZ then we need to do
 it again ... so Loop until the value is adjusted correctly</div></div>
									<p class="debug-note">Next we need to put the correct sign on the number.</p>
									<div class="assembly-row-combined"><div>0ED2</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the value of the current input buffer pointer of the string being parsed from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0ED3</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the sign value from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>0ED4</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the value of the current input buffer pointer of the string being parsed in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0ED5-0ED7</div><div><a href="#097BH" class="memory-link">CALL Z,097BH<span class="origrom2" style="display: inline;">CALL Z,VNEG</span></a><span class="opcode2" style="display: none;">CC 7B 09</span></div><div>If the Z FLAG is set, then convert the current value to negative</div></div>
									<div class="assembly-row-combined"><div>0ED8</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the value of the current input buffer pointer of the string being parsed from the STACK and put it in Register Pair HL</div></div>
									<p class="debug-note">Next we want -32768 to be an integer (it would be single precision at this point)</p>
									<div class="assembly-row-combined"><div>0ED9</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H<span class="origrom2" style="display: inline;">GETYPE</span></a><span class="opcode2" style="display: none;">E7</span></div><div>We
 need to check the value of the current number type flag, so we call the
 TEST DATA MODE routine at RST 20H which determines the type of the 
current value in the ACCumulator and returns a combination of STATUS 
flags and unique numeric values in the register A according to the data 
mode flag (40AFH).  The results are returned as follows:<br><br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>0EDA</div><div>RET PE<span class="opcode2" style="display: none;">E8</span></div><div>If that test shows we have anything other than a SINGLE PRECISION number, then we do no thave -32678, so RETurn</div></div>
									<div class="assembly-row-combined"><div>0EDB</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>If
 we are here, then we have a single preciosin number.  Save the value of
 the current input buffer pointer of the string being parsed in Register
 Pair HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>0EDC-0EDE</div><div>LD HL,0890H<span class="origrom2" style="display: inline;">LD HL,POPHRT</span><span class="opcode2" style="display: none;">21 90 08</span></div><div>Load Register Pair HL with the return address of the POPHRT routine because CONIS2 does funny things to the stack.</div></div>
									<div class="assembly-row-combined"><div>0EDF</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the value of the return address in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0EE0-0EE2</div><div><a href="#0AA3H" class="memory-link">CALL 0AA3H<span class="origrom2" style="display: inline;">CALL CONIS2</span></a><span class="opcode2" style="display: none;">CD A3 0A</span></div><div>Check
 to see if we have -32768 via a GOSUB to CONIS2 which will convert the 
current value in the ACCumulator to an integer if possible</div></div>
									<div class="assembly-row-combined"><div>0EE3</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer.  If we didn't have -32768 then this will RETurn to POPHRT</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0EE4H">0EE4 - Math Routine<span class="origrom">- "FINDP"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine checks to see if we have seen TWO decimal points
 and to set the decimal point flag.  We jumped here when we found a 
single decimal point.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0EE4<span class="origrom2" style="display: inline;">FINDP</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H<span class="origrom2" style="display: inline;">GETYPE</span></a><span class="opcode2" style="display: none;">E7</span></div><div>We
 need to check the value of the current number type flag, so we call the
 TEST DATA MODE routine at RST 20H which determines the type of the 
current value in the ACCumulator and returns a combination of STATUS 
flags and unique numeric values in the register A according to the data 
mode flag (40AFH).  The results are returned as follows:<br><br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>0EE5</div><div>INC C<span class="opcode2" style="display: none;">0C</span></div><div>Increment the value in Register C to adjust the flag</div></div>
									<div class="assembly-row-combined"><div>0EE6-0EE7</div><div><a href="#0EC7H" class="memory-link">JR NZ,0EC7H<span class="origrom2" style="display: inline;">JR NZ,FINE</span></a><span class="opcode2" style="display: none;">20 DF</span></div><div>If the INC C is NOT ZERO then we have 2 decimal points, so we are DONE.</div></div>
									<div class="assembly-row-combined"><div>0EE8-0EEA</div><div><a href="#0EFBH" class="memory-link">CALL C,0EFBH<span class="origrom2" style="display: inline;">CALL C,FINFRC</span></a><span class="opcode2" style="display: none;">DC FB 0E</span></div><div>If
 we are still here, then we have 1 decimal point, so convert the 
ACCumulator to single prevision via a GOSUB to 0EFBH to convert the 
current value in the ACCumulator to single precision</div></div>
									<div class="assembly-row-combined"><div>0EEB-0EED</div><div><a href="#0E83H" class="memory-link">JP 0E83H<span class="origrom2" style="display: inline;">JP FINC</span></a><span class="opcode2" style="display: none;">C3 83 0E</span></div><div>Jump to 0E83H to continue looking for digits</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0EEEH">0EEE - Math Routine<span class="origrom">- "FININT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0EEE<span class="origrom2" style="display: inline;">FININT</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H<span class="origrom2" style="display: inline;">GETYPE</span></a><span class="opcode2" style="display: none;">E7</span></div><div>We
 need to check the value of the current number type flag, so we call the
 TEST DATA MODE routine at RST 20H which determines the type of the 
current value in the ACCumulator and returns a combination of STATUS 
flags and unique numeric values in the register A according to the data 
mode flag (40AFH).  The results are returned as follows:<br><br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>0EEF-0EF1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1997H" class="memory-link">JP P,1997H<span class="origrom2" style="display: inline;">JP P,SNERR</span></a><span class="opcode2" style="display: none;">F2 97 19</span></div><div>If that test shows anything but an INTEGER, jump to the Level II BASIC error routine and display a ?SN ERROR message</div></div>
									<div class="assembly-row-combined"><div>0EF2<span class="origrom2" style="display: inline;">INFINE</span></div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Top of a loop.  If we are here, then we have something other than a single precision number.  Next we move past the <span class="code">%</span>character
 at the input buffer pointer to the sting being processed (tracked in 
Register Pair HL).  We know this is the last character (a trailing %).</div></div>
									<div class="assembly-row-combined"><div>0EF3-0EF4</div><div><a href="#0EC7H" class="memory-link">JR 0EC7H<span class="origrom2" style="display: inline;">JR FINE</span></a><span class="opcode2" style="display: none;">18 D2</span></div><div>We are now done, so Jump to 0EC7H to finish.</div></div>
									<div class="assembly-row-combined"><div>0EF5<span class="origrom2" style="display: inline;">FINDBF</span></div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>If we are here then we need to force double precision, so set the NZ FLAG</div></div>
									<div class="assembly-row-combined"><div>0EF6-0EF8<span class="origrom2" style="display: inline;">FINSNF</span></div><div><a href="#0EFBH" class="memory-link">CALL 0EFBH<span class="origrom2" style="display: inline;">CALL FINFRC</span></a><span class="opcode2" style="display: none;">CD FB 0E</span></div><div>Force
 a type conversion via a GOSUB to FINFRC to convert the current value in
 the ACCumulator to either single precision or double precision, based 
on the concents of Register A (Z=Force to Single or NZ=Force to Double)</div></div>
									<div class="assembly-row-combined"><div>0EF9-0EFA</div><div><a href="#0EF2H" class="memory-link">JR 0EF2H<span class="origrom2" style="display: inline;">JR INFINE</span></a><span class="opcode2" style="display: none;">18 F7</span></div><div>Bump the pointer in HL and go to FINE via a JUMP to INFINE</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0EFBH">0EFB - Math Routine<span class="origrom">- "FINFRC"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will force the ACCumulator to be either single 
precision or double precision based on the Z FLAG.  Z FLAG = Force to 
single precision; NZ FLAG = Force to double precision.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0EFB<span class="origrom2" style="display: inline;">FINFRC</span></div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the value of the current input buffer pointer of the string being parsed in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0EFC</div><div>PUSH DE<span class="opcode2" style="display: none;">D5</span></div><div>Save the exponent (held in Register Pair DE) to the STACK</div></div>
									<div class="assembly-row-combined"><div>0EFD</div><div>PUSH BC<span class="opcode2" style="display: none;">C5</span></div><div>Save the decimal point information (held in Register Pair BC) to the STACK</div></div>
									<div class="assembly-row-combined"><div>0EFE</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the sp/dp value flag for the conversion (held in Register A) to the STACK</div></div>
									<div class="assembly-row-combined" id="0F00H"><div>0EFF-0F01</div><div><a href="#0AB1H" class="memory-link">CALL Z,0AB1H<span class="origrom2" style="display: inline;">CALL Z,FRCSNG</span></a><span class="opcode2" style="display: none;">CC B1 0A</span></div><div>If
 the Z FLAG is set, call the CONVERT TO SINGLE PRECISION routine at 
0AB1H (which converts the contents of ACCumulator from integer or double
 precision into single precision)</div></div>
									<div class="assembly-row-combined"><div>0F02</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Restore the sp/dp value flag for the conversion from the STACK and put it in Register Pair AF</div></div>
									<div class="assembly-row-combined"><div>0F03-0F05</div><div><a href="#0ADBH" class="memory-link">CALL NZ,0ADBH<span class="origrom2" style="display: inline;">CALL NZ,FRCDBL</span></a><span class="opcode2" style="display: none;">C4 DB 0A</span></div><div>If
 the NZ FLAG is set, Call the CONVERT TO DOUBLE PRECISION routine at 
0ADBH (where the contents of ACCumulator are converted from integer or 
single precision to double precision)</div></div>
									<div class="assembly-row-combined"><div>0F06</div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>Restore the decimal point information from the STACK and put it in Register Pair BC</div></div>
									<div class="assembly-row-combined"><div>0F07</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Restore the exponent from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0F08</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Restore the value of the current input buffer pointer of the string being parsed from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0F09</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0EE4H">0EE4 - Math Routine<span class="origrom">- "FINMUL" and "FINMLT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This subroutine multiplies a number by 10 once.  The original
 ROM source notes that the reason this is a subroutine is that it can 
also double as a check to see if A is ZERO, thus saving bytes.   All 
registers are affected.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0F0A<span class="origrom2" style="display: inline;">FINMUL</span></div><div>RET Z<span class="opcode2" style="display: none;">C8</span></div><div>If the exponent is ZERO then exit right back out</div></div>
									<div class="assembly-row-combined"><div>0F0B<span class="origrom2" style="display: inline;">FINMLT</span></div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the exponent (held in Register Pair AF) to the STACK.  FOUT enters the routine here.</div></div>
									<div class="assembly-row-combined"><div>0F0C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H<span class="origrom2" style="display: inline;">GETYPE</span></a><span class="opcode2" style="display: none;">E7</span></div><div>We
 need to check the value of the current number type flag, so we call the
 TEST DATA MODE routine at RST 20H which determines the type of the 
current value in the ACCumulator and returns a combination of STATUS 
flags and unique numeric values in the register A according to the data 
mode flag (40AFH).  The results are returned as follows:<br><br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>0F0D</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save exponent and the value type from AF to the STACK</div></div>
									<div class="assembly-row-combined"><div>0F0E-0F10</div><div><a href="#093EH" class="memory-link">CALL PO,093EH<span class="origrom2" style="display: inline;">CALL PO,MUL10</span></a><span class="opcode2" style="display: none;">E4 3E 09</span></div><div>If that test shows SINGLE PRECISION, go to 093EH to multiply the current value in the ACCumulator by "10.0"</div></div>
									<div class="assembly-row-combined"><div>0F11</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the exponent and the value type from the STACK back into AF</div></div>
									<div class="assembly-row-combined"><div>0F12-0F14</div><div><a href="#0E4DH" class="memory-link">CALL PE,0E4DH<span class="origrom2" style="display: inline;">CALL PE,DMUL10</span></a><span class="opcode2" style="display: none;">EC 4D 0E</span></div><div>If that test shows DOUBLE PRECISION, go to 0E4DH to multiply the current value in the ACCumulator by "10D0"</div></div>
									<div class="assembly-row-combined"><div>0F15</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the exponent and the value type from the STACK and put it in Register Pair AF</div></div>
									<div class="assembly-row-combined"><div>0F16<span class="origrom2" style="display: inline;">DCRART</span></div><div>DEC A<span class="opcode2" style="display: none;">3D</span></div><div>Decrement the exponent (held in Register A) since we have now multiplied by 1 since (x^10 = 10x^9).</div></div>
									<div class="assembly-row-combined"><div>0F17</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0F18H">0F18 - Math Routine<span class="origrom">- "FINDIV"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This subroutine divides a number by 10 once.  FIN and FOUT use this routine.  Registers A, B, and C are affected.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0F18<span class="origrom2" style="display: inline;">FINDIV</span></div><div>PUSH DE<span class="opcode2" style="display: none;">D5</span></div><div>Preserve DE to the STACK for POPing at the end</div></div>
									<div class="assembly-row-combined"><div>0F19</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Preserve HL to the STACK for POPing at the end</div></div>
									<div class="assembly-row-combined"><div>0F1A</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Since we need to divide we need to preserve the exponent, so save the value in Register A on the STACK</div></div>
									<div class="assembly-row-combined"><div>0F1B</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H<span class="origrom2" style="display: inline;">GETYPE</span></a><span class="opcode2" style="display: none;">E7</span></div><div>We
 need to check the value of the current number type flag, so we call the
 TEST DATA MODE routine at RST 20H which determines the type of the 
current value in the ACCumulator and returns a combination of STATUS 
flags and unique numeric values in the register A according to the data 
mode flag (40AFH).  The results are returned as follows:<br><br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>0F1C</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the value of the FLAGS from the RST 20H call to the STACK</div></div>
									<div class="assembly-row-combined"><div>0F1D-0F1F</div><div><a href="#0897H" class="memory-link">CALL PO,0897H<span class="origrom2" style="display: inline;">CALL PO,DIV10</span></a><span class="opcode2" style="display: none;">E4 97 08</span></div><div>If that test shows SINGLE PRECISION, go to 0897H to divide the current value in the ACCumulator by "10.0"</div></div>
									<div class="assembly-row-combined"><div>0F20</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the value from the STACK and put it in Register Pair AF</div></div>
									<div class="assembly-row-combined"><div>0F21-0F23</div><div><a href="#0DDCH" class="memory-link">CALL PE,0DDCH<span class="origrom2" style="display: inline;">CALL PE,DDIV10</span></a><span class="opcode2" style="display: none;">EC DC 0D</span></div><div>If that test shows DOUBLE PRECISION, go to 0DDCH to divide the current value in the ACCumulator by "10D0"</div></div>
									<div class="assembly-row-combined"><div>0F24</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Restore the flags from the STACK and put it in Register Pair F</div></div>
									<div class="assembly-row-combined"><div>0F25</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the value from the STACK and put it in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0F26</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Get the value from the STACK and put it in Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>0F27</div><div>INC A<span class="opcode2" style="display: none;">3C</span></div><div>Increment the exponent (stored in Register A) since 10x^9 = x^10</div></div>
									<div class="assembly-row-combined"><div>0F28</div><div>RET<span class="opcode2" style="display: none;">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0F29H">0F29 - Math Routine<span class="origrom">- "FINDIG"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will pack the next digit of the number into the 
ACCumulator.  To do this, the ACCumulator is multipled by ten to shift 
everything over and make room for the digit, and then the digit is added
 in.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0F29<span class="origrom2" style="display: inline;">FINDIG</span></div><div>PUSH DE<span class="opcode2" style="display: none;">D5</span></div><div>Save the exponent (held in Register Pair DE) on the STACK</div></div>
									<div class="assembly-row-combined"><div>0F2A</div><div>LD A,B<span class="opcode2" style="display: none;">78</span></div><div>We need to check where the decimal point is, so load Register A with the value in Register B</div></div>
									<div class="assembly-row-combined"><div>0F2B</div><div>ADC A,C<span class="opcode2" style="display: none;">89</span></div><div>Increement the decimal place count if we are past the decimal point by adding the value in Register C to the value in Register A</div></div>
									<div class="assembly-row-combined"><div>0F2C</div><div>LD B,A<span class="opcode2" style="display: none;">47</span></div><div>Save the revised decimal point location (tracked in Register B)</div></div>
									<div class="assembly-row-combined"><div>0F2D</div><div>PUSH BC<span class="opcode2" style="display: none;">C5</span></div><div>Save the decimal point information (tracked in Register Pair BC) on the STACK</div></div>
									<div class="assembly-row-combined"><div>0F2E</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the value of the current input buffer pointer of the string being parsed in Register Pair HL on the STACK</div></div>
									<div class="assembly-row-combined"><div>0F2F</div><div>LD A,(HL)<span class="opcode2" style="display: none;">7E</span></div><div>Fetch the digit we want to pack at the location of the current input buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0F30-0F31</div><div>SUB 30H<span class="origrom2" style="display: inline;">SUB "0"</span><span class="opcode2" style="display: none;">D6 30</span></div><div>Subtract 30H from the ASCII value in Register A so that it will be binary</div></div>
									<div class="assembly-row-combined"><div>0F32</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the adjusted value in the digit (held in Register A) to the STACK</div></div>
									<div class="assembly-row-combined"><div>0F33</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H<span class="origrom2" style="display: inline;">GETYPE</span></a><span class="opcode2" style="display: none;">E7</span></div><div>We
 need to check the value of the current number type flag, so we call the
 TEST DATA MODE routine at RST 20H which determines the type of the 
current value in the ACCumulator and returns a combination of STATUS 
flags and unique numeric values in the register A according to the data 
mode flag (40AFH).  The results are returned as follows:<br><br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>0F34-0FJ6</div><div><a href="#0F5DH" class="memory-link">JP P,0F5DH<span class="origrom2" style="display: inline;">JP P,FINDGV</span></a><span class="opcode2" style="display: none;">F2 5D 0F</span></div><div>If
 that test shows we have anything but an INTEGER, jump to FINDGV to 
handle the cases of a a single precision or double precision number</div></div>
									<p class="debug-note">If we are here, then we re packing the next digit of an integer.</p>
									<div class="assembly-row-combined"><div>0F37-0FJ9</div><div>LD HL,(4121H)<span class="origrom2" style="display: inline;">LD HL,(FACLO)</span><span class="opcode2" style="display: none;">2A 21 41</span></div><div>Now that we know we have an integer, put it into the ACCumulator at (HL)</div></div>
									<div class="assembly-row-combined"><div>0F3A-0FJC</div><div>LD DE,0CCDH<span class="opcode2" style="display: none;">11 CD 0C</span></div><div>Load Register Pair DE with 3277 to see if we will overflow</div></div>
									<div class="assembly-row-combined"><div>0F3D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H<span class="origrom2" style="display: inline;">COMPAR</span></a><span class="opcode2" style="display: none;">DF</span></div><div>Now
 we need to check to see if the integer value in HL is greater than or 
equal to 0CCDH (in DE), so we call the COMPARE DE:HL routine, which 
numerically compares DE and HL. Will not work for signed integers 
(except positive ones). Uses the A-register only. The result of the 
comparison is returned in the status Register As:  <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>0F3E-0F3F</div><div><a href="#0F59H" class="memory-link">JR NC,0F59H<span class="origrom2" style="display: inline;">JR NC,FINDG2</span></a><span class="opcode2" style="display: none;">30 19</span></div><div>If
 the NC FLAG is set then HL (the number we are working on) &gt; DE (an 
overflow value), so the number is too big.  JUMP to FING2</div></div>
									<div class="assembly-row-combined"><div>0F40<br>0F41</div><div>LD D,H<br>LD E,L<span class="opcode2" style="display: none;">54</span></div><div>Let DE = HL</div></div>
									<div class="assembly-row-combined"><div>0F42</div><div>ADD HL,HL<span class="opcode2" style="display: none;">29</span></div><div>Multiply the integer value in Register Pair HL by two</div></div>
									<div class="assembly-row-combined"><div>0F43</div><div>ADD HL,HL<span class="opcode2" style="display: none;">29</span></div><div>Multiply the integer value in Register Pair HL by two. Register Pair HL now holds the original integer value times four</div></div>
									<div class="assembly-row-combined"><div>0F44</div><div>ADD HL,DE<span class="opcode2" style="display: none;">19</span></div><div>Add
 the original integer value in Register Pair DE to the integer value in 
Register Pair HL. Register Pair HL now holds the original integer value 
times five</div></div>
									<div class="assembly-row-combined"><div>0F45</div><div>ADD HL,HL<span class="opcode2" style="display: none;">29</span></div><div>Multiply the integer value in Register Pair HL by two. Register Pair HL now holds the origmal integer value times ten</div></div>
									<p class="debug-note">At this point, the number has shifted over to make room for the new digit in the ones place.</p>
									<div class="assembly-row-combined"><div>0F46</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the binary value for the number we want to pack in from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>0F47</div><div>LD C,A<span class="opcode2" style="display: none;">4F</span></div><div>Load Register C with the value of the character in Register A.  Why C?  The DAD routine needs it there and B is already zero.</div></div>
									<div class="assembly-row-combined" id="0F48H"><div>0F48</div><div>ADD HL,BC<span class="opcode2" style="display: none;">09</span></div><div>Add the value of the character in Register Pair BC to the newly shifted integer value in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0F49</div><div>LD A,H<span class="opcode2" style="display: none;">7C</span></div><div>We next need to test for an overflow, so load Register A with the MSB of the integer value in Register H</div></div>
									<div class="assembly-row-combined"><div>0F4A</div><div>OR A<span class="opcode2" style="display: none;">B7</span></div><div>Set the flags based on the MSB</div></div>
									<div class="assembly-row-combined"><div>0F4B-0F4D</div><div><a href="#0F57H" class="memory-link">JP M,0F57H<span class="origrom2" style="display: inline;">JP M,FINDG1</span></a><span class="opcode2" style="display: none;">FA 57 0F</span></div><div>If the M FLAG is set, then we have overflowed, so JUMP to FINDG1</div></div>
									<div class="assembly-row-combined"><div>0F4E-0F50</div><div>LD (4121H),HL<span class="origrom2" style="display: inline;">LD (FACLO),HL</span><span class="opcode2" style="display: none;">22 21 41</span></div><div>If we are here, then we did not overflow so save the new integer back into the ACCumulator</div></div>
									<div class="assembly-row-combined" id="0F51H"><div>0F51<span class="origrom2" style="display: inline;">FINDGE</span></div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Restore the value of the current input buffer pointer of the string being parsed into Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0F52</div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>Restore the the decimal point information (tracked in Register Pair BC) from the STACK</div></div>
									<div class="assembly-row-combined"><div>0F53</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Restore the exponent (held in Register Pair DE) from the STACK</div></div>
									<div class="assembly-row-combined"><div>0F54-0F56</div><div><a href="#0E83H" class="memory-link">JP 0E83H<span class="origrom2" style="display: inline;">JP FINC</span></a><span class="opcode2" style="display: none;">C3 83 0E</span></div><div>Jump to 0E83H to process the next character</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0F57H">0F57 - Math Routine<span class="origrom">- "FINDG1"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine handles 32768 and 32769</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0F57<span class="origrom2" style="display: inline;">FINDG1</span></div><div>LD A,C<span class="opcode2" style="display: none;">79</span></div><div>Load Register A with the binary value of the character in Register C</div></div>
									<div class="assembly-row-combined"><div>0F58</div><div>PUSH AF<span class="opcode2" style="display: none;">F5</span></div><div>Save the value in Register A on the STACK</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0F59H">0F59 - Math Routine<span class="origrom">- "FINDG2"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Convert integer digits into single precision digits</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0F59-0F5B<span class="origrom2" style="display: inline;">FINDG2</span></div><div><a href="#0ACCH" class="memory-link">CALL 0ACCH<span class="origrom2" style="display: inline;">CALL CONSI</span></a><span class="opcode2" style="display: none;">CD CC 0A</span></div><div>Go convert the current value in the ACCumulator to single precision</div></div>
									<div class="assembly-row-combined"><div>0F5C</div><div>SCF<span class="opcode2" style="display: none;">37</span></div><div>Set the Carry flag to avoid the next instruction jumping away</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0F5DH">0F5D - Math Routine<span class="origrom">- "FINDGV"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Determine if we have a single precision or a double prevision number</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0F5D-0F5E<span class="origrom2" style="display: inline;">FINDGV</span></div><div><a href="#0F77H" class="memory-link">JR NC,0F77H<span class="origrom2" style="display: inline;">JR NC,FINDGD</span></a><span class="opcode2" style="display: none;">30 18</span></div><div>If
 the current value in the ACCumulator is double precision, then JUMP to 
FINGD to use the double precision routine to pack in the next digit</div></div>
									<p class="debug-note">These next 2 instruction set up BCDE to hold "1000000"</p>
									<div class="assembly-row-combined"><div>0F5F-0F61</div><div>LD BC,9474H<span class="opcode2" style="display: none;">01 74 94</span></div><div>Load Register Pair BC with the exponent and the MSB of a single precision constant</div></div>
									<div class="assembly-row-combined"><div>0F62-0F64</div><div>LD DE,2400H<span class="opcode2" style="display: none;">11 00 24</span></div><div>Load
 Register Pair DE with the NMSB and the LSB of a single precision 
constant. Register Pairs BC and DE now hold a single precision constant 
equal to 1E6</div></div>
									<div class="assembly-row-combined"><div>0F65-0F67</div><div><a href="#0A0CH" class="memory-link">CALL 0A0CH<span class="origrom2" style="display: inline;">CALL FCOMP</span></a><span class="opcode2" style="display: none;">CD 0C 0A</span></div><div>Call
 the SINGLE PRECISION COMPARISON routine at 0A0CH to algebraically 
compare the single precision value in BC/DE (which is 1000000) to the 
single precision value ACCumulator.  The results are stored in A as 
follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Register A</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator = BCDE</td><td style="border: 1px solid black; padding: 8px;">00</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator &gt; BCDE</td><td style="border: 1px solid black; padding: 8px;">01</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator &lt; BCDE</td><td style="border: 1px solid black; padding: 8px;">FF</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>0F68-0F6A</div><div><a href="#0F74H" class="memory-link">JP P,0F74H<span class="origrom2" style="display: inline;">JP P,FINDG3</span></a><span class="opcode2" style="display: none;">F2 74 0F</span></div><div>If
 the single precision value in the ACCumulator is greater than or equal 
to 1000000 then we need to change from single precision to double 
precision, so JUMP to FINDG3 to covert the number to double precision.</div></div>
									<div class="assembly-row-combined"><div>0F6B-0F6D</div><div><a href="#093EH" class="memory-link">CALL 093EH<span class="origrom2" style="display: inline;">CALL MUL10</span></a><span class="opcode2" style="display: none;">CD 3E 09</span></div><div>Go multiply the single precision value in the ACCumulator by 10</div></div>
									<div class="assembly-row-combined"><div>0F6E</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the binary value of the number we want to pack in from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>0F6F-0F71</div><div><a href="#0F89H" class="memory-link">CALL 0F89H<span class="origrom2" style="display: inline;">CALL FINLOG</span></a><span class="opcode2" style="display: none;">CD 89 0F</span></div><div>Add the value in Register A to the single precision value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0F72-0F33</div><div><a href="#0F51H" class="memory-link">JR 0F51H<span class="origrom2" style="display: inline;">JR FINDGE</span></a><span class="opcode2" style="display: none;">18 DD</span></div><div>Jump to 0F51H to get the flags off of the stack and finish.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0F74H">0F74 - Math Routine<span class="origrom">- "FINDG3" and "FINDGD"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The routine will convert a 7 digit single precision number into a double precision number</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0F74-0F76<span class="origrom2" style="display: inline;">FINDG3</span></div><div><a href="#0AE3H" class="memory-link">CALL 0AE3H<span class="origrom2" style="display: inline;">CALL CONDS</span></a><span class="opcode2" style="display: none;">CD E3 0A</span></div><div>Go convert the single precision value in the ACCumulator to double precision</div></div>
									<p class="debug-note">This routine will pack in a digit into a double precision number</p>
									<div class="assembly-row-combined"><div>0F77-0F79<span class="origrom2" style="display: inline;">FINDGD</span></div><div><a href="#0E4DH" class="memory-link">CALL 0E4DH<span class="origrom2" style="display: inline;">CALL DMUL10</span></a><span class="opcode2" style="display: none;">CD 4D 0E</span></div><div>Go multiply the double precision value in the ACCumulator by ten</div></div>
									<div class="assembly-row-combined"><div>0F7A-0F7C</div><div><a href="#09FCH" class="memory-link">CALL 09FCH<span class="origrom2" style="display: inline;">CALL VMOVAF</span></a><span class="opcode2" style="display: none;">CD FC 09</span></div><div>Go move the double precision value in the ACCumulator to ARG (a/k/a REG 2)</div></div>
									<div class="assembly-row-combined"><div>0F7D</div><div>POP AF<span class="opcode2" style="display: none;">F1</span></div><div>Get the binary value for the number to pack in from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>0F7E-0F80</div><div><a href="#0964H" class="memory-link">CALL 0964H<span class="origrom2" style="display: inline;">CALL FLOAT</span></a><span class="opcode2" style="display: none;">CD 64 09</span></div><div>Go convert that binary value to single precision</div></div>
									<div class="assembly-row-combined"><div>0F81-0F83</div><div><a href="#0AE3H" class="memory-link">CALL 0AE3H<span class="origrom2" style="display: inline;">CALL CONDS</span></a><span class="opcode2" style="display: none;">CD E3 0A</span></div><div>Go convert that single precision value to double precision</div></div>
									<div class="assembly-row-combined"><div>0F84-0F86</div><div><a href="#0C77H" class="memory-link">CALL 0C77H<span class="origrom2" style="display: inline;">CALL DADD</span></a><span class="opcode2" style="display: none;">CD 77 0C</span></div><div>Call
 the DOUBLE PRECISION ADD function (whcih adds the double precision 
value in ARG (a/k/a REG 2) to the value in the ACCumulator.  Result is 
left in the ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>0F87-0F88</div><div><a href="#0F51H" class="memory-link">JR 0F51H<span class="origrom2" style="display: inline;">JR FINDGE</span></a><span class="opcode2" style="display: none;">18 C8</span></div><div>Jump to 0F51H to get the flags off of the stack and finish.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0F89H">0F89H-0F93H - SINGLE PRECISION MATH ROUTINE<span class="origrom">- "FINLOG"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is a subroutine for FIN and for LOG</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0F89-0F8B<span class="origrom2" style="display: inline;">FINLOG</span></div><div><a href="#09A4H" class="memory-link">CALL 09A4H<span class="origrom2" style="display: inline;">CALL PUSHF</span></a><span class="opcode2" style="display: none;">CD A4 09</span></div><div>Call 09A4 which moves the SINGLE PRECISION value in the ACCumulator to the STACK (stored in LSB/MSB/Exponent order)</div></div>
									<div class="assembly-row-combined"><div>0F8C-0F8E</div><div><a href="#0964H" class="memory-link">CALL 0964H<span class="origrom2" style="display: inline;">CALL FLOAT</span></a><span class="opcode2" style="display: none;">CD 64 09</span></div><div>Go convert the value in Register A to a single precision floating number and return with the result in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0F8F</div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>Clear off the stack</div></div>
									<div class="assembly-row-combined"><div>0F90</div><div>POP DE<span class="opcode2" style="display: none;">D1</span></div><div>Clear off the stack</div></div>
									<div class="assembly-row-combined"><div>0F91-0F93</div><div><a href="#0716H" class="memory-link">JP 0716H<span class="origrom2" style="display: inline;">JP FADD</span></a><span class="opcode2" style="display: none;">C3 16 07</span></div><div>Jump
 to the SINGLE PRECISION ADD routine at 0716H (which adds the single 
precision value in (BC/DE) to the single precision value in the 
ACCumulator. The sum is left in the ACCumulator)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0F94H">0F94H-0FA6H - LEVEL II BASIC MATH ROUTINE<span class="origrom">- "FINEDG"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Pack in a digit of the exponent.  This is done by multiplying
 the old exponent by 10 and then adding in the desired digit.  Note: 
This routine does NOT check for overflow.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0F94<span class="origrom2" style="display: inline;">FINEDG</span></div><div>LD A,E<span class="opcode2" style="display: none;">7B</span></div><div>Load Register A with the value of the exponent in Register E</div></div>
									<div class="assembly-row-combined"><div>0F95-0F96</div><div>CP 0AH<span class="opcode2" style="display: none;">FE 0A</span></div><div>Test
 for overfly by checking to see if the value of the exponent in Register
 A is greater than or equal to 10.  This is necessary because if it 
overflows the Register E will be corrupted</div></div>
									<div class="assembly-row-combined"><div>0F97-0F98</div><div><a href="#0FA2H" class="memory-link">JR NC,0FA2H<span class="origrom2" style="display: inline;">JR NC,FINEDO</span></a><span class="opcode2" style="display: none;">30 09</span></div><div>If
 the value of the exponent in Register A is greater than or equal to 10 
then we already have two digits, so JUMP to FINEDO to keep processing</div></div>
									<div class="assembly-row-combined"><div>0F99</div><div>RLCA<span class="opcode2" style="display: none;">07</span></div><div>Multiply the value in Register A by two</div></div>
									<div class="assembly-row-combined"><div>0F9A</div><div>RLCA<span class="opcode2" style="display: none;">07</span></div><div>Multiply the value in Register A by two. Register A now holds the original value of the exponent times four</div></div>
									<div class="assembly-row-combined"><div>0F9B</div><div>ADD A,E<span class="opcode2" style="display: none;">83</span></div><div>Add the original value of the exponent in Register E to the adjusted value of the exponent in Register A</div></div>
									<div class="assembly-row-combined"><div>0F9C</div><div>RLCA<span class="opcode2" style="display: none;">07</span></div><div>Multiply the value in Register A by two. Register A now holds the original value of the exponent times ten</div></div>
									<div class="assembly-row-combined"><div>0F9D</div><div>ADD A,(HL)<span class="opcode2" style="display: none;">86</span></div><div>Add the value of the number at the location of the input buffer pointer in Register Pair HL to the adjusted value in Register A</div></div>
									<div class="assembly-row-combined"><div>0F9E-0F9F</div><div>SUB 30H<span class="origrom2" style="display: inline;">SUB "0"</span><span class="opcode2" style="display: none;">D6 30</span></div><div>Convert the adjusted value in Register A to it's binary equivalent (which is subtracting 0011 0000)</div></div>
									<div class="assembly-row-combined"><div>0FA0</div><div>LD E,A<span class="opcode2" style="display: none;">5F</span></div><div>Save the adjusted exponent into Register E</div></div>
									<div class="assembly-row-combined"><div>0FA1-0FA3</div><div>JP M,321EH<span class="opcode2" style="display: none;">FA 1E 32</span></div><div>Z-80 TRICK.  If passing through, this will never trigger, but neither will the next instruction!</div></div>
									<div class="assembly-row-combined"><div>0FA2-0FA3<span class="origrom2" style="display: inline;">FINEDO</span></div><div>LD E,32H<span class="opcode2" style="display: none;">1E 32</span></div><div>If
 JUMPed here, E will be reset (from Register A's value) to 50 Decimal, 
which, as an exponent, will SAFELY cause an overflow or underflow.  If 
passing through, this will not be seen</div></div>
									<div class="assembly-row-combined"><div>0FA4-0FA6</div><div><a href="#0EBDH" class="memory-link">JP 0EBDH<span class="origrom2" style="display: inline;">JP FINEC</span></a><span class="opcode2" style="display: none;">C3 BD 0E</span></div><div>Jump to 0EBDH to continue the routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0FA7H">0FA7H-0FAEH - DISPLAY MESSAGE ROUTINE<span class="origrom">- "INPRT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine is to output a floating point number.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0FA7<span class="origrom2" style="display: inline;">INPRT</span></div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the line number (held in Register Pair HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>0FA8-0FAA</div><div>LD HL,1924H<span class="origrom2" style="display: inline;">LD HL,INTXT</span><span class="opcode2" style="display: none;">21 24 19</span></div><div>Load Register Pair HL with the starting address of the " IN " +00H message (which is 1924H)</div></div>
									<div class="assembly-row-combined"><div>0FAB-0FAD</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#28A7H" class="memory-link">CALL 28A7H<span class="origrom2" style="display: inline;">CALL STROUT</span></a><span class="opcode2" style="display: none;">CD A7 28</span></div><div>Call the WRITE MESSAGE routine at 28A7H..<br><span class="bold">NOTE:</span><br><ul><li>The routine at 28A7 displays the message pointed to by HL on current system output device (usually video).</li><li>The string to be displayed must be terminated by a byte of machine zeros or a carriage return code 0D.</li><li>If terminated with a carriage return, control is returned to the caller after taking the DOS exit at 41D0H (JP 5B99H).</li></ul></div></div>
									<div class="assembly-row-combined"><div>0FAE</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Get the value from the STACK and put it in Register Pair HL and then pass through to the LINPRT routine.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0FAFH">0FAFH-0FBCH - CONVERT BINARY TO ASCII AND DISPLAY RESULT<span class="origrom">- "LINPRT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine converts the two byte number in the HL Register 
Pair (which is assumed to be an integer) to ASCII and displays it at the
 current cursor position on the video screen.  The space for the sign at
 the beginning of a line is removed.  All registers are affected.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0FAF-0FB1<span class="origrom2" style="display: inline;">LINPRT</span></div><div><a href="#0A9AH" class="memory-link">CALL 0A9AH<span class="origrom2" style="display: inline;">CALL MAKINT</span></a><span class="opcode2" style="display: none;">CD 9A 0A</span></div><div>Go save the line number (held in the ACCumulator) as an integer into Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0FB2</div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A to indicate that the output should be a free format</div></div>
									<div class="assembly-row-combined"><div>0FB3-0FB5</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1034H" class="memory-link">CALL 1034H<span class="origrom2" style="display: inline;">CALL FOUINI</span></a><span class="opcode2" style="display: none;">CD 34 10</span></div><div>Go initialize the input buffer for the ASCII conversion.  This will set up the sign.</div></div>
									<div class="assembly-row-combined"><div>0FB6</div><div>OR (HL)<span class="opcode2" style="display: none;">B6</span></div><div>Turn off the Z FLAG.</div></div>
									<div class="assembly-row-combined"><div>0FB7-0FB9</div><div><a href="#0FD9H" class="memory-link">CALL 0FD9H<span class="origrom2" style="display: inline;">CALL FOUT2</span></a><span class="opcode2" style="display: none;">CD D9 0F</span></div><div>Go convert the integer value in the ACCumulator to an ASCII string. Return with Register Pair HL pointing to the result</div></div>
									<div class="assembly-row-combined"><div>0FBA-0FBC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#28A6H" class="memory-link">JP 28A6H<span class="origrom2" style="display: inline;">JP STROUI</span></a><span class="opcode2" style="display: none;">C3 A6 28</span></div><div>Go display the message pointed to by Register Pair HL</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0FBDH">0FBDH-1363H - BINARY TO ASCII CONVERSION ROUTINE<span class="origrom">- "FOUT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p><b>According to the original ROM source code:</b><br>This 
routine will output the value held in the ACCumulator according to the 
format specifications held in Registers A, B, and C.  The ACCumulator 
contents are lost and all registers are affected.<br><br>
								The format codes are as follows:</p><ul><li>Register A:<ul><li>Bit 7: <ul><li>0
 means free format output, i.e. the other bits of a must be zero, 
trailing zeros are suppressed, a number is printed in fixed or floating 
point notation according to its magnitude, the number is left justified 
in its field, and Registers B and C are ignored.</li><li>1 means fixed 
format output, i.e. the other bits of a are checked for formatting 
information, the number is right justified in its field, trailing zeros 
are not suppressed.  this is used for print using.</li></ul></li><li>Bit 6: <ul><li>0 means means don't print the number with commas.</li><li>1 means group the digits in the integer part of the number into groups of three and separate the groups by commas.</li></ul></li><li>Bit 5:  1 means fill the leading spaces in the field with asterisks ("*")</li><li>Bit 4:  1 means output the number with a floating dollar sign ("$")</li><li>Bit 3:  1 means print the sign of a positive number as a plus sign ("+") instead of a space</li><li>Bit 2:  1 means print the sign of the number after the number</li><li>Bit 1:  Unused</li><li>Bit 0: <ul><li>1
 means print the number in floating point notation i.e. "e notation".  
If this bit is on, the comma specification (bit 6) is ignored.</li><li>0 means print the number in fixed point notation.  Numbers &gt; 1e16 cannot be printed in fixed point notation.</li></ul></li><li>Register B:  The number of places in the field to the left of the decimal point (B does not include the decimal point)</li><li>Register C:  The number of places in the field to the right of the decimal point (C includes the decimal point)</li><li>Note 1:  B and C do not include the 4 positions for the exponent.  If bit 0 is on FOUT assumes b+c &lt;= 24 (decimal)</li><li>Note
 2:  If the number is too big to fit in the field, a percent sign ("%") 
is printed and the field is extended to hold the number.</li></ul></li></ul><p></p>
								<p><b>According to other sources:</b><br>Conversion routine. 
Converts the value from ACCumulator to an ASCII string delimited with a 
zero byte. The number type can be any of Integer, single or 
double-precision. After execution HL will be pointing to the start of 
the string. ACCumulator and ARG (a/k/a REG 2) are destroyed by the 
process.<br><br>To use a ROM call to convert a number to a string of 
digits, and to display the latter on the video screen starting at the 
current cursor position, store the number in 4121H-4122H (if it's an 
integer), or in 4121H-4124H (if it's single precision), or in 
411DH-4124H (if it's double precision).  Then store the variable type 
(2, 4, or 8, respectively) in 40AFH.  Call 0FBDH and then call the WRITE
 MESSAGE routine at 28A7H. </p><ul><li>NOTE 1: The subroutine at 28A7H 
is a general program for displaying a string of characters and updating 
the cursor position. The string to be displayed must be terminated by a 
zero byte, and the HL Register Pair must contain the address of the 
first character of the string before 28A7H is called. (The routine at 
0FBDH effects this setup automatically.)</li><li>NOTE 2: DISK SYSTEM 
CAUTION: The subroutine at 28A7H has two exits to DISK BASIC, with RAM 
transfer points at 41C1H and 41D0H. To use this routine safely, either 
be certain that DISK BASIC is in place or have your assembly language 
program fill locations 41C1H and 41D0H with RET's (C9H), before calling 
the routine.</li></ul><p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0FBD<span class="origrom2" style="display: inline;">FOUT</span></div><div>XOR A<span class="opcode2" style="display: none;">AF</span></div><div>Zero Register A so that the format is set for free output</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="0FBEH">0FBEH-0FC0H - FLOATING to ASCII Conversion Routine<span class="origrom">- "PUFOUT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine converts a single or double precision number in 
the ACCumulator to its ASCII equivalent.  The ASCII value is stored at 
the buffer pointed to by the HL Register Pair. As the value is converted
 from binary to ASCII, it is formatted as it would be if a PRINT USING 
statement had been invoked. The format modes that can be specified are 
selected by loading the following values into the A, B, and C registers 
as follows: </p><ul><li>A=0 means do not edit; this is a binary to ASCII conversion</li><li>A=X
 means edit as follows:  Bit 7=1 means edit the value, Bit 6=Print 
commas every third digit, Bit 5=Include leading asterisks, Bit 4=Print a
 leading $, Bit 3=Sign Follows Value, and Bit 1=Exponential Notation</li><li>B = The number of digits to the left of the decimal point.</li><li>C = The number of digits after the decimal point.</li></ul><p></p>
								<p>Note: If you wanted to convert any integer/single/double into
 its character string, store the variable in 4121H-4122H for integer, 
4121H-4124H for single, or in 411DH-4124H for double.  Then load 40AFH 
with a 2, 4, or 8 depending on whether that variable was integer, 
single, or double.  Then call 0FBDH.  Upon return, the character string 
is stored in 4130H and on, ending with a 00H. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>0FBE-0FC0<span class="origrom"><br>&nbsp;‚Ü≥&nbsp;PUFOUT</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#1034H" class="memory-link">CALL 1034H<span class="origrom2" style="display: inline;">CALL FOUINI</span></a><span class="opcode2" style="display: none;">CD 34 10</span></div><div>Save
 the formt specification in Register A and put a space for positive 
numbers into the buffer and loads HL with the starting address of the 
input buffer</div></div>
									<div class="assembly-row-combined"><div>0FC1-0FC2</div><div>AND 08H<span class="opcode2" style="display: none;">E6 08</span></div><div>Turn off some bits so we can check the value of Register A to see if a plus sign is required to be included for positive numbers</div></div>
									<div class="assembly-row-combined"><div>0FC3-0FC4</div><div><a href="#0FC7H" class="memory-link">JR Z,0FC7H<span class="origrom2" style="display: inline;">JR Z,FOUT1</span></a><span class="opcode2" style="display: none;">28 02</span></div><div>If a plus sign is NOT required to be added to the ASCII output string, then Jump to 0FC7H</div></div>
									<div class="assembly-row-combined"><div>0FC5-0FC6</div><div>LD (HL),2BH<span class="origrom2" style="display: inline;">LD (HL),"+"</span><span class="opcode2" style="display: none;">36 2B</span></div><div>If we are here, then it is required, so put a <span class="code">+</span>into the buffer pointed to by Register Pair HL</div></div>
									<div class="assembly-row-combined" id="0FC7H"><div>0FC7<span class="origrom2" style="display: inline;">FOUT1</span></div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Load Register Pair DE with the value of the buffer pointer (held in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>0FC8-0FCA</div><div><a href="#0994H" class="memory-link">CALL 0994H<span class="origrom2" style="display: inline;">CALL VSIGN</span></a><span class="opcode2" style="display: none;">CD 94 09</span></div><div>Go determine the value of the sign for the current value in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>0FCB</div><div>EX DE,HL<span class="opcode2" style="display: none;">EB</span></div><div>Restore the buffer pointer back to HL</div></div>
									<div class="assembly-row-combined"><div>0FCC-0FCE</div><div><a href="#0FD9H" class="memory-link">JP P,0FD9H<span class="origrom2" style="display: inline;">JP P,FOUT2</span></a><span class="opcode2" style="display: none;">F2 D9 0F</span></div><div>If the P FLAG is set then we have a negative number, so we need to negate it by JUMPing to FOUT2</div></div>
									<div class="assembly-row-combined"><div>0FCF-0FD0</div><div>LD (HL),2DH<span class="origrom2" style="display: inline;">LD (HL),"-"</span><span class="opcode2" style="display: none;">36 2D</span></div><div>Save a minus sign (-) at the location of the buffer pointer in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>0FD1</div><div>PUSH BC<span class="opcode2" style="display: none;">C5</span></div><div>Save the field length specifications held in B and C to the STACK</div></div>
									<div class="assembly-row-combined"><div>0FD2</div><div>PUSH HL<span class="opcode2" style="display: none;">E5</span></div><div>Save the buffer pointer to the STACK</div></div>
									<div class="assembly-row-combined"><div>0FD3-0FD5</div><div><a href="#097BH" class="memory-link">CALL 097BH<span class="origrom2" style="display: inline;">CALL VNEG</span></a><span class="opcode2" style="display: none;">CD 7B 09</span></div><div>GOSUB to 097BH to convert the negative value in the ACCumulator to its positive equivalent</div></div>
									<div class="assembly-row-combined"><div>0FD6</div><div>POP HL<span class="opcode2" style="display: none;">E1</span></div><div>Restore the buffer pointer from the STACK into HL</div></div>
									<div class="assembly-row-combined"><div>0FD7</div><div>POP BC<span class="opcode2" style="display: none;">C1</span></div><div>Restore the field length specifications from the STACK into B and C</div></div>
									<div class="assembly-row-combined"><div>0FD8</div><div>OR H<span class="opcode2" style="display: none;">B4</span></div><div>Turn off the Z FLAG.  This relies on the fact that FBUFR is never on page 0</div></div>
									<div class="assembly-row-combined" id="0FD9H"><div>0FD9<span class="origrom2" style="display: inline;">FOUT2</span></div><div>INC HL<span class="opcode2" style="display: none;">23</span></div><div>Increment the buffer pointer in Register Pair HL to where the next character will be placed</div></div>
									<div class="assembly-row-combined"><div>0FDA-0FDB</div><div>LD (HL),30H<span class="opcode2" style="display: none;">36 30</span></div><div>Save
 an ASCII zero (0) at the location of the input buffer pointer in 
Register Pair HL EITHER because a "0" will ultimately go there (if we 
are processing in free format) OR to to reserve a space fro a floating 
dollar sign (if we are processing in fixed format)</div></div>
									<div class="assembly-row-combined"><div>0FDC-0FDE</div><div>LD A,(40D8H)<span class="origrom2" style="display: inline;">LD A,(TEMP3)</span><span class="opcode2" style="display: none;">3A D8 40</span></div><div>Load Register A with the format specification (held in a temporary storage location)</div></div>
									<div class="assembly-row-combined"><div>0FDF</div><div>LD D,A<span class="opcode2" style="display: none;">57</span></div><div>Preserve the format specification into Register D</div></div>
									<div class="assembly-row-combined"><div>0FE0</div><div>RLA<span class="opcode2" style="display: none;">17</span></div><div>Move the "free format" or "fixed format" bit into the Carry flag</div></div>
									<div class="assembly-row-combined"><div>0FE1-0FE3</div><div>LD A,(40AFH)<span class="origrom2" style="display: inline;">LD A,(VALTYP)</span><span class="opcode2" style="display: none;">3A AF 40</span></div><div>Since VNEG may have changed VALTYP, re-fetch it (as -32768 is and integer but 32768 is single-precision).</div></div>
									<div class="assembly-row-combined"><div>0FE4-0FE6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#109AH" class="memory-link">JP C,109AH<span class="origrom2" style="display: inline;">JP C,FOUTFX</span></a><span class="opcode2" style="display: none;">DA 9A 10</span></div><div>The
 comment in the original source says to JUMP to FOUTFX because "the man 
wants fixed formatted output here to print numbers in free format"</div></div>
									<div class="assembly-row-combined"><div>0FE7-0FE9</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#1092H" class="memory-link">JP Z,1092H<span class="origrom2" style="display: inline;">JP Z,FOUTZR</span></a><span class="opcode2" style="display: none;">CA 92 10</span></div><div>If the Z FLAG is set, then JUMP to FOUTZR to finish it up</div></div>
									<div class="assembly-row-combined"><div>0FEA-0FEB</div><div>CP 04H<span class="opcode2" style="display: none;">FE 04</span></div><div>Check to see if the current value in the ACCumulator is single or double precision</div></div>
									<div class="assembly-row-combined"><div>0FEC-0FEE</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#103DH" class="memory-link">JP NC,103DH<span class="origrom2" style="display: inline;">JP NC,FOUFRV</span></a><span class="opcode2" style="display: none;">D2 3D 10</span></div><div>If the current value in the ACCumulator is single or double precision JUMP to FOUFRV</div></div>
									<div class="assembly-row-combined"><div>0FEF-0FF1</div><div>LD BC,0000H<span class="opcode2" style="display: none;">01 00 00</span></div><div>If
 we are here (and didn't jump away) then we are dealing with an INTEGER.
  First, set the decimal point counter and comma counter to ZERO</div></div>
									<div class="assembly-row-combined"><div>0FF2-0FF4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#132FH" class="memory-link">CALL 132FH<span class="origrom2" style="display: inline;">CALL FOUTCI</span></a><span class="opcode2" style="display: none;">CD 2F 13</span></div><div>Call
 the INTEGER TO ASCII routine at 1232F to convert the integer in the 
ACCumulator to ASCII and stores the ASCII string in the buffer pointed 
to in HL.  We then fall through to FOUTZS</div></div>
									<p class="debug-note">This routine will zero suppress the digits in FBUFFR and asterisk fill and zero suppress if necessary.</p>
									<div class="assembly-row-combined"><div>0FF5-0FF7<span class="origrom2" style="display: inline;">FOUTZS</span></div><div>LD HL,4130H<span class="origrom2" style="display: inline;">LD HL,FBUFFR+1</span><span class="opcode2" style="display: none;">21 30 41</span></div><div>Load Register Pair HL with the starting address of the buffer, which will hold the SIGN</div></div>
									<div class="assembly-row-combined"><div>0FF8</div><div>LD B,(HL)<span class="opcode2" style="display: none;">46</span></div><div>Load Register B with the sign (i.e., the character at the location of the buffer pointer in Register Pair HL)</div></div>
									<div class="assembly-row-combined"><div>0FF9-0FFA</div><div>LD C,20H<span class="origrom2" style="display: inline;">LD C," "</span><span class="opcode2" style="display: none;">0E 20</span></div><div>Load Register C with a <kbd>SPACE</kbd> </div></div>
									<div class="assembly-row-combined"><div>0FFB-0FFD</div><div>LD A,(40D8H)<span class="origrom2" style="display: inline;">LD A,(TEMP3)</span><span class="opcode2" style="display: none;">3A D8 40</span></div><div>Load Register A with format specifications</div></div>
									<div class="assembly-row-combined"><div>0FFE</div><div>LD E,A<span class="opcode2" style="display: none;">5F</span></div><div>Put the format specifications into Register E</div></div>
									<div class="assembly-row-combined"><div>0FFF-1000</div><div>AND 20H<span class="origrom2" style="display: inline;">AND 0010 0000</span><span class="opcode2" style="display: none;">E6 20</span></div><div>MASK the format specifications (by AND against 0010 0000) to see an asterisk fill is required</div></div>
								</div>
							</div>
						</div>
					</div>

					<div class="section-wrapper">
						<h2 id="pagenav">Disassembly Navigation<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
						<div class="section-content">
							<div class="top-menu-shorter">
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0000H">0000</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0100H">0100</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0200H">0200</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0300H">0300</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0400H">0400</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0500H">0500</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0600H">0600</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0700H">0700</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0800H">0800</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0900H">0900</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A00H">0A00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0B00H">0B00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0C00H">0C00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0D00H">0D00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0E00H">0E00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0F00H">0F00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1000H">1000</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1100H">1100</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1200H">1200</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1300H">1300</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1400H">1400</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1500H">1500</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1600H">1600</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1608H">Reserved Words</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#18C9H">Error Messages</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1900H">1900</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1A00H">1A00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1B00H">1B00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C00H">1C00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D00H">1D00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E00H">1E00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1F00H">1F00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2000H">2000</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2100H">2100</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2200H">2200</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2300H">2300</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2400H">2400</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2500H">2500</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2600H">2600</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2700H">2700</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2800H">2800</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2900H">2900</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2A00H">2A00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2B00H">2B00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2C00H">2C00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2D00H">2D00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2E00H">2E00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2F00H">2F00</a>
							</div>
						</div>
					</div>
				</div>
			</main>
		</div>
	</div>
	<!-- Fancybox JavaScript -->
	<script src="Model%20I%20ROM%20Explained%20-%20Part%201_files/fancybox.umd.js"></script>
	<!-- Initialize Fancybox -->
	<script>
		Fancybox.bind("[data-fancybox]", {
			Toolbar: {
				display: {
					left: ["infobar"],
					middle: [],
					right: ["slideshow", "thumbs", "close"],
				},
			},
			Thumbs: {
				autoStart: false,
			},
		});
	</script>
	<script>
	document.addEventListener('DOMContentLoaded', function() {
		function toggleElements(selector, isVisible) {
			const elements = document.querySelectorAll(selector);
			elements.forEach(el => {
				el.style.display = isVisible ? 'inline' : 'none';
			});
		}

		// OpCode Toggle
		const opCodeToggle = document.getElementById('OpCodeToggle');
		if (opCodeToggle) {
			toggleElements('.opcode2', opCodeToggle.checked); // Set initial visibility
			opCodeToggle.addEventListener('change', function() {
				toggleElements('.opcode2', this.checked);
			});
		}

		// Labels Toggle
		const labelsToggle = document.getElementById('LabelsToggle');
		if (labelsToggle) {
			toggleElements('.origrom2', labelsToggle.checked); // Set initial visibility
			labelsToggle.addEventListener('change', function() {
				toggleElements('.origrom2', this.checked);
			});
		}
	});
	</script>
	<!-- Last Modified Date -->
	<script>
		document.write("<p style='text-align:right; padding: 10px 20px; font-style: italic; font-size: 0.85em; color: #666;'>Last edited: " + document.lastModified + "</p>");
	</script><p style="text-align:right; padding: 10px 20px; font-style: italic; font-size: 0.85em; color: #666;">Last edited: 02/06/2026 21:23:31</p>

<div id="mobile-overlay" class="mobile-menu-overlay"></div></body></html>