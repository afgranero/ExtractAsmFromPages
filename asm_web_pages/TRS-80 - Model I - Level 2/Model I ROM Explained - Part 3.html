<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="TRS-80 Revived Site by Ira Goldklang's is an archive of everything related to the Tandy Radio Shack TRS-80 microcomputer lines. Site contains emulators, programs, manuals, books, patches, games, hints, discussions, and tons more.">
	<meta name="author" content="Ira Goldklang">
	<meta name="robots" content="index, follow">
	<link rel="icon" href="https://www.trs-80.com/icon.ico" type="image/x-icon">
	<link rel="canonical" href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm">
	<meta property="og:title" content="TRS-80 Revived Site - Ira Goldklang's TRS-80 Archive">
	<meta property="og:description" content="Complete archive of TRS-80 emulators, programs, manuals, books, and games for Tandy Radio Shack TRS-80 computers.">
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm">
	<meta name="twitter:card" content="summary">
	<meta name="twitter:title" content="TRS-80 Revived Site">
	<meta name="twitter:description" content="Complete archive of TRS-80 emulators, programs, and resources.">
	<title>Model I ROM Explained - Part 3</title>
	<!-- Load your existing CSS file -->
	<link rel="stylesheet" href="Model%20I%20ROM%20Explained%20-%20Part%203_files/trs80-css.css">
	<link rel="stylesheet" href="Model%20I%20ROM%20Explained%20-%20Part%203_files/trs80-hamburger.css">
	<!-- Fancybox CSS -->
	<link rel="stylesheet" href="Model%20I%20ROM%20Explained%20-%20Part%203_files/fancybox.css">
	<!-- Load the component loader -->
	<script src="Model%20I%20ROM%20Explained%20-%20Part%203_files/trs80-loader.js"></script>
	<script src="Model%20I%20ROM%20Explained%20-%20Part%203_files/trs80-hamburger.js"></script>
</head>
<body class="trs80-loaded"><button id="hamburger-btn" class="hamburger-menu" aria-label="Toggle menu">
            <span></span>
            <span></span>
            <span></span>
        </button>
	<div class="site-container">
		<!-- Header will be loaded here -->
		<div id="header"><style>
    .trs80-header-grid {
        display: grid;
        /* 'auto' lets the images take only needed space, '1fr' gives the rest to the text */
        grid-template-columns: auto 1fr auto;
        grid-template-rows: 1fr;
        grid-column-gap: 20px;
        grid-row-gap: 0;
        background-color: #003399;
        margin-top: 10px;
        padding: 10px;
        /* This ensures all items in the grid (images and text) are aligned to the top */
        align-items: start;
    }

    .trs80-header-left { grid-area: 1 / 1 / 2 / 2; display: flex; align-items: start; }
    .trs80-header-center { grid-area: 1 / 2 / 2 / 3; text-align: center; }
    .trs80-header-right { grid-area: 1 / 3 / 2 / 4; display: flex; align-items: start; justify-content: flex-end; }

    .trs80-title { color: white !important; font-size: 170%; text-align: center; margin: 0 0 10px 0; font-weight: bold; }

    .trs80-description {
        color: white !important;
        font-size: 120%;
        text-align: center;
        margin: 0 auto 15px auto;
        padding: 0 10px;
        line-height: 1.4;
    }

    .trs80-header-grid img { border: 0 !important; margin: 0 2px; }
    .trs80-img-60 { width: 60px; }
    .trs80-img-80 { width: 80px; }
    .trs80-img-90 { width: 90px; }
    .trs80-img-100 { width: 100px; }

    /* Search Button Styling */
    .header-search-container {
        margin-bottom: 10px;
    }

    .header-search-link {
        display: inline-block;
        background: #ffcc00; /* Retro TRS-80 Amber */
        color: #003399 !important;
        padding: 6px 15px;
        border-radius: 4px;
        font-weight: bold;
        font-size: 0.9em;
        text-decoration: none;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        transition: transform 0.2s, background 0.2s;
    }

    .header-search-link:hover {
        background: #ffe066;
        transform: scale(1.05);
        text-decoration: none;
    }

    @media screen and (max-width: 768px) {
        .trs80-header-grid {
            grid-template-columns: 1fr;
            grid-template-rows: auto auto auto;
            text-align: center;
            justify-items: center;
        }
        .trs80-header-left { grid-area: 1 / 1 / 2 / 2; justify-content: center; }
        .trs80-header-center { grid-area: 2 / 1 / 3 / 2; }
        .trs80-header-right { grid-area: 3 / 1 / 4 / 2; justify-content: center; }
        .trs80-title { font-size: 130%; }
        .trs80-description { font-size: 100%; text-align: center; }
        .trs80-img-60 { width: 50px; }
        .trs80-img-80 { width: 65px; }
        .trs80-img-90 { width: 75px; }
        .trs80-img-100 { width: 80px; }
    }
</style>

<div class="trs80-header-grid">
    <div class="trs80-header-left">
        <img src="Model%20I%20ROM%20Explained%20-%20Part%203_files/computer-model1-keyboardandscreen-100.png" alt="[Model I]" class="trs80-img-60">
        <img src="Model%20I%20ROM%20Explained%20-%20Part%203_files/computer-model3-rsc05-blur-x100.png" alt="[Model III]" class="trs80-img-60">
        <img src="Model%20I%20ROM%20Explained%20-%20Part%203_files/computer-model4-rsc10-x100.png" alt="[Model 4]" class="trs80-img-90">
    </div>

    <div class="trs80-header-center">
        <p class="trs80-title">Welcome To Ira Goldklang's TRS-80 Revived Site</p>

        <p class="trs80-description">
            TRS-80 Revived Site is an archive of everything related to 
the Tandy Radio Shack TRS-80 home microcomputer lines. Site contains 
emulators, programs, manuals, books, patches, games, hints, discussions,
 and tons more.
        </p>

        <div class="header-search-container">
            <a href="https://www.trs-80.com/main-search-site.htm" class="header-search-link">
                <span class="search-icon">üîç</span> SEARCH THIS SITE
            </a>
        </div>
    </div>

    <div class="trs80-header-right">
        <img src="Model%20I%20ROM%20Explained%20-%20Part%203_files/computer-model-4p-sideways-view-x100.png" alt="[Model 4P]" class="trs80-img-90">
        <img src="Model%20I%20ROM%20Explained%20-%20Part%203_files/computer-model100-ccf836-x100.png" alt="[Model 100]" class="trs80-img-80">
        <img src="Model%20I%20ROM%20Explained%20-%20Part%203_files/computer-pc2-rsc07-x100.png" alt="[Pocket Computer]" class="trs80-img-100">
    </div>
</div>
</div>
		<!-- Content wrapper with sidebar and main content -->
		<div class="content-wrapper">
			<!-- Left Navigation will be loaded here -->
			<aside class="sidebar" id="navbar"><div class="navigationpanelv2">
	<div class="nav-entry-block">
		<h2>FIRST TIME VISITORS</h2>
		<p style="font-size:150%; margin-top:0; text-align:center; color:red;"><a href="https://www.trs-80.com/main-welcome.htm">Visit the WELCOME page</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>Services</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-faq-reading-disks.htm" style="color:red !important;">Do you have TRS-80 Disks?  Send them in for Preservation and Conversion for use in an Emulator</a></li>
			<li><a href="https://www.trs-80.com/main-disketterequest.htm">Request Real DOS Disks</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>General</h2>
		<ul>
			<li><a href="https://www.trs-80.com/index.html">Site News</a></li>
			<li><a href="https://www.trs-80.com/main-introduction-to-emulators.htm">Intro to Emulation</a></li>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-interviews.htm">Interviews</a></span>
				<ul>
					<li><a href="https://americanhistory.si.edu/comphist/gates.htm">Bill Gates</a></li>
					<li><a href="http://www.trs-80.org/interview-bill-hogue/">Bill Hogue</a></li>
					<li><a href="http://www.trs-80.org/interview-dan-gookin/">Dan Gookin</a></li>
					<li><a href="https://www.trs-80.com/sub-interview-don-french.htm">Don French</a></li>
					<li><a href="https://bluebilby.com/dubois-mcnamara/">Dubouis &amp; McNamara</a></li>
					<li><a href="http://www.trs-80.org/interview-j-weaver/">J. Weaver Jr.</a></li>
					<li><a href="http://www.trs-80.org/interview-jack-crenshaw/">Jack Crenshaw</a></li>
					<li><a href="http://www.trs-80.org/interview-jim-stutsman/">Jim Stutsman</a></li>
					<li><a href="http://www.48k.ca/JoshLavinsky.html">Josh Lavinsky</a></li>
					<li><a href="http://www.trs-80.org/interview-kevin-tschudi/">Kevin Tschudi</a></li>
					<li><a href="http://www.trs-80.org/interview-paul-andreasen/">Paul Andreasen</a></li>
					<li><a href="https://www.trs-80.com/sub-interview-steve-leininger.htm">Steven W. Leininger</a></li>
					<li><a href="https://www.trs-80.com/sub-interview-bill-demas.htm">William Demas</a></li>
				</ul>
			</li>
			<li><a href="https://www.trs-80.com/main-shipping.htm">Shipping a TRS-80</a></li>
			<li><a href="https://www.trs-80.com/main-lore.htm">Radio Shack Lore</a></li>
			<li><a href="https://www.trs-80.com/main-fun-stuff.htm">Fun Stuff</a></li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>Help The Site!</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-missing-software.htm">Missing Software</a></li>
			<li><a href="https://www.trs-80.com/main-missing-magazines.htm">Missing Magazines</a></li>
			<li><a href="https://www.trs-80.com/main-faq-reading-disks.htm">Send in Your Disks for Archiving</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Searches</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-search-site.htm">Site-Wide Search</a></li>
			<li><a href="https://www.trs-80.com/main-search-software.htm">Software Search</a></li>
			<li><a href="https://www.trs-80.com/main-search-magazines.htm">Magazine Search</a></li>
			<li><a href="https://www.trs-80.com/main-search-rs-catalogs.htm">Catalog Search</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Emulation and Virtual Media</h2>
		<span>Info and Downloads:</span>
		<ul>
			<li><a href="https://www.trs-80.com/main-emulators.htm">Emulators</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-tape-utilities.htm">Virtual Tape Utilities</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-disk-utilities.htm">Virtual Disk Utilities</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-misc-utilities.htm">Misc TRS-80 Utilities</a></li>
		</ul>
		<span>How To Convert:</span>
		<ul>
			<li><a href="https://www.trs-80.com/main-emulation-conversion-tapes.htm">Tapes to Virtual</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-conversion-disks.htm">Disks to Virtual</a></li>
			<li><a href="https://www.classic-computers.org.nz/system-80/software_esf_archive-imaging.htm">Stringy Floppy to Virtual</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Advanced</h2>
		<span>Internal Operations</span>
		<ul>
			<li>
				<span class="submenu-toggle">ROM/Z-80 Info</span>
				<ul>
					<li><a href="https://www.trs-80.com/main-internal-rom-related.htm#compared">ROMs Compared</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-level-1.htm">Model I Level 1 ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm">Model I Level II ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm">Model III Level II ROM</a></li>
					<li><a href="https://github.com/kiwisincebirth/TRS-80">Model III Level II Compilable Source</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4.htm">Model 4 ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4-xdrom-main.htm">Model 4 XDROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4p.htm">Model 4P Boot ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-network-4.htm">Network 4 ROM</a></li>
					<li><a href="https://www.gatesnotes.com/microsoft-original-source-code">Orig Source Code</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-bugs.htm">Bugs</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-rom-addresses.htm">Memory map and address reference</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-entry-points.htm">Entry Points to routines</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-io-and-misc-routines.htm">I/O and Misc ROM routines</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-math-calls.htm">Math Routines</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-rst-vectors.htm">RST vectors and Disk BASIC entry points</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-z80-info.htm">Reference for Z-80 opcodes and undocumented command</a></li>
				</ul>
			</li>
			<li><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm">RAM Addresses/Routines</a></li>
			<li><a href="https://www.trs-80.com/main-internal-ports-and-i-o.htm">Ports and I/O Devices</a></li>
			<li><a href="https://www.trs-80.com/sub-rom-dcbs.htm">Device Control Blocks (DCB's)</a></li>
			<li><a href="https://www.trs-80.com/main-internal-keyboard-map.htm">Keyboard Map</a></li>
		</ul>

		<span>Disassemblies</span>
		<ul>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-disassemblies.htm">Disassemblies</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-level-1.htm">Level I ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm">Level II ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm">Model III ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-4-durda.htm">Frank Durda Modified C-ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4.htm">Model 4 ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4p.htm">Model 4P Bootstrap ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4-xdrom-main.htm">XDROM - Frank Durda's Model 4 ROM C replacement</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-dos-nd80-m1-main.htm">NEWDOS/80 v2.0</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-dos-td13-main.htm">TRSDOS v1.3</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-dos-td23-main.htm">TRSDOS v2.3</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-network-4.htm">Network 4 Transporter ROM code analysis</a></li>
				</ul>
			</li>
		</ul>

		<span>Zaps/Patches/Fixes</span>
		<ul>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-zaps-and-patches.htm">Zaps and Patches</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/main-zaps-and-patches.htm#dos">DOS</a></li>
					<li><a href="https://www.trs-80.com/sub-zaps-sw-electric-pencil.htm">Electric Pencil</a></li>
					<li><a href="https://www.trs-80.com/sub-zaps-sw-general.htm">Other Software</a></li>
					<li><a href="https://www.trs-80.com/main-zaps-and-patches.htm#software-zaps-and">ZIPs of Patches</a></li>
				</ul>
			</li>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-tips-and-tricks.htm">Tips and Tricks</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/sub-tips-hard-drive.htm">Hard Drive Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-packing.htm">String Packing and USR Routines</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-level2.htm">Level II Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-reference-dos-newdos80-main.htm#tips">NEWDOS/80 Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-dos.htm">Other DOS Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-graphics.htm">TRS-80 Graphics</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-file-formats.htm">Tape and File Formats/Structures</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-easter-eggs.htm">Bugs and Easter Eggs</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-misc.htm">Misc Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-model-3.htm">Model III Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-model-4.htm">Model 4 Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-model-4p.htm">Model 4P Tips and Tricks</a></li>
				</ul>
			</li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>TRS-80 Models</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-models.htm">Timeline</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model1.htm">Model I</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model2.htm">Model II</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model3.htm">Model III</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model4.htm">Model 4/4P/4D</a></li>
			<li><a href="https://www.trs-80.com/sub-models-coco.htm">Color (Coco 1-3, MC-10)</a></li>
			<li><a href="https://www.trs-80.com/sub-models-laptops.htm">Laptops (100/200/600)</a></li>
			<li><a href="https://www.trs-80.com/sub-models-pocket.htm">Pocket (PC-1 to PC-8)</a></li>
			<li><a href="https://www.trs-80.com/sub-models-clones.htm">Clones</a></li>
			<li><a href="https://www.trs-80.com/sub-models-printers.htm">Printers</a></li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>Reference</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-reference-dos-trsdos-main.htm">TRSDOS</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-dos-dosplus.htm">DOSPlus</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-dos-newdos80-main.htm">NEWDOS/80</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-multidos.htm">MULTIDOS</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-dos-cpm.htm">CP/M</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-level-2-basic.htm">Level II BASIC Ref</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Detailed Products</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-details-orchestra.htm">ORCH-80/85/90</a></li>
			<li><a href="https://www.trs-80.com/sub-details-speed-up-boards.htm">Speed-Up Boards</a></li>
			<li><a href="https://www.trs-80.com/sub-details-scott-adams.htm">Scott Adams Adventures</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Tandy Publications</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-rs-csbs.htm">Customer Service Bulletins</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-memos.htm">Memos / Bulletins / Releases</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-cc-answers.htm">Comp Center Answers</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-catalogs.htm">Catalogs</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-comics.htm">Comic Books</a></li>
		</ul>
		<span>Microcomputer News</span>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-rs-micronewsletter-usa.htm">USA Edition</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-micronewsletter-aus.htm">Australian Edition</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-micronewsletter-other.htm">Other Editions</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Publications</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-books.htm">Books</a></li>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-magazine-main-menu.htm">Magazines (Non-Tandy)</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/sub-mag-80micro-main.htm">80 Microcomputing</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-80-notebook.htm">80 Notebook</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-80us-detail.htm">80 U.S. Journal</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-alternatesource-detail.htm">The Alternate Source</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-baron.htm">Baron's Microcomputing</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-cie.htm">C.I.E.</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-cload.htm">CLOAD</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-codeworks.htm">CodeWorks</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-computernews80.htm">Computer News 80</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-computer-user.htm">Computer User</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-creative.htm">Creative Computing</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-hecomputronics-detail.htm">H&amp;E Computronics</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-lsi-journal.htm">LDOS / LSI</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-micro80.htm">Micro-80</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-misosys-notes.htm">Misosys Notes</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-misosys-quarterly.htm">Misosys Quarterly</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-softside-detail.htm">Softside</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-the8ighty.htm">The 8ighty</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-trace.htm">Trace</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-trs8bit.htm">TRS8Bit</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-trstimes.htm">TRSTimes</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-other.htm">Other Magazines</a></li>
				</ul>
			</li>
			<li><a href="https://www.trs-80.com/sub-publications-manuals-software-1.htm">Software Manuals</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-user-groups-1.htm">User's Group Newsletters</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-catalogs.htm">Catalogs (Non-Tandy)</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-flyers.htm">Product Flyers</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-company-news.htm">Company Newsletters</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>This Section for TRS-80 Hardware Owners</h2>
		<span>TRS-80 Upgrades/Parts:</span>
		<ul>
			<li><a href="https://www.trs-80.com/main-upgrades.htm">Upgrades and Parts</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-parts-thingverse.htm">Schematics/3-D Printable Parts</a></li>
		</ul>
		<span>TRS-80 Repairs:</span>
		<ul>
			<li class="navbumpv2"><a href="https://www.trs-80.com/main-repairs.htm">Main Repair Page</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-repair-people.htm">Repair People</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-how-to-open.htm">Opening a TRS-80</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-eprom.htm">Using an EPROM</a></li>
		</ul>
		<span>Hardware Mods and Hacks:</span>
		<ul>
			<li><a href="https://www.trs-80.com/sub-tips-modifications-model-1.htm">Model I</a></li>
			<li><a href="https://www.trs-80.com/sub-tips-modifications-model-3.htm">Model III</a></li>
			<li><a href="https://www.trs-80.com/sub-tips-modifications-model-4.htm">Model 4</a></li>
		</ul>
		<span>Other Items ...</span>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-manuals-hardware-1.htm">Hardware Manuals</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-manuals-service.htm">Service Manuals</a></li>
			<li><a href="https://voidstar.blog/tandy-radio-shack-computer-cassette-recorder-trs-ccr-usage/">Using a Computer / Tablet / Smartphone for Cassette I/O</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Misc</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-emailme.htm">Send Me Email</a></li>
			<li><a href="https://www.trs-80.com/main-old-news.htm">Archived News and Guestbook</a></li>
			<li><a href="https://www.trs-80.com/main-personalstories.htm">Personal Stories Submitted</a></li>
			<li><a href="https://www.trs-80.com/main-emaillinks.htm">Email and other TRS-80 Sites</a></li>
			<li><a href="https://www.trs-80.com/main-copyrights.htm">Copyrights</a></li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>
</div></aside>
			<!-- Main Content -->
			<main class="main-content">
				<div class="main-page-container">
					<h1>Model I ROM Explained - Part 3</h1>
					<div class="section-wrapper">
						<h2 id="page-customization">Page Customization<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
						<div class="section-content">
							<div class="toggle-container">
								<label class="toggle-label">
									<input type="checkbox" id="OpCodeToggle">
									Display OPCodes
								</label>
							</div>
							<div class="toggle-container">
								<label class="toggle-label">
									<input type="checkbox" id="LabelsToggle" checked="checked">
									Display Labels
								</label>
							</div>
						</div>
					</div>

					<div class="section-wrapper">
						<h2 id="pagenav">Disassembly Navigation<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
						<div class="section-content">
							<div class="top-menu-shorter">
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0000H">0000</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0100H">0100</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0200H">0200</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0300H">0300</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0400H">0400</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0500H">0500</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0600H">0600</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0700H">0700</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0800H">0800</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0900H">0900</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A00H">0A00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0B00H">0B00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0C00H">0C00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0D00H">0D00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0E00H">0E00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0F00H">0F00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1000H">1000</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1100H">1100</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1200H">1200</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1300H">1300</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1400H">1400</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1500H">1500</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1600H">1600</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1608H">Reserved Words</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#18C9H">Error Messages</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1900H">1900</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1A00H">1A00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1B00H">1B00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C00H">1C00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D00H">1D00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E00H">1E00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1F00H">1F00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2000H">2000</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2100H">2100</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2200H">2200</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2300H">2300</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2400H">2400</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2500H">2500</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2600H">2600</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2700H">2700</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2800H">2800</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2900H">2900</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2A00H">2A00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2B00H">2B00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2C00H">2C00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2D00H">2D00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2E00H">2E00</a>
								<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2F00H">2F00</a>
							</div>
						</div>
					</div>

					<div class="section-wrapper">
						<h2 id="disassembly-2xxxh">Disassembly (2xxxH)<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
						<div class="section-content">
							<h2 class="assembly-section-title skip-banner" id="2003H">2003 - UE ERROR entry point <span class="origrom">- "GOERR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2003-2004 <span class="origrom2">GOERR</span></div><div>LD E,26H <span class="origrom2">LD E,ERRUE <span class="opcode2">1E 26</span></span></div><div>Load Register E with the ERROR code for a <span class="code">?UE ERROR</span></div></div>
									<div class="assembly-row-combined" id="2005H"><div>2005-2007</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#19A2H" class="memory-link">JP 19A2H <span class="origrom2">JP ERROR</span></a><span class="opcode2">C3 A2 19</span></div><div>Go to the Level II BASIC error routine and display the appropriate error message</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2008H">2008-2038 - LEVEL II BASIC <span class="code">AUTO</span> ROUTINE <span class="origrom">- "AUTO"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source code, the AUTO 
[beginning line,[increment]] command is used to automatically generate 
line number for lines to be inserted.  The beginning line is used to 
specify the initial line (and if omitted, defaults to 10) and the 
increment is used to specify the increment used to generate the next 
line number.  If only a comma is used after the beginning line, the old 
increment is used.<br><br>On entry, Z will be set if there was nothing following the command.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2008-200A <span class="origrom2">AUTO</span></div><div>LD DE,000AH <span class="opcode2">11 0A 00</span></div><div>Load DE with a default starting line number of ten</div></div>
									<div class="assembly-row-combined"><div>200B</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the default STACK line number in DE to the STACK</div></div>
									<div class="assembly-row-combined"><div>200C-200D</div><div><a href="#2025H" class="memory-link">JR Z,2025H <span class="origrom2">JR Z,SNGAUT</span></a><span class="opcode2">28 17</span></div><div>Jump down to 2025H if this is the end of the <span class="code">AUTO</span> statement (meaning that no parameters were provided).  This will default to AUTO 10,10</div></div>
									<div class="assembly-row-combined"><div>200E-2010</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E4FH" class="memory-link">CALL 1E4FH <span class="origrom2">CALL LINSPC</span></a><span class="opcode2">CD 4F 1E</span></div><div>If we are here, then there were parameters after the <span class="code">AUTO</span>
 statement so we need to GOSUB to 1E4FH to evaluate the line number at 
the current location of the BASIC program pointer in HL and return with 
the result in DE. The Z flag will be set if that was the end of the 
command</div></div>
									<div class="assembly-row-combined"><div>2011</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Since there is no such Z-80 command as <span class="code">EX (SP),DE</span>
 we now need to do some swapping to get DE into (SP).  First, exchange 
the value of the line number in DE with the value of the current BASIC 
program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2012</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Next,
 exchange the default line number (to the STACK from the above push of 
DE) with the line number that the user provided (in HL)</div></div>
									<p class="debug-note">At this point, DE points to the current 
character in the BASIC line being processed, "10" is in HL, and the 
initial number is on the STACK.</p>
									<div class="assembly-row-combined"><div>2013-2014</div><div><a href="#2026H" class="memory-link">JR Z,2026H <span class="origrom2">JR Z,SNGAU1</span></a><span class="opcode2">28 11</span></div><div>Jump down to 2026H if this is the end of the <span class="code">AUTO</span> statement (meaning that only 1 parameter was provided).  This will default to 10</div></div>
									<div class="assembly-row-combined"><div>2015</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load HL with the value of the current BASIC program pointer in DE</div></div>
									<div class="assembly-row-combined"><div>2016-2017</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 2C <span class="origrom2">SYNCHK <span class="code">,</span></span></a><span class="opcode2">CF 2C</span></div><div>If we are here, then we have an <span class="code">AUTO</span>
 command with one parameter (starting line number) and we have not 
finished with the command. Since the only valid addition to that would 
be a trailing <span class="code">,</span> , we need to test the current BASIC program pointer in HL for a COMMA (=2CH), by calling the COMPARE SYMBOL at RST 08H.<br><br><span class="bold nobottomborder">NOTE:</span>
 The RST 08H routine compares the symbol in the input string pointed to 
by HL Register to the value in the location following the RST 08 call.<ul><li>If
 there is a match, control is returned to the next execution address 
(i.e, the RST 08H instruction + 2) with the next symbol in the A 
Register and HL incremented by one.</li><li>If the two characters do not match, a syntax error message is given and control returns to the Input Phase).</li></ul></div></div>
									<div class="assembly-row-combined"><div>2018</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>If we are here, then it matched (a <span class="code">?SN ERROR</span> would have occurred otherwise) so load DE with the value of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2019-201B</div><div>LD HL,(40E4H) <span class="origrom2">LD HL,(AUTINC)</span>  <span class="opcode2">2A E4 40</span></div><div>Load HL with the last provided <span class="code">AUTO</span> increment value.<br>Note: 40E4H-40E5H holds <span class="code">AUTO</span> increment</div></div>
									<div class="assembly-row-combined"><div>201C</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Exchange the value of the current BASIC program pointer in DE with the last <span class="code">AUTO</span> increment value in HL</div></div>
									<div class="assembly-row-combined"><div>201D-201E</div><div><a href="#2025H" class="memory-link">JR Z,2025H <span class="origrom2">JR Z,SNGAUT</span></a><span class="opcode2">28 06</span></div><div>Jump to 2025H if this is the end of the BASIC statement (meaning, we got <span class="code">AUTO nn,</span> but no further parameter).  This will then use the last provided increment</div></div>
									<div class="assembly-row-combined"><div>201F-2021</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E5AH" class="memory-link">CALL 1E5AH <span class="origrom2">CALL LINGET</span></a><span class="opcode2">CD 5A 1E</span></div><div>If
 we are here, there was a second parameter so we GOSUB to 1E5AH to get 
the second parameter as the routine at 1E5A converts the ASCII string 
pointed to by HL to an integer deposited into DE.  If the routine finds a
 non-numerica character, the conversion is stopped</div></div>
									<div class="assembly-row-combined"><div>2022-2024</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1997H" class="memory-link">JP NZ,1997H <span class="origrom2">JP NZ,SNERR</span></a><span class="opcode2">C2 97 19</span></div><div>If that prior GOSUB found a non-numeric character it aborted with a NZ, so if there is a NZ, jump to 1997H to show a <span class="code">?SN ERROR</span></div></div>
									<div class="assembly-row-combined" id="2025H"><div>2025 <span class="origrom2">SNGAUT</span></div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Exchange the <span class="code">AUTO</span> increment number in DE with the value of the current BASIC program pointer in HL.  HL should now hold the AUTO increment</div></div>
									<div class="assembly-row-combined" id="2026H"><div>2026 <span class="origrom2">SNGAU1</span></div><div>LD A,H <span class="opcode2">7C</span></div><div>Prepare to test to see if it is zero.  First, load Register A with the MSB of the <span class="code">AUTO</span> increment number in Register H. (This is step 1 of a test to see if HL is zero)</div></div>
									<div class="assembly-row-combined"><div>2027</div><div>OR L <span class="opcode2">B5</span></div><div>Combine the LSB of the <span class="code">AUTO</span> increment number in Register L with the MSB of the <span class="code">AUTO</span> increment number in Register A. (This is step 2 of a test to see if HL is zero)</div></div>
									<div class="assembly-row-combined"><div>2028-202A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E4AH" class="memory-link">JP Z,1E4AH <span class="origrom2">JP Z,FCERR</span></a><span class="opcode2">CA 4A 1E</span></div><div>That all tested the value of HL to see if it was zero. If it was, jupm to 1E4AH to show a <span class="code">?FC ERROR</span> message</div></div>
									<div class="assembly-row-combined"><div>202B-202D</div><div>LD (40E4H),HL <span class="origrom2">LD (AUTINC),HL</span>  <span class="opcode2">22 E4 40</span></div><div>Save the value of the <span class="code">AUTO</span> increment number in HL.<br>Note: 40E4H-40E5H holds <span class="code">AUTO</span> increment</div></div>
									<div class="assembly-row-combined"><div>202E-2030</div><div>LD (40E1H),A <span class="origrom2">LD (AUTFLG),A</span>  <span class="opcode2">32 E1 40</span></div><div>Set the <span class="code">AUTO</span> flag to non-zero. We know A is non-zero because we would have jumped 2 instruction ago if it was</div></div>
									<div class="assembly-row-combined"><div>2031</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the starting line number from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2032-2034</div><div>LD (40E2H),HL <span class="origrom2">LD (AUTLIN),HL</span>  <span class="opcode2">22 E2 40</span></div><div>Save the line number in HL as the next AUTO line number.<br>Note: 40E2H-40E3H holds Current BASIC line number</div></div>
									<div class="assembly-row-combined"><div>2035</div><div>POP BC <span class="opcode2">C1</span></div><div>Clean up the return address of NEWSTT from the STACK</div></div>
									<div class="assembly-row-combined"><div>2036-2038</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1A33H" class="memory-link">JP 1A33H <span class="origrom2">JP MAIN</span></a><span class="opcode2">C3 33 1A</span></div><div>Jump to the Level II BASIC command mode</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2039H">2039-2066 - LEVEL II BASIC <span class="code">IF</span> ROUTINE <span class="origrom">- "IF"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2039-203B <span class="origrom2">IF</span></div><div><a href="#2337H" class="memory-link">CALL 2337H <span class="origrom2">CALL FRMEVL</span></a><span class="opcode2">CD 37 23</span></div><div>GOSUB to 2337H to evaluate the BASIC expression pointed to by HL and return with the result in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>203C</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>203D-203E</div><div>CP 2CH <span class="opcode2">FE 2C</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">,</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.	</div></div>
									<div class="assembly-row-combined"><div>203F-2041</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">CALL Z,1D78H <span class="origrom2">JP Z,CHRGTR</span></a><span class="opcode2">CC 78 1D</span></div><div>If the character at the location of the current BASIC program pointer in Register A is a <span class="code">,</span> then go bump the value of the current BASIC program pointer in HL until it points to the next character</div></div>
									<div class="assembly-row-combined"><div>2042-2043</div><div>CP 0CAH <span class="opcode2">FE CA</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">THEN</span> token<br>.
  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set.  
If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.	</div></div>
									<div class="assembly-row-combined"><div>2044-2046</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">CALL Z,1D78H <span class="origrom2">JP Z,CHRGTR</span></a><span class="opcode2">CC 78 1D</span></div><div>If Z flag is set, the character at the location of the current BASIC program pointer in Register A is a <span class="code">THEN</span> token, so we need to bump the value of the current BASIC program pointer until it points to the next character</div></div>
									<div class="assembly-row-combined"><div>2047</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the current BASIC program pointer in HL so that we are still positioned at the <span class="code">THEN</span> token</div></div>
									<div class="assembly-row-combined"><div>2048 <span class="origrom2">OKGOTO</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer to the STACK</div></div>
									<div class="assembly-row-combined"><div>2049-204B</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0994H" class="memory-link">CALL 0994H <span class="origrom2">CALL VSIGN</span></a><span class="opcode2">CD 94 09</span></div><div>GOSUB to 0994H to see if the expression after the <span class="code">IF</span> token was true or false</div></div>
									<div class="assembly-row-combined"><div>204C</div><div>POP HL <span class="opcode2">E1</span></div><div>Restore the address of the current position in the current statement (from the STACK) into HL</div></div>
									<div class="assembly-row-combined"><div>204D-204E</div><div><a href="#2056H" class="memory-link">JR Z,2056H <span class="origrom2">JR Z,FALSIF</span></a><span class="opcode2">28 07</span></div><div>Jump down to 2056H if the expression was false</div></div>
									<div class="assembly-row-combined" id="204FH"><div>204F <span class="origrom2">DOCOND</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2050-2052</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1EC2H" class="memory-link">JP C,1EC2H <span class="origrom2">JP C,GOTO</span></a><span class="opcode2">DA C2 1E</span></div><div>Jump to the <span class="code">GOTO</span> routine if the character at the location of the current BASIC program pointer in HL is numeric</div></div>
									<div class="assembly-row-combined"><div>2053-2055</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D5FH" class="memory-link">JP 1D5FH <span class="origrom2">JP GONE</span></a><span class="opcode2">C3 5F 1D</span></div><div>Jump to the execution driver at 1D5FH to evaluate the rest of the statement string</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2056H">2056H - LEVEL II BASIC <span class="code">ELSE</span> ROUTINE <span class="origrom">- "FALSIF"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2056-2057 <span class="origrom2">FALSIF</span></div><div>LD D,01H <span class="opcode2">16 01</span></div><div>Load
 Register D with the scan counter as we will need to count the number of
 ELSEs.  The "DATA" routine increments this counter ever time it finds 
an <span class="code">IF</span> statement</div></div>
									<div class="assembly-row-combined" id="2058H"><div>2058-205A <span class="origrom2">SKPMRF</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1F05H" class="memory-link">CALL 1F05H <span class="origrom2">CALL DATA</span></a><span class="opcode2">CD 05 1F</span></div><div>Go
 scan the BASIC statement to skip a statement.  A ":" is placed in front
 of each ELSE so that the DATA routine will stop before an ELSE clause</div></div>
									<div class="assembly-row-combined"><div>205B</div><div>OR A <span class="opcode2">B7</span></div><div>Since
 a LD command does not affect the flags, OR A is commonly used to set 
the flags based on A.  This is to check to see if this is the end of the
 BASIC line</div></div>
									<div class="assembly-row-combined"><div>205C</div><div>RET Z <span class="opcode2">C8</span></div><div>If this is the end of the BASIC statement then there isn't going to be an ELSE, so RETurn to CALLer</div></div>
									<div class="assembly-row-combined" id="205DH"><div>205D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>205E-205F</div><div>CP 95H <span class="origrom2">CP $ELSE</span>  <span class="opcode2">FE 95</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is an <span class="code">ELSE</span>
 token.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.	</div></div>
									<div class="assembly-row-combined"><div>2060-2061</div><div><a href="#2058H" class="memory-link">JR NZ,2058H <span class="origrom2">JR NZ,SKPMRF</span></a><span class="opcode2">20 F6</span></div><div>If this wasn't an ELSE then we are still in the THEN clause, so loop back to 2058H until an <span class="code">ELSE</span> token is found</div></div>
									<div class="assembly-row-combined"><div>2062</div><div>DEC D <span class="opcode2">15</span></div><div>Decrement the number of ELSE statements that have been found</div></div>
									<div class="assembly-row-combined"><div>2063-2064</div><div><a href="#2058H" class="memory-link">JR NZ,2058H <span class="origrom2">JR NZ,SKPMRF</span></a><span class="opcode2">20 F3</span></div><div>If that DEC didn't hit ZERO, then we haven't found them all, so loop back to 2058H until all of the <span class="code">ELSE</span> tokens have been found</div></div>
									<div class="assembly-row-combined"><div>2065-2066</div><div><a href="#204FH" class="memory-link">JR 204FH <span class="origrom2">JR DOCOND</span></a><span class="opcode2">18 E8</span></div><div>If we are here, then we have found the right ELSE statement!  Jump to 204FH to evaluate the rest of the expression</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2067H">2067-206E - LEVEL II BASIC LPRINT ROUTINE - FOR v1.0 ONLY <span class="origrom">- "LPRINT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2067-2068 <span class="origrom2">LPRINT</span></div><div>LD A,01H <span class="opcode2">3E 01</span></div><div>Load Register A with the output device code for the printer</div></div>
									<div class="assembly-row-combined"><div>2069-206B</div><div>LD (409CH),A <span class="origrom2">LD (PRTFLG),A</span>  <span class="opcode2">32 9C 40</span></div><div>Save the value in Register A as the current output device type number (-1=cassette, 0=video; or 1=printer)</div></div>
									<div class="assembly-row-combined"><div>206C-206E</div><div><a href="#209BH" class="memory-link">JP 209BH <span class="origrom2">JP NEWCHR</span></a><span class="opcode2">C3 9B 20</span></div><div>Jump to 209BH to analyze the rest of the statement</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="206FH">206F-2177 - LEVEL II BASIC PRINT@ ROUTINE - FOR v1.0 ONLY <span class="origrom">- "PRINT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>206F-2071 <span class="origrom2">PRINT</span></div><div>CALL 41CAH <span class="origrom2">CALL FILGET</span>  <span class="opcode2">CD CA 41</span></div><div>Do a DOS Vector call in case this is to go to a disk file</div></div>
									<div class="assembly-row-combined"><div>2072-2073</div><div>CP 40H <span class="opcode2">FE 40</span></div><div>Check the character at the location of the current BASIC program pointer in Register A to see if it's an <span class="code">@</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.	</div></div>
									<div class="assembly-row-combined"><div>2074-2075</div><div><a href="#208FH" class="memory-link">JR NZ,208FH <span class="origrom2">JR NZ,PNOTAT</span></a><span class="opcode2">20 19</span></div><div>Jump to 208FH if the character at the location of the current BASIC program pointer in Register A isn't an <span class="code">@</span></div></div>
									<div class="assembly-row-combined"><div>2076-2078</div><div><a href="#2B01H" class="memory-link">CALL 2B01H <span class="origrom2">CALL GETINT</span></a><span class="opcode2">CD 01 2B</span></div><div>GOSUB to 2B01H to evaluate the <span class="code">PRINT@</span> expression (which is at the location of the current BASIC program pointer in HL and return with the result in DE)</div></div>
									<div class="assembly-row-combined"><div>2079-207A</div><div>CP 04 <span class="opcode2">FE 04</span></div><div>Check
 to see if the location in DE is greater than 1023H.  If they match, the
 Z FLAG is set, and otherwise the NZ FLAG is set.  If A &lt; the checked
 value, then the C FLAG is set.  If A &gt;= the checked value, the NC 
FLAG is set.	</div></div>
									<div class="assembly-row-combined"><div>207B-207D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E4AH" class="memory-link">JP NC,1E4AH <span class="origrom2">JP NC,FCERR</span></a><span class="opcode2">D2 4A 1E</span></div><div>If that check resulted in no CARRY flag, jump to 1E4AH to show a <span class="code">?FC error</span></div></div>
									<div class="assembly-row-combined"><div>207E</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Push the current code string address (held in HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>207F-2081</div><div>LD HL,3C00H <span class="opcode2">21 00 3C</span></div><div>Load HL with the start of the display area</div></div>
									<div class="assembly-row-combined"><div>2082</div><div>ADD HL,DE <span class="opcode2">19</span></div><div>Add DE to HL so that HL now will be the start of the diplay area PLUS the <span class="code">PRINT@</span> offset position</div></div>
									<div class="assembly-row-combined"><div>2083-2085</div><div>LD (4020H),HL <span class="origrom2">LD (CURSOR),HL</span>  <span class="opcode2">22 20 40</span></div><div>Store the cursor position of the screen address matching the <span class="code">PRINT@</span>
 position into the display DCB held in memory location 4020H (which 
holds the video memory address of the current cursor position)</div></div>
									<div class="assembly-row-combined"><div>2086</div><div>LD A,E <span class="opcode2">7B</span></div><div>E is the current position within the line</div></div>
									<div class="assembly-row-combined"><div>2087-2088</div><div>AND 3FH<span class="origrom2">AND 00111111</span> <span class="opcode2">E6 3F</span></div><div>Make it not exceed 63 and then save it</div></div>
									<div class="assembly-row-combined"><div>2089</div><div>LD (40A6H),A <span class="origrom2">LD (TTYPOS),A</span>  <span class="opcode2">32 A6 40</span></div><div>. into the current cursor offset (which is held in 40A6H)</div></div>
									<div class="assembly-row-combined"><div>208C</div><div>POP HL <span class="opcode2">E1</span></div><div>Restore the code string address to HL</div></div>
									<div class="assembly-row-combined"><div>208D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 2C</a><span class="opcode2">CF 2C</span></div><div>At this point we have a <span class="code">PRINT@nnnn</span> so the only valid next character is a <span class="code">,</span> so we need to call RST 08H to check against 2C, the code for comma.<br><br><span class="bold nobottomborder">NOTE:</span>
 The RST 08H routine compares the symbol in the input string pointed to 
by HL Register to the value in the location following the RST 08 call.<ul><li>If
 there is a match, control is returned to the next execution address 
(i.e, the RST 08H instruction + 2) with the next symbol in the A 
Register and HL incremented by one.</li><li>If the two characters do not match, a syntax error message is given and control returns to the Input Phase).</li></ul></div></div>
									<div class="assembly-row-combined" id="208FH"><div>208F <span class="origrom2">PNOTAT</span></div><div>CP 23H <span class="opcode2">FE 23</span></div><div>We also need to look for a <span class="code">#</span>
 character.  If they match, the Z FLAG is set, and otherwise the NZ FLAG
 is set.  If A &lt; the checked value, then the C FLAG is set.  If A 
&gt;= the checked value, the NC FLAG is set.	</div></div>
									<div class="assembly-row-combined"><div>2091</div><div><a href="#209BH" class="memory-link">JR NZ,209BH <span class="origrom2">JR NZ,PNOTCS</span></a><span class="opcode2">20 08</span></div><div>If it is not a <span class="code">#</span> character (meaning this is not a <span class="code">PRINT#</span> , jump to 209BH</div></div>
									<div class="assembly-row-combined"><div>2093</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0284H" class="memory-link">CALL 0284H <span class="origrom2">CALL CWRTON</span></a><span class="opcode2">CD 84 02</span></div><div>If we are here, we had a <span class="code">PRINT#</span> so GOSUB to 0284H to analyze the rest of the string</div></div>
									<div class="assembly-row-combined"><div>2096</div><div>LD A,80H <span class="opcode2">3E 80</span></div><div>Set A to 80H (the write to cassette flag)</div></div>
									<div class="assembly-row-combined"><div>2098</div><div>LD (409CH),A <span class="origrom2">LD (PRTFLG),A</span>  <span class="opcode2">32 9C 40</span></div><div>Load the cassette flag at (409CH) with 80H</div></div>
									<div class="assembly-row-combined" id="209BH"><div>209B <span class="origrom2">NEWCHR</span></div><div>DEC HL <span class="opcode2">2B</span></div><div>Backspace over the previous symbol in the input stream</div></div>
									<div class="assembly-row-combined"><div>209C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>Re-analyze the next character in the input stream</div></div>
									<div class="assembly-row-combined"><div>209D</div><div><a href="#20FEH" class="memory-link">CALL Z,20FEH <span class="origrom2">CALL Z,CRDO</span></a><span class="opcode2">CC FE 20</span></div><div>If
 that test resulted in a zero, GOSUB to 20FEH to print a carriage 
return/end of statement and then flush the line to the device</div></div>
									<div class="assembly-row-combined" id="20A0H"><div>20A0 <span class="origrom2">PRINTC</span></div><div><a href="#2169H" class="memory-link">JP Z,2169H <span class="origrom2">JP Z,FINPRT</span></a><span class="opcode2">CA 69 21</span></div><div>Jump to 2169H to write the sync bytes and clear output</div></div>
									<div class="assembly-row-combined"><div>20A3</div><div>CP 0BFH <span class="origrom2">CP USINTK</span>  <span class="opcode2">FE BF</span></div><div>Check to see if we have a <span class="code">USING</span>
 token.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.	</div></div>
									<div class="assembly-row-combined"><div>20A5</div><div><a href="#2CBDH" class="memory-link">JP Z,2CBDH <span class="origrom2">JP Z,PRINUS</span></a><span class="opcode2">CA BD 2C</span></div><div>. if so, go to the PRINUS handler routine to continue processing</div></div>
									<div class="assembly-row-combined"><div>20A8</div><div>CP BCH <span class="origrom2">CP TABTK</span>  <span class="opcode2">FE BC</span></div><div>Test for a <span class="code">TAB</span>
 token.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.	</div></div>
									<div class="assembly-row-combined"><div>20AA</div><div><a href="#2137H" class="memory-link">JP Z,2137H <span class="origrom2">JP Z,TABER</span></a><span class="opcode2">CA 37 21</span></div><div>and if it is a <span class="code">TAB</span> token (meaning the command is <span class="code">PRINT TAB</span> , jump down to 2137H</div></div>
									<div class="assembly-row-combined"><div>20AD</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Continuing on a <span class="code">PRINT#</span> , save the current position in the BASIC program being processed to the top of the STACK</div></div>
									<div class="assembly-row-combined"><div>20AE</div><div>CP 2CH <span class="opcode2">FE 2C</span></div><div>Test for a <span class="code">,</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.	</div></div>
									<div class="assembly-row-combined"><div>20B0</div><div><a href="#2108H" class="memory-link">JP Z,2108H <span class="origrom2">JP Z,COMPRT</span></a><span class="opcode2">CA 08 21</span></div><div>If there is a comma, jump down to 2108H to get the next item</div></div>
									<div class="assembly-row-combined"><div>20B3</div><div>CP 3BH <span class="opcode2">FE 3B</span></div><div>Since its not a comma, next we need to check for a <span class="code">;</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>20B5</div><div><a href="#2164H" class="memory-link">JP Z,2164H <span class="origrom2">JP Z,NOTABR</span></a><span class="opcode2">CA 64 21</span></div><div>If it is a <span class="code">;</span> , jump down to 2164H to process</div></div>
									<div class="assembly-row-combined"><div>20B8</div><div>POP BC <span class="opcode2">C1</span></div><div>It wasn't a <span class="code">,</span> or a <span class="code">;</span> so we just discard the old pointer to the BASIC line bring processed</div></div>
									<div class="assembly-row-combined"><div>20B9</div><div><a href="#2337H" class="memory-link">CALL 2337H <span class="origrom2">CALL FRMEVL</span></a><span class="opcode2">CD 37 23</span></div><div>Get the address or value of the next item to be printed by calling the formula evaluator at 2337H</div></div>
									<div class="assembly-row-combined"><div>20BC</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the location on the BASIC line being processed to the top of the STACK</div></div>
									<div class="assembly-row-combined"><div>20BD</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H <span class="origrom2">GETYPE</span></a><span class="opcode2">E7</span></div><div>Check its data type with a call to RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
 The RST 20H routine determines the type of the current value in 
ACCumulator and returns a combination of STATUS flags and unique numeric
 values in the A Register according to the data mode flag (40AFH).  The 
results are returned as follows:<br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>20BE</div><div><a href="#20F2H" class="memory-link">JR Z,20F2H <span class="origrom2">JR Z,STRDON</span></a><span class="opcode2">28 32</span></div><div>If it is a string, jump down to 20F2H to handle that case</div></div>
									<div class="assembly-row-combined"><div>20C0</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0FBDH" class="memory-link">CALL 0FBDH <span class="origrom2">CALL FOUT</span></a><span class="opcode2">CD BD 0F</span></div><div>GOSUB to the routine at 0FBDH to convert the number to an ASCII string and move to the print buffer</div></div>
									<div class="assembly-row-combined"><div>20C3</div><div><a href="#2865H" class="memory-link">CALL 2865H <span class="origrom2">CALL STRLIT</span></a><span class="opcode2">CD 65 28</span></div><div>GOSUB to the routine at 2865H to build a literal string pool entry for the ASCII number</div></div>
									<div class="assembly-row-combined"><div>20C6</div><div>CALL 41CDH <span class="origrom2">CALL EXDSKL</span>  <span class="opcode2">CD CD 41</span></div><div>GOSUB to DOS to see if DOS wants to do anything here</div></div>
									<div class="assembly-row-combined"><div>20C9</div><div>LD HL,(4121H) <span class="origrom2">LD HL,(FACLO)</span>  <span class="opcode2">2A 21 41</span></div><div>Put the address of the pointer to the current print string into HL</div></div>
									<div class="assembly-row-combined"><div>20CC</div><div>LD A,(409CH) <span class="origrom2">LD A,(PRTFLG)</span>  <span class="opcode2">3A 9C 40</span></div><div>Get the output device type flag and put it into A.<br><ul><li>Note: 409CH holds the current output device type number (-1=cassette, 0=video; or 1=printer)</li></ul></div></div>
									<div class="assembly-row-combined"><div>20CF</div><div>OR A <span class="opcode2">B7</span></div><div>Since
 a LD command does not affect the flags, OR A is commonly used to set 
the flags based on A.  This is to test the output device type flag</div></div>
									<div class="assembly-row-combined"><div>20D0</div><div><a href="#20E9H" class="memory-link">JP M,20E9H <span class="origrom2">JP M,LINCH2</span></a><span class="opcode2">FA E9 20</span></div><div>If we writing to a cassette (i.e., <span class="code">PRINT#</span> ) jump to 20E9H</div></div>
									<div class="assembly-row-combined"><div>20D3</div><div><a href="#20DDH" class="memory-link">JR Z,20DDH <span class="origrom2">JP Z,ISTTY</span></a><span class="opcode2">28 08</span></div><div>If, instead, we do NOT have a <span class="code">LPRINT</span> , jump down to 20DDH</div></div>
									<div class="assembly-row-combined"><div>20D5-20D7</div><div>LD A,(409BH) <span class="origrom2">LD A,(LPTPOS)</span>  <span class="opcode2">3A 9B 40</span></div><div>If we are here, we have a <span class="code">LPRINT</span> so load A with the current carriage position.<br>Note: 409BH holds the printer carriage position</div></div>
									<div class="assembly-row-combined"><div>20D8 <span class="origrom2">LPTCD2</span></div><div>ADD A,(HL) <span class="opcode2">86</span></div><div>Add
 the length of the string to be sent to the printer at the location of 
the memory pointer in HL to the current carriage position in Register A</div></div>
									<div class="assembly-row-combined"><div>20D9-20DA</div><div>CP 84H <span class="origrom2">CP LPTLEN</span>  <span class="opcode2">FE 84</span></div><div>Check
 to see if the adjusted length in Register A is greater than 132.  If 
they match, the Z FLAG is set, and otherwise the NZ FLAG is set.  If A 
&lt; the checked value, then the C FLAG is set.  If A &gt;= the checked 
value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>20DB-20DC</div><div><a href="#20E6H" class="memory-link">JR 20E6H <span class="origrom2">JR LINCHK</span></a><span class="opcode2">18 09</span></div><div>Jump forward to 20E6H</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="20DDH">20DDH - LEVEL II BASIC PRINT@ ROUTINE - Jumped here if we are sure we are using the display <span class="origrom">- "ISTTY"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="20DDH"><div>20DD-20DF <span class="origrom2">ISTTY</span></div><div>LD A,(409DH) <span class="origrom2">LD A,(LINLEN)</span>  <span class="opcode2">3A 9D 40</span></div><div>Load Register A with the video line size.<br>Note: 409DH holds the size of line on the video display</div></div>
									<div class="assembly-row-combined"><div>20E0</div><div>LD B,A <span class="opcode2">47</span></div><div>Load Register B with the video line size in Register A</div></div>
									<div class="assembly-row-combined"><div>20E1-20E3</div><div>LD A,(40A6H) <span class="origrom2">LD A,(TTYPOS)</span>  <span class="opcode2">3A A6 40</span></div><div>Load Register A with the current video line position.<br>Note: 40A6H holds the current cursor line position</div></div>
									<div class="assembly-row-combined"><div>20E4</div><div>ADD A,(HL) <span class="opcode2">86</span></div><div>Add
 the length of the string to be sent to the video display at the 
location of the memory pointer in HL to the value of the current video 
line position in Register A</div></div>
									<div class="assembly-row-combined"><div>20E5 <span class="origrom2">LINPT3</span></div><div>CP B <span class="opcode2">B8</span></div><div>Check
 to see if the length in Register A is greater than the video line 
length.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined" id="20E6H"><div>20E6-20E8 <span class="origrom2">LINCHK</span></div><div><a href="#20FEH" class="memory-link">CALL NC,20FEH <span class="origrom2">CALL NC,CRDO</span></a><span class="opcode2">D4 FE 20</span></div><div>If NC is set, the new line will overflow the buffer so send a carriage return to the current output device</div></div>
									<div class="assembly-row-combined" id="20E9H"><div>20E9-20EB <span class="origrom2">LINCH2</span></div><div><a href="#28AAH" class="memory-link">CALL 28AAH <span class="origrom2">CALL STRPRT</span></a><span class="opcode2">CD AA 28</span></div><div>Go send the string to the current output device</div></div>
									<div class="assembly-row-combined"><div>20EC-20ED</div><div>LD A,20H <span class="opcode2">3E 20</span></div><div>Load Register A with a <kbd>SPACE</kbd> </div></div>
									<div class="assembly-row-combined"><div>20EE-20F0</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go send the space in Register A to the current output device</div></div>
									<div class="assembly-row-combined"><div>20F1</div><div>OR A <span class="opcode2">B7</span></div><div>Since
 a LD command does not affect the flags, OR A is commonly used to set 
the flags based on A.  This is to check to see if Register A is equal to
 zero</div></div>
									<div class="assembly-row-combined" id="20F2H"><div>20F2-20F4 <span class="origrom2">STRDON</span></div><div><a href="#28AAH" class="memory-link">CALL Z,28AAH <span class="origrom2">CALL Z,STRPRT</span></a><span class="opcode2">CC AA 28</span></div><div>If necessary go send the string to the current output device</div></div>
									<div class="assembly-row-combined"><div>20F5</div><div>POP HL <span class="opcode2">E1</span></div><div>Restore the current code string to HL</div></div>
									<div class="assembly-row-combined"><div>20F6-20F8</div><div>*<a href="#209BH" class="memory-link">JP 209BH <span class="origrom2">JP NEWCHR</span></a><span class="opcode2">C3 9B 20</span></div><div>For ROM v1.0 - Loop to 209BH until an end of statement code is found. Going to 209BH parses only for <span class="code">PRINT TAB</span> or <span class="code">PRINT #</span> , but not <span class="code">PRINT @</span> , so it was not possible, under ROM v1.0, to have a <span class="code">PRINT@</span> appear later in a <span class="code">PRINT</span> command than a <span class="code">PRINT TAB</span> or <span class="code">PRINT #</span></div></div>
									<div class="assembly-row-combined"><div>*20F6-20F8</div><div><a href="#207CH" class="memory-link">JP 207CH</a></div><div>For ROM v1.2 - Loop to 207CH until an end of statement code is found. Going all the way back to 207CH will also test for a <span class="code">PRINT @</span> , thus permitting a <span class="code">PRINT @</span> to appear other than first</div></div>
									<div class="assembly-row-combined" id="20F9H"><div>20F9-20FB <span class="origrom2">CRDONZ</span></div><div>LD A,(40A6H) <span class="origrom2">LD A,(TTYPOS)</span>  <span class="opcode2">3A A6 40</span></div><div>Load Register A with the number of characters printed on the current line.<br>Note: 40A6H holds the current cursor line position</div></div>
									<div class="assembly-row-combined"><div>20FC</div><div>OR A <span class="opcode2">B7</span></div><div>Since
 a LD command does not affect the flags, OR A is commonly used to set 
the flags based on A.  This is to check to see if any characters have 
been printed on the current line</div></div>
									<div class="assembly-row-combined"><div>20FD</div><div>RET Z <span class="opcode2">C8</span></div><div>Return out of this routine if we are at the start of a line</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="20FEH">20FE - This routine outputs a carriage return (0DH) to a device determined by flag stored at (409CH) <span class="origrom">- "CRDO"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>NOTE: This routine may be CALLed at 20F9H, in which case it 
will not perform the above action if the video display cursor is already
 positioned at the beginning of a line, as determined by checking the 
contents of the cursor position flag at 40A6H (if zero, cursor is at 
start of line). This routine CALLs the routine at 032AH and also CALLs a
 Disk BASIC link at 41D0H.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="20FEH"><div>20FE-20FF <span class="origrom2">CRDO</span></div><div>LD A,0DH <span class="opcode2">3E 0D</span></div><div>Otherwise, we need to skip to the next line so load Register A with a carriage return</div></div>
									<div class="assembly-row-combined" id="2100H"><div>2100-2102</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go send the carriage return in Register A to the current output device</div></div>
									<div class="assembly-row-combined"><div>2103-2105 <span class="origrom2">CRFIN</span></div><div>CALL 41D0H <span class="origrom2">CALL EXDSCR</span>  <span class="opcode2">CD D0 41</span></div><div>GOSUB to the DOS routine at 41D0H to deal with screen wrap</div></div>
									<div class="assembly-row-combined"><div>2106</div><div>XOR A <span class="opcode2">AF</span></div><div>Zero Register A and the carry flags</div></div>
									<div class="assembly-row-combined"><div>2107</div><div>RET <span class="opcode2">C9</span></div><div>Return back to the calling routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2108H">2108 - This is the jump point for a continuation of the <span class="code">PRINT#</span> code <span class="origrom">- "COMPRT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2108-210A <span class="origrom2">COMPRT</span></div><div>CALL 41D3H <span class="origrom2">CALL EXPDOS</span>  <span class="opcode2">CD D3 41</span></div><div>Jump to DOS to see if DOS wants to modify the behavior</div></div>
									<div class="assembly-row-combined"><div>210B-210D</div><div>LD A,(409CH) <span class="origrom2">LD A,(PRTFLG)</span>  <span class="opcode2">3A 9C 40</span></div><div>Load Register A with the value of the current output device flag.<br><ul><li>Note: 409CH holds the current output device type number (-1=cassette, 0=video; or 1=printer)</li></ul></div></div>
									<div class="assembly-row-combined"><div>210E</div><div>OR A <span class="opcode2">B7</span></div><div>Test the value of the current output device flag in Register A.<br><ul><li>M will be set if the value in A is negative.</li><li>P will be set if the value in A is positive or zero.</li></ul></div></div>
									<div class="assembly-row-combined"><div>210F-2111</div><div><a href="#2119H" class="memory-link">JP P,2119H <span class="origrom2">JP P,NTCAS</span></a><span class="opcode2">F2 19 21</span></div><div>Jump down a few instructions to 2119H if the printer or the video display is the current output device</div></div>
									<div class="assembly-row-combined"><div>2112-2113</div><div>LD A,2CH <span class="opcode2">3E 2C</span></div><div>So now that we know the current device is cassette, we will load Register A with a <span class="code">,</span></div></div>
									<div class="assembly-row-combined"><div>2114-2116</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Send the <span class="code">,</span>
 in Register A to current output device.  In this case, it is the 
cassette recorder because we otherwise would have jumped away at 210FH</div></div>
									<div class="assembly-row-combined"><div>2117-2118</div><div><a href="#2164H" class="memory-link">JR 2164H <span class="origrom2">CALL NOTABR</span></a><span class="opcode2">18 4B</span></div><div>Jump forward to 2164H to fetch the next character from the code string</div></div>
									<div class="assembly-row-combined" id="2119H"><div>2119-211A <span class="origrom2">NTCAS</span></div><div><a href="#2123H" class="memory-link">JR Z,2123H <span class="origrom2">JR Z,ISCTTY</span></a><span class="opcode2">28 08</span></div><div>We
 landed here from 210FH knowing that the current output device flag was 
either video or printer. Now we need to break that down too, so if the 
device flag is the video display, jump down to 2123H</div></div>
									<div class="assembly-row-combined"><div>211B-211D <span class="origrom2">LPTCD3</span></div><div>LD A,(409BH) <span class="origrom2">LD A,(LPTPOS)</span>  <span class="opcode2">3A 9B 40</span></div><div>We're here because the output device is a printer. First, load Register A with the current carriage position.<br>Note: 409BH holds the printer carriage position</div></div>
									<div class="assembly-row-combined"><div>211E-211F <span class="origrom2">NLPPOS</span></div><div>CP 70H <span class="origrom2">CP NLPPOS</span>  <span class="opcode2">FE 70</span></div><div>Check
 to see if the current carriage position in Register A is greater than 
112.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2120-2122</div><div><a href="#212BH" class="memory-link">JP 212BH <span class="origrom2">JP CHKCOM</span></a><span class="opcode2">C3 2B 21</span></div><div>Jump forward a few instructions to 212BH</div></div>
									<div class="assembly-row-combined" id="2123H"><div>2123-2125 <span class="origrom2">ISCTTY</span></div><div>LD A,(409EH) <span class="origrom2">LD A,(CLMLST)</span>  <span class="opcode2">3A 9E 40</span></div><div>We were jumped to this point because the output device is the video display. So load Register A with the video line length.<br>Note: 409EH holds the size of line on the printer</div></div>
									<div class="assembly-row-combined"><div>2126</div><div>LD B,A <span class="opcode2">47</span></div><div>Load Register B with the video line length in Register A</div></div>
									<div class="assembly-row-combined"><div>2127-2129</div><div>LD A,(40A6H) <span class="origrom2">LD A,(TTYPOS)</span>  <span class="opcode2">3A A6 40</span></div><div>Load Register A with the current video line position.<br>Note: 40A6H holds the current cursor line position</div></div>
									<div class="assembly-row-combined"><div>212A <span class="origrom2">NCMPOS</span></div><div>CP B <span class="opcode2">B8</span></div><div>Test
 to see if there is room on this line by checking to see if the current 
video line position in Register A is equal to the video line length in 
Register B.  If they match, the Z FLAG is set, and otherwise the NZ FLAG
 is set.  If A &lt; the checked value, then the C FLAG is set.  If A 
&gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined" id="212BH"><div>212B-212D <span class="origrom2">CHKCOM</span></div><div><a href="#20FEH" class="memory-link">CALL NC,20FEH <span class="origrom2">CALL NC,CRDO</span></a><span class="opcode2">D4 FE 20</span></div><div>If
 the NC is set, there is no room on the current line, so we need to 
GOSUB to 20FEH to print a carriage return on the current output device</div></div>
									<div class="assembly-row-combined" id="212EH"><div>212E-212F</div><div><a href="#2164H" class="memory-link">JR NC,2164H <span class="origrom2">JR NC,NOTABR</span></a><span class="opcode2">30 34</span></div><div>If we are beyond the last comma field, quit via a JUMP to 2164H</div></div>
									<div class="assembly-row-combined" id="2130H"><div>2130-2131 <span class="origrom2">MORCOM</span></div><div>SUB 10H <span class="origrom2">SUB CLMWID</span>  <span class="opcode2">D6 10</span></div><div>Calculate A MOD CLDMWID to see if there are at least 16 spaces left on the current line for the current output device</div></div>
									<div class="assembly-row-combined" id="2132H"><div>2132-2133</div><div><a href="#2130H" class="memory-link">JR NC,2130H <span class="origrom2">JR NC,MORCOM</span></a><span class="opcode2">30 FC</span></div><div>Loop back until there are at least 16 spaces left on the current line</div></div>
									<div class="assembly-row-combined"><div>2134</div><div>CPL <span class="opcode2">2F</span></div><div>Figure the number of spaces to be sent to the current output device so that we have an even CLMWID</div></div>
									<div class="assembly-row-combined"><div>2135-2136</div><div><a href="#215AH" class="memory-link">JR 215AH <span class="origrom2">JR ASPA2</span></a><span class="opcode2">18 23</span></div><div>Jump to 215AH to print Register A + 1 number of spaces/blanks</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2137H">2137 - TAB logic <span class="origrom">- "TABER"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine is the TAB function for video or printer 
(determined by flag at 409CH). On entry: E Register contains desired TAB
 position, HL points to start of message to be displayed (or zero byte 
if no message). This routine does extensive string processing and may 
not be the most efficient method of achieving the desired result, 
particularly if it is desired only to tab over a number of spaces. Also,
 this routine CALLs several Disk BASIC links which may have to be 
"plugged". 2169 - Reset device type flag at 409CH to zero (output to 
video display), also turns off cassette drive if necessary. CALLs Disk 
BASIC link at 41BEH prior to return.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2137H"><div>2137-2139 <span class="origrom2">TABER</span></div><div><a href="#2B1BH" class="memory-link">CALL 2B1BH <span class="origrom2">CALL GTBYTC</span></a><span class="opcode2">CD 1B 2B</span></div><div>GOSUB
 forward to 2B1BH to evaluate the tab number at the location of the 
current BASIC program pointer in HL and return with the result in 
Register A</div></div>
									<div class="assembly-row-combined"><div>213A-213B</div><div>AND 3FH<span class="origrom2">AND 00111111</span> <span class="opcode2">E6 3F</span></div><div>The results are in A so mask the tab number in Register A so that it doesn't exceed 63</div></div>
									<div class="assembly-row-combined"><div>213C</div><div>LD E,A <span class="opcode2">5F</span></div><div>Load Register E with the value of the tab number from Register A</div></div>
									<div class="assembly-row-combined"><div>213D-213E</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 29</a><span class="origrom2">SNCHK ")"</span>  <span class="opcode2">CF 29</span></div><div>At this point, we have a <span class="code">TAB(nn</span> , so the next character needs to be a <span class="code">)</span>
 . Since the character at the location of the current BASIC program 
pointer in HL must be a ")", call the COMPARE SYMBOL at RST 08H.<br><br><span class="bold nobottomborder">NOTE:</span>
 The RST 08H routine compares the symbol in the input string pointed to 
by HL Register to the value in the location following the RST 08 call.<ul><li>If
 there is a match, control is returned to the next execution address 
(i.e, the RST 08H instruction + 2) with the next symbol in the A 
Register and HL incremented by one.</li><li>If the two characters do not match, a syntax error message is given and control returns to the Input Phase).</li></ul></div></div>
									<div class="assembly-row-combined"><div>213F</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the current BASIC program pointer in HL so that it points to the <span class="code">(</span></div></div>
									<p class="debug-note"></p><ul><li>NOTE 1: The cursor position 
cannot be moved backward by this procedure. If n is not greater than the
 current cursor position on the line, no change will occur.</li><li>NOTE
 2: To locate the cursor at a given position on the screen (the function
 of the PRINT@ command in BASIC), the simplest procedure is to modify 
the cursor position bytes, which are located at 4020H-4021H. The address
 contained in these memory cells is that of the position in video memory
 (3C00H-3FFFH) at which the (abstract) cursor resides. This cursor 
position controls subsequent printing via the subroutine at 28A7H</li><li>DISK
 SYSTEM CAUTION: The subroutine at 213FH has three exits to DISK BASIC, 
with RAM transfer points at 41BEH, 41C1H, and 41D3H. To use this routine
 safely, either be certain that DISK BASIC is in place, or have your 
assembly language program fill locations 41BEH, 41C1H, and 41D3H with 
RET's (C9H), before calling the routine.</li></ul><p></p>
									<div class="assembly-row-combined"><div>2140</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2141</div><div>CALL 41D3H <span class="origrom2">CALL EXPDOS</span>  <span class="opcode2">CD D3 41</span></div><div>Jump to DOS to see if DOS wants to modify the behavior</div></div>
									<div class="assembly-row-combined"><div>2144-2146</div><div>LD A,(409CH) <span class="origrom2">LD A,(PRTFLG)</span>  <span class="opcode2">3A 9C 40</span></div><div>Load Register A with the value of the current output device flag.<br><ul><li>Note: 409CH holds the current output device type number (-1=cassette, 0=video; or 1=printer)</li></ul></div></div>
									<div class="assembly-row-combined"><div>2147</div><div>OR A <span class="opcode2">B7</span></div><div>Test the value of the current output device flag in Register A.  A NZ means line printer</div></div>
									<div class="assembly-row-combined"><div>2148-214A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E4AH" class="memory-link">JP M,1E4AH <span class="origrom2">JP M,FCERR</span></a><span class="opcode2">FA 4A 1E</span></div><div>Since you cannot send a tab to the cassette, display a <span class="code">?FC ERROR</span> message if the current output device is the cassette recorder</div></div>
									<div class="assembly-row-combined"><div>214B-214D</div><div><a href="#2153H" class="memory-link">JP Z,2153H <span class="origrom2">JP Z,TTYIST</span></a><span class="opcode2">CA 53 21</span></div><div>Jump forward a few instructions to 2153H if the current output device is the video display</div></div>
									<div class="assembly-row-combined"><div>214E-2150</div><div>LD A,(409BH) <span class="origrom2">LD A,(LPTPOS)</span>  <span class="opcode2">3A 9B 40</span></div><div>Since
 we have already jumped away if the current output device is to cassette
 or screen, if we are here we know that this is to go to the printer, so
 load Register A with the current carriage position.<br>Note: 409BH holds the printer carriage position</div></div>
									<div class="assembly-row-combined"><div>2151-2152</div><div><a href="#2156H" class="memory-link">JR 2156H <span class="origrom2">JR DOSIZT</span></a><span class="opcode2">18 03</span></div><div>Jump over the next instruction (which is a video instruction)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2153H">2153H - Displaying to Screen <span class="origrom">- "TTYIST"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2153-2155 <span class="origrom2">TTYIST</span></div><div>LD A,(40A6H) <span class="origrom2">LD A,(TTYPOS)</span>  <span class="opcode2">3A A6 40</span></div><div>Load Register A with the current video line position.<br>Note: 40A6H holds the current cursor line position</div></div>
									<div class="assembly-row-combined" id="2156H"><div>2156 <span class="origrom2">DOSIZT</span></div><div>CPL <span class="opcode2">2F</span></div><div>When
 we land here, A holds either the current carriage position (printer) or
 the current line position (video). Regardless, complement (make 
negative) that value in preparation to determine how many spaces to 
print (which would be Register E - Register A)</div></div>
									<div class="assembly-row-combined"><div>2157</div><div>ADD A,E <span class="opcode2">83</span></div><div>Add the tab number in Register B to the adjusted line position in Register A so that A=-current position + tab</div></div>
									<div class="assembly-row-combined" id="2158H"><div>2158-2159</div><div><a href="#2164H" class="memory-link">JR NC,2164H <span class="origrom2">JR NC,NOTABR</span></a><span class="opcode2">30 0A</span></div><div>If
 we we have a negative number of spaces to print, then we aren't going 
to print any, so jump forward a few instructions to 2164H to skip over 
the actual TAB effectuation routine</div></div>
									<div class="assembly-row-combined" id="215AH"><div>215A <span class="origrom2">ASPA2</span></div><div>INC A <span class="opcode2">3C</span></div><div>Bump the number of spaces to be printed in Register A</div></div>
									<div class="assembly-row-combined"><div>215B <span class="origrom2">ASPAC</span></div><div>LD B,A <span class="opcode2">47</span></div><div>Load Register B with the number of spaces to be printed in Register A</div></div>
									<div class="assembly-row-combined"><div>215C-215D</div><div>LD A,20H <span class="opcode2">3E 20</span></div><div>Load Register A with a <kbd>SPACE</kbd> </div></div>
									<div class="assembly-row-combined" id="215EH"><div>215E-2160 <span class="origrom2">REPOUT</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Send the space in Register A to the current output device</div></div>
									<div class="assembly-row-combined"><div>2161</div><div>DEC B <span class="opcode2">05</span></div><div>Decrement the number of <kbd>SPACE</kbd> 's to be displayed (counter in Register B)</div></div>
									<div class="assembly-row-combined"><div>2162-2163</div><div><a href="#215EH" class="memory-link">JR NZ,215EH <span class="origrom2">JR NZ,REPOUT</span></a><span class="opcode2">20 FA</span></div><div>Loop back to 215EH until all of the spaces have been displayed/printed</div></div>
									<div class="assembly-row-combined" id="2164H"><div>2164 <span class="origrom2">NOTABR</span></div><div>POP HL <span class="opcode2">E1</span></div><div>Restore the position in of the current BASIC program pointer (from the STACK) into HL</div></div>
									<div class="assembly-row-combined"><div>2165</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2166-2168</div><div><a href="#20A0H" class="memory-link">JP 20A0H <span class="origrom2">JP PRINTC</span></a><span class="opcode2">C3 A0 20</span></div><div>Jump back to 20A0H to process the rest of the <span class="code">PRINT TAB</span> statement</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2169-this-routine">2169 - 
This routine resets the device type flag at 409CH to zero (output to 
video display), also turns off cassette drive if necessary. CALLs Disk 
BASIC link at 41BEH prior to return <span class="origrom">- "FINPRT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2169H"><div>2169-216B <span class="origrom2">FINPRT</span></div><div>LD A,(409CH) <span class="origrom2">LD A,(PRTFLG)</span>  <span class="opcode2">3A 9C 40</span></div><div>If
 we land here, we need to turn off the cassette and reset the current 
output device to be video. To do this we first load Register A with the 
current output device flag.<br><ul><li>Note: 409CH holds the current output device type number (-1=cassette, 0=video; or 1=printer)</li></ul></div></div>
									<div class="assembly-row-combined"><div>216C</div><div>OR A <span class="opcode2">B7</span></div><div>Test the value of the current output device flag in Register A.  If the M flag is set, A was negative</div></div>
									<div class="assembly-row-combined"><div>216D-216F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#01F8H" class="memory-link">CALL M,01F8H <span class="origrom2">CALL M,CTOFF</span></a><span class="opcode2">FC F8 01</span></div><div>If the current output device flag is the cassette recorder, GOSUB to 01F8H to turn it off</div></div>
									<div class="assembly-row-combined"><div>2170</div><div>XOR A <span class="opcode2">AF</span></div><div>Clear Register A (which will set A to 0) and clear the status flags</div></div>
									<div class="assembly-row-combined"><div>2171-2173</div><div>LD (409CH),A <span class="origrom2">LD (PRTFLG),A</span>  <span class="opcode2">32 9C 40</span></div><div>Save the value in Register A (which is 0) as the current value of the output device flag.<br><ul><li>Note: 409CH holds the current output device type number (-1=cassette, 0=video; or 1=printer)</li></ul></div></div>
									<div class="assembly-row-combined"><div>2174</div><div>CALL 41BEH <span class="origrom2">CALL FINDRT</span><span class="opcode2">CD BE 41</span></div><div>GOSUB to DOS to see if DOS wants to do anything here</div></div>
									<div class="assembly-row-combined"><div>2177</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2178H">2178-217E - MESSAGE STORAGE LOCATION FOR REDO MESSAGE <span class="origrom2"><br>- "TRYAGN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2178-217E <span class="origrom2">TRYAGN</span></div><div>"?REDO" + CRLF + 00H</div><div>The ?REDO message is stored here</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="217FH">217F-2285 - LEVEL II BASIC INPUT AND READ ROUTINES <span class="origrom">- "TRMNOK"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is a multi-purpose processing routine.  We can wind up 
here because DATA was typed in or DATA statements were improperly 
formatted.  We can also wind up here where we want an INPUT to start 
again.  If we are here because of a READ, throw a ?SN ERROR at the data 
line.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="217FH"><div>217F-2181 <span class="origrom2">TRMNOK</span></div><div>LD A,(40DEH) <span class="origrom2">LD A,(FLGINP)</span>  <span class="opcode2">3A DE 40</span></div><div>Load Register A with the READ flag to help us try to figure out if this was a READ or an INPUT.<br>Note: 40DEH holds READ flag</div></div>
									<div class="assembly-row-combined"><div>2182</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if the read flag is set.  If Z FLAG then it was INPUT</div></div>
									<div class="assembly-row-combined"><div>2183-2185</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1991H" class="memory-link">JP NZ,1991H <span class="origrom2">JP NZ.DATSNE</span></a><span class="opcode2">C2 91 19</span></div><div>If the read flag is set, go give a <span class="code">?SN ERROR</span></div></div>
									<div class="assembly-row-combined"><div>2186-2188</div><div>LD A,(40A9H) <span class="origrom2">LD A,(CASFLG)</span>  <span class="opcode2">3A A9 40</span></div><div>Now we know the read flag is NOT set, so we need to load Register A with the INPUT type flag.<br>Note: 40A9H holds Cassette input flag</div></div>
									<div class="assembly-row-combined"><div>2189</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if the cassette recorder is the current input device, as we will need to give a FILE DATA error</div></div>
									<div class="assembly-row-combined"><div>218A-218B</div><div>LD E,2AH <span class="opcode2">1E 2A</span></div><div>Load Register E with the <span class="code">?FD ERROR</span> code</div></div>
									<div class="assembly-row-combined"><div>218C-218E</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#19A2H" class="memory-link">JP Z,19A2H <span class="origrom2">JP Z,ERROR</span></a><span class="opcode2">CA A2 19</span></div><div>If the current input device is the cassette recorder, go give a <span class="code">?FD ERROR</span></div></div>
									<div class="assembly-row-combined"><div>218F</div><div>POP BC <span class="opcode2">C1</span></div><div>Clean up the STACK (discards the pointer into the variable list)</div></div>
									<div class="assembly-row-combined"><div>2190-2192 <span class="origrom2">RDOINP</span></div><div>LD HL,2178H <span class="origrom2">LD HL,TRYAGN</span>  <span class="opcode2">21 78 21</span></div><div>Load HL with the starting address of the <span class="code">?REDO</span> message</div></div>
									<div class="assembly-row-combined"><div>2193-2195</div><div>CALL 28A7H <span class="origrom2">CALL STROUT</span><span class="opcode2">CD A7 28</span></div><div>Display the "?REDO FROM START" message</div></div>
									<div class="assembly-row-combined"><div>2196-2198</div><div>LD HL,(40E6H) <span class="origrom2">LD HL,(SAVTXT)</span>  <span class="opcode2">2A E6 40</span></div><div>Get the value of the current BASIC program pointer in HL.<br>Note: 40E6H-40E7H is a common temporary storage location</div></div>
									<div class="assembly-row-combined"><div>2199</div><div>RET <span class="opcode2">C9</span></div><div>Return out of this routine back to NEWSTT of the INPUT statement</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="219AH">219A - INPUT logic <span class="origrom">- "INPUT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>219A-219C <span class="origrom2">INPUT</span></div><div><a href="#2828H" class="memory-link">CALL 2828H <span class="origrom2">CALL ERRDIR</span></a><span class="opcode2">CD 28 28</span></div><div>Check to see if there is an illegal direct in the input statement</div></div>
									<div class="assembly-row-combined"><div>219D</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>219A-219C</div><div><a href="#2828H" class="memory-link">CALL 2828H <span class="origrom2">CALL FILSTI</span></a><span class="opcode2">CD 28 28</span></div><div>Check to see if there is an illegal direct in the input statement</div></div>
									<div class="assembly-row-combined"><div>21A1-21A2</div><div>SUB 23H <span class="opcode2">D6 23</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">#</span></div></div>
									<div class="assembly-row-combined"><div>21A3-21A5</div><div>LD (40A9H),A <span class="origrom2">LD (CASFLG),A</span>  <span class="opcode2">32 A9 40</span></div><div>Set the current input device flag for the cassette recorder.<br>Note: 40A9H holds cassette input flag</div></div>
									<div class="assembly-row-combined"><div>21A6</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>21A7-21A8</div><div><a href="#21C9H" class="memory-link">JR NZ,21C9H <span class="origrom2">JR NZ,INTCAS</span></a><span class="opcode2">20 20</span></div><div>Jump to 21C9H if there is keyboard input</div></div>
									<div class="assembly-row-combined"><div>21A9-21AB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0293H" class="memory-link">CALL 0293H <span class="origrom2">CALL CSRDON</span></a><span class="opcode2">CD 93 02</span></div><div>If we are here, then the input is coming from the cassette, so GOSUB to 0293H to read the cassette leader and find the sync byte</div></div>
									<div class="assembly-row-combined"><div>21AC</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the current BASIC program pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>21AD-21AE</div><div>LD B,FAH <span class="opcode2">06 FA</span></div><div>Load Register B with 250, which is the maximum number of characters which can be read</div></div>
									<div class="assembly-row-combined"><div>21AF-21B1</div><div>LD HL,(40A7H) <span class="origrom2">LD HL,(BUFPNT)</span>  <span class="opcode2">2A A7 40</span></div><div>Load HL with the starting address of the input buffer.<br>Note: 40A7H-40A8H holds the input Buffer pointer</div></div>
									<div class="assembly-row-combined" id="21B2H"><div>21B2-21B4 <span class="origrom2">FILBUF</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0235H" class="memory-link">CALL 0235H <span class="origrom2">CALL CASIN</span></a><span class="opcode2">CD 35 02</span></div><div>Top
 of a DJNZ Loop.  Calls the READ ONE BYTE FROM CASSETTE routine at 0235H
 (which reads one byte from the cassette drive specified in Register A, 
and returns the byte in Register A)</div></div>
									<div class="assembly-row-combined"><div>21B5</div><div>LD (HL),A <span class="opcode2">77</span></div><div>Save the byte read from the cassette recorder in Register A at the location of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>21B6</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>21B7-21B8</div><div>CP 0DH <span class="opcode2">FE 0D</span></div><div>Check
 to see if the character read from the cassette recorder in Register A 
is a carriage return.  If they match, the Z FLAG is set, and otherwise 
the NZ FLAG is set.  If A &lt; the checked value, then the C FLAG is 
set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>21B9-21BA</div><div><a href="#21BDH" class="memory-link">JR Z,21BDH <span class="origrom2">JR Z,ENDREC</span></a><span class="opcode2">28 02</span></div><div>Jump out of this routine if the character read from the cassette recorder in Register A is a carriage return</div></div>
									<div class="assembly-row-combined"><div>21BB-21BC</div><div><a href="#21B2H" class="memory-link">DJNZ 21B2H <span class="origrom2">DJNZ FILBUF</span></a><span class="opcode2">10 F5</span></div><div>Loop back to 21B2H until the input buffer is full</div></div>
									<div class="assembly-row-combined" id="21BDH"><div>21BD <span class="origrom2">ENDREC</span></div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the input buffer pointer in HL to make room in the buffer for a terminator character</div></div>
									<div class="assembly-row-combined"><div>21BE-21BF</div><div>LD (HL),00H <span class="opcode2">36 00</span></div><div>Save a zero (which is a terminator)( at the location of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>21C0-21C2</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#01F8H" class="memory-link">CALL 01F8H <span class="origrom2">CALL CTOFF</span></a><span class="opcode2">CD F8 01</span></div><div>GOSUB to 01F8H to put a 00H at the end of the tape and turn the cassette recorder off</div></div>
									<div class="assembly-row-combined" id="21C3H"><div>21C3-21C5</div><div>LD HL,(40A7H) <span class="origrom2">LD HL,(BUFPNT)</span>  <span class="opcode2">2A A7 40</span></div><div>Load HL with the starting address of the input buffer.<br>Note: 40A7H-40A8H holds the input Buffer pointer</div></div>
									<div class="assembly-row-combined"><div>21C6</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>21C7-21C8</div><div><a href="#21EBH" class="memory-link">JR 21EBH <span class="origrom2">JR INPCN3</span></a><span class="opcode2">18 22</span></div><div>Jump to 21EBH to store a comma there so we can use the READ processing</div></div>
									<div class="assembly-row-combined" id="21DBH"><div>21C9-21CB <span class="origrom2">INTCAS</span></div><div>LD BC,21DBH <span class="origrom2">LD BC,NOTQTI</span>  <span class="opcode2">01 DB 21</span></div><div>Load BC with a return address of 21DBH for where to go when done dealing with a quoted string</div></div>
									<div class="assembly-row-combined"><div>21CC</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the value of the return address in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>21CD-21CE <span class="origrom2">QTINP</span></div><div>CP 22H <span class="opcode2">FE 22</span></div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in Register A is a quote.  If they match, the Z FLAG is set, and
 otherwise the NZ FLAG is set.  If A &lt; the checked value, then the C 
FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>21CF</div><div>RET NZ <span class="opcode2">C0</span></div><div>Return to 21DBH if the character at the location of the current BASIC program pointer in Register A isn't a quote</div></div>
									<div class="assembly-row-combined" id="21D0H"><div>21D0-21D2</div><div><a href="#2866H" class="memory-link">CALL 2866H <span class="origrom2">CALL STRLTI</span></a><span class="opcode2">CD 66 28</span></div><div>Go set up pointers for the prompting message in the temporary string work area</div></div>
									<div class="assembly-row-combined"><div>21D3-21D4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 3B<span class="origrom2">SYNCHK <span class="code">;</span></span></a><span class="opcode2">CF 3B</span></div><div>Since
 the character at the location of the current BASIC program pointer in 
HL must be a ";", call the COMPARE SYMBOL routine at RST 08H.<br><br><span class="bold nobottomborder">NOTE:</span>
 The RST 08H routine compares the symbol in the input string pointed to 
by HL Register to the value in the location following the RST 08 call.<ul><li>If
 there is a match, control is returned to the next execution address 
(i.e, the RST 08H instruction + 2) with the next symbol in the A 
Register and HL incremented by one.</li><li>If the two characters do not match, a syntax error message is given and control returns to the Input Phase).</li></ul></div></div>
									<div class="assembly-row-combined"><div>21D5</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>21D6-21D8</div><div><a href="#28AAH" class="memory-link">CALL 28AAH <span class="origrom2">CALL STRPRT</span></a><span class="opcode2">CD AA 28</span></div><div>Go display the prompting message</div></div>
									<div class="assembly-row-combined"><div>21D9</div><div>POP HL <span class="opcode2">E1</span></div><div>Restore the code string address (from the STACK) into HL</div></div>
									<div class="assembly-row-combined"><div>21DA</div><div>RET <span class="opcode2">C9</span></div><div>Return to 21DBH</div></div>
									<div class="assembly-row-combined" id="21DBH"><div>21DB <span class="origrom2">NOTQTI</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>21DC-21DE <span class="origrom2">GETAGN</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1BB3H" class="memory-link">CALL 1BB3H <span class="origrom2">CALL QINLIN</span></a><span class="opcode2">CD B3 1B</span></div><div>Print the <span class="code">?</span> prompt and get the input from the keyboard</div></div>
									<div class="assembly-row-combined"><div>21DF</div><div>POP BC <span class="opcode2">C1</span></div><div>Remove the value of the current BASIC program pointer from the STACK, as we may be exiting</div></div>
									<div class="assembly-row-combined"><div>21E0-21E2</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1DBEH" class="memory-link">JP C,1DBEH <span class="origrom2">JP C,STPEND</span></a><span class="opcode2">DA BE 1D</span></div><div>The CARRY FLAG will be set if a <kbd>BREAK</kbd> was hit (meaning we got no input).  Jump back to 1DBEH if the <kbd>BREAK</kbd> key was pressed</div></div>
									<div class="assembly-row-combined"><div>21E3</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>21E4</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>21E5</div><div>OR A <span class="opcode2">B7</span></div><div>Test the value of the character at the location of the input buffer pointer in Register A</div></div>
									<div class="assembly-row-combined"><div>21E6</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>21E7</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Since it turns out we didn't exit, put the return address back onto to the STACK</div></div>
									<div class="assembly-row-combined"><div>21E8-21EA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1F04H" class="memory-link">JP Z,1F04H <span class="origrom2">JP Z,DATAH</span></a><span class="opcode2">CA 04 1F</span></div><div>Skip
 to the next statement if the character at the location of the input 
buffer pointer in Register A is an end of the input character (i.e., a <span class="code">CARRIAGE RETURN</span></div></div>
									<div class="assembly-row-combined" id="21EBH"><div>21EB-21EC <span class="origrom2">INPCN3</span></div><div>LD (HL),2CH <span class="opcode2">36 2C</span></div><div>Save a " <span class="code">,</span> " at the location of the current input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>21ED-21EE</div><div><a href="#21F4H" class="memory-link">JR 21F4H <span class="origrom2">JR INPCON</span></a><span class="opcode2">18 05</span></div><div>Jump to 21F4H (which address uses a Z-80 trick)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="21EFH">21EF - <span class="code">READ</span> logic <span class="origrom">- "READ"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>21EF <span class="origrom2">READ</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>21F0-21F2</div><div>LD HL,(40FFH) <span class="origrom2">LD HL,(DATPTR)</span>  <span class="opcode2">2A FF 40</span></div><div>Load HL with the location of the last DATA statement read.<br>Note: 40FFH-4100H holds <span class="code">READ</span> pointer</div></div>
									<div class="assembly-row-combined"><div>21F3-21F4</div><div>OR 0AFH <span class="origrom2">OR 1010 1111</span>  <span class="opcode2">F6 AF</span></div><div>Turn on some bits in Register A to set Register A to a non-zero value if entered from the <span class="code">READ</span> routine and, due to a Z-80 trick, set to zero if entered from the <span class="code">INPUT</span> routine</div></div>
									<div class="assembly-row-combined"><div>21F4 <span class="origrom2">INPCON</span></div><div>XOR A <span class="opcode2">AF</span></div><div>Set the flag to indicate that this is an INPUT</div></div>
									<div class="assembly-row-combined"><div>21F5-21F7</div><div>LD (40DEH),A <span class="origrom2">LD (FLGINP),A</span>  <span class="opcode2">32 DE 40</span></div><div>Save the value of the input type flag in Register A.<br>Note: 40DEH holds READ flag</div></div>
									<p class="debug-note">A note in the original ROM source code 
indicates that when processing DATA and READ, we keep one pointer which 
points to the data being fetched, and another pointer which points to 
the lists of variables.  The data pointer will always start by pointing 
to a terminator (either a "," a ":" or an END OF LINE).</p>
									<div class="assembly-row-combined"><div>21F8</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Swap
 HL and the top of STACK, so that the DATA POINTER goes to the top of 
the STACK, and HL will now hold the variable list pointer</div></div>
									<div class="assembly-row-combined"><div>21F9-21FA</div><div><a href="#21FDH" class="memory-link">JR 21FDH <span class="origrom2">JR LOPDAT</span></a><span class="opcode2">18 02</span></div><div>Skip over the next instruction</div></div>
									<div class="assembly-row-combined" id="21FBH"><div>21FB-21FC <span class="origrom2">LOPDT2</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 2C<span class="origrom2">SYNCHK ","</span></a><span class="opcode2">CF 2C</span></div><div>Since the character at the location of the current BASIC program pointer in HL must be a <span class="code">,</span> , call the COMPARE SYMBOL at RST 08H.<br><br><span class="bold nobottomborder">NOTE:</span>
 The RST 08H routine compares the symbol in the input string pointed to 
by HL Register to the value in the location following the RST 08 call.<ul><li>If
 there is a match, control is returned to the next execution address 
(i.e, the RST 08H instruction + 2) with the next symbol in the A 
Register and HL incremented by one.</li><li>If the two characters do not match, a syntax error message is given and control returns to the Input Phase).</li></ul></div></div>
									<div class="assembly-row-combined" id="21FDH"><div>21FD-21FF <span class="origrom2">LOPDAT</span></div><div><a href="#260DH" class="memory-link">CALL 260DH <span class="origrom2">CALL PTRGET</span></a><span class="opcode2">CD 0D 26</span></div><div>Call
 the FIND ADDRESS OF VARIABLE routine at 260DH which searches the 
Variable List Table for a variable name which matches the name in the 
string pointed to in HL, and return the address of that variable in DE 
(and if there is no variable, it creates it, zeroes it, and returns THAT
 location)</div></div>
									<div class="assembly-row-combined" id="2200H"><div>2200</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Swap
 HL and the top of STACK, so that the Variable List Pointer goes to the 
top of the STACK and HL will hold the DATA LIST POINTER</div></div>
									<p class="debug-note">A note in the original ROM source code 
indicates that if we are here, we have a variable which is expecting 
data, so we only have two choices - get it some data or complain about 
it not getting expected data.</p>
									<div class="assembly-row-combined"><div>2201</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the pointer to the variable we are about to load with a value (held in Register Pair DE)</div></div>
									<div class="assembly-row-combined"><div>2202</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the DATA LIST POINTER.  This could be a terminator if its the first read</div></div>
									<div class="assembly-row-combined"><div>2203-2204</div><div>CP 2CH <span class="opcode2">FE 2C</span></div><div>Check to see if the character at the location of the input buffer pointer Register A is a <span class="code">,</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2205-2206</div><div><a href="#222DH" class="memory-link">JR Z,222DH <span class="origrom2">JR Z,DATBK</span></a><span class="opcode2">28 26</span></div><div>Jump
 to 222DH to fetch the impending data if we know that the character at 
the location of the input buffer pointer in Register A is a <span class="code">,</span></div></div>
									<div class="assembly-row-combined"><div>2207-2209</div><div>LD A,(40DEH) <span class="origrom2">LD A,(FLGINP)</span>  <span class="opcode2">3A DE 40</span></div><div>Load Register A with the input type flag so we can see what kind of statement called this routine (READ or INPUT).<br>Note: 40DEH holds READ flag</div></div>
									<div class="assembly-row-combined"><div>220A</div><div>OR A <span class="opcode2">B7</span></div><div>Since
 a LD command does not affect the flags, OR A is commonly used to set 
the flags based on A.  This is to Check for READ or INPUT</div></div>
									<div class="assembly-row-combined"><div>220B-220D</div><div><a href="#2296H" class="memory-link">JP NZ,2296H <span class="origrom2">JP NZ,DATLOP</span></a><span class="opcode2">C2 96 22</span></div><div>Jump to 2296H if the input type flag in Register A indicates READ meaning we need to go search for another data statement</div></div>
									<div class="assembly-row-combined"><div>220E-2210</div><div>LD A,(40A9H) <span class="origrom2">LD A,(CASFLG)</span>  <span class="opcode2">3A A9 40</span></div><div>Load Register A with the value of the cassette input flag.<br>Note: 40A9H holds Cassette input flag</div></div>
									<div class="assembly-row-combined"><div>2211</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if the input is from the cassette recorder, because if it is, then we have run out of data when we needed it</div></div>
									<div class="assembly-row-combined"><div>2212-2213</div><div>LD E,06H <span class="origrom2">LD E,ERROD</span>  <span class="opcode2">1E 06</span></div><div>Load Register E with an <span class="code">?OD ERROR</span> code</div></div>
									<div class="assembly-row-combined"><div>2214-2216</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#19A2H" class="memory-link">JP Z,19A2H <span class="origrom2">JP Z,ERROR</span></a><span class="opcode2">CA A2 19</span></div><div>Go to the Level II BASIC error routine and display an <span class="code">?OD ERROR</span> message if the input is from the cassette recorder</div></div>
									<div class="assembly-row-combined"><div>2217-2218</div><div>LD A,3FH <span class="opcode2">3E 3F</span></div><div>Load Register A with a "?"</div></div>
									<div class="assembly-row-combined"><div>2219-221B</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>GOSUB
 to 032AH which is a general purpose output routine that outputs a byte 
from the A Register to video, tape or printer (based on what is in 
409CH)</div></div>
									<div class="assembly-row-combined"><div>221C-221E</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1BB3H" class="memory-link">CALL 1BB3H <span class="origrom2">CALL QINLIN</span></a><span class="opcode2">CD B3 1B</span></div><div>Go get the keyboard line input using the routine that will also print a "?" as we want "??" when we need more input</div></div>
									<div class="assembly-row-combined"><div>221F</div><div>POP DE <span class="opcode2">D1</span></div><div>Get the address of VARIABLE POINT (the variable to be set) from the STACK and put it in DE</div></div>
									<div class="assembly-row-combined"><div>2220</div><div>POP BC <span class="opcode2">C1</span></div><div>Get the return address from the STACK and put it in BC because we might be exiting this routine</div></div>
									<div class="assembly-row-combined"><div>2221-2223</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1DBEH" class="memory-link">JP C,1DBEH <span class="origrom2">JP C,STPEND</span></a><span class="opcode2">DA BE 1D</span></div><div>Exit this routine via a jump to 1DBEH if we have an empty input (such as if the <kbd>BREAK</kbd> key was pressed)</div></div>
									<div class="assembly-row-combined"><div>2224</div><div>INC HL <span class="opcode2">23</span></div><div>Since we got no input, get ready to exit.  First, bump the value of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2225</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2226</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if the character at the location of the input buffer pointer in Register A is an end of the input character</div></div>
									<div class="assembly-row-combined"><div>2227</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2228</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the RETurn address back to the top of the STACK because we didn't actually exit</div></div>
									<div class="assembly-row-combined"><div>2229-222B</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1F04H" class="memory-link">JP Z,1F04H <span class="origrom2">JP Z,DATAH</span></a><span class="opcode2">CA 04 1F</span></div><div>Jump if the character at the location of the input buffer pointer in Register A is an end of the input character (i.e., a <span class="code">CARRIAGE RETURN</span> )</div></div>
									<div class="assembly-row-combined"><div>222C</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save
 the variable pointer (the variable's address) in DE to the STACK.  At 
this point, the DATA will now start at the beginning of the buffer and 
QINLIN will leave HL set to point to that buffer</div></div>
									<div class="assembly-row-combined"><div>222D-222F <span class="origrom2">DATABK</span></div><div>JP Z,1F04H <span class="origrom2">CALL FILIND</span><span class="opcode2">CD DC 41</span></div><div>Check with DOS to see if it wants to do anything here</div></div>
									<div class="assembly-row-combined"><div>2230</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H <span class="origrom2">GETYPE</span></a><span class="opcode2">E7</span></div><div>We
 need to know if this is a string, so check the value of the current 
number type flag by calling the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
 The RST 20H routine determines the type of the current value in 
ACCumulator and returns a combination of STATUS flags and unique numeric
 values in the A Register according to the data mode flag (40AFH).  The 
results are returned as follows:<br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>2231</div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the number type of the variable to the STACK</div></div>
									<div class="assembly-row-combined"><div>2232-2233</div><div><a href="#224DH" class="memory-link">JR NZ,224DH <span class="origrom2">JR NZ,NUMINS</span></a><span class="opcode2">20 19</span></div><div>If
 that test shows we do NOT have a STRING, jump to 224DH.  Note that we 
do not check the contents, so an unquoted string could contain all 
digits</div></div>
									<div class="assembly-row-combined"><div>2234</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2235</div><div>LD D,A <span class="opcode2">57</span></div><div>We
 are going to assume we have a quoted string here.  First, load Register
 D with the character at the location of the input buffer pointer in 
Register A</div></div>
									<div class="assembly-row-combined"><div>2236</div><div>LD B,A <span class="opcode2">47</span></div><div>Load Register B with the character at the location of the input buffer pointer in Register A</div></div>
									<div class="assembly-row-combined"><div>2237-2238</div><div>CP 22H <span class="opcode2">FE 22</span></div><div>Check
 to see if the character at the location of the input buffer pointer in 
Register A is a quote.  If they match, the Z FLAG is set, and otherwise 
the NZ FLAG is set.  If A &lt; the checked value, then the C FLAG is 
set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2239-223A</div><div><a href="#2240H" class="memory-link">JR Z,2240H <span class="origrom2">JR Z,NOWGET</span></a><span class="opcode2">E7</span></div><div>Jump to 2240H if the character at the location of the input buffer pointer in Register A is a quote</div></div>
									<div class="assembly-row-combined"><div>223B-223C</div><div>LD D,3AH <span class="opcode2">16 3A</span></div><div>Load D with the character <span class="code">:</span> , which could act as an unquoted string terminator</div></div>
									<div class="assembly-row-combined"><div>223D-223E</div><div>LD B,2CH <span class="opcode2">06 2C</span></div><div>Load Register B with the character <span class="code">,</span> which could ALSO act as an unquoted string terminator</div></div>
									<div class="assembly-row-combined"><div>223F</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement
 the pointer to the BASIC line being interpreted since we need this 
starting character to be included in the quoted string</div></div>
									<div class="assembly-row-combined" id="2240H"><div>2240-2242 <span class="origrom2">NOWGETR</span></div><div><a href="#2869H" class="memory-link">CALL 2869H <span class="origrom2">CALL STRLT2</span></a><span class="opcode2">CD 69 28</span></div><div>Set up a string descriptor for the value and copy it if necessary</div></div>
									<div class="assembly-row-combined"><div>2243 <span class="origrom2">DOASIG</span></div><div>POP AF <span class="opcode2">F1</span></div><div>Discard the number type for the variable from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>2244</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load DE with the pointer to the BASIC line being processed</div></div>
									<div class="assembly-row-combined"><div>2245-2247</div><div>LD HL,225AH <span class="origrom2">LD HL,STRDN2</span>  <span class="opcode2">21 5A 22</span></div><div>Load HL with the value of a RETurn address</div></div>
									<div class="assembly-row-combined"><div>2248</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Exchange HL and the top of the STACK, so that HL now points to the place to store the variable value</div></div>
									<div class="assembly-row-combined"><div>2249</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the pointer to the BASIC line being processed to the STACK</div></div>
									<div class="assembly-row-combined"><div>224A-224C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1F33H" class="memory-link">JP 1F33H <span class="origrom2">JP INPCOM</span></a><span class="opcode2">C3 33 1F</span></div><div>Go set the variable to the value of the string</div></div>
									<div class="assembly-row-combined" id="224DH"><div>224D <span class="origrom2">NUMINS</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>224E</div><div>POP AF <span class="opcode2">F1</span></div><div>Load Register A with the number type for the variable to be set</div></div>
									<div class="assembly-row-combined"><div>224F</div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save it back to to the STACK</div></div>
									<div class="assembly-row-combined" id="2250H"><div>2250-2252</div><div>LD BC,2243H <span class="origrom2">LD BC,DOASIG</span>  <span class="opcode2">01 43 22</span></div><div>Load BC with the value of the return address so that the assignment will jump to the LET routine</div></div>
									<div class="assembly-row-combined"><div>2253</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the return address in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>2254-2256</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0E6CH" class="memory-link">JP C,0E6CH <span class="origrom2">JP C,FIN</span></a><span class="opcode2">DA 6C 0E</span></div><div>If
 the current number type is integer or single precision (i.e., NOT 
double precision), call the ASCII TO BINARY routine at 0E6C (which 
converts the ASCII string pointed to by HL to binary with the result in 
ACCumulator and the mode flag will have changed)</div></div>
									<div class="assembly-row-combined"><div>2257-2259</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0E65H" class="memory-link">JP NC,0E65H <span class="origrom2">JP NC,FINDBL</span></a><span class="opcode2">D2 65 0E</span></div><div>If the current number type is double precision, jump to the ASCII TO DOUBLE routine at 0E65H.<br><ul><li>NOTE: 0E65H converts the ASCII string pointed to by HL to its double precision equivalent; with output left in ACCumulator).</li></ul></div></div>
									<div class="assembly-row-combined"><div>225A <span class="origrom2">STRDN2</span></div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the pointer to the BASIC line being processed by 1 character</div></div>
									<div class="assembly-row-combined"><div>225B</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>225C-225D</div><div><a href="#2263H" class="memory-link">JR Z,2263H <span class="origrom2">JR Z,TRMOK</span></a><span class="opcode2">28 05</span></div><div>Jump to 2263H if the character at the location of the input buffer pointer in HL is an end of the input character</div></div>
									<div class="assembly-row-combined"><div>225E-225F</div><div>CP 2CH <span class="opcode2">FE 2C</span></div><div>Check
 to see if the character at the location of the input buffer pointer in 
Register A is a comma.  If they match, the Z FLAG is set, and otherwise 
the NZ FLAG is set.  If A &lt; the checked value, then the C FLAG is 
set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2260-2262</div><div><a href="#217FH" class="memory-link">JP NZ,217FH <span class="origrom2">JR NZ,TRMNOK</span></a><span class="opcode2">C2 7F 21</span></div><div>Jump to 217FH if the character at the location of the input buffer pointer in Register A isn't a comma</div></div>
									<div class="assembly-row-combined" id="2263H"><div>2263 <span class="origrom2">TRMOK</span></div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Exchange the value of the input buffer pointer in HL with the value of the current BASIC program pointer to the STACK</div></div>
									<div class="assembly-row-combined"><div>2264</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the current BASIC program pointer in HL to point to the terminator character</div></div>
									<div class="assembly-row-combined"><div>2265</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2266-2268</div><div><a href="#21FBH" class="memory-link">JP NZ,21FBH <span class="origrom2">JP NZ,LOPDT2</span></a><span class="opcode2">C2 FB 21</span></div><div>If Z FLAG is set, then we are not ending, so we will need to check for a "," and get another variable to fill with data</div></div>
									<div class="assembly-row-combined"><div>2269</div><div>POP DE <span class="opcode2">D1</span></div><div>Remove the pointer to the data location from the STACK</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="226AH">226A-226E - For ROM v1.0 - Test for FD Error<br>Removed in ROM v1.2 because this was not needed.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Note: There is no ROM call to this location; it operates only
 as passing down from the above routine.  A FD ERROR means that bad file
 data was read as part of the <span class="code">READ</span> command reading from cassette.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>226A-226C</div><div>LD A,(40A9H) <span class="origrom2">LD A,(CASFLG)</span>  <span class="opcode2">3A A9 40</span></div><div>Check to see if we were working off of data stored on cassette by loading Register A.<br>Note: 40A9H holds Cassette input flag</div></div>
									<div class="assembly-row-combined"><div>226D</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if the error flag in Register A indicates an error</div></div>
									<div class="assembly-row-combined"><div>226E</div><div>RET Z <span class="opcode2">C8</span></div><div>Return to the BASIC interpreter if the error flag in Register A doesn't indicate an error</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="21EFH">*226A-226E - For ROM v1.2 - Replaced with NOPS<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>226F-2271</div><div>LD A,(40DEH) <span class="origrom2">LD A,(FLGINP)</span>  <span class="opcode2">3A DE 40</span></div><div>Load Register A with the value of the input type flag to see if we are here because of READ or because of INPUT.<br>Note: 40DEH holds READ flag</div></div>
									<div class="assembly-row-combined"><div>2272</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if the input type is <span class="code">READ</span> or <span class="code">INPUT</span></div></div>
									<div class="assembly-row-combined"><div>2273</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load DE with the value of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2274-2276</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D96H" class="memory-link">JP NZ,1D96H <span class="origrom2">JP NZ,RESFIN</span></a><span class="opcode2">C2 96 1D</span></div><div>Jump if the input type flag is set for READ so we can set the DATA POINTER</div></div>
									<div class="assembly-row-combined"><div>2277</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the current BASIC program pointer in DE to the STACK</div></div>
									<div class="assembly-row-combined"><div>2278-227A</div><div>CALL 41DFH <span class="origrom2">CALL EXCHDS</span><span class="opcode2">CD DF 41</span></div><div>GOSUB to DOS to see if DOS wants to modify any behavior</div></div>
									<div class="assembly-row-combined"><div>227B</div><div>OR (HL) <span class="opcode2">B6</span></div><div>Check to see if this is the end of the input (which could be a "," or a ":")</div></div>
									<div class="assembly-row-combined"><div>227C-227E</div><div>LD HL,2286H <span class="origrom2">LD HL,EXIGNT</span>  <span class="opcode2">21 86 22</span></div><div>Load HL with the starting address of the <span class="code">?EXTRA IGNORED</span> message</div></div>
									<div class="assembly-row-combined"><div>227F-2281</div><div><a href="#28A7H" class="memory-link">CALL NZ,28A7H <span class="origrom2">CALL NZ,STROUT</span></a><span class="opcode2">C4 A7 28</span></div><div>If the Z FLAG was set, then we weren't really at the end, so We need to display the <span class="code">?EXTRA IGNORED</span> message, so we call the WRITE MESSAGE routine at 28A7H.<br><span class="bold">NOTE:</span><br><ul><li>The routine at 28A7 displays the message pointed to by HL on current system output device (usually video).</li><li>The string to be displayed must be terminated by a byte of machine zeros or a carriage return code 0D.</li><li>If terminated with a carriage return, control is returned to the caller after taking the DOS exit at 41D0H (JP 5B99H).</li></ul></div></div>
									<div class="assembly-row-combined"><div>2282 <span class="origrom2">FINPRG</span></div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the pointer to the BASIC line being processed from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2283-2285</div><div><a href="#2169H" class="memory-link">JP 2169H <span class="origrom2">JP FINPRT</span></a><span class="opcode2">C3 69 21</span></div><div>Go turn off the cassette recorder and return to the BASIC interpreter</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2286H">2286-2295 - MESSAGE STORAGE LOCATION <span class="origrom">- "EXIGNT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2286-2295 <span class="origrom2">EXIGNT</span></div><div>"?Extra ignored" + 0DH + 00H <span class="opcode2">3F</span></div><div>The EXTRA IGNORED message is stored here</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2296H">2296-22B5 - FIND THE NEXT DATA STATEMENT ROUTINE - "DATLOP"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The original ROM source notes that the search is mad by 
uising the execution code for DATA to skp over statements.  The start 
word of each statement is compared against $DATA.  Each new line number 
is stored in DATLIN so that if an error occurs while reading data, the 
error message can give the line number of the bad formatted data.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2296H"><div>2296-2298 <span class="origrom2">DATLOP</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1F05H" class="memory-link">CALL 1F05H <span class="origrom2">CALL DATA</span></a><span class="opcode2">CD 05 1F</span></div><div>Go find the next DATA statement</div></div>
									<div class="assembly-row-combined"><div>2299 <span class="origrom2">DATFND</span></div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if this is the end of the BASIC line</div></div>
									<div class="assembly-row-combined"><div>229A-229B</div><div><a href="#22AEH" class="memory-link">JR NZ,22AEH <span class="origrom2">JR NZ.NOWLIN</span></a><span class="opcode2">20 12</span></div><div>Jump to 22AEH if the BASIC statement is terminated with a <span class="code">:</span></div></div>
									<div class="assembly-row-combined"><div>229C</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>229D</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the LSB of the line address at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>229E</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>229F</div><div>OR (HL) <span class="opcode2">B6</span></div><div>Combine
 the MSB of the line address at the location of the current BASIC 
program in HL with the LSB of the line address in Register A</div></div>
									<div class="assembly-row-combined"><div>22A0-22A1</div><div>LD E,06H <span class="opcode2">1E 06</span></div><div>Load Register E with an <span class="code">?OD ERROR</span> code</div></div>
									<div class="assembly-row-combined"><div>22A2-22A4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#19A2H" class="memory-link">JP Z,19A2H <span class="origrom2">JP Z,ERROR</span></a><span class="opcode2">CA A2 19</span></div><div>Go to the Level II BASIC error routine and display an OD ERROR message if this is the end of the BASIC program</div></div>
									<div class="assembly-row-combined"><div>22A5</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>22A6</div><div>LD E,(HL) <span class="opcode2">5E</span></div><div>Load Register E with the LSB of the BASIC line number at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>22A7</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>22A8</div><div>LD D,(HL) <span class="opcode2">56</span></div><div>Load Register D with the MSB of the BASIC line number at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>22A9</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Exchange the value of the current BASIC program pointer in HL with the value of the BASIC line number in DE</div></div>
									<div class="assembly-row-combined"><div>22AA-22AC</div><div>LD (40DAH),HL <span class="origrom2">LD (DATLIN),HL</span>  <span class="opcode2">22 DA 40</span></div><div>Save the BASIC line number in HL.<br>Note: 40DAH-40DBH holds DATA line number</div></div>
									<div class="assembly-row-combined"><div>22AD</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Exchange the value of the current BASIC program pointer in DE with the value of the BASIC line number in HL</div></div>
									<div class="assembly-row-combined" id="22AEH"><div>22AE <span class="origrom2">NOWLIN</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>22AF-22B0</div><div>CP 88H <span class="origrom2">CP $DATA</span>  <span class="opcode2">FE 88</span></div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in Register A is a DATA token.  If they match, the Z FLAG is 
set, and otherwise the NZ FLAG is set.  If A &lt; the checked value, 
then the C FLAG is set.  If A &gt;= the checked value, the NC FLAG is 
set.</div></div>
									<div class="assembly-row-combined"><div>22B1-22B2</div><div><a href="#2296H" class="memory-link">JR NZ,2296H <span class="origrom2">JR NZ,DATLOP</span></a><span class="opcode2">20 E3</span></div><div>Jump
 to 2296H (=find the next DATA statement routine) if the character at 
the location of the current BASIC program pointer in Register A isn't a 
DATA token</div></div>
									<div class="assembly-row-combined"><div>22B3-22B5</div><div><a href="#222DH" class="memory-link">JP 222DH <span class="origrom2">JP DATBK</span></a><span class="opcode2">C3 2D 22</span></div><div>Now we know that the current BASIC program pointer is pointing to a DATA token, so jump to 222DH to read it</div></div>
								</div>
							</div>

<h2 class="assembly-section-title" id="22B6H">22B6-2336 - LEVEL II BASIC <span class="code">NEXT</span> ROUTINE <span class="origrom">- "NEXT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
<div class="card-item">
<p>The NEXT statement traverses the stack to find the matching FOR frame
 for the specified variable (or the most recent if no variable given). 
All FOR/NEXT frames are <strong>fixed at exactly 16 bytes</strong> ‚Äî 
with padding in the integer case ‚Äî allowing NEXT to skip non-matching 
frames uniformly by adding 14 bytes (0EH) during the search loop (code 
at ~194D: BC=000EH; ADD HL,BC; this aligns to the next frame's check 
point).</p>
<p>On entry, HL points to the variable name being NEXTed (or is ignored 
for plain NEXT). NEXT searches upward through the stack frames:</p>
<ul>
  <li>Starts at SP+4, checks for FOR token (81H) at offset +1 of the frame.</li>
  <li>Compares the variable pointer (bytes +2 to +3) with the current variable.</li>
  <li>If no match ‚Üí adds 14 bytes to skip to the next potential frame and continues.</li>
  <li>On match: pops the 16-byte frame and uses the data type flag at 
offset +5 (FFH = integer, 01H = single-precision) to determine how to 
load/add/compare STEP and TO values from +6‚Äì13.</li>
</ul>
<p>Key frame elements used by NEXT:</p>
<ul>
  <li>Sign of STEP (at +0 and duplicate at +4)</li>
  <li>Data type flag (at +5) ‚Äì this is the primary way NEXT knows 
whether to use 16-bit integer arithmetic or single-precision 
floating-point addition</li>
  <li>STEP/TO values (at +6‚Äì13): 2+2 bytes for integer (with +6‚Äì9 as unused padding), 4+4 bytes for single-precision</li>
  <li>Line number (+14‚Äì15) and text pointer (+16‚Äì17, restored from saved position) for jumping back to the FOR statement</li>
</ul>
<p>Because the frame size is fixed at 16 bytes, NEXT can safely traverse
 the stack without knowing the loop type in advance. The known ?OV ERROR
 bug in integer loops occurs because NEXT performs 16-bit signed 
addition on STEP and index: adding STEP to index overflows ¬±32767 ‚Üí 
promotes to single-precision in FAC (4121H‚Äì4124H, NTF=01H/4). Storing 
back to integer var fails type check in LET (1F21H) ‚Üí OV.</p>
<div class="assembly-table">
<div class="assembly-row-combined"><div>22B6-22B8 <span class="origrom2">NEXT</span></div><div>LD DE,0000H <span class="opcode2">11 00 00</span></div><div>Load
 DE with the default for cases where NEXT doesn't include a variable 
name (such as "NEXT X"). By doing this, FNDFOR will be called with DE = 0</div></div>
<div class="assembly-row-combined" id="22B9H"><div>22B9-22BB <span class="origrom2">NEXTC</span></div><div><a href="#260DH" class="memory-link">CALL NZ,260DH <span class="origrom2">CALL NZ,PTRGET</span></a><span class="opcode2">C4 0D 26</span></div><div>Get the pointer to variable which follows the <span class="code">NEXT</span>
 token, call the FIND ADDRESS OF VARIABLE routine at 260DH which 
searches the Variable List Table for a variable name which matches the 
name in the string pointed to in HL, and return the address of that 
variable in DE (and if there is no variable, it creates it, zeroes it, 
and returns THAT location)</div></div>
<div class="assembly-row-combined"><div>22BC-22BE</div><div>LD (40DFH),HL <span class="origrom2">LD (TEMP),HL</span> <span class="opcode2">22 DF 40</span></div><div>Save the value of the current BASIC program pointer (contained in HL) into a common temporary storage area</div></div>
<div class="assembly-row-combined"><div>22BF-22C1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1936H" class="memory-link">CALL 1936H <span class="origrom2">CALL FNDFOR</span></a><span class="opcode2">CD 36 19</span></div><div>Go search the STACK for the appropriate FOR entry that matches the variable name being used here</div></div>
<div class="assembly-row-combined"><div>22C2-22C4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#199DH" class="memory-link">JP NZ,199DH <span class="origrom2">JP NZ,NFERR</span></a><span class="opcode2">C2 9D 19</span></div><div>If FNDFOR found nothing, then display a NF ERROR message if the appropriate FOR push wasn't found</div></div>
<div class="assembly-row-combined"><div>22C5</div><div>LD SP,HL <span class="opcode2">F9</span></div><div>Clean up the STACK. First set the STACK pointer with the value of the memory pointer in HL</div></div>
<div class="assembly-row-combined"><div>22C6-22C8</div><div>LD (40E8H),HL <span class="origrom2">LD (SAVSTK),HL</span> <span class="opcode2">22 E8 40</span></div><div>Save the value in HL to the STACK pointer pointer</div></div>
<div class="assembly-row-combined"><div>22C9</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the pointer to the variables address (in DE) to the STACK</div></div>
<div class="assembly-row-combined"><div>22CA</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the value of the sign for the <span class="code">STEP</span> value</div></div>
<div class="assembly-row-combined"><div>22CB</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL</div></div>
<div class="assembly-row-combined"><div>22CC</div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the value of the sign for the <span class="code">STEP</span> value in Register A to the STACK</div></div>
<div class="assembly-row-combined"><div>22CD</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the pointer to the loop variable (in DE) to the STACK</div></div>
<div class="assembly-row-combined"><div>22CE</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the number type flag for the <span class="code">STEP</span> value to help determine if it is an integer</div></div>
<div class="assembly-row-combined"><div>22CF</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of "FOR" entry pointer in HL</div></div>
<div class="assembly-row-combined"><div>22D0</div><div>OR A <span class="opcode2">B7</span></div><div>Check the value of the number type flag for the <span class="code">STEP</span> flag in Register A. The MINUS FLAG will be set if it is an integer</div></div>
<div class="assembly-row-combined"><div>22D1-22D3</div><div><a href="#22EAH" class="memory-link">JP M,22EAH <span class="origrom2">JP M,INTNXT</span></a><span class="opcode2">FA EA 22</span></div><div>Jump to 22EAH if the <span class="code">STEP</span> value is an integer</div></div>
<div class="assembly-row-combined"><div>22D4-22D6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09B1H" class="memory-link">CALL 09B1H <span class="origrom2">CALL MOVFM</span></a><span class="opcode2">CD B1 09</span></div><div>Move the step value into the ACC via a GOSUB to 09B1H (which moves a SINGLE PRECISION number pointed to by HL to ACCumulator)</div></div>
<div class="assembly-row-combined"><div>22D7</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Exchange
 the top of the STACK with HL, so that the pointer for the LOOP variable
 goes into HL and the pointer for the FOR entry goes to the top of the 
STACK</div></div>
<div class="assembly-row-combined"><div>22D8</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the pointer to the loop variable's address in HL to the STACK</div></div>
<div class="assembly-row-combined"><div>22D9-22DB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#070BH" class="memory-link">CALL 070BH <span class="origrom2">CALL FADDS</span></a><span class="opcode2">CD 0B 07</span></div><div>Add the single precision value at the location of the memory pointer in HL to the single precision <span class="code">STEP</span> value in Register Pairs BC and DE. Return with the result in ACCumulator</div></div>
<div class="assembly-row-combined"><div>22DC</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the pointer to the loop variable from the STACK and put it in HL</div></div>
<div class="assembly-row-combined"><div>22DD-22DF</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09CBH" class="memory-link">CALL 09CBH <span class="origrom2">CALL MOVMF</span></a><span class="opcode2">CD CB 09</span></div><div>Go move the single precision result from ACCumulator to the loop variable's address in HL</div></div>
<div class="assembly-row-combined"><div>22E0</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the ENTRY POINTER from the STACK and put it in HL</div></div>
<div class="assembly-row-combined"><div>22E1-22E3</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09C2H" class="memory-link">CALL 09C2H <span class="origrom2">CALL MOVRM</span></a><span class="opcode2">CD C2 09</span></div><div>Get
 the final loop number into the registers via a GOSUB to 09C2H (which 
loads a SINGLE PRECISION value pointed to by HL into Register Pairs BC 
and DE)</div></div>
<div class="assembly-row-combined"><div>22E4</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the ENTRY POINTER to the STACK</div></div>
<div class="assembly-row-combined"><div>22E5-22E7</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A0CH" class="memory-link">CALL 0A0CH <span class="origrom2">CALL FCOMP</span></a><span class="opcode2">CD 0C 0A</span></div><div>Compare
 the numbers returning 377 if the ACC is less than the registers, 0 if 
equal, and otherwise 1. This is done by a GOSUB to the SINGLE PRECISION 
COMPARISON routine at 0A0CH.<br><br><span class="nobottomborder bold">NOTE:</span> The routine at 0A0CH algebraically compares the single precision value in BC/DE to the single precision value ACCumulator.<br>The results are stored in A as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Register A</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator = BCDE</td><td style="border: 1px solid black; padding: 8px;">00</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator &gt; BCDE</td><td style="border: 1px solid black; padding: 8px;">01</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If ACCumulator &lt; BCDE</td><td style="border: 1px solid black; padding: 8px;">FF</td></tr></tbody></table></div></div>
<div class="assembly-row-combined"><div>22E8-22E9</div><div><a href="#2313H" class="memory-link">JR 2313H <span class="origrom2">JR FINNXT</span></a><span class="opcode2">18 29</span></div><div>Jump forward to 2313H to skip over the integer processing code</div></div>
</div>
</div>
<h2 class="assembly-section-title" id="22EAH">22EAH - Part of the <span class="code">NEXT</span> code, where we process the variable as an integer <span class="origrom">- "INTNXT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
<div class="card-item">
<div class="assembly-table">
<div class="assembly-row-combined"><div>22EA <span class="origrom2">INTNXT</span></div><div>INC HL <span class="opcode2">23</span></div><div>Since we are dealing with an integer, and not a single precision number, we need to skip 4 bytes of the <span class="code">TO</span> value</div></div>
<div class="assembly-row-combined"><div>22EB</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL</div></div>
<div class="assembly-row-combined"><div>22EC</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL</div></div>
<div class="assembly-row-combined"><div>22ED</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL</div></div>
<div class="assembly-row-combined"><div>22EE</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Load Register C with the LSB of the <span class="code">STEP</span> value (held at the location of the memory pointer in HL)</div></div>
<div class="assembly-row-combined"><div>22EF</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL to be the MSB of the <span class="code">STEP</span> value</div></div>
<div class="assembly-row-combined"><div>22F0</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load Register B with the MSB of the <span class="code">STEP</span> value at the location of the memory pointer in HL</div></div>
<div class="assembly-row-combined"><div>22F1</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL so that it is the STACK address of the <span class="code">TO</span> limit</div></div>
<div class="assembly-row-combined"><div>22F2</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Exchange
 HL and the value at the top of the STACK, so that HL will point to the 
loop's variable and the ENTRY POINTER will be at the top of the STACK</div></div>
<div class="assembly-row-combined"><div>22F3</div><div>LD E,(HL) <span class="opcode2">5E</span></div><div>Next we need to get the loop's variable value into Register Pair DE. First, load Register E with the LSB of the loop variable</div></div>
<div class="assembly-row-combined"><div>22F4</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL to point to the MSB of the index</div></div>
<div class="assembly-row-combined"><div>22F5</div><div>LD D,(HL) <span class="opcode2">56</span></div><div>Load Register D with the MSB of the loop variable</div></div>
<div class="assembly-row-combined"><div>22F6</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the pointer to the loop variable value to the STACK</div></div>
<div class="assembly-row-combined"><div>22F7</div><div>LD L,C <span class="opcode2">69</span></div><div>Next, we are going to need to add DE to HL. First, load Register L with the LSB of the <span class="code">STEP</span> value in Register C</div></div>
<div class="assembly-row-combined"><div>22F8</div><div>LD H,B <span class="opcode2">60</span></div><div>Load Register H with the MSB of the <span class="code">STEP</span> value in Register B</div></div>
<div class="assembly-row-combined"><div>22F9-22FB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0BD2H" class="memory-link">CALL 0BD2H <span class="origrom2">CALL IADD</span></a><span class="opcode2">CD D2 0B</span></div><div>With the <span class="code">STEP</span>
 value in HL, call the INTEGER ADD routine at 0BD2H (which adds the 
integer value in DE to the integer in HL. The sum is left in HL and the 
original contents of DE are preserved. If overflow occurs (sum exceeds 
2**15), both values are converted to single precision and then added. 
The result would be left in ACCumulator and the mode flag would be 
updated)</div></div>
<div class="assembly-row-combined"><div>22FC-22FE</div><div>LD A,(40AFH) <span class="origrom2">LD A,(VALTYP)</span> <span class="opcode2">3A AF 40</span></div><div>Load Register A with the current value of the data type flag, as we want to check for an overflow.<br>Note: 40AFH holds Current number type flag</div></div>
<div class="assembly-row-combined" id="2300H"><div>22FF</div><div>CP 04H <span class="opcode2">FE 04</span></div><div>Check
 to see if the current value in ACCumulator was turned into single 
precision. If they match, the Z FLAG is set, and otherwise the NZ FLAG 
is set. If A &lt; the checked value, then the C FLAG is set. If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
<div class="assembly-row-combined"><div>2301-2303</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#07B2H" class="memory-link">JP Z,07B2H <span class="origrom2">JP Z,OVERR</span></a><span class="opcode2">CA B2 07</span></div><div>Show an <span class="code">?OV ERROR</span>
 message if the index (i.e., the current value in ACCumulator) has 
overflowed to be a single precision number instead of an integer</div></div>
<div class="assembly-row-combined"><div>2304</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap DE and HL so that DE will now hold the new loop variable value</div></div>
<div class="assembly-row-combined"><div>2305</div><div>POP HL <span class="opcode2">E1</span></div><div>Restore the pointer to the loop variable back into HL</div></div>
<div class="assembly-row-combined"><div>2306</div><div>LD (HL),D <span class="opcode2">72</span></div><div>Save the MSB of the result in Register D at the location of the memory pointer in HL</div></div>
<div class="assembly-row-combined"><div>2307</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the memory pointer in register pair HL</div></div>
<div class="assembly-row-combined"><div>2308</div><div>LD (HL),E <span class="opcode2">73</span></div><div>Save the LSB of the result in Register E at the location of the memory pointer in HL</div></div>
<div class="assembly-row-combined"><div>2309</div><div>POP HL <span class="opcode2">E1</span></div><div>Restore the pointer for the FOR entry back into HL</div></div>
<div class="assembly-row-combined"><div>230A</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the value of the loop's variable (the index) in DE to the STACK</div></div>
<div class="assembly-row-combined"><div>230B</div><div>LD E,(HL) <span class="opcode2">5E</span></div><div>We need DE to hold the final value, so first load Register E with the LSB of the <span class="code">TO</span> value at the location of the memory pointer in HL</div></div>
<div class="assembly-row-combined"><div>230C</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL to point to the MSB of the <span class="code">TO</span> value</div></div>
<div class="assembly-row-combined"><div>230D</div><div>LD D,(HL) <span class="opcode2">56</span></div><div>Load Register D with the MSB of the <span class="code">TO</span> value at the location of the memory pointer in HL</div></div>
<div class="assembly-row-combined"><div>230E</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL so now it points to the line number</div></div>
<div class="assembly-row-combined"><div>230F</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Swap the <span class="code">TO</span> value at the memory location pointed to by the STACK with the address of the binary line number for the <span class="code">FOR</span> statement (now in HL)</div></div>
<div class="assembly-row-combined"><div>2310-2312</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A39H" class="memory-link">CALL 0A39H <span class="origrom2">CALL ICOMP</span></a><span class="opcode2">CD 39 0A</span></div><div>We
 need to compare the new index to the limit so we call the INTEGER 
COMPARISON routine at 0A39H (which algebraically compares two integer 
values in DE and HL. The contents of DE and HL are left intact. The 
result of the comparison is left in the A Register and status Register 
as:<br>If DE &gt; HL then A will be -1;<br>If DE &lt; HL then A will be +1; and<br>If DE = HL then A will be 0</div></div>
</div>
</div>
<h2 class="assembly-section-title" id="2313H">2313H - Part of the <span class="code">NEXT</span> code, jumped to continue after skipping over the integer processing <span class="origrom">- "FINNXT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
<div class="card-item">
<div class="assembly-table">
<div class="assembly-row-combined"><div>2313 <span class="origrom2">FINNXT</span></div><div>POP HL <span class="opcode2">E1</span></div><div>Restore the "FOR" entry pointer (which is now pointing past the final value) into HL</div></div>
<div class="assembly-row-combined"><div>2314</div><div>POP BC <span class="opcode2">C1</span></div><div>Get the value of the sign from the STACK and put it in BC</div></div>
<div class="assembly-row-combined"><div>2315</div><div>SUB B <span class="opcode2">90</span></div><div>We
 need to see if the sign is the sign we expected so we subtract the 
value of the sign in Register B from the value in Register A (which is 
currently set to CURRENT VALUE - FINAL VALUE)</div></div>
<div class="assembly-row-combined"><div>2316-2318</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09C2H" class="memory-link">CALL 09C2H <span class="origrom2">CALL MOVRM</span></a><span class="opcode2">CD C2 09</span></div><div>Call 09C2H (which loads a SINGLE PRECISION value pointed to by HL into Register Pairs BC and DE)</div></div>
<div class="assembly-row-combined"><div>2319-231A</div><div><a href="#2324H" class="memory-link">JR Z,2324H <span class="origrom2">JR Z,LOOPDN</span></a><span class="opcode2">28 09</span></div><div>If the loop has completed (current value has passed the TO limit), jump to LOOPDN to exit the loop</div></div>
<div class="assembly-row-combined"><div>231B</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load HL with the BASIC line number of the <span class="code">FOR</span> statement in DE. Loop should continue - save line number and jump back to 1D1AH to execute the loop body again</div></div>
<div class="assembly-row-combined"><div>231C-231E</div><div>LD (40A2H),HL <span class="origrom2">LD (CURLIN),HL</span> <span class="opcode2">22 A2 40</span></div><div>Save the BASIC line number in HL as the current BASIC line number (which is stored at 40A2H-40A3H).</div></div>
<div class="assembly-row-combined"><div>231F</div><div>LD L,C <span class="opcode2">69</span></div><div>Set
 up the pointer to the current character in the BASIC program being 
processed by first loading Register L with the LSB of the current BASIC 
program pointer in Register C</div></div>
<div class="assembly-row-combined"><div>2320</div><div>LD H,B <span class="opcode2">60</span></div><div>Load Register H with the MSB of the current BASIC program pointer in Register B</div></div>
<div class="assembly-row-combined"><div>2321-2323</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D1AH" class="memory-link">JP 1D1AH <span class="origrom2">JP NXTCON</span></a><span class="opcode2">C3 1A 1D</span></div><div>Jump to 1D1AH to continue execution and restore the <span class="code">FOR</span> token and GAP for FOR</div></div>
</div>
</div>
<h2 class="assembly-section-title" id="2313H">2313H - Part of the <span class="code">NEXT</span> code, Common path after incrementing loop variable <span class="origrom">- "LOOPDN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
<div class="card-item">
<div class="assembly-table">
<div class="assembly-row-combined"><div>2324 <span class="origrom2">LOOPDN</span></div><div>LD SP,HL <span class="opcode2">F9</span></div><div>Loop
 has completed normally. Remove the FOR entry from the stack by setting 
SP=HL (discarding the frame), then check for comma to handle multiple 
NEXT variables</div></div>
<div class="assembly-row-combined"><div>2325-2327</div><div>LD (40E8H),HL <span class="origrom2">LD (SAVSTK),HL</span> <span class="opcode2">22 E8 40</span></div><div>Reset the STACK pointer pointer</div></div>
<div class="assembly-row-combined"><div>2328-232A</div><div>LD HL,(40DFH) <span class="origrom2">LD HL,(TEMP)</span> <span class="opcode2">2A DF 40</span></div><div>Save the value of the current BASIC program pointer in HL into a common temporary storage area</div></div>
<div class="assembly-row-combined"><div>232B</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>We
 are going to need to check for a "," so first load Register A with the 
next token (i.e., the character at the location of the current BASIC 
program pointer in HL)</div></div>
<div class="assembly-row-combined"><div>232C-232D</div><div>CP 2CH <span class="opcode2">FE 2C</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">,</span>
 . If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
If A &lt; the checked value, then the C FLAG is set. If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
<div class="assembly-row-combined"><div>232E-2330</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D1EH" class="memory-link">JP NZ,1D1EH <span class="origrom2">JP NZ,NEWSTT</span></a><span class="opcode2">C2 1E 1D</span></div><div>If the character at the location of the current BASIC program pointer in Register A isn't a <span class="code">,</span> then we need to look at another variable name for the NEXT, so JUMP to NEWSTT</div></div>
<div class="assembly-row-combined"><div>2331</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds. On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric. All strings must have a 00H at the end.</div></div>
<div class="assembly-row-combined"><div>2332-2334</div><div><a href="#22B9H" class="memory-link">CALL 22B9H <span class="origrom2">CALL NEXTC</span></a><span class="opcode2">CD B9 22</span></div><div>GOSUB to 22B9H to process <span class="code">NEXT</span> , but do not allow a blank variable name</div></div>
</div>
</div>

							<h2 class="assembly-section-title" id="2335H">2335-27C8 - EVALUATE EXPRESSION <span class="origrom">- "FRMPRN" and "FRMEVL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source, this routine starts 
with HL pointing to the first character of a formula.  At the end of the
 routine HL points to the terminator, and ACC holds the result.  
Important to note that on exit Register A does not necessarily reflect 
the terminating character.<br><br>The formula evaluator uses the operation table ("OPTAB") to determine the precedent and to dispatch addresses for each operator.<br><br></p><li>During operation, the STACK has the following format:<ul><li>The RETURN location on completion (RETAOP)</li><li>The floating point temporary result</li><li>The address of the operator routine</li><li>The precedence of the operator</li></ul>Another
 description of this routine is that it evaluates a BASIC expression 
pointed to by the HL and stores the result in the ACC. The expression 
must be terminated with zero byte, comma, right bracket or colon. After 
execution, HL will point to the delimiter and, in the case of string 
expressions, the ACC will contain the address of the first of three 
bytes that contain string length and string address. Note that the STACK
 is used frequently and the machine should be formatted for RUN mode in 
order to use this routine.<p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2335H"><div>2335 <span class="origrom2">FRMPRN</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 28<span class="origrom2">SYNCHK "("</span></a><span class="opcode2">CF 28</span></div><div>If
 we chose THIS entry point, we require a parenthesis to start.  Since 
the character at the location of the current BASIC program pointer in HL
 must be a <span class="code">(</span> , call the COMPARE SYMBOL routine at RST 08H.<br><br><span class="bold nobottomborder">NOTE:</span>
 The RST 08H routine compares the symbol in the input string pointed to 
by HL Register to the value in the location following the RST 08 call.<ul><li>If
 there is a match, control is returned to the next execution address 
(i.e, the RST 08H instruction + 2) with the next symbol in the A 
Register and HL incremented by one.</li><li>If the two characters do not match, a syntax error message is given and control returns to the Input Phase).</li></ul></div></div>
									<div class="assembly-row-combined" id="2337H"><div>2337 <span class="origrom2">FRMEVL</span></div><div>DEC HL <span class="opcode2">2B</span></div><div>This
 would be the entry point if we don't need a lead-in "(".  First, 
decrement the value of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined" id="2338H"><div>2338-2339 <span class="origrom2">FRMCHK</span></div><div>LD D,00H <span class="opcode2">16 00</span></div><div>Load Register D with zero as a dummy precedence for the formula</div></div>
									<div class="assembly-row-combined" id="233AH"><div>233A <span class="origrom2">LPOPER</span></div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the value in DE to the STACK</div></div>
									<div class="assembly-row-combined"><div>233B-233C</div><div>LD C,01H <span class="opcode2">0E 01</span></div><div>Load Register C with the number of bytes of memory required for a return address -1 (so 2 bytes)</div></div>
									<div class="assembly-row-combined"><div>233D-233F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1963H" class="memory-link">CALL 1963H <span class="origrom2">CALL GETSTK</span></a><span class="opcode2">CD 63 19</span></div><div>Since
 we must make sure that there is enough room for recursive calls, we 
GOSUB to 1963H to compute the amount of space between HL and the end of 
memory at FFC6H</div></div>
									<div class="assembly-row-combined"><div>2340-2342</div><div><a href="#249FH" class="memory-link">CALL 249FH <span class="origrom2">CALL EVAL</span></a><span class="opcode2">CD 9F 24</span></div><div>Go get the value of the next part of the expression at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2343-2345</div><div>LD (40F3H),HL <span class="origrom2">LD (TEMP2),HL</span>  <span class="opcode2">22 F3 40</span></div><div>Save the value of the current BASIC program pointer (i.e., the next token) in HL.<br>Note: 40F3H-40F4H is a temporary storage location</div></div>
									<div class="assembly-row-combined" id="2346H"><div>2346-2348 <span class="origrom2">RETAOP</span></div><div>LD HL,(40F3H) <span class="origrom2">LD HL,(TEMP2)</span>  <span class="opcode2">2A F3 40</span></div><div>Load HL with the value of the current BASIC program pointer.<br>Note: 40F3H-40F4H is a temporary storage location</div></div>
									<div class="assembly-row-combined"><div>2349 <span class="origrom2">TSTOP</span></div><div>POP BC <span class="opcode2">C1</span></div><div>Get the last PRECEDENCE value from the STACK and put it in BC</div></div>
									<div class="assembly-row-combined"><div>234A <span class="origrom2">NOTSTV</span></div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>234B-234C</div><div>LD D,00H <span class="opcode2">16 00</span></div><div>Load
 Register D with zero as an assumption that there are no relation 
operations AND to set up the high order of the index into OPTAB</div></div>
									<div class="assembly-row-combined" id="234DH"><div>234D-234E <span class="origrom2">LOPREL</span></div><div>SUB D4H <span class="origrom2">SUB GREATK</span>  <span class="opcode2">D6 D4</span></div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in Register A is an arithmetic or logical (i.e., relational) 
token (by subtracting 212 from it)</div></div>
									<div class="assembly-row-combined" id="234FH"><div>234F-2350</div><div><a href="#2364H" class="memory-link">JR C,2364H <span class="origrom2">JR C,ENDREL</span></a><span class="opcode2">38 13</span></div><div>Jump to 2364H if the character at the location of the current BASIC program pointer in Register A is "relational" (i.e., <span class="code">+</span> , <span class="code">-</span> , <span class="code">*</span> , <span class="code">/</span> , <span class="code">?</span> , <span class="code">AND</span> or <span class="code">OR</span></div></div>
									<div class="assembly-row-combined"><div>2351-2352 <span class="origrom2">NMREL</span></div><div>CP 03H <span class="origrom2">CP NMREL</span>  <span class="opcode2">FE 03</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is really relational (i.e., a <span class="code">&gt;</span> , <span class="code">=</span> , or <span class="code">&lt;</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined" id="2353H"><div>2353-2354</div><div><a href="#2364H" class="memory-link">JR NC,2364H <span class="origrom2">JR NC,ENDREL</span></a><span class="opcode2">30 0F</span></div><div>If the character at the location of the current BASIC program pointer in Register A isn't a <span class="code">&gt;</span> , <span class="code">=</span> , or <span class="code">&lt;</span> , and it's jsut BIG, JUMP to ENDREL</div></div>
									<div class="assembly-row-combined"><div>2355-2356</div><div>CP 01H <span class="opcode2">FE 01</span></div><div>Set the Carry flag if <span class="code">&gt;</span> . Then test for <span class="code">&lt;=</span> or <span class="code">&gt;=</span></div></div>
									<div class="assembly-row-combined"><div>2357</div><div>RLA <span class="opcode2">17</span></div><div>Adjust the value in Register A to give <span class="code">&gt;</span> as 1, <span class="code">=</span> as 2, or <span class="code">&lt;</span> as 4</div></div>
									<div class="assembly-row-combined"><div>2358</div><div>XOR D <span class="opcode2">AA</span></div><div>Combine the current value in Register A with the value of the last token examined to see if this is a legal combination of <span class="code">&lt;=</span> or <span class="code">=&gt;</span> or illegal combination of <span class="code">&lt;&lt;</span> , <span class="code">==</span> , or <span class="code">&gt;&gt;</span></div></div>
									<div class="assembly-row-combined"><div>2359</div><div>CP D <span class="opcode2">BA</span></div><div>Check
 to make sure that the result is bigger and to avoid an illegal 
combination of operators.  If they match, the Z FLAG is set, and 
otherwise the NZ FLAG is set.  If A &lt; the checked value, then the C 
FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>235A</div><div>LD D,A <span class="opcode2">57</span></div><div>Load Register D with the mask in Register A</div></div>
									<div class="assembly-row-combined"><div>235B-235D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1997H" class="memory-link">JP C,1997H <span class="origrom2">JP C,SNERR</span></a><span class="opcode2">DA 97 19</span></div><div>If we have two of the same operators then display a <span class="code">?SN ERROR</span></div></div>
									<div class="assembly-row-combined"><div>235E-2360</div><div>LD (40D8H),HL <span class="origrom2">LD (TEMP3),HL</span>  <span class="origrom2">LD (TEMP3),HL</span>  <span class="opcode2">22 D8 40</span></div><div>Save the address of the <span class="code">&gt;</span> , <span class="code">=</span> , or <span class="code">&lt;</span> token (held in HL) to 40D8H, which is another temporary storage location</div></div>
									<div class="assembly-row-combined"><div>2361</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next token so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2362-2363</div><div><a href="#234DH" class="memory-link">JR 234DH <span class="origrom2">JR LOPREL</span></a><span class="opcode2">18 E9</span></div><div>Jump back to 234DH</div></div>
									<div class="assembly-row-combined" id="2364H"><div>2364<span class="origrom2">ENDREL</span></div><div>LD A,D <span class="opcode2">7A</span></div><div>Load Register A with the mask from Register D</div></div>
									<div class="assembly-row-combined"><div>2365</div><div>OR A <span class="opcode2">B7</span></div><div>Test the value of the operator in Register A against the mask to see if any of the masked operators are present</div></div>
									<div class="assembly-row-combined"><div>2366-2368</div><div><a href="#23ECH" class="memory-link">JP NZ,23ECH <span class="origrom2">JP NZ,FNDREL</span></a><span class="opcode2">C2 EC 23</span></div><div>If the NZ FLAG is set, then one of the masked operators ( <span class="code">&gt;</span> , <span class="code">=</span> , or <span class="code">&lt;</span> ) is present, so JUMP to FINDREL to handle those</div></div>
									<div class="assembly-row-combined"><div>2369</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>236A-236C</div><div>LD (40D8H),HL <span class="origrom2">LD (TEMP3),HL</span>  <span class="opcode2">22 D8 40</span></div><div>Save
 the address of the current BASIC program pointer in HL (which is an 
arithmetic operator) to 40D8H, which is another temporary storage 
location</div></div>
									<div class="assembly-row-combined"><div>236D-236E</div><div>SUB 0CDH <span class="origrom2">SUB PLUSTK</span>  <span class="opcode2">D6 CD</span></div><div>Check to see if the operator at the location of the current BASIC program pointer in Register A is an arithmetic token</div></div>
									<div class="assembly-row-combined"><div>236F</div><div>RET C <span class="opcode2">D8</span></div><div>Return if the character at the location of the current BASIC program pointer in Register A isn't an arithmetic token</div></div>
									<div class="assembly-row-combined" id="2370H"><div>2370-2371</div><div>CP 07H <span class="origrom2">CP LSTOPK</span>  <span class="opcode2">FE 07</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">+</span> to <span class="code">OR</span>
 token.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2372</div><div>RET NC <span class="opcode2">D0</span></div><div>Return if the character at the location of the current BASIC program pointer in Register A isn't a <span class="code">+</span> to <span class="code">OR</span> token</div></div>
									<div class="assembly-row-combined" id="2373H"><div>2373</div><div>LD E,A <span class="opcode2">5F</span></div><div>Load
 Register E with the operator value in Register A (which would be 
between 0 and 7).  This also sets up for a MULTIPLY BY 3 since the table
 entries are 3 bytes each.<br>E&nbsp;&nbsp;&nbsp;Token<br>0&nbsp;&nbsp;&nbsp; <span class="code">+</span><br>1&nbsp;&nbsp;&nbsp; <span class="code">-</span><br>2&nbsp;&nbsp;&nbsp; <span class="code">*</span><br>3&nbsp;&nbsp;&nbsp; <span class="code">/</span><br>4&nbsp;&nbsp;&nbsp; <span class="code">@@</span><br>5&nbsp;&nbsp;&nbsp; <span class="code">AND</span><br>6&nbsp;&nbsp;&nbsp; <span class="code">OR</span></div></div>
									<div class="assembly-row-combined"><div>2374-2376</div><div>LD A,(40AFH) <span class="origrom2">LD A,(VALTYP)</span>  <span class="opcode2">3A AF 40</span></div><div>Load Register A with the current value of the number type flag.<br>Note: 40AFH holds Current number type flag</div></div>
									<div class="assembly-row-combined"><div>2377-2378</div><div>SUB 03H <span class="opcode2">D6 03</span></div><div>Test
 for a string by adjusting the value of the number type flag to get a -1
 if integer, 0 for a string, 1 for single precision, and 5 for double 
precision</div></div>
									<div class="assembly-row-combined"><div>2379</div><div>OR E <span class="opcode2">B3</span></div><div>Combine
 the operator value in Register E with the adjusted number type flag in 
Register A.  If it turns out to be a "+" then the Z FLAG will be set</div></div>
									<div class="assembly-row-combined"><div>237A-237C</div><div><a href="#298FH" class="memory-link">JP Z,298FH <span class="origrom2">JP Z,CAT</span></a><span class="opcode2">CA 8F 29</span></div><div>Jump
 down to 298FH if the combination of the adjusted number type flag in 
Register A and the operator value in Register E indicates string 
addition</div></div>
									<div class="assembly-row-combined"><div>237D-237F</div><div>LD HL,189AH <span class="origrom2">LD HL,OPTAB</span>  <span class="opcode2">21 9A 18</span></div><div>Load HL with the starting address of the table of precedence operator values</div></div>
									<div class="assembly-row-combined"><div>2380</div><div>ADD HL,DE <span class="opcode2">19</span></div><div>Add the value of the offset in DE to the table of precedence values pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2381</div><div>LD A,B <span class="opcode2">78</span></div><div>Load Register A with the old precedence (i.e., the precedence value for the last operator) in Register B</div></div>
									<div class="assembly-row-combined"><div>2382</div><div>LD D,(HL) <span class="opcode2">56</span></div><div>Load Register D with the precedence value for the current operator</div></div>
									<div class="assembly-row-combined"><div>2383</div><div>CP D <span class="opcode2">BA</span></div><div>Let
 A = OLD PRECEDENCE minus NEW PRECEDENCE so as to compare the precedence
 value for the current operator in Register D with the precedence value 
for the last operator in Register A.  If they match, the Z FLAG is set, 
and otherwise the NZ FLAG is set.  If A &lt; the checked value, then the
 C FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2384</div><div>RET NC <span class="opcode2">D0</span></div><div>We
 need to apply the old precedence if it has greater or equal precedence 
to the new one, so if the NC flag is set, RETurn out of this routine</div></div>
									<div class="assembly-row-combined" id="2385H"><div>2385</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the precedence value and the token for the last operator in BC to the STACK</div></div>
									<div class="assembly-row-combined" id="2346H"><div>2386-2388</div><div>LD BC,2346H <span class="origrom2">LD BC,RETAOP</span>  <span class="opcode2">01 46 23</span></div><div>Load BC with the return address in case there is a break in precedence</div></div>
									<div class="assembly-row-combined"><div>2389</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the return address in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>238A</div><div>LD A,D <span class="opcode2">7A</span></div><div>Load Register A with the precedence value for the current operator in Register D so that we can test for an exponent</div></div>
									<div class="assembly-row-combined"><div>238B-238C</div><div>CP 7FH <span class="origrom2">CP EXPSTK</span>  <span class="opcode2">FE 7F</span></div><div>Check
 to see if the precedence value for the current operator in Register A 
indicates an exponential operator.  If so, then we need FRCSNG and a 
special STACK entry</div></div>
									<div class="assembly-row-combined"><div>238D-238F</div><div><a href="#23D4H" class="memory-link">JP Z,23D4H</a><span class="opcode2">CA D4 23</span></div><div>Jump down to 23D4H if the precedence value for the current operator in Register A indicates an exponential operator</div></div>
									<div class="assembly-row-combined"><div>238D-238F</div><div><a href="#23D4H" class="memory-link">JP Z,23D4H <span class="origrom2">JP Z,EPSTK</span></a><span class="opcode2">CA D4 23</span></div><div>Jump down to 23D4H if the precedence value for the current operator in Register A indicates an exponential operator</div></div>
									<div class="assembly-row-combined"><div>2390-2391</div><div>CP 51H <span class="opcode2">FE 51</span></div><div>Check
 to see if the precedence value for the current operator in Register A 
indicates an "AND" or an "OR" logical operator.  If they match, the Z 
FLAG is set, and otherwise the NZ FLAG is set.  If A &lt; the checked 
value, then the C FLAG is set.  If A &gt;= the checked value, the NC 
FLAG is set.</div></div>
									<div class="assembly-row-combined" id="23E1H"><div>2392-2394</div><div><a href="#23E1H" class="memory-link">JP C,23E1H <span class="origrom2">JP C,ANDORD</span></a><span class="opcode2">DA E1 23</span></div><div>Jump if the precedence value for the current operator in Register A indicates a logical operator</div></div>
									<p class="debug-note" id="2395H">According to the original ROM 
source code, the following will push the current value in the ACC onto 
the STACK EXCEPT in the case of a string, in which case it will throw a 
TYPE MISMATCH error.  Registers D and E are preserved.  This routine is 
also used in the user-defined function value savings</p>
									<div class="assembly-row-combined"><div>2395-2397 <span class="origrom2">NUMREL</span></div><div>LD HL,4121H <span class="origrom2">LD HL,FACLO</span>  <span class="opcode2">21 21 41</span></div><div>Load HL with the address of the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>2398</div><div>OR A <span class="opcode2">B7</span></div><div>Ensure the CARRY FLAG is off</div></div>
									<div class="assembly-row-combined"><div>2399-239B <span class="origrom2">PUSVAL</span></div><div>LD A,(40AFH) <span class="origrom2">LD A,(VALTYP)</span>  <span class="opcode2">3A AF 40</span></div><div>Load Register A with the type of value we are dealing with.<br>Note: 40AFH holds Current number type flag</div></div>
									<div class="assembly-row-combined"><div>239C</div><div>DEC A <span class="opcode2">3D</span></div><div>Next we need to set the flags without setting CARRY ... Adjust the current number type flag in Register A</div></div>
									<div class="assembly-row-combined"><div>239D</div><div>DEC A <span class="opcode2">3D</span></div><div>Adjust the current number type flag in Register A</div></div>
									<div class="assembly-row-combined"><div>239E</div><div>DEC A <span class="opcode2">3D</span></div><div>Adjust the current number type flag in Register A. Now A will be -1=Integer, 0=String, 1=Single Precision, 5=Double Precision</div></div>
									<div class="assembly-row-combined"><div>239F-23A1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0AF6H" class="memory-link">JP Z,0AF6H <span class="origrom2">JP Z,TMERR</span></a><span class="opcode2">CA F6 0A</span></div><div>Display a <span class="code">?TM ERROR</span> if the current value in ACCumulator is a string</div></div>
									<div class="assembly-row-combined"><div>23A2</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Get the value at the location of the memory pointer in HL and put it in Register C</div></div>
									<div class="assembly-row-combined"><div>23A3</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>23A4</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load Register B with the value at the location of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>23A5</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the FACLO (held in B) to the STACK</div></div>
									<div class="assembly-row-combined"><div>23A6-23A8</div><div><a href="#23C5H" class="memory-link">JP M,23C5H <span class="origrom2">JP M,VPUSHD</span></a><span class="opcode2">FA C5 23</span></div><div>If the data was an integer, then we are done, so in that case JUMP to 23C5H</div></div>
									<div class="assembly-row-combined"><div>23A9</div><div>INC HL <span class="opcode2">23</span></div><div>It's not an integer, so lets get the rest of the value by bumping the value of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>23AA</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Load Register C with the value at the location of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>23AB</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>23AC</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load Register B with the value at the location of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>23AD</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the value in BC (the rest of the digit) to the STACK</div></div>
									<div class="assembly-row-combined"><div>23AE</div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the variable flag (held in value in AF as the type - 3) to the STACK</div></div>
									<div class="assembly-row-combined"><div>23AF</div><div>OR A <span class="opcode2">B7</span></div><div>Reset the status flags so that we can test if the current number type is double precision</div></div>
									<div class="assembly-row-combined"><div>23B0-23B2</div><div><a href="#23C4H" class="memory-link">JP PO,23C4H <span class="origrom2">JP PO,VPSHD1</span></a><span class="opcode2">E2 C4 23</span></div><div>Jump down to 23C4H if the current number type is single precision</div></div>
									<div class="assembly-row-combined"><div>23B3</div><div>POP AF <span class="opcode2">F1</span></div><div>Restore the variable flag into Register Pair AF from the STACK</div></div>
									<div class="assembly-row-combined"><div>23B4</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL</div></div>
									<div class="assembly-row-combined" id="23B5H"><div>23B5-23B6</div><div><a href="#23BAH" class="memory-link">JR C,23BAH <span class="origrom2">JR C,PUSDVR</span></a><span class="opcode2">38 03</span></div><div>Skip the next instruction if the current number type is single precision</div></div>
									<div class="assembly-row-combined"><div>23B7-23B9</div><div>LD HL,411DH <span class="origrom2">LD HL,DFACLO</span>  <span class="opcode2">21 1D 41</span></div><div>Reset HL to start of ACCumulator for a double density number.<br>Note: 411DH-4124H holds REG l</div></div>
									<div class="assembly-row-combined" id="23BAH"><div>23BA <span class="origrom2">PUSDVR</span></div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Load Register C with the rest of the double precision value (held at the location of the memory pointer in HL)</div></div>
									<div class="assembly-row-combined"><div>23BB</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>23BC</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load Register B with the next digit LSB (at the location of the memory pointer in HL)</div></div>
									<div class="assembly-row-combined"><div>23BD</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL to the next digit</div></div>
									<div class="assembly-row-combined"><div>23BE</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the LSB/NMSB of the double precision value (held in BC) to the STACK</div></div>
									<div class="assembly-row-combined"><div>23BF</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Load Register C with the value at the location of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>23C0</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>23C1</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load Register B with the value at the location of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>23C2</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the value in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>23C3</div><div>LD B,0F1H <span class="opcode2">06 F1</span></div><div>Z-80 Trick to nullify the next opcode if passing through</div></div>
									<div class="assembly-row-combined" id="23C4H"><div>23C4 <span class="origrom2">VPSHD1</span></div><div>POP AF <span class="opcode2">F1</span></div><div>Restore the variable flag (which is actually the variable flag - 3)</div></div>
									<div class="assembly-row-combined" id="23C5H"><div>23C5-23C6 <span class="origrom2">VPUSHD</span></div><div>ADD A,03H <span class="opcode2">C6 03</span></div><div>Adjust the number type in Register A up 3</div></div>
									<div class="assembly-row-combined"><div>23C7</div><div>LD C,E <span class="opcode2">4B</span></div><div>Load Register C with the value of the current operator token in Register E (0-7)</div></div>
									<div class="assembly-row-combined"><div>23C8</div><div>LD B,A <span class="opcode2">47</span></div><div>Load Register B with the number type flag in Register A</div></div>
									<div class="assembly-row-combined"><div>23C9</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save these two new things (held in BC) to the STACK</div></div>
									<div class="assembly-row-combined" id="23CAH"><div>23CA-23CC</div><div>LD BC,2406H <span class="origrom2">LD BC,APPLOP</span>  <span class="opcode2">01 06 24</span></div><div>Load BC with the return address of 2406H which is the APPLOP general operator application routine to do type conversions</div></div>
									<div class="assembly-row-combined" id="23CDH"><div>23CD <span class="origrom2">FINTMP</span></div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the return address in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>23CE-23D0</div><div>LD HL,(40D8H) <span class="origrom2">LD HL,(TEMP3)</span>  <span class="opcode2">2A D8 40</span></div><div>Load HL with the value of the current BASIC program pointer.<br>Note: 40D8H-40D9H holds Temporary storage location</div></div>
									<div class="assembly-row-combined"><div>23D1-23D3</div><div><a href="#233AH" class="memory-link">JP 233AH <span class="origrom2">JP LPOPER</span></a><span class="opcode2">C3 3A 23</span></div><div>Jump back to 233AH to continue reading the formula</div></div>
								</div>
							</li></div>

							<h2 class="assembly-section-title" id="23D4H">23D4-23D6 - Part of the Evaluation Routine <span class="origrom">- "EPSTK"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Per the original ROM source, for exponentiation, we want to 
force the current value in the ACCumulator to be single precision.  When
 application time comes, we force the right hand operand to single 
precision as well.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>23D4-23D6 <span class="origrom2">EXPSTK</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0AB1H" class="memory-link">CALL 0AB1H <span class="origrom2">CALL FRCSNG</span></a><span class="opcode2">CD B1 0A</span></div><div>Call
 the CONVERT TO SINGLE PRECISION routine at 0AB1H (which converts the 
contents of ACCumulator from integer or double precision into single 
precision)</div></div>
									<div class="assembly-row-combined"><div>23D7-23D9</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09A4H" class="memory-link">CALL 09A4H <span class="origrom2">CALL PUSHF</span></a><span class="opcode2">CD A4 09</span></div><div>Call 09A4 which moves the SINGLE PRECISION value in the ACCumulator to the STACK (stored in LSB/MSB/Exponent order)</div></div>
									<div class="assembly-row-combined"><div>23DA-23DC</div><div>LD BC,13F2H <span class="origrom2">LD BC,FPWRQ</span>  <span class="opcode2">01 F2 13</span></div><div>Load BC with the address of the exponential X <span class="code">^</span> Y routine at 13F2H</div></div>
									<div class="assembly-row-combined"><div>23DD-23DE</div><div>LD D,7FH <span class="opcode2">16 7F</span></div><div>Load Register D with the precedence value for an exponential operator</div></div>
									<div class="assembly-row-combined"><div>23DF-23E0</div><div><a href="#23CDH" class="memory-link">JR 23CDH <span class="origrom2">JR FINTMP</span></a><span class="opcode2">18 EC</span></div><div>Jump back to 23CDH to continue expression evaluation</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="23E1H">23D4-23D6 - Part of the Evaluation Routine <span class="origrom">- "ANDORD"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source, for <span class="code">AND</span> and <span class="code">OR</span> and <span class="code">\</span> and <span class="code">MOD</span>
 we want to force the current value in the ACCumulator to be an integer,
 and at application time force the right hand operator to be an integer 
as well.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>23E1 <span class="origrom2">ANDORD</span></div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the precedence value and the operator token in DE to the STACK</div></div>
									<div class="assembly-row-combined"><div>23E2-23E4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A7FH" class="memory-link">CALL 0A7FH <span class="origrom2">CALL FRCINT</span></a><span class="opcode2">CD 7F 0A</span></div><div>Call
 the CONVERT TO INTEGER routine at 0A7FH (where the contents of 
ACCumulator are converted from single or double precision to integer and
 deposited into HL)</div></div>
									<div class="assembly-row-combined"><div>23E5</div><div>POP DE <span class="opcode2">D1</span></div><div>Get the precedence value and the operator token from the STACK and put it in DE</div></div>
									<div class="assembly-row-combined"><div>23E6</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the left hand operand in HL to the STACK</div></div>
									<div class="assembly-row-combined" id="23E7H"><div>23E7-23E9</div><div>LD BC,25E9H <span class="origrom2">LD BC,DANDOR</span>  <span class="opcode2">01 E9 25</span></div><div>Load BC with a return address of 25E9H to handle AND and OR</div></div>
									<div class="assembly-row-combined"><div>23EA-23EB</div><div><a href="#23CDH" class="memory-link">JR 23CDH <span class="origrom2">JR FINTMP</span></a><span class="opcode2">18 E1</span></div><div>Jump back to 23CDH to push this address, push precedence, and then keep processing the expression.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="23ECH">23D4-23D6 - Part of the Evaluation Routine <span class="origrom">- "FINREL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source, this routine will build
 an entry for a relational operator strings are treated specially. 
Numeric compares are different from most operator entries only in the 
fact that at the bottom instead of having RETAOP, DOCMP and the 
relational bits are stored. Strings have STRCMP, the pointer at the 
string descriptor, DOCMP and the relational bits.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>23EC <span class="origrom2">FINREL</span></div><div>LD A,B <span class="opcode2">78</span></div><div>Load Register A with the precedence value for the PRIOR operator in Register B</div></div>
									<div class="assembly-row-combined"><div>23ED-23EE</div><div>CP 64H <span class="opcode2">FE 64</span></div><div>Check
 to see if the last operator was a logical/relational operator, as those
 have a value of 100.  If they match, the Z FLAG is set, and otherwise 
the NZ FLAG is set.  If A &lt; the checked value, then the C FLAG is 
set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>23EF</div><div>RET NC <span class="opcode2">D0</span></div><div>If the PRIOR operator has a higher precedentnce then apply that one instead via a RETurn</div></div>
									<div class="assembly-row-combined" id="23F0H"><div>23F0</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the precedence value and the operator token for the PRIOR operator in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>23F1</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the precedence value (D) and the token (E) for the current operator from DE (either a 6, 5, or 3) to the STACK</div></div>
									<div class="assembly-row-combined"><div>23F2-23F4</div><div>LD DE,6404H <span class="origrom2">LD DE,256 * 100 + OPCNT</span>  <span class="opcode2">11 04 64</span></div><div>Load DE with the precedence value (of 100) and the displatch offset of the token for the new operator</div></div>
									<div class="assembly-row-combined"><div>23F5-23F7</div><div>LD HL,25B8H <span class="origrom2">LD HL,DOCMP</span>  <span class="opcode2">21 B8 25</span></div><div>LD
 HL with the routine to take compare routine results and relation bits 
and return the answer; routine will do a JUMP to DOCMP when complete</div></div>
									<div class="assembly-row-combined"><div>23F8</div><div>PUSH HL <span class="opcode2">E5</span></div><div>and push it to the STACK</div></div>
									<div class="assembly-row-combined"><div>23F9</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H <span class="origrom2">GETYPE</span></a><span class="opcode2">E7</span></div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
 The RST 20H routine determines the type of the current value in 
ACCumulator and returns a combination of STATUS flags and unique numeric
 values in the A Register according to the data mode flag (40AFH).  The 
results are returned as follows:<br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>23FA-23FC</div><div><a href="#2395H" class="memory-link">JP NZ,2395H <span class="origrom2">JP NZ,NUMREL</span></a><span class="opcode2">C2 95 23</span></div><div>If that test shows we do NOT have a STRING (i.e., we have numbers), jump back to 2395H to build an APPLOP entry</div></div>
									<div class="assembly-row-combined"><div>23FD-23FF</div><div>LD HL,(4121H) <span class="origrom2">LD HL,(FACLO)</span>  <span class="opcode2">2A 21 41</span></div><div>If
 we are here then we have a string, so first load HL with the string 
address held at the memory location pointed to by ACCumulator</div></div>
									<div class="assembly-row-combined" id="2400H"><div>2400</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the string's address in HL to the STACK so that STRCMP can use it.</div></div>
									<div class="assembly-row-combined" id="2401H"><div>2401-2303</div><div>LD BC,258CH <span class="origrom2">LD BC,STRCMP</span>  <span class="opcode2">01 8C 25</span></div><div>Load BC with the address of the string comparison routine</div></div>
									<div class="assembly-row-combined"><div>2404-2405</div><div><a href="#23CDH" class="memory-link">JR 23CDH <span class="origrom2">JR FINTMP</span></a><span class="opcode2">18 C7</span></div><div>Jump back to 23CDH which will push BC, re-get the text pointer, save the precedence, and then scan more of the expression.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2406H">2406 - Part of the Evaluation Routine <span class="origrom">- "APPLOP"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source code, APPLOP is returned
 to when it is time to apply an arithmetic or numeric comparison 
operation.  The STACK has a double byte entry with the operator number 
and the VALTYP of the value on the STACK.  APPLOP decides what value 
level the operation will occur at, and converts the arguments.  APPLOP 
uses different calling conventions for each value type:</p><ul><li>integers: left in [d,e] right in [h,l]</li><li></li><li>singles:  left in [b,c,d,e] right in the fac</li><li>doubles:  left in fac   right in arg</li></ul><p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2406 <span class="origrom2">APPLOP</span></div><div>POP BC <span class="opcode2">C1</span></div><div>Get the operand value type into B and the Operator Offset (i.e., token) for the last operator from the STACK and put it in C</div></div>
									<div class="assembly-row-combined"><div>2407</div><div>LD A,C <span class="opcode2">79</span></div><div>Load Register A with the operator token in Register C</div></div>
									<div class="assembly-row-combined"><div>2408-240A</div><div>LD (40B0H),A <span class="origrom2">LD (DORES),A</span>  <span class="opcode2">32 B0 40</span></div><div>Save the operator token in Register A.<br>Note: 40B0H holds Temporary storage location</div></div>
									<div class="assembly-row-combined"><div>240B</div><div>LD A,B <span class="opcode2">78</span></div><div>Load Register A with the operand value type for the value held in the STACK (held in Register B)</div></div>
									<div class="assembly-row-combined"><div>240C-240D</div><div>CP 08H <span class="opcode2">FE 08</span></div><div>Check
 the precision type of the number in the STACK against 08H.  If they 
match, the Z FLAG is set, and otherwise the NZ FLAG is set.  If A &lt; 
the checked value, then the C FLAG is set.  If A &gt;= the checked 
value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>240E-240F</div><div><a href="#2438H" class="memory-link">JR Z,2438H <span class="origrom2">JR Z,STKDBL</span></a><span class="opcode2">28 28</span></div><div>Jump forward to 2438H to force the number in the STACK to double precision</div></div>
									<div class="assembly-row-combined"><div>2410-2412</div><div>LD A,(40AFH) <span class="origrom2">LD A,(VALTYP)</span>  <span class="opcode2">3A AF 40</span></div><div>Load Register A with the number type for the current result in ACCumulator.<br>Note: 40AFH holds Current number type flag</div></div>
									<div class="assembly-row-combined"><div>2413-2414</div><div>CP 08H <span class="opcode2">FE 08</span></div><div>Check
 to see if the current result in ACCumulator is double precision.  If 
they match, the Z FLAG is set, and otherwise the NZ FLAG is set.  If A 
&lt; the checked value, then the C FLAG is set.  If A &gt;= the checked 
value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2415-2417</div><div><a href="#2460H" class="memory-link">JP Z,2460H <span class="origrom2">JP Z,FACDBL</span></a><span class="opcode2">CA 60 24</span></div><div>Jump
 forward to 2460H if the current value in ACCumulator is double 
precision so that we can convert the STACK operand to double density</div></div>
									<div class="assembly-row-combined"><div>2418</div><div>LD D,A <span class="opcode2">57</span></div><div>Load Register D with the current data type flag for the value in the ACCumulator held in Register A</div></div>
									<div class="assembly-row-combined"><div>2419</div><div>LD A,B <span class="opcode2">78</span></div><div>Load Register A with value type of the value in the STACK entry (looking for single precision)</div></div>
									<div class="assembly-row-combined"><div>241A-241B</div><div>CP 04H <span class="opcode2">FE 04</span></div><div>Check
 to see if the number type in the STACK is single precision.  If they 
match, the Z FLAG is set, and otherwise the NZ FLAG is set.  If A &lt; 
the checked value, then the C FLAG is set.  If A &gt;= the checked 
value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>241C-241E</div><div><a href="#2472H" class="memory-link">JP Z,2472H <span class="origrom2">JP Z,STKSNG</span></a><span class="opcode2">CA 72 24</span></div><div>If so, jump forward to 2472H to convert he ACCumulator number to single precision</div></div>
									<div class="assembly-row-combined"><div>241F</div><div>LD A,D <span class="opcode2">7A</span></div><div>Load Register A with the number type flag for the value in ACCumulator for single precision.</div></div>
									<div class="assembly-row-combined"><div>2420-2421</div><div>CP 03H <span class="opcode2">FE 03</span></div><div>Check
 to see if the current value in ACCumulator is a string.  If they match,
 the Z FLAG is set, and otherwise the NZ FLAG is set.  If A &lt; the 
checked value, then the C FLAG is set.  If A &gt;= the checked value, 
the NC FLAG is set.</div></div>
									<div class="assembly-row-combined" id="2425H"><div>2425-2427</div><div><a href="#247CH" class="memory-link">JP NC,247CH <span class="origrom2">JP NC,FACSNG</span></a><span class="opcode2">22 E8 40</span></div><div>Jump
 forward to 247CH if the current value in ACCumulator is single 
precision to convert the value in the STACK to single precision.</div></div>
									<div class="assembly-row-combined" id="2325H"><div>2325-2427</div><div><a href="#247CH" class="memory-link">JP NC,247CH <span class="origrom2">JP NC,FACSNG</span></a><span class="opcode2">22 E8 40</span></div><div>Jump
 forward to 247CH if the current value in ACCumulator is single 
precision to convert the value in the STACK to single precision.</div></div>
									<p class="debug-note">At this point, the number in the STACK MUST be an integer.</p>
									<div class="assembly-row-combined"><div>2428-242A</div><div>LD HL,18BFH <span class="origrom2">LD HL,INTDSP</span>  <span class="opcode2">21 BF 18</span></div><div>Load HL with the starting address of the arithmetic jump table</div></div>
									<div class="assembly-row-combined"><div>242B-242C</div><div>LD B,00H <span class="opcode2">06 00</span></div><div>Load Register B with zero</div></div>
									<div class="assembly-row-combined"><div>242D</div><div>ADD HL,BC <span class="opcode2">09</span></div><div>Add the operator's token in BC to the value of the arithmetic jump table pointer in HL</div></div>
									<div class="assembly-row-combined"><div>242E</div><div>ADD HL,BC <span class="opcode2">09</span></div><div>Add
 the operator's token in BC to the value of the arithmetic jump table 
pointer in HL.  HL will now point to where to go to process.</div></div>
									<div class="assembly-row-combined"><div>242F</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Now
 that HL points to the token, we need to get the address from the lookup
 table.  Load Register C with the LSB of the jump address at the 
location of the arithmetic jump table pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2430</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the arithmetic jump table pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2431</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load Register B with the MSB of the jump address at the location of the arithmetic jump table pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2432</div><div>POP DE <span class="opcode2">D1</span></div><div>Get the left hand operand from the STACK and put it into Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>2433-2435</div><div>LD HL,(4121H) <span class="origrom2">LD HL,(FACLO)</span>  <span class="opcode2">2A 21 41</span></div><div>Get the right hand operand from (FACLO) and put it into Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>2436</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the arithmetic routine's jump address in register pair BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>2437</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to the arithmetic routine of choice.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2438H">2438 - Part of the Evaluation Routine <span class="origrom">- "STKDBL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source code, at this point we 
know the STACK operand is double precision, so the number in the ACC 
must be forced into double precision, then moved into ARG and the STACK 
value POPped into ACC.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2438-243A <span class="origrom2">STKDBL</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0ADBH" class="memory-link">CALL 0ADBH <span class="origrom2">CALL FRCDBL</span></a><span class="opcode2">CD DB 0A</span></div><div>Make
 the ACCumulator double precision via a call to the CONVERT TO DOUBLE 
PRECISION routine at 0ADBH (where the contents of ACCumulator are 
converted from integer or single precision to double precision)</div></div>
									<div class="assembly-row-combined"><div>243B-243D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09FCH" class="memory-link">CALL 09FCH <span class="origrom2">CALL VMOVAF</span></a><span class="opcode2">CD FC 09</span></div><div>Move the ACC into the ARG</div></div>
									<div class="assembly-row-combined"><div>243E</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the STACK operand into the ACCumulator ...POP the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>243F-2441</div><div>LD (411FH),HL <span class="origrom2">LD (DFACLO+2),HL</span>  <span class="opcode2">22 1F 41</span></div><div>Save the value in HL near the end of the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>2442</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2443-2445</div><div>LD (411DH),HL <span class="origrom2">LD (DFACLO),HL</span>  <span class="opcode2">22 1D 41</span></div><div>Save the value in HL in the ACCumulator.<br>Note: 411DH-4124H holds the ACCumulator</div></div>
									<div class="assembly-row-combined" id="2446H"><div>2446 <span class="origrom2">SNGDBL</span></div><div>POP BC <span class="opcode2">C1</span></div><div>Next we need 4 bytes from the STACK so ... get the value from the STACK and put it in BC</div></div>
									<div class="assembly-row-combined"><div>2447</div><div>POP DE <span class="opcode2">D1</span></div><div>Get the value from the STACK and put it in DE</div></div>
									<div class="assembly-row-combined"><div>2448-244A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09B4H" class="memory-link">CALL 09B4H <span class="origrom2">CALL MOVFR</span></a><span class="opcode2">CD B4 09</span></div><div>Put
 those 4 bytes into the ACCumulator via a call 09B4H (which moves the 
SINGLE PRECISION value in DC/DE into ACCumulator). This moves DE to 
(4121H) and BC to (4123H)</div></div>
									<div class="assembly-row-combined" id="244BH"><div>244B-244D <span class="origrom2">SETDBL</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0ADBH" class="memory-link">CALL 0ADBH <span class="origrom2">CALL FRCDBL</span></a><span class="opcode2">CD DB 0A</span></div><div>Convert
 the first value to double precision by calling the CONVERT TO DOUBLE 
PRECISION routine at 0ADBH (where the contents of ACCumulator are 
converted from integer or single precision to double precision)</div></div>
									<div class="assembly-row-combined"><div>244E-2450</div><div>LD HL,18ABH <span class="origrom2">LD HL,DBLDSP</span>  <span class="opcode2">21 AB 18</span></div><div>Load HL with the double precision arithmetic jump table's starting address</div></div>
									<div class="assembly-row-combined" id="2451H"><div>2451-2453 <span class="origrom2">DODSP</span></div><div>LD A,(40B0H)<br><span class="origrom2">LD A,(DORES)</span>  <span class="opcode2">3A B0 40</span></div><div>Load Register A with the operator token in Register A.<br>Note: 40B0H holds Temporary storage location</div></div>
									<div class="assembly-row-combined"><div>2454</div><div>RLCA <span class="opcode2">07</span></div><div>Multiply the value of the operator token in Register A by two since each byte of the table is 2 bytes.</div></div>
									<div class="assembly-row-combined"><div>2455</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the value in BC to the STACK so we can use it for 16 bit arithmetic.</div></div>
									<div class="assembly-row-combined"><div>2456</div><div>LD C,A <span class="opcode2">4F</span></div><div>Load Register C with the adjusted value of the operator token in Register A (i.e., 2 x token)</div></div>
									<div class="assembly-row-combined"><div>2457-2458</div><div>LD B,00H <span class="opcode2">06 00</span></div><div>Load Register B with zero</div></div>
									<div class="assembly-row-combined"><div>2459</div><div>ADD HL,BC <span class="opcode2">09</span></div><div>Add
 the value of the adjusted operator token in BC (which is token value * 
2) to 18ABH (which is the double precision arithmetic jump table's 
starting address) in HL</div></div>
									<div class="assembly-row-combined"><div>245A</div><div>POP BC <span class="opcode2">C1</span></div><div>Restore BC from the STACK and put it in BC in preparation for single precision math</div></div>
									<div class="assembly-row-combined"><div>245B</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the LSB of the jump address at the location of the arithmetic jump table pointer in HL</div></div>
									<div class="assembly-row-combined"><div>245C</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the arithmetic jump table pointer in HL</div></div>
									<div class="assembly-row-combined"><div>245D</div><div>LD H,(HL) <span class="opcode2">66</span></div><div>Load Register H with the MSB of the jump address at the location of the arithmetic jump table pointer in HL</div></div>
									<div class="assembly-row-combined"><div>245E</div><div>LD L,A <span class="opcode2">6F</span></div><div>Load Register L with the LSB of the jump address in Register A</div></div>
									<div class="assembly-row-combined" id="245FH"><div>245F</div><div>JP (HL) <span class="opcode2">E9</span></div><div>Jump to the routine held in (HL).</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2460H">2460H - Part of the Evaluation Routine <span class="origrom">- "FACDBL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source code, at this point the 
ACCumulator holds a double precision numbe, and the STACK holds either 
an integer or a single precision number, so we need to convert it.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2460 <span class="origrom2">FACDBL</span></div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the number type of the value held in the STACK</div></div>
									<div class="assembly-row-combined"><div>2461-2463</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09FCH" class="memory-link">CALL 09FCH <span class="origrom2">CALL VMOVAF</span></a><span class="opcode2">CD FC 09</span></div><div>Move the value in the ACCumulator into ARG</div></div>
									<div class="assembly-row-combined"><div>2464</div><div>POP AF <span class="opcode2">F1</span></div><div>Load Register A with the value type of the number in the STACK</div></div>
									<div class="assembly-row-combined"><div>2465-2467</div><div>LD (40AFH),A <span class="origrom2">LD (VALTYP),A</span>  <span class="opcode2">32 AF 40</span></div><div>Save the value of the current number type flag in Register A.<br>Note: 40AFH holds Current number type flag</div></div>
									<div class="assembly-row-combined"><div>2468-2469</div><div>CP 04H <span class="opcode2">FE 04</span></div><div>Check
 to see if the current result in ACCumulator is single precision.  If 
they match, the Z FLAG is set, and otherwise the NZ FLAG is set.  If A 
&lt; the checked value, then the C FLAG is set.  If A &gt;= the checked 
value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>246A-246B</div><div><a href="#2446H" class="memory-link">JR Z,2446H <span class="origrom2">JR Z,SNGDBL</span></a><span class="opcode2">28 DA</span></div><div>Jump
 back to 2446H if the current result in ACCumulator is single precision.
  That will POP BC and DE, and then CALL MOVFR to continue</div></div>
									<div class="assembly-row-combined"><div>246C</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the integer value from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>246D-246F</div><div>LD (4121H),HL <span class="origrom2">LD (FACLO),HL</span>  <span class="opcode2">22 21 41</span></div><div>Save the integer value in HL in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>2470-2471</div><div><a href="#244BH" class="memory-link">JR 244BH <span class="origrom2">JR SETDBL</span></a><span class="opcode2">18 D9</span></div><div>Jump back to 244BH to set it up</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2472H">2472H - Part of the Evaluation Routine <span class="origrom">- "STKSNG"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source code, at this point the 
STACK holds a single precision number, we know that the ACCumulator 
holds either an integer or a single precision number, so we need to 
convert it.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2472-2474 <span class="origrom2">STKSNG</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0AB1H" class="memory-link">CALL 0AB1H <span class="origrom2">CALL FRCSNG</span></a><span class="opcode2">CD B1 0A</span></div><div>Convert
 the ACCumulator if necessary via a call to the CONVERT TO SINGLE 
PRECISION routine at 0AB1H (which converts the contents of ACCumulator 
from integer or double precision into single precision)</div></div>
									<div class="assembly-row-combined"><div>2475</div><div>POP BC <span class="opcode2">C1</span></div><div>Get the left hand operand into the registers.  First POP the value from the STACK and put it in BC</div></div>
									<div class="assembly-row-combined"><div>2476</div><div>POP DE <span class="opcode2">D1</span></div><div>and then get the value from the STACK and put it in DE</div></div>
									<div class="assembly-row-combined" id="2477H"><div>2477-2479 <span class="origrom2">SNGDO</span></div><div>LD HL,18B5H <span class="origrom2">LD HL,SNGDSP</span>  <span class="opcode2">21 B5 18</span></div><div>Load HL with the starting address of the single precision arithmetic jump table</div></div>
									<div class="assembly-row-combined"><div>247A-247B</div><div><a href="#2451H" class="memory-link">JR 2451H <span class="origrom2">JR DODSP</span></a><span class="opcode2">18 D5</span></div><div>Jump back to 2451H to perform the operation held in Registe Pair HL</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="247CH">247CH - Part of the Evaluation Routine <span class="origrom">- "FACSNG"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source code, at this point the 
ACCuumulator holds a single precision number and the STACK holds an 
integer.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>247C <span class="origrom2">FACSNG</span></div><div>POP HL <span class="opcode2">E1</span></div><div>Get the integer value from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>247D-247F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09A4H" class="memory-link">CALL 09A4H <span class="origrom2">CALL PUSHF</span></a><span class="opcode2">CD A4 09</span></div><div>Call 09A4 which moves the SINGLE PRECISION value in ACCumulator to the STACK (stored in LSB/MSB/Exponent order)</div></div>
									<div class="assembly-row-combined"><div>2480-2482</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0ACFH" class="memory-link">CALL 0ACFH <span class="origrom2">CALL CONSIH</span></a><span class="opcode2">CD CF 0A</span></div><div>Go convert the integer value in HL to single precision</div></div>
									<div class="assembly-row-combined"><div>2483-2485</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09BFH" class="memory-link">CALL 09BFH <span class="origrom2">CALL MOVRF</span></a><span class="opcode2">CD BF 09</span></div><div>Call 09BF which loads the SINGLE PRECISION value (tyhe left hand operator) in ACCumulator into BC/DE</div></div>
									<div class="assembly-row-combined"><div>2486</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the ACCumulator LSB/NMSB from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2487-2489</div><div>LD (4123H),HL <span class="origrom2">LD (FAC-1),HL</span><span class="opcode2">22 23 41</span></div><div>Save the value in HL in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>248A</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the MSB and exponent from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>248B-248D</div><div>LD (4121H),HL <span class="origrom2">LD (FACLO),HL</span>  <span class="opcode2">22 21 41</span></div><div>Save the value in HL in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>248E-248F</div><div><a href="#2477H" class="memory-link">JR 2477H <span class="origrom2">JR SNGDO</span></a><span class="opcode2">18 E7</span></div><div>Jump back to 2477H to perform the operation</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2490H">2490 - Integer divide <span class="origrom">- "INTDIV"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>(ACC=DE / HL) Result will be in single-precision (NTF=4) and will be in the ACC.<br>Divides
 DE by HL. Both values are converted to single precision before the 
division is started. The quotient is left in REG l; the mode flag is 
updated. The orginal contents of the DE and HL Register sets are lost<br><br>The
 original ROM source code points that we can't just live in integer 
world here, because we want 1/3 to be .3333 and not 0!  So all arguments
 must be single precision even if they are integer<br><br>Integer 
Division: Divides DE by HL. Both values are converted to single 
precision before the division is started. The quotient is left in the 
ACCumulator; the mode flag is updated. The orginal contents of the DE 
and HL Register sets are lost<br><br>Single Precision Divide Divides the
 single precision value in (BC/DE) by the single precision value in the 
ACCumulator. The quotient is left in the ACCumulator.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2490 <span class="origrom2">INTDIV</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the right hand argument (in HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>2491</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Exchange the left hand argument into HL and the right hand argument into DE</div></div>
									<div class="assembly-row-combined"><div>2492-2494</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0ACFH" class="memory-link">CALL 0ACFH <span class="origrom2">CALL CONSIH</span></a><span class="opcode2">CD CF 0A</span></div><div>Go convert the integer value in HL to single precision and return with the result in the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>2495</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the right hand argument from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2496-2498</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09A4H" class="memory-link">CALL 09A4H <span class="origrom2">CALL PUSHF</span></a><span class="opcode2">CD A4 09</span></div><div>Call
 09A4 which moves the SINGLE PRECISION value the ACCumulator (i.e., the 
converted left hand argument) to the STACK (stored in LSB/MSB/Exponent 
order)</div></div>
									<div class="assembly-row-combined"><div>2499-249B</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0ACFH" class="memory-link">CALL 0ACFH <span class="origrom2">CALL CONSIH</span></a><span class="opcode2">CD CF 0A</span></div><div>Go
 convert the integer value in HL (i.e., the right hand argument) to 
single precision and return with the result the ACCumulator</div></div>
									<div class="assembly-row-combined"><div>249C-249E</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#08A0H" class="memory-link">JP 08A0H <span class="origrom2">JP FDIVT</span></a><span class="opcode2">C3 A0 08</span></div><div>Go do a single precision divide</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="249FH">249F - Evaluate a Variable, Constant, or Function Call <span class="origrom">- "EVAL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>249F <span class="origrom2">EVAL</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>24A0-24A1</div><div>LD E,28H <span class="opcode2">1E 28</span></div><div>Load Register E with a <span class="code">?MO ERROR</span> code</div></div>
									<div class="assembly-row-combined"><div>24A2-24A4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#19A2H" class="memory-link">JP Z,19A2H <span class="origrom2">JP Z,ERROR</span></a><span class="opcode2">CA A2 19</span></div><div>Display a <span class="code">?MO ERROR</span> if we are at the end of the string</div></div>
									<div class="assembly-row-combined"><div>24A5-24A7</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0E6CH" class="memory-link">JP C,0E6CH <span class="origrom2">JP C,FIN</span></a><span class="opcode2">DA 6C 0E</span></div><div>If
 the character at the location of the current BASIC program pointer in 
HL is numeric, call the ASCII TO BINARY routine at 0E6C (which converts 
the ASCII string pointed to by HL to binary with the result in 
ACCumulator and the mode flag will have changed)</div></div>
									<div class="assembly-row-combined"><div>24A8-24AA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E3DH" class="memory-link">CALL 1E3DH <span class="origrom2">CALL ISLET</span></a><span class="opcode2">CD 3D 1E</span></div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in HL is alphabetic (as we are also looking to see if we have a 
variable name)</div></div>
									<div class="assembly-row-combined" id="24ABH"><div>24AB-24AD</div><div><a href="#2540H" class="memory-link">JP NC,2540H <span class="origrom2">JP NC,ISVAR</span></a><span class="opcode2">D2 40 25</span></div><div>If
 the character at the location of the current BASIC program pointer in 
HL is alphabetic then we have a variable, so JUMP to 1E3DH to deal with 
that.</div></div>
									<div class="assembly-row-combined"><div>24AE-24AF</div><div>CP 0CDH <span class="origrom2">CP PLUSTK</span>  <span class="opcode2">FE CD</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">+</span>
 token.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>24B0-24B1</div><div><a href="#249FH" class="memory-link">JR Z,249FH <span class="origrom2">JR Z,EVAL</span></a><span class="opcode2">28 ED</span></div><div>We want to ignore any <span class="code">+</span> token here, so if we have one, JUMP back to the top of this EVAL routine and keep parsing.</div></div>
									<div class="assembly-row-combined"><div>24B2-24B3</div><div>CP 2EH <span class="opcode2">FE 2E</span></div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in Register A is a decimal point.  If they match, the Z FLAG is 
set, and otherwise the NZ FLAG is set.  If A &lt; the checked value, 
then the C FLAG is set.  If A &gt;= the checked value, the NC FLAG is 
set.</div></div>
									<div class="assembly-row-combined"><div>24B4-24B6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0E6CH" class="memory-link">JP Z,0E6CH <span class="origrom2">JP Z,FIN</span></a><span class="opcode2">CA 6C 0E</span></div><div>If
 the character at the location of the current BASIC program pointer in 
HL is a decimal point, call the ASCII TO BINARY routine at 0E6C (which 
converts the ASCII string pointed to by HL to binary with the result in 
ACCumulator and the mode flag will have changed)</div></div>
									<div class="assembly-row-combined"><div>24B7-24B8</div><div>CP 0CEH <span class="origrom2">CP MINUTK</span>  <span class="opcode2">FE CE</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">-</span>
 token.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>24B9-24BB</div><div><a href="#2532H" class="memory-link">JP Z,2532H <span class="origrom2">JP Z,DOMIN</span></a><span class="opcode2">CA 32 25</span></div><div>Process a negation via a jump to 2532H if the character at the location of the current BASIC program pointer in Register A is a <span class="code">-</span> token</div></div>
									<div class="assembly-row-combined" id="24BCH"><div>24BC-24BD</div><div>CP 22H <span class="opcode2">FE 22</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">"</span> .<br><p class="bold" style="margin-bottom:0px;">Notes:</p><ul><li>22H is a <span class="code">"</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</li></ul></div></div>
									<div class="assembly-row-combined"><div>24BE-24C0</div><div><a href="#2866H" class="memory-link">JP Z,2866H <span class="origrom2">JP Z,STRLTI</span></a><span class="opcode2">CA 66 28</span></div><div>If
 the character is a quote then we have a string constant, so jump to 
2866H if the character at the location of the current BASIC program 
pointer in Register A is a <span class="code">"</span></div></div>
									<div class="assembly-row-combined"><div>24C1-24C2</div><div>CP 0CBH <span class="origrom2">CP NOTTK</span>  <span class="opcode2">FE CB</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">NOT</span>
 token.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>24C3-24C5</div><div><a href="#25C4H" class="memory-link">JP Z,25C4H <span class="origrom2">JP Z,NOTER</span></a><span class="opcode2">CA C4 25</span></div><div>Jump to 25C4H if the character at the location of the current BASIC program pointer in Register A is a <span class="code">NOT</span> token</div></div>
									<div class="assembly-row-combined"><div>24C6-24C7</div><div>CP 26H <span class="opcode2">FE 26</span></div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in Register A is a &amp;.  If they match, the Z FLAG is set, and
 otherwise the NZ FLAG is set.  If A &lt; the checked value, then the C 
FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>24C8-24CA</div><div><a href="#25C4H" class="memory-link">JP Z,4194H <span class="origrom2">JP Z,OCTCNS</span></a><span class="opcode2">CA 94 41</span></div><div>Just to DOS to handle a &amp;O; and &amp;H;</div></div>
									<div class="assembly-row-combined"><div>24CB-24CC</div><div>CP 0C3H <span class="origrom2">CP ERCTK</span>  <span class="opcode2">FE C3</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is an <span class="code">ERR</span> token.<br><p class="bold" style="margin-bottom:0px;">Notes:</p><ul><li>C3H is a <span class="code">ERR</span> token.</li><li>A CP will return Z if there is a match against Register A, and NZ if not a match against Register A.</li></ul></div></div>
									<div class="assembly-row-combined"><div>24CD-24CE</div><div><a href="#24D9H" class="memory-link">JR NZ,24D9H <span class="origrom2">JP NZ,NTERC</span></a><span class="opcode2">20 0A</span></div><div>Jump to 24D9H if the character at the location of the current BASIC program pointer in Register A isn't an <span class="code">ERR</span> token</div></div>
									<div class="assembly-row-combined"><div>24CF</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We
 now need bump the value of the current BASIC program pointer until it 
points to the next character, call the EXAMINE NEXT SYMBOL routine at 
RST 10H.<br><br>The RST 10H routine parses the characters starting at 
HL+1 for the first non-SPACE,non-09H,non-0BH character it finds.  On 
exit, Register A will hold that character, and the C FLAG is set if its 
alphabetic, and NC FLAG if its alphanumeric.  All strings must have a 
00H at the end.</div></div>
									<div class="assembly-row-combined"><div>24D0-24D2</div><div>LD A,(409AH) <span class="origrom2">LD A,(ERRFLG)</span>  <span class="opcode2">3A 9A 40</span></div><div>Load Register A with the value of the current error number.<br>Note: 409AH holds the <span class="code">RESUME</span> flag</div></div>
									<div class="assembly-row-combined"><div>24D3 <span class="origrom2">NTDERC</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>24D4-24D6</div><div><a href="#27F8H" class="memory-link">CALL 27F8H <span class="origrom2">CALL SNGFLT</span></a><span class="opcode2">CD F8 27</span></div><div>Go save the value of the current error number in Register A (as an integer) as the current result in REG l</div></div>
									<div class="assembly-row-combined"><div>24D7</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the current BASIC program pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>24D8</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
									<div class="assembly-row-combined" id="24D9H"><div>24D9-24DA <span class="origrom2">NTERC</span></div><div>CP C2H <span class="origrom2">CP ERLTK</span>  <span class="opcode2">FE C2</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">ERL</span> token</div></div>
									<div class="assembly-row-combined"><div>24DB-24DC</div><div><a href="#24E7H" class="memory-link">JR NZ,24E7H <span class="origrom2">R NZ,NTERL</span></a><span class="opcode2">20 0A</span></div><div>Jump to 24E7H if the character at the location of the current BASIC program pointer in Register A isn't an <span class="code">ERL</span> token</div></div>
									<div class="assembly-row-combined"><div>24DD</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>24DE</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>24DF-24E1</div><div>LD HL,(40EAH) <span class="origrom2">LD HL,(ERRLIN)</span>  <span class="opcode2">2A EA 40</span></div><div>Load HL with the current error line number.<br>Note: 40EAH-40EBH holds the line number with error</div></div>
									<div class="assembly-row-combined"><div>24E2-24E3</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0C66H" class="memory-link">CALL 0C66H <span class="origrom2">CALL INEG2</span></a><span class="opcode2">CD 66 0C</span></div><div>Go save the error line number in HL as the current result in REG1</div></div>
									<div class="assembly-row-combined"><div>24E5</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the current BASIC program pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>24E6</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="24E7H">24E7-24FE <span class="code">VARPTR</span> logic <span class="origrom">- "NTERL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="24E7H"><div>24E7-24E8 <span class="origrom2">NTERL</span></div><div>CP 0C0H <span class="origrom2">CP $VARPTR</span>  <span class="opcode2">FE C0</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">VARPTR</span> token</div></div>
									<div class="assembly-row-combined"><div>24E9-24EA</div><div><a href="#24FFH" class="memory-link">JR NZ,24FFH <span class="origrom2">JR NZ,NTVARP</span></a><span class="opcode2">20 14</span></div><div>Jump back to 24FFH if the character at the location of the current BASIC program pointer in Register A isn't a <span class="code">VARPTR</span> token</div></div>
									<div class="assembly-row-combined"><div>24EB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>24EC-24ED</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 28<span class="origrom2">SYNCHK "("</span></a><span class="opcode2">CF 28</span></div><div>Since the character at the location of the current BASIC program pointer in HL must be a <span class="code">(</span> , call the COMPARE SYMBOL routine at RST 08H.<br><br><span class="bold nobottomborder">NOTE:</span>
 The RST 08H routine compares the symbol in the input string pointed to 
by HL Register to the value in the location following the RST 08 call.<ul><li>If
 there is a match, control is returned to the next execution address 
(i.e, the RST 08H instruction + 2) with the next symbol in the A 
Register and HL incremented by one.</li><li>If the two characters do not match, a syntax error message is given and control returns to the Input Phase).</li></ul></div></div>
									<div class="assembly-row-combined"><div>24EE-24F0</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#260DH" class="memory-link">CALL 260DH <span class="origrom2">CALL PTRGET</span></a><span class="opcode2">CD 0D 26</span></div><div>Call
 the FIND ADDRESS OF VARIABLE routine at 260DH which searches the 
Variable List Table for a variable name which matches the name in the 
string pointed to in HL, and return the address of that variable in DE 
(and if there is no variable, it creates it, zeroes it, and returns THAT
 location)</div></div>
									<div class="assembly-row-combined"><div>24F1-24F2 <span class="origrom2">VARRET</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 29<span class="origrom2">SYNCHK ")"</span></a><span class="opcode2">CF 29</span></div><div>Since the character at the location of the current BASIC program pointer in HL must be a <span class="code">)</span>
 , call the COMPARE SYMBOL routine which compares the symbol in the 
input string pointed to by HL Register to the value in the location 
following the RST 08 call. If there is a match, control is returned to 
address of the RST 08 instruction + 2 with the next symbol in the A 
Register and HL incremented by one. If the two characters do not match, a
 syntax error message is given and control returns to the Input Phase)</div></div>
									<div class="assembly-row-combined"><div>24F3</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>24F4</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap DE and HL so that HL now holds the value to return</div></div>
									<div class="assembly-row-combined"><div>24F5</div><div>LD A,H <span class="opcode2">7C</span></div><div>Load Register A with MSB of the variable's address in Register H to make sure that it isn't undefined.</div></div>
									<div class="assembly-row-combined"><div>24F6</div><div>OR L <span class="opcode2">B5</span></div><div>Combine
 the LSB of the variable's address in Register L with the MSB of the 
variable's address in Register A. This type of pattern is used to check 
for something being zero</div></div>
									<div class="assembly-row-combined"><div>24F7-24F9</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E4AH" class="memory-link">JP Z,1E4AH <span class="origrom2">JP Z,FCERR</span></a><span class="opcode2">CA 4A 1E</span></div><div>Display a <span class="code">?FC ERROR</span> if the variable's address in HL is equal to zero, meaning that the variable is undefined</div></div>
									<div class="assembly-row-combined"><div>24FA-24FC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A9AH" class="memory-link">CALL 0A9AH <span class="origrom2">CALL MAKINT</span></a><span class="opcode2">CD 9A 0A</span></div><div>Save the variable's address in HL as an integer into ACCumulator</div></div>
									<div class="assembly-row-combined"><div>24FD</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the current BASIC program pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>24FE</div><div>RET <span class="opcode2">C9</span></div><div>Return to the execution driver</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="24FFH">24FF - Other Function Routine - Jumped here if it wasn't VARPTR to see what else it might have been <span class="origrom">- "NTVARP"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="24FFH"><div id="2500H">24FF-2500 <span class="origrom2">NTVARP</span></div><div>CP 0C1H <span class="origrom2">CP USRTK</span>  <span class="opcode2">FE C1</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">USR</span>
 token.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2501-2503</div><div><a href="#27FEH" class="memory-link">JP Z,27FEH <span class="origrom2">JP Z,USRFN</span></a><span class="opcode2">CA FE 27</span></div><div>Jump to 27FEH if the character at the location of the current BASIC program pointer in Register A is a <span class="code">USR</span> token</div></div>
									<div class="assembly-row-combined"><div>2504-2505</div><div>CP 0C5H <span class="origrom2">CP INSRTK</span>  <span class="opcode2">FE C5</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">INSTR</span>
 token.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2501-2503</div><div><a href="#27FEH" class="memory-link">JP Z,419DH <span class="origrom2">JP Z,INSTR</span></a><span class="opcode2">CA FE 27</span></div><div>If the character at the location of the current BASIC program pointer in Register A is a <span class="code">INSTR</span> token, jump to DOS to deal with it.</div></div>
									<div class="assembly-row-combined"><div>2509-250A</div><div>CP 0C8H <span class="origrom2">CP $MEM</span>  <span class="opcode2">FE C8</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">MEM</span>
 token.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>250B-250D</div><div><a href="#27C9H" class="memory-link">JP Z,27C9H <span class="origrom2">JP Z,MEM</span></a><span class="opcode2">CA C9 27</span></div><div>If the character at the location of the current BASIC program pointer in Register A is a <span class="code">MEM</span>
 token, jump to the RETURN AMOUNT OF FREE MEMORY routine at 27C9H which 
computes the amount of memory remaining between the end of the variable 
list and the end of the STACK and puts the result in ACCumulator as a 
SINGLE PRECISION number</div></div>
									<div class="assembly-row-combined"><div>250E-250F</div><div>CP 0C7H <span class="origrom2">CP $TIME</span>  <span class="opcode2">FE C7</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">TIME$</span>
 token.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>250B-250D</div><div><a href="#27C9H" class="memory-link">JP Z,417DH <span class="origrom2">JP Z,TIME</span></a><span class="opcode2">CA C9 27</span></div><div>If the character at the location of the current BASIC program pointer in Register A is a <span class="code">MEM</span> token, jump to DOS to deal with it.</div></div>
									<div class="assembly-row-combined"><div>2513-2514</div><div>CP 0C6H <span class="origrom2">CP $POINT</span>  <span class="opcode2">FE C6</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">POINT</span>
 token.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2515-2517</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0132H" class="memory-link">JP Z,0132H <span class="origrom2">JP Z,POINT</span></a><span class="opcode2">CA 32 01</span></div><div>Jump to 0132H if the character at the location of the current BASIC program pointer in Register A is a <span class="code">POINT</span> token</div></div>
									<div class="assembly-row-combined"><div>2518-2519</div><div>CP 0C9H <span class="origrom2">CP $INKEY</span>  <span class="opcode2">FE C9</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is an <span class="code">INKEY$</span>
 token.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>251A-251C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#019DH" class="memory-link">JP Z,019DH <span class="origrom2">JP Z,INKEY</span></a><span class="opcode2">CA 9D 01</span></div><div>Jump to 019DH if the character at the location of the current BASIC program pointer in Register A is an <span class="code">INKEY$</span> token</div></div>
									<div class="assembly-row-combined"><div>251D-251E</div><div>CP 0C4H <span class="origrom2">CP $STRING</span>  <span class="opcode2">FE C4</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">STRING$</span>
 token.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>241F-2421</div><div><a href="#2A2FH" class="memory-link">JP Z,2A2FH <span class="origrom2">JP Z,STRNG$</span></a><span class="opcode2">7A</span></div><div>Jump to 2A2FH if the character at the location of the current BASIC program pointer in Register A is a <span class="code">STRING$</span> token</div></div>
									<div class="assembly-row-combined"><div>2522-2523</div><div>CP 0BEH <span class="origrom2">CP FNTK</span>  <span class="opcode2">FE BE</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">FN</span>
 token.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>241F-2421</div><div>JP Z,4155H <span class="origrom2">JP Z,FNDOER</span>  <span class="opcode2">7A</span></div><div>If the character at the location of the current BASIC program pointer in Register A is a <span class="code">FN</span> token, jump to DOS to deal with it.</div></div>
									<div class="assembly-row-combined"><div>2527-2528</div><div>SUB 0D7H <span class="origrom2">SUB ONEFUN</span>  <span class="opcode2">D6 D7</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a function name between the <span class="code">SGN</span> and <span class="code">MID$</span> token</div></div>
									<div class="assembly-row-combined" id="254EH"><div>2529-252B</div><div><a href="#254EH" class="memory-link">JP NC,254EH <span class="origrom2">JP NC,ISFUN</span></a><span class="opcode2">D2 4E 25</span></div><div>Jump to 254EH if the character at the location of the current BASIC program pointer in Register A is a <span class="code">SGN</span> to <span class="code">MID$</span>
 token.  The original ROM source notes that there is no need to check 
for an upper bound because functions are the highest allowed characters</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="252CH">252CH - Other Function Routine - If we pass through to here, the only other possibility is that it is a function in parenthesis <span class="origrom">- "PARCHK"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>252C-252E <span class="origrom2">PARCHK</span></div><div><a href="#2335H" class="memory-link">CALL 2335H <span class="origrom2">CALL FRMPRN</span></a><span class="opcode2">CD 35 23</span></div><div>GOSUB to 2335H to recursively evaluate the expression at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>252F-2530</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 29<span class="origrom2">SYNCHK ")"</span></a><span class="opcode2">CF 29</span></div><div>Since the character at the location of the current BASIC program pointer in HL must be a <span class="code">)</span> , call the COMPARE SYMBOL routine at RST 08H.<br><br><span class="bold nobottomborder">NOTE:</span>
 The RST 08H routine compares the symbol in the input string pointed to 
by HL Register to the value in the location following the RST 08 call.<ul><li>If
 there is a match, control is returned to the next execution address 
(i.e, the RST 08H instruction + 2) with the next symbol in the A 
Register and HL incremented by one.</li><li>If the two characters do not match, a syntax error message is given and control returns to the Input Phase).</li></ul></div></div>
									<div class="assembly-row-combined"><div>2531</div><div>RET <span class="opcode2">C9</span></div><div>Return out of this routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2532H">2532 - Binary Minus Routine <span class="origrom">- "DOMIN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2532 <span class="origrom2">DOMIN</span></div><div>LD D,7DH <span class="opcode2">16 7D</span></div><div>Load Register D with a precedence value below "^" but above everything else since its a uniary minus.</div></div>
									<div class="assembly-row-combined"><div>2534-2536</div><div><a href="#233AH" class="memory-link">CALL 233AH <span class="origrom2">CALL LPOPER</span></a><span class="opcode2">CD 3A 23</span></div><div>GOSUB to 233AH to evaluate the variable at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2537-2539</div><div>LD HL,(40F3H) <span class="origrom2">LD HL,(TEMP2)</span>  <span class="opcode2">2A F3 40</span></div><div>Load HL with the value of the current BASIC program pointer.<br>Note: 40F3H-40F4H is a temporary storage location</div></div>
									<div class="assembly-row-combined"><div>253A</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL to the STACK so we know where to continue</div></div>
									<div class="assembly-row-combined"><div>253B-253D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#097BH" class="memory-link">CALL 097BH <span class="origrom2">CALL VNEG</span></a><span class="opcode2">CD 7B 09</span></div><div>Invert the sign of the current value in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>253E <span class="origrom2">LABBCK</span></div><div>POP HL <span class="opcode2">E1</span></div><div>According
 to the original ROM source, this is where functions that don't return 
string values return.  Restore the code string address from the STACK 
and put it in HL. We need this because we return here after executing 
functions <span class="code">SNG(</span> to <span class="code">MID$(</span></div></div>
									<div class="assembly-row-combined"><div>253F</div><div>RET <span class="opcode2">C9</span></div><div>Return to the expression evaluation</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2540H">2540 - Math Routine <span class="origrom">- "ISVAR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source code, this routine loads
 a variable to the ACC and sets the NTF. The HL must point to the ASCII 
variable name. After execution the HL will point to the character 
following the last character of the variable used. The value of the 
variable will be loaded in the ACC. For strings however (NTF=3), the ACC
 will contain the address of the first three bytes which contain the 
string length and string address (see Level II BASIC manual). Also note 
that if the variable cannot be found it will be created and given a 
value of zero.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2540H"><div>2540-2542 <span class="origrom2">ISVAR</span></div><div><a href="#260DH" class="memory-link">CALL 260DH <span class="origrom2">CALL PTRGET</span></a><span class="opcode2">CD 0D 26</span></div><div>Get
 the pointer to the variable held in Register Pair DE by calling the 
FIND ADDRESS OF VARIABLE routine at 260DH which searches the Variable 
List Table for a variable name which matches the name in the string 
pointed to in HL, and return the address of that variable in DE (and if 
there is no variable, it creates it, zeroes it, and returns THAT 
location)</div></div>
									<div class="assembly-row-combined"><div>2543 <span class="origrom2">RETVAR</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2544</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap
 DE and HL so that the pointer to the variable value is now held in 
Register Pair HL.  This is the pointer to a descriptor, not the actual 
variable.</div></div>
									<div class="assembly-row-combined"><div>2545-2547</div><div>LD (4121H),HL <span class="origrom2">LD (FACLO),HL</span>  <span class="opcode2">22 21 41</span></div><div>In case it is a string, we will store the pointer to the descriptor in FACLO.</div></div>
									<div class="assembly-row-combined"><div>2548</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H <span class="origrom2">GETYPE</span></a><span class="opcode2">E7</span></div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
 The RST 20H routine determines the type of the current value in 
ACCumulator and returns a combination of STATUS flags and unique numeric
 values in the A Register according to the data mode flag (40AFH).  The 
results are returned as follows:<br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>2549-254B</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09F7H" class="memory-link">CALL NZ,09F7H <span class="origrom2">CALL NZ,VMOVFM</span></a><span class="opcode2">C4 F7 09</span></div><div>If
 we had a string, then we are just going to leave a pointer in the 
ACCumulator.  If not, the we need to actually transfer the value into th
 ACCumulator using the pointer in Register Pair HL.  With this, if that 
test shows we do NOT have a STRING, call 09F7H to move data</div></div>
									<div class="assembly-row-combined"><div>254C</div><div>POP HL <span class="opcode2">E1</span></div><div>Restore the value of the current BASIC program pointer to Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>254D</div><div>RET <span class="opcode2">C9</span></div><div>Return to the caller</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="254EH">254E - This routine processes an expression for <span class="code">SNG(</span> to <span class="code">MID$(</span>  <span class="origrom">- "ISFUN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>254E-254F <span class="origrom2">ISFUN</span></div><div>LD B,00H <span class="opcode2">06 00</span></div><div>Load Register B with zero</div></div>
									<div class="assembly-row-combined"><div>2550</div><div>RLCA <span class="opcode2">07</span></div><div>Set A to be 2 * (token - D7H)</div></div>
									<div class="assembly-row-combined"><div>2551</div><div>LD C,A <span class="opcode2">4F</span></div><div>Save the new token</div></div>
									<div class="assembly-row-combined"><div>2552</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save 0/2*(token-D7) on STACK</div></div>
									<div class="assembly-row-combined"><div>2553</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>Get the next character from the tokenized string by calling RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2554</div><div>LD A,C <span class="opcode2">79</span></div><div>Prepare to look for the function number</div></div>
									<div class="assembly-row-combined"><div>2555 <span class="origrom2">NUMGFN</span></div><div>CP 41H <span class="origrom2">CP NUMGFN</span>  <span class="opcode2">FE 41</span></div><div>Test
 the adjusted token to see if it is past 2 * LASNUM - 2 * ONEFUN + 1.  
If they match, the Z FLAG is set, and otherwise the NZ FLAG is set.  If A
 &lt; the checked value, then the C FLAG is set.  If A &gt;= the checked
 value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2557</div><div><a href="#256FH" class="memory-link">JR C,256FH <span class="origrom2">JR C,OKNORM</span></a><span class="opcode2">38 16</span></div><div>If the CARRY FLAG is set, then the function is past that last number, so JUMP to 256FH if the token is <span class="code">SGN(</span> to <span class="code">CHR$(</span> . If not, it is a <span class="code">LEFT$</span> - <span class="code">MID$</span></div></div>
									<div class="assembly-row-combined"><div>2559</div><div><a href="#2335H" class="memory-link">CALL 2335H <span class="origrom2">CALL FRMPRN</span></a><span class="opcode2">CD 35 23</span></div><div>Otherwise,
 it must be a normal function so GOSUB to 2335H to capture the "(" and 
the first argument.  This routine will evaluate the expression part of 
the calling sequence (which requires 2 or parameters)</div></div>
									<p class="debug-note">The original source code has this to say about being here:<br><br>Most
 functions take a single argument.  The return address of these 
functions is a small routine that checks to make sure valtyp is 0 
(numeric) and pops off the text pointer. so normal functions that return
 string results (i.e. chr$) must pop off the return address of labbck, 
and pop off the text pointer and then return to FRMEVL.<br><br>The so 
called "funny" functions can take more than one argument, the first of 
which must be string and the second of which must be a number between 0 
and 256.  The text pointer is passed to these functions so additional 
arguments can be read.  The text pointer is passed in Register Pair DE. 
 The close parenthesis must be checked and return is directly to FRMEVL 
with Register Pair HL setup as the text pointer pointing beyond the ")".<br><br>The
 pointer to the descriptor of the string argument is stored on the STACK
 underneath the value of the integer argument (2 bytes).<br><br>The first argument is ALWAY a string.  The second is always an integer.</p>
									<div class="assembly-row-combined"><div>255C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 2C<span class="origrom2">SYNCHK ","</span></a><span class="opcode2">CF 2C</span></div><div>We need TWO arguments, so there needs to be a ",".  With this we use RST 08H to test for a <span class="code">,</span></div></div>
									<div class="assembly-row-combined"><div>255E</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0AF4H" class="memory-link">CALL 0AF4H <span class="origrom2">CALL CHKSTR</span></a><span class="opcode2">CD F4 0A</span></div><div>GOSUB to 0AF4H to ensure the current variable is a string, otherwise it is an error</div></div>
									<div class="assembly-row-combined"><div>2561</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap
 DE and HL so that DE will now point to the position in the current 
BASIC program being evaluated and HL is the address of the current 
variable (which MUST be a string)</div></div>
									<div class="assembly-row-combined"><div>2562</div><div>LD HL,(4121H) <span class="origrom2">LD HL,(FACLO)</span>  <span class="opcode2">2A 21 41</span></div><div>Load HL with the string descriptor address held at the memory location pointed to by ACCumulator</div></div>
									<div class="assembly-row-combined"><div>2565</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Put the pointer to the string descriptor onto the STACK and put the function number into Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>2566</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save function number (i.e., 00 / 2*(token-D7H)) to the STACK</div></div>
									<div class="assembly-row-combined"><div>2567</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap DE and HL so that HL will now point to the position in the current BASIC program being evaluated.</div></div>
									<div class="assembly-row-combined"><div>2568</div><div><a href="#2B1CH" class="memory-link">CALL 2B1CH <span class="origrom2">CALL GETBYT</span></a><span class="opcode2">CD 1C 2B</span></div><div>Evaluate n portion of the string function.  Register E will contain the value of the formula.</div></div>
									<div class="assembly-row-combined"><div>256B</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap
 DE and HL so that HL will now hold the integer value of the second 
argument and DE will point to the position in the current BASIC program 
being evaluated.</div></div>
									<div class="assembly-row-combined"><div>256C</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Swap
 (SP) and HL so that HL will now hold the function number, and the 
integer value of the second argument will be at the top of the STACK</div></div>
									<div class="assembly-row-combined"><div>256D</div><div><a href="#2583H" class="memory-link">JR 2583H <span class="origrom2">JR FINGO</span></a><span class="opcode2">18 14</span></div><div>Jump down to 2583H to process the token</div></div>
									<div class="assembly-row-combined" id="256FH"><div>256F-2571 <span class="origrom2">OKNORM</span></div><div><a href="#252CH" class="memory-link">CALL 252CH <span class="origrom2">CALL PARCHK</span></a><span class="opcode2">CD 2C 25</span></div><div>Next
 we need to check out the argument (and make sure it is followed by a 
")") via a single variable parameter call. First, GOSUB to 252CH to 
evaluate the expression at the location of the current BASIC program 
pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2572</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Swap
 (SP) and HL so that HL will now hold the function number [0 + 2 * 
(token - D7H)], and the pointer to the position in the current BASIC 
program being evaluated will be at the top of the STACK.</div></div>
									<p class="debug-note">The original source code has this to say about being here:<br><br>We next have to check to see if a special coercion must be done for one of the transcendental functions ( <span class="code">RND</span> , <span class="code">SQR</span> , <span class="code">COS</span> , <span class="code">SIN</span> , <span class="code">TAN</span> , <span class="code">ATN</span> , <span class="code">LOG</span> , and <span class="code">EXP</span> ).<br><br>Since
  these functions do not look at VALTYP, but rather assume the argument 
passed in the ACCumulator is single precision, we MUST call FRCSNG 
before dispatching to them.</p>
									<div class="assembly-row-combined"><div>2573</div><div>LD A,L <span class="opcode2">7D</span></div><div>Load Register A with the function number [i.e., 2 * (token - D7H)]</div></div>
									<div class="assembly-row-combined"><div>2574-2575 <span class="origrom2">BOTCON</span></div><div>CP 0CH <span class="origrom2">CP (SQRTK-ONEFUN)*2</span>  <span class="opcode2">FE 0C</span></div><div>Check to see if the operator token in Register A is one less than <span class="code">SQR</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined" id="2576H"><div>2576-2577</div><div><a href="#257FH" class="memory-link">JR C,257FH <span class="origrom2">JR C,NOTFRF</span></a><span class="opcode2">38 07</span></div><div>Jump down to 257FH to avoid forcing the argument if the operator token in Register A is <span class="code">SGN</span> to <span class="code">SQR</span></div></div>
									<div class="assembly-row-combined"><div>2578-2579 <span class="origrom2">TOPCON</span></div><div>CP 1BH <span class="origrom2">CP (ATNTK-ONEFUN)*2+1</span>  <span class="opcode2">FE 1B</span></div><div>Check to see if the operator token in Register A is bigger than <span class="code">ATN()</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>257A</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the function number (i.e., 0 + 2*(token - D7H)) to the stop of the STACK</div></div>
									<div class="assembly-row-combined"><div>257B-257D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0AB1H" class="memory-link">CALL C,0AB1H <span class="origrom2">CALL C,FRCSNG</span></a><span class="opcode2">DC B1 0A</span></div><div>If
 we are still here, then we need to force the ACCumulator into Single 
Precision, so CALL the CONVERT TO SINGLE PRECISION routine at 0AB1H 
(which converts the contents of ACCumulator [4121H] from integer or 
double precision into single precision)</div></div>
									<div class="assembly-row-combined" id="257FH"><div>257F-2581 <span class="origrom2">NOTFRF</span></div><div>LD DE,253EH <span class="origrom2">LD DE,LABBCK</span>  <span class="opcode2">11 3E 25</span></div><div>Load DE with a return address of 253EH for once the function is executed</div></div>
									<div class="assembly-row-combined"><div>2582</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the value of the return address in DE to the STACK so it will act as the return adddress</div></div>
									<div class="assembly-row-combined" id="2583H"><div>2583-2585 <span class="origrom2">FINGO</span></div><div>LD BC,1608H <span class="origrom2">LD BC,FUNDSP</span>  <span class="opcode2">01 08 16</span></div><div>Load BC with the function dispatch/jump table address</div></div>
									<div class="assembly-row-combined" id="2586H"><div>2586 <span class="origrom2">DISPAT</span></div><div>ADD HL,BC <span class="opcode2">09</span></div><div>Add the jump table pointer in BC (i.e., the offset) with the value of the operator token in HL</div></div>
									<div class="assembly-row-combined"><div>2587</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Load Register C with the LSB of the jump address at the location of the jump table pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2588</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the jump table pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2589</div><div>LD H,(HL) <span class="opcode2">66</span></div><div>Load Register H with the MSB of the jump address at the location of the jump table pointer in HL</div></div>
									<div class="assembly-row-combined"><div>258A</div><div>LD L,C <span class="opcode2">69</span></div><div>Load Register L with the LSB of the jump address in Register C</div></div>
									<div class="assembly-row-combined"><div>258B</div><div>JP (HL) <span class="opcode2">E9</span></div><div>Perform the function.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="258CH">258C - Part of the Formula Evaluation Code <span class="origrom">- "STRCMP"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source, this routine will 
compare two strings, one with the description in Register Pair DE and 
the other in FACLO/FACLO+1.  On exit:</p>
								<ul><li>A = 0 if the strings are equal</li><li>A = 377 if BCDE &gt; FACLO</li><li>A = 1 if BCDE &lt; FACLO</li></ul>
								<p>This routine will do a relational comparison of two strings.<br>It
 will load A with the length of the first string and BC with the 
string's address. Then it will load D with the length of the second 
string and HL with the string's address.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>258C-258E <span class="origrom2">STRCMP</span></div><div><a href="#29D7H" class="memory-link">CALL 29D7H <span class="origrom2">CALL FRESTR</span></a><span class="opcode2">CD D7 29</span></div><div>First
 we need to free up the FAC string and get the pointer to the FAC 
descriptor into Register Pair HL.  We do this via a GOSUB to 29D7H to 
check to see if there is enough memory for the string</div></div>
									<div class="assembly-row-combined"><div>258F</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the LSB of the length of the string in the FACLO</div></div>
									<div class="assembly-row-combined"><div>2590</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the string's VARPTR in HL so that HL points to the LSB of the string address</div></div>
									<div class="assembly-row-combined"><div>2591</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Load Register C with the LSB of the string in the FACLO</div></div>
									<div class="assembly-row-combined"><div>2592</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the string's VARPTR in HL so that HL points to the MSB of the string address</div></div>
									<div class="assembly-row-combined"><div>2593</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load Register B with the MSB of the string in the FACLO.  Register Pair BC now points to the FACLO string.</div></div>
									<div class="assembly-row-combined"><div>2594</div><div>POP DE <span class="opcode2">D1</span></div><div>Put the STACK string pointer into Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>2595</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the pointer to the FACLO string data</div></div>
									<div class="assembly-row-combined"><div>2596</div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the FACLO string's length in Register A to the STACK</div></div>
									<div class="assembly-row-combined"><div>2597-2599</div><div>CALL 29DEH <span class="origrom2">CALL FRETMP</span><span class="opcode2">CD DE 29</span></div><div>Free up the STACK string and RETURN with the pointer to the STACK string descriptor in Register Pair HL.</div></div>
									<div class="assembly-row-combined"><div>259A</div><div>POP DE <span class="opcode2">D1</span></div><div>Get the length of the FACLO string from the STACK and put it in Register D</div></div>
									<div class="assembly-row-combined"><div>259B</div><div>LD E,(HL) <span class="opcode2">5E</span></div><div>Load Register E with the STACK / BCDE string's length</div></div>
									<div class="assembly-row-combined"><div>259C</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the pointer to the STACK / BCDE string's entry in HL</div></div>
									<div class="assembly-row-combined"><div>259D</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Load Register C with the LSB of the STACK / BCDE string's address</div></div>
									<div class="assembly-row-combined"><div>259E</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the pointer to the STACK / BCDE string's entry in HL</div></div>
									<div class="assembly-row-combined"><div>259F</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load Register B with the MSB of the STACK / BCDE string's address</div></div>
									<div class="assembly-row-combined"><div>25A0</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the second character pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>25A1 <span class="origrom2">CSLOOP</span></div><div>LD A,E <span class="opcode2">7B</span></div><div>Load Register A with the length of the STACK / BCDE string in Register E</div></div>
									<div class="assembly-row-combined"><div>25A2</div><div>OR D <span class="opcode2">B2</span></div><div>Combine the FACLO string's length in Register D with the STACK / BCDE string's length in Register A</div></div>
									<div class="assembly-row-combined"><div>25A3</div><div>RET Z <span class="opcode2">C8</span></div><div>If
 both string lengths are the same, then we are done, so return out of 
the routine since there aren't any characters left in either string to 
be compared</div></div>
									<div class="assembly-row-combined" id="25A4H"><div>25A4</div><div>LD A,D <span class="opcode2">7A</span></div><div>Load Register A with the FACLO string's length in Register D</div></div>
									<div class="assembly-row-combined"><div>25A5-25A6</div><div>SUB 01H <span class="opcode2">D6 01</span></div><div>Check
 to see if the FACLO string's length in Register A is equal to zero, by 
setting the CARRY FLAG and turning Register A into 255 if Register D was
 0.</div></div>
									<div class="assembly-row-combined"><div>25A7</div><div>RET C <span class="opcode2">D8</span></div><div>If the CARRY FLAG is set, then the FACLO string has run out of characters, so RETurn</div></div>
									<div class="assembly-row-combined" id="25A8H"><div>25A8</div><div>XOR A <span class="opcode2">AF</span></div><div>If
 we are here, then FACLO wasn't out of characters, so we next need to 
see if the STACK / BCDE string ended first.  First we load Register A 
with zero</div></div>
									<div class="assembly-row-combined"><div>25A9</div><div>CP E <span class="opcode2">BB</span></div><div>Check
 to see if the STACK / BCDE string's length in Register E is equal to 
zero.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>25AA</div><div>INC A <span class="opcode2">3C</span></div><div>Bump the value in Register A for a return code of A = 1</div></div>
									<div class="assembly-row-combined"><div>25AB</div><div>RET NC <span class="opcode2">D0</span></div><div>Return if there aren't any more characters in the STACK / BCDE string to be compared</div></div>
									<div class="assembly-row-combined" id="25ACH"><div>25AC</div><div>DEC D <span class="opcode2">15</span></div><div>If we are STILL here, then neither string has ended.  First, decrement the value of the FACLO string's length in Register D</div></div>
									<div class="assembly-row-combined"><div>25AD</div><div>DEC E <span class="opcode2">1D</span></div><div>Decrement the value of the STACK / BCDE string's length in Register E</div></div>
									<div class="assembly-row-combined"><div>25AE</div><div>LD A,(BC) <span class="opcode2">0A</span></div><div>Load Register A with the character at the location of the STACK / BCDE string pointer in BC</div></div>
									<div class="assembly-row-combined"><div>25AF</div><div>CP (HL) <span class="opcode2">BE</span></div><div>Compare
 the character at the location of the STACK / BCDE string pointer in 
Register A with the character at the location of the FACLO string 
pointer in HL.  If they match, the Z FLAG is set, and otherwise the NZ 
FLAG is set.  If A &lt; the checked value, then the C FLAG is set.  If A
 &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>25B0</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the first string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>25B1</div><div>INC BC <span class="opcode2">03</span></div><div>Bump the value of the second string pointer in BC</div></div>
									<div class="assembly-row-combined"><div>25B2-25B3</div><div><a href="#25A1H" class="memory-link">JR Z,25A1H <span class="origrom2">JR Z,CSLOOP</span></a><span class="opcode2">28 ED</span></div><div>Loop back to 25A1H to keep going if the characters match</div></div>
									<div class="assembly-row-combined"><div>25B4</div><div>CCF <span class="opcode2">3F</span></div><div>If we are here, then the NZ FLAG was set and the strings are NOT equal.  Since they are not equal, reverse the CARRY flag</div></div>
									<div class="assembly-row-combined"><div>25B5-25B7</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0960H" class="memory-link">JP 0960H <span class="origrom2">JP SIGNS</span></a><span class="opcode2">C3 60 09</span></div><div>Jump back to 0960H to set up Register A based on the CARRY FLAG.</div></div>
									<div class="assembly-row-combined"><div>25B8 <span class="origrom2">DOCMP</span></div><div>INC A <span class="opcode2">3C</span></div><div>Bump the value of the current precedence value in Register A</div></div>
									<div class="assembly-row-combined"><div>25B9</div><div>ADC A,A <span class="opcode2">8F</span></div><div>Adjust
 the value of the current precedence value in Register A.  Depending on 
which routine called this this will give either (A) a 1 with a NC if 0 
or a 0 with C if FF or (B) 4=Less, 2=Equal, 1=Greater</div></div>
									<div class="assembly-row-combined"><div>25BA</div><div>POP BC <span class="opcode2">C1</span></div><div>Get the last operator value from the STACK and put it in BC</div></div>
									<div class="assembly-row-combined"><div>25BB</div><div>AND B <span class="opcode2">A0</span></div><div>Combine the precedence value in Register B with the precedence value in Register A to see if any of the bits match.</div></div>
									<div class="assembly-row-combined"><div>25BC-25BD</div><div>ADD A,FFH <span class="opcode2">C6 FF</span></div><div>Adjust the value in Register A. This will give a 0 if both are equal and a CARRY if they are unequal</div></div>
									<div class="assembly-row-combined"><div>25BE</div><div>SBC A,A <span class="opcode2">9F</span></div><div>Check
 to see if the precedence values in registers A and B match. This will 
set A=0 if equal, and, depending on the routine which called this, 
either an A+1 or a A=377 if unequal</div></div>
									<div class="assembly-row-combined"><div>25BF-25C1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#098DH" class="memory-link">CALL 098DH <span class="origrom2">CALL CONIA</span></a><span class="opcode2">CD 8D 09</span></div><div>Convert
 Register A to a signed integer via a CALL to 098DH. This will set the 
current value to 00 if A is positive, and to FF if A is negative.<br>If the values match, set the current result in zero. If they do not match, set the current result to -1</div></div>
									<div class="assembly-row-combined"><div>25C2-25C3</div><div><a href="#25D6H" class="memory-link">JR 25D6H <span class="origrom2">JR RETAPG</span></a><span class="opcode2">18 12</span></div><div>At
 this point we want to return from the operator application place so the
 text pointer will get set up to what it was when LPOPER returned.  To 
do this we jump forward to 25D6H to continue with the expression 
evaluation</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="25C4H">25C4 -  <span class="code">NOT</span>  Routine <span class="origrom">- "NOTER"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="25C4H"><div>25C4-25C5 <span class="origrom2">NOTER</span></div><div>LD D,5AH <span class="opcode2">16 5A</span></div><div>NOT has a precedence value of 90, so we need a dummy entry of 90 on the STACK</div></div>
									<div class="assembly-row-combined"><div>25C6-25C8</div><div><a href="#233AH" class="memory-link">CALL 233AH <span class="origrom2">CALL LPOPER</span></a><span class="opcode2">CD 3A 23</span></div><div>Go evaluate the expression with a dummy entry of 90 on the STACK</div></div>
									<div class="assembly-row-combined"><div>25C9-25CB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A7FH" class="memory-link">CALL 0A7FH <span class="origrom2">CALL FRCINT</span></a><span class="opcode2">CD 7F 0A</span></div><div>We
 need the argument to be an integer so CALL the CONVERT TO INTEGER 
routine at 0A7FH (where the contents of ACCumulator are converted from 
single or double precision to integer and deposited into HL)</div></div>
									<div class="assembly-row-combined"><div>25CC</div><div>LD A,L <span class="opcode2">7D</span></div><div>The next bunch of instructions are to complement Register Pair HL.  First, load Register A with the LSB of the integer value</div></div>
									<div class="assembly-row-combined"><div>25CD</div><div>CPL <span class="opcode2">2F</span></div><div>Compliment the LSB of the integer value in Register A</div></div>
									<div class="assembly-row-combined"><div>25CE</div><div>LD L,A <span class="opcode2">6F</span></div><div>Load Register L with the adjusted LSB of the integer value in Register A</div></div>
									<div class="assembly-row-combined"><div>25CF</div><div>LD A,H <span class="opcode2">7C</span></div><div>Load Register A with the MSB of the integer value in Register H</div></div>
									<div class="assembly-row-combined"><div>25D0</div><div>CPL <span class="opcode2">2F</span></div><div>Compliment the MSB of the integer value in Register A</div></div>
									<div class="assembly-row-combined"><div>25D1</div><div>LD H,A <span class="opcode2">67</span></div><div>Load Register H with the adjusted MSB of the integer value in Register A</div></div>
									<div class="assembly-row-combined"><div>25D2-25D4</div><div>LD (4121H),HL <span class="origrom2">LD (FACLO),HL</span>  <span class="opcode2">22 21 41</span></div><div>Save the complimented integer value in HL as the current result in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>25D5</div><div>POP BC <span class="opcode2">C1</span></div><div>Clean up the STACK</div></div>
									<div class="assembly-row-combined" id="25D6H"><div>25D6-25D8 <span class="origrom2">RETAPG</span></div><div><a href="#2346H" class="memory-link">JP 2346H <span class="origrom2">JP RETAOP</span></a><span class="opcode2">C3 46 23</span></div><div>Jump
 back to 2346H to continue with the expression evaluation.  We need to 
do this because FRMEVL, after seeing a precedence level of 90, thinks it
 is applying an operator, which it isn't.  It has the text pointer 
stored in TEXT 2 so we need to JUMP to RETAOP to re-fetch that pointer.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="25D9H">25D9 - The RST 20H code <span class="origrom">- "GETYPR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the TEST DATA MODE, which determines the type of the 
current value in ACCumulator and returns a combination of STATUS flags 
and unique numeric values in the A Register according to the data mode 
flag (40AFH).<font face="Courier" size="-1">TYPE&nbsp;&nbsp;&nbsp;CODE&nbsp;&nbsp;&nbsp;ZERO&nbsp;&nbsp;&nbsp;CARRY&nbsp;&nbsp;&nbsp;NEG&nbsp;&nbsp;&nbsp;PARITY&nbsp;&nbsp;&nbsp;A-
Register<br>INT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NZ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1<br>STR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;03&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>SNG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;04&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NZ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;O&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>DBL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;08&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NZ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5</font></p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="25D9H"><div>25D9-25DBH <span class="origrom2">GETPYR</span></div><div>LD A,(40AFH) <span class="origrom2">LD A,(VALTYP)</span>  <span class="opcode2">3A AF 40</span></div><div>Load Register A with the current value of the number type flag.<br>Note: 40AFH holds Current number type flag</div></div>
									<div class="assembly-row-combined"><div>25DC-25DD</div><div>CP 08H <span class="opcode2">FE 08</span></div><div>Check
 to see if the current value in ACCumulator is double precision (02=INT,
 03=STR, 04=SNG, 08=DBL).  If they match, the Z FLAG is set, and 
otherwise the NZ FLAG is set.  If A &lt; the checked value, then the C 
FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined" id="25DEH"><div>25DE-25DF <span class="origrom2">CGETYP</span></div><div><a href="#25E5H" class="memory-link">JR NC,25E5H <span class="origrom2">JR NC,NCASE</span></a><span class="opcode2">30 05</span></div><div>If that test shows that we have a DOUBLE PRECISION number, jump forward to 25E5H</div></div>
									<div class="assembly-row-combined"><div>25E0-25E1</div><div>SUB 03H <span class="opcode2">D6 03</span></div><div>If the number is not double precision, subtract 3</div></div>
									<div class="assembly-row-combined"><div>25E2</div><div>OR A <span class="opcode2">B7</span></div><div>Set the status flags of the adjusted number type flag in Register A</div></div>
									<div class="assembly-row-combined"><div>25E3</div><div>SCF <span class="opcode2">37</span></div><div>Set the Carry flag</div></div>
									<div class="assembly-row-combined"><div>25E4</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
									<div class="assembly-row-combined" id="25E5H"><div>25E5-25E6 <span class="origrom2">NCASE</span></div><div>SUB 03H <span class="opcode2">D6 03</span></div><div>We are dealing with a double precision number so adjust the value of the current number type flag in Register A</div></div>
									<div class="assembly-row-combined"><div>25E7</div><div>OR A <span class="opcode2">B7</span></div><div>Test the value of the current number type flag in Register A, which will exit without the CARRY flag set</div></div>
									<div class="assembly-row-combined"><div>25E8</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="25E9H">25E9 - <span class="code">AND</span> and <span class="code">OR</span> Routines <span class="origrom">- "DANDOR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source, this routine applies the <span class="code">AND</span> and <span class="code">OR</span> operators and should be used to implement all logical operators<br><br>Whenever an operator is applied, its precedence is in Register B<br><br>This fact is used to distinguish between <span class="code">AND</span> and <span class="code">OR</span><br><br>The right hand argument is coerced to integer, just as the left hand one was when it was pushed on the STACK</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>25E9 <span class="origrom2">DANDOR</span></div><div>PUSH BC <span class="opcode2">C5</span></div><div>B has he precedence value, so save BC to the STACK.  The precedence value for OR is 70.</div></div>
									<div class="assembly-row-combined"><div>25EA-25EC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A7FH" class="memory-link">CALL 0A7FH <span class="origrom2">CALL FRCINT</span></a><span class="opcode2">CD 7F 0A</span></div><div>We
 need the right hand argument to be an integer, so GOSUB the CONVERT TO 
INTEGER routine at 0A7FH (where the contents of ACCumulator are 
converted from single or double precision to integer and deposited into 
HL)</div></div>
									<div class="assembly-row-combined"><div>25ED</div><div>POP AF <span class="opcode2">F1</span></div><div>Get the precedence value from the STACK and put it in Register A so that we can detemined between span class="code"&gt;AND and <span class="code">OR</span></div></div>
									<div class="assembly-row-combined"><div>25EE</div><div>POP DE <span class="opcode2">D1</span></div><div>Get the left hand argument from the STACK and put it in DE</div></div>
									<div class="assembly-row-combined" id="25EFH"><div>25EF-25F1</div><div>LD BC,27FAH <span class="origrom2">LD BC,GIVINT</span>  <span class="opcode2">01 FA 27</span></div><div>Load BC with a return address of 27FAH</div></div>
									<div class="assembly-row-combined"><div>25F2</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the value of the return address in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>25F3-25F4</div><div>CP 46H <span class="opcode2">FE 46</span></div><div>Check to see if the operator value in Register A is an <span class="code">OR</span>
 token.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>25F5-25F6</div><div><a href="#25FDH" class="memory-link">JR NZ,25FDH <span class="origrom2">JR NZ,NOTOR</span></a><span class="opcode2">20 06</span></div><div>If Register A was not 46H then we have an <span class="code">AND</span> , so jump forward a few instructions to 25FDH (to the <span class="code">AND</span> code) if the operator value in Register A isn't an <span class="code">OR</span> token</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="25F7H">25F7 - <span class="code">OR</span> logic.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>25F7</div><div>LD A,E <span class="opcode2">7B</span></div><div>Load Register A with the LSB of the first value in Register E</div></div>
									<div class="assembly-row-combined"><div>25F8</div><div>OR L <span class="opcode2">B5</span></div><div>Combine the LSB of the first value in Register A with the LSB of the second value in Register L</div></div>
									<div class="assembly-row-combined"><div>25F9</div><div>LD L,A <span class="opcode2">6F</span></div><div>Load Register L with the ORed value in Register A</div></div>
									<div class="assembly-row-combined"><div>25FA</div><div>LD A,H <span class="opcode2">7C</span></div><div>Load Register A with the MSB of the second value in Register H</div></div>
									<div class="assembly-row-combined"><div>25FB</div><div>OR D <span class="opcode2">B2</span></div><div>Combine the MSB of the first value in Register D with the MSB of the second value in Register A</div></div>
									<div class="assembly-row-combined"><div>25FC</div><div>RET <span class="opcode2">C9</span></div><div>Return to 27FAH (=convert the result to integer and return that integer calue to 2346H)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="25FDH">25FD - <span class="code">AND</span> logic <span class="origrom">- "NOTOR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="25FDH"><div>25FD <span class="origrom2">NOTOR</span></div><div>LD A,E <span class="opcode2">7B</span></div><div>Load Register A with the LSB of the first value in Register E</div></div>
									<div class="assembly-row-combined"><div>25FE</div><div>AND L <span class="opcode2">A5</span></div><div>Combine the LSB of the first value in Register A with the LSB of the second value in Register L</div></div>
									<div class="assembly-row-combined"><div>25FF</div><div>LD L,A <span class="opcode2">6F</span></div><div>Load Register L with the ANDed value in Register A</div></div>
									<div class="assembly-row-combined" id="2600H"><div>2600</div><div>LD A,H <span class="opcode2">7C</span></div><div>Load Register A with the MSB of the second value in Register H</div></div>
									<div class="assembly-row-combined"><div>2601</div><div>AND D <span class="opcode2">A2</span></div><div>Combine the MSB of the first value in Register D with the MSB of the second value in Register A</div></div>
									<div class="assembly-row-combined"><div>2602</div><div>RET <span class="opcode2">C9</span></div><div>Return to 27FAH (=Make the result an integer and return to 2346H)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2603H">2603 - Dimension and Variable Searching Routine <span class="origrom">- "DIMCON"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2603 <span class="origrom2">DIMCON</span></div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the BASIC program pointer in HL so that we can see what the prior character was</div></div>
									<div class="assembly-row-combined"><div>2604</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2605</div><div>RET Z <span class="opcode2">C8</span></div><div>If the CHGRGET routine returned a Z FLAG, then we have a terminator; so RETurn since this is the end of the BASIC statement</div></div>
									<div class="assembly-row-combined" id="2606H"><div>2606-2607</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 2C<span class="origrom2">SYNCHK ","</span></a><span class="opcode2">CF 2C</span></div><div>Since the character at the location of the current BASIC program pointer in HL must be a <span class="code">,</span> , call the COMPARE SYMBOL routine at RST 08H.<br><br><span class="bold nobottomborder">NOTE:</span>
 The RST 08H routine compares the symbol in the input string pointed to 
by HL Register to the value in the location following the RST 08 call.<ul><li>If
 there is a match, control is returned to the next execution address 
(i.e, the RST 08H instruction + 2) with the next symbol in the A 
Register and HL incremented by one.</li><li>If the two characters do not match, a syntax error message is given and control returns to the Input Phase).</li></ul></div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2608H">2608 - <span class="code">DIM</span>  logic <span class="origrom">- "DIM"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The original ROM source code states that this DIM code sets 
DIMFLG and then falls into the variable search routine, which then looks
 at DIMFLG at three different points:</p>
								<ol><li>If an entry is found, dimflg being on indicates a "doubly dimensioned" variable</li><li>When
 a new entry is being built dimflg's being on indicates the indices 
should be used for the size of each indice. otherwise the default of ten
 is used.</li><li>When the build entry code finishes, only if dimflg is off will indexing be done</li></ol>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2608-260A <span class="origrom2">DIM</span></div><div>LD BC,2603H <span class="origrom2">D BC,DIMCON</span>  <span class="opcode2">01 03 26</span></div><div>Load BC with a return address of 2603H</div></div>
									<div class="assembly-row-combined"><div>260B</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the return address of 2603H (in BC) to the STACK</div></div>
									<div class="assembly-row-combined"><div>260C-260D</div><div>OR AFH <span class="opcode2">F6 AF</span></div><div>This
 is part of a Z-80 trick.  If passed through, then this will just OR A 
to force A to be non-zero.  It will then skip the next instruction</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="260DH">260D - Variable location and creation logic <span class="origrom">- "PTRGET"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The original ROM source code states that this routine will  
read the variable name at the current text position and put a pointer to
 its value in Register Pair DE.  Register Pair HL is then updated to 
point to the character after the variable name and VALTYP is set up.  
Evaluating subscripts in a variable name can cause recursive calls to 
PTRGET so at that point all values must be stored on the STACK.  On 
RETurn, [a] does not reflect the value of the terminating character.</p>
								<p>This routine will return the address of a variable in memory 
or create it if it is not found. In order to use this routine, the HL 
must point to the variable name (ASCII). Then, after execution, HL will 
point to the character following the variable name and the location of 
the variable will be returned in the DE Register Pair. For integer, 
single or doubleprecision (NTF=2, 4 or 8) the address returned in DE 
will be the same as for the VARPTR command under BASIC. (see Level II 
BASIC manual on VARPTR) For strings (NTF=3) however the address returned
 in DE will point to the first of three bytes containing the string 
length and string address.<br>This entry point searches the Variable 
List Table (VLT) for a variable name which matches the name in the 
string pointed to by HL. If the variable exists, its address is returned
 in DE. If it is not defined, then it is created with an initial value 
ofzero and its address is returned in DE. Dimensioned and 
non-dimensioned variables may be located, and suffixs for data mode may 
be included in the name string. A byte of machine zeros must terminate 
the name string. All registers are used.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>260D <span class="origrom2">PTRGET</span></div><div>XOR A <span class="opcode2">AF</span></div><div>If JUMPed here, then A is set to ZERO.  As a reminder, if passed through from the above routine, A will be NOT ZERO.</div></div>
									<div class="assembly-row-combined"><div>260E-2610</div><div>LD (40AEH),A <span class="origrom2">LD (DIMFLG),A</span>  <span class="opcode2">32 AE 40</span></div><div>Save the value in Register A as the current variable location/creation flag.<br>Note: 40AEH holds LOCATE/CREATE variable flag</div></div>
									<div class="assembly-row-combined"><div>2611</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load Register B with the first character of the variable name</div></div>
									<div class="assembly-row-combined"><div>2612-2614 <span class="origrom2">PTRGT2</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E3DH" class="memory-link">CALL 1E3DH <span class="origrom2">CALL ISLET</span></a><span class="opcode2">CD 3D 1E</span></div><div>GOSUB to 1E3DH to make sure the first character of the variable name is a letter</div></div>
									<div class="assembly-row-combined"><div>2615-2617</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1997H" class="memory-link">JP C,1997H <span class="origrom2">JP C,SNERR</span></a><span class="opcode2">DA 97 19</span></div><div>Display a <span class="code">?SN ERROR</span> if the first character of the variable name isn't a letter</div></div>
									<div class="assembly-row-combined"><div>2618</div><div>XOR A <span class="opcode2">AF</span></div><div>Zero Register A</div></div>
									<div class="assembly-row-combined"><div>2619</div><div>LD C,A <span class="opcode2">4F</span></div><div>Set up to assume that there is no second character by zeroing Register C</div></div>
									<div class="assembly-row-combined"><div>261A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined" id="2622H"><div>261B-261C</div><div><a href="#2622H" class="memory-link">JR C,2622H <span class="origrom2">JR C,ISSEC</span></a><span class="opcode2">38 05</span></div><div>Jump to 2622H if the character at the location of the current BASIC program pointer in Register A is numeric</div></div>
									<div class="assembly-row-combined"><div>261D-261F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E3DH" class="memory-link">CALL 1E3DH <span class="origrom2">CALL ISLET</span></a><span class="opcode2">CD 3D 1E</span></div><div>GOSUB
 to 1E3DH to check to see if the character at the location of the 
current BASIC program pointer is a letter.  This will set the CARRY 
FLAG.</div></div>
									<div class="assembly-row-combined" id="262BH"><div>2620-2621</div><div><a href="#262BH" class="memory-link">JR C,262BH <span class="origrom2">JR C,NOSEC</span></a><span class="opcode2">38 09</span></div><div>Jump to 262BH if the character at the location of the current BASIC program pointer in Register A isn't a letter</div></div>
									<div class="assembly-row-combined" id="2622H"><div>2622 <span class="origrom2">ISSEC</span></div><div>LD C,A <span class="opcode2">4F</span></div><div>If we are here, then the second character was a number, so save it in Register C</div></div>
									<div class="assembly-row-combined" id="2623H"><div>2623 <span class="origrom2">EATEM</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We
 now need bump the value of the current BASIC program pointer until it 
points to the next character, call the EXAMINE NEXT SYMBOL routine at 
RST 10H.<br><br>The RST 10H routine parses the characters starting at 
HL+1 for the first non-SPACE,non-09H,non-0BH character it finds.  On 
exit, Register A will hold that character, and the C FLAG is set if its 
alphabetic, and NC FLAG if its alphanumeric.  All strings must have a 
00H at the end.</div></div>
									<div class="assembly-row-combined" id="2623H"><div>2624-2625</div><div><a href="#2623H" class="memory-link">JR C,2623H <span class="origrom2">JR C,EATEM</span></a><span class="opcode2">38 FD</span></div><div>Loop back one OPCODE to keep eating characters until a non-numeric character is found</div></div>
									<div class="assembly-row-combined"><div>2626-2628</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E3DH" class="memory-link">CALL 1E3DH <span class="origrom2">CALL ISLET</span></a><span class="opcode2">CD 3D 1E</span></div><div>Go check to see if the character at the location of the current BASIC program pointer in HL is alphabetic</div></div>
									<div class="assembly-row-combined" id="2623H"><div>2629-262A</div><div><a href="#2623H" class="memory-link">JR NC,2623H <span class="origrom2">JR NC,EATEM</span></a><span class="opcode2">30 F8</span></div><div>Jump back to 2623H if the character at the location of the current BASIC program pointer in HL is alphabetic</div></div>
									<div class="assembly-row-combined" id="262BH"><div>262B-262D <span class="origrom2">NOSEC</span></div><div>LD DE,2652H <span class="origrom2">LD DE,HAVTYP</span>  <span class="opcode2">11 52 26</span></div><div>Load DE with a return address of 2652H.  Done to save time/RAM from using JUMPs instead.</div></div>
									<div class="assembly-row-combined"><div>262E</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the value of the return address in DE to the STACK</div></div>
									<div class="assembly-row-combined"><div>262F-2630</div><div>LD D,02H <span class="opcode2">16 02</span></div><div>Load Register D with an integer number type flag</div></div>
									<div class="assembly-row-combined"><div>2631-2632</div><div>CP 25H <span class="opcode2">FE 25</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">%</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2633</div><div>RET Z <span class="opcode2">C8</span></div><div>Return if the character at the location of the current BASIC program pointer in Register A is a <span class="code">%</span></div></div>
									<div class="assembly-row-combined" id="2634H"><div>2634</div><div>INC D <span class="opcode2">14</span></div><div>Bump Register D so that it will be equal to a string number type flag (02=INT, 03=STR, 04=SNG, 08=DBL)</div></div>
									<div class="assembly-row-combined"><div>2635-2636</div><div>CP 24H <span class="opcode2">FE 24</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">$</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2637</div><div>RET Z <span class="opcode2">C8</span></div><div>Return if the character at the location of current BASIC program pointer in Register A is a <span class="code">$</span></div></div>
									<div class="assembly-row-combined" id="2638H"><div>2638</div><div>INC D <span class="opcode2">14</span></div><div>Bump Register D so that it will be equal to a single precision number type flag (02=INT, 03=STR, 04=SNG, 08=DBL)</div></div>
									<div class="assembly-row-combined"><div>2639-263A</div><div>CP 21H <span class="opcode2">FE 21</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">!</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>263B</div><div>RET Z <span class="opcode2">C8</span></div><div>Return if the character at the location of the current BASIC program pointer in Register A is a <span class="code">!</span></div></div>
									<div class="assembly-row-combined" id="263CH"><div>263C-263D</div><div>LD D,08H <span class="opcode2">16 08</span></div><div>Load
 Register D with a double precision number type flag. We have to do this
 because 04H (SNG) would bump to 05H if we just did another INC, but we 
need 08H for DBL</div></div>
									<div class="assembly-row-combined"><div>263E-263F</div><div>CP 23H <span class="opcode2">FE 23</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">#</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2640</div><div>RET Z <span class="opcode2">C8</span></div><div>Return if the character at the location of the current BASIC program pointer in Register A is a <span class="code">#</span></div></div>
									<div class="assembly-row-combined" id="2641H"><div>2641</div><div>LD A,B <span class="opcode2">78</span></div><div>Load Register A with the first character of the variable name from Register B</div></div>
									<div class="assembly-row-combined"><div>2642-2643</div><div>SUB 41H <span class="opcode2">D6 41</span></div><div>Adjust
 the value of the first character of the variable name in Register A so 
that it is in the range of 0 to 25 for a table offset</div></div>
									<div class="assembly-row-combined"><div>2644-2645</div><div>AND 7FH<span class="origrom2">AND 01111111</span> <span class="opcode2">E6 7F</span></div><div>Get rid of the user-defined function bit in Register B by ANDing it against 0111 1111</div></div>
									<div class="assembly-row-combined"><div>2646</div><div>LD E,A <span class="opcode2">5F</span></div><div>Next
 we need to build a two byte offset so first load Register E with the 
adjusted first character of the variable name in Register A</div></div>
									<div class="assembly-row-combined"><div>2647-2648</div><div>LD D,00H <span class="opcode2">16 00</span></div><div>Load Register D with zero</div></div>
									<div class="assembly-row-combined"><div>2649</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>264A-264C</div><div>LD HL,4101H <span class="origrom2">LD HL,DEFTBL</span>  <span class="opcode2">21 01 41</span></div><div>Load HL with the starting address of the variable declaration table.<br><span class="nobottomborder bold">NOTE:</span> 4101H-411AH holds Variable Declaration Table</div></div>
									<div class="assembly-row-combined"><div>264D</div><div>ADD HL,DE <span class="opcode2">19</span></div><div>Add the offset to the top of the table</div></div>
									<div class="assembly-row-combined"><div>264E</div><div>LD D,(HL) <span class="opcode2">56</span></div><div>Load Register D with the number type value from the variable declaration table pointer in HL</div></div>
									<div class="assembly-row-combined"><div>264F</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the current BASIC program pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2650</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the current BASIC program pointer in HL as there was no marking character</div></div>
									<div class="assembly-row-combined"><div>2651</div><div>RET <span class="opcode2">C9</span></div><div>Return with data type in D</div></div>
									<div class="assembly-row-combined" id="2652H"><div>2652<span class="origrom2">HAVTYP</span></div><div>LD A,D <span class="opcode2">7A</span></div><div>Load Register A with the value of the number type flag in Register D</div></div>
									<div class="assembly-row-combined"><div>2653-2655</div><div>LD (40AFH),A <span class="origrom2">LD (VALTYP),A</span>  <span class="opcode2">32 AF 40</span></div><div>Save the number type flag for the current variable name from Register A.<br><span class="nobottomborder bold">NOTE:</span> 40AFH holds Current number type flag</div></div>
									<div class="assembly-row-combined"><div>2656</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We
 want to skip the "type marker" so we need the next character in the 
BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2657-2659</div><div>LD A,(40DCH) <span class="origrom2">LD A,(SUBFLG)</span>  <span class="opcode2">3A DC 40</span></div><div>Load Register A with the <span class="code">FOR</span> flag.  Why the FOR flag?  It doubles as a "should we allow arrays here" flag!</div></div>
									<div class="assembly-row-combined"><div>265A</div><div>OR A <span class="opcode2">B7</span></div><div>Test the value of the <span class="code">FOR</span> flag in Register A</div></div>
									<div class="assembly-row-combined"><div>265B-265D</div><div><a href="#2664H" class="memory-link">JP NZ,2664H <span class="origrom2">JP NZ,NOARYS</span></a><span class="opcode2">C2 64 26</span></div><div>Jump to 2664H if a arrays are not permitted</div></div>
									<div class="assembly-row-combined"><div>265E</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Re-
fetch the next element of the code string by loading Register A with the
 character at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>265F-2660</div><div>SUB 28H <span class="opcode2">D6 28</span></div><div>Next,
 test for an array by checking to see if the character at the location 
of the current BASIC program pointer in Register A is a <span class="code">(</span></div></div>
									<div class="assembly-row-combined"><div>2661-2663</div><div><a href="#26E9H" class="memory-link">JP Z,26E9H <span class="origrom2">JP Z,ISARY</span></a><span class="opcode2">CA E9 26</span></div><div>If the Z FLAG is set then we have an array (meaning, it is a subscripted variable), so JUMP to 26E9H</div></div>
									<div class="assembly-row-combined" id="2664H"><div>2664 <span class="origrom2">NOARYS</span></div><div>XOR A <span class="opcode2">AF</span></div><div>Zero Register A so that we can allow for parenthesis now</div></div>
									<div class="assembly-row-combined"><div>2665-2667</div><div>LD (40DCH),A <span class="origrom2">LD (SUBFLG),A</span>  <span class="opcode2">32 DC 40</span></div><div>Set the "permit arrays" array flag to 'no subscript'.<br>Note: 40DCH holds <span class="code">FOR</span> flag</div></div>
									<div class="assembly-row-combined"><div>2668</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2669</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the number type flag for the variable in DE to the STACK</div></div>
									<div class="assembly-row-combined"><div>266A-266C</div><div>LD HL,(40F9H) <span class="origrom2">LD HL,(VARTAB)</span>  <span class="opcode2">2A F9 40</span></div><div>Load HL with the value of the simple variables pointer, which will be t he place to start the search.<br><ul><li>Note: 40F9H-40FAH holds the starting address of the simple variable storage area.</li></ul></div></div>
									<div class="assembly-row-combined" id="266DH"><div>266D <span class="origrom2">LOPFND</span></div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap DE and HL so that DE will not point to the place to start the search. We don't care what happens to HL</div></div>
									<div class="assembly-row-combined"><div>266E-2670</div><div>LD HL,(40FBH) <span class="origrom2">LD HL,(ARYTAB)</span>  <span class="opcode2">2A FB 40</span></div><div>Load
 HL with the pointer to the end of simple variables.  40FBH-40FCH holds 
the starting address of the BASIC array variable storage area</div></div>
									<div class="assembly-row-combined"><div>2671</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now
 we need to see if we have reached the end of the table so we compare 
the value of the simple variables pointer in DE with the array variables
 pointer in HL, so we call the COMPARE DE:HL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2672</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the number type flag for the variable from STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2673-2674</div><div><a href="#268EH" class="memory-link">JR Z,268EH <span class="origrom2">JR Z,NOTFNS</span></a><span class="opcode2">28 19</span></div><div>If
 the Z FLAG is set (because the simple variables pointer in DE is 
greater than or equal to the array variables pointer) then the variable 
was not found, and so we need to create a new variable.  To do this we 
JUMP to 268EH</div></div>
									<div class="assembly-row-combined"><div>2675</div><div>LD A,(DE) <span class="opcode2">1A</span></div><div>Load Register A with the number type flag for the variable at the location of the simple variables pointer in DE</div></div>
									<div class="assembly-row-combined"><div>2676</div><div>LD L,A <span class="opcode2">6F</span></div><div>Preserve Register A into Register L so we know how many entries to skip.</div></div>
									<div class="assembly-row-combined"><div>2677</div><div>CP H <span class="opcode2">BC</span></div><div>Compare
 the number type flag for the variable in Register H to the number type 
flag in Register A.  If they match, the Z FLAG is set, and otherwise the
 NZ FLAG is set.  If A &lt; the checked value, then the C FLAG is set.  
If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2678</div><div>INC DE <span class="opcode2">13</span></div><div>Bump the value of the current simple variables pointer in DE to the 2nd character name for this entry</div></div>
									<div class="assembly-row-combined"><div>2679-267A</div><div><a href="#2686H" class="memory-link">JR NZ,2686H <span class="origrom2">JR NZ,NOTIT1</span></a><span class="opcode2">20 0B</span></div><div>If the NZ FLAG is set then we did not have the right type of variable and need to skip it VIA a JUMP to 2686H</div></div>
									<div class="assembly-row-combined"><div>267B</div><div>LD A,(DE) <span class="opcode2">1A</span></div><div>Since
 the type matches, compare the 1st characters by loading Register A with
 the first character of variable name at the location of the simple 
variables pointer in DE</div></div>
									<div class="assembly-row-combined"><div>267C</div><div>CP C <span class="opcode2">B9</span></div><div>Compare
 the character at the location of the simple variables pointer in 
Register A with the first character of the variable name in Register C. 
 If they match, the Z FLAG is set, and otherwise the NZ FLAG is set.  If
 A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>267D-2637</div><div><a href="#2686H" class="memory-link">JR NZ,2686H <span class="origrom2">JR NZ,NOTIT1</span></a><span class="opcode2">20 07</span></div><div>Jump to 2686H if the first characters of the variable names don't match</div></div>
									<div class="assembly-row-combined"><div>267F</div><div>INC DE <span class="opcode2">13</span></div><div>Bump the value of the current simple variables pointer in DE</div></div>
									<div class="assembly-row-combined"><div>2680</div><div>LD A,(DE) <span class="opcode2">1A</span></div><div>Load Register A with the second character of the variable name at the location of the simple variables pointer in DE</div></div>
									<div class="assembly-row-combined"><div>2681</div><div>CP B <span class="opcode2">B8</span></div><div>Compare
 the character at the location of the simple variables pointer in 
Register A with the first character of the variable name in Register B. 
 If they match, the Z FLAG is set, and otherwise the NZ FLAG is set.  If
 A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2682-2684</div><div><a href="#26CCH" class="memory-link">JP Z,26CCH <span class="origrom2">JP Z,FINPTR</span></a><span class="opcode2">CA CC 26</span></div><div>Jump
 to 26CCH if the character at the location of the simple variables 
pointer in Register A matches the first character of the variable name 
in Register B</div></div>
									<div class="assembly-row-combined"><div>2685-2686</div><div>LD A,13H <span class="opcode2">3E 13</span></div><div>Z-80 Trick to skip the next INC DE if continuing through</div></div>
									<div class="assembly-row-combined" id="2686H"><div>2686 <span class="origrom2">NOTIT1</span></div><div>INC DE <span class="opcode2">13</span></div><div>Bump to the next entry in the simple variable list part 1</div></div>
									<div class="assembly-row-combined"><div>2687</div><div>INC DE <span class="opcode2">13</span></div><div>Bump the value of the simple variables pointer in DE part 2</div></div>
									<div class="assembly-row-combined"><div>2688</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the number type flag for the variable in HL to the STACK so that it can be re-loaded at 2672H</div></div>
									<div class="assembly-row-combined"><div>2689-268A</div><div>LD H,00H <span class="opcode2">26 00</span></div><div>Load Register H with zero so that Register Pair HL is the number of bytes to skip, but in 16 bits.</div></div>
									<div class="assembly-row-combined"><div>268B</div><div>ADD HL,DE <span class="opcode2">19</span></div><div>Add the value of the simple variables pointer in DE to the value of the number type flag in HL</div></div>
									<div class="assembly-row-combined"><div>268C-268D</div><div><a href="#266DH" class="memory-link">JR 266DH <span class="origrom2">JR LOPFND</span></a><span class="opcode2">18 DF</span></div><div>Loop back to 266DH to keep searching</div></div>
									<div class="assembly-row-combined" id="268EH"><div>268E <span class="origrom2">NOTFNS</span></div><div>LD A,H <span class="opcode2">7C</span></div><div>Load Register A with the length for the variable in Register H</div></div>
									<div class="assembly-row-combined"><div>268F</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the current BASIC program pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2690</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Exchange
 (SP) and HL so that Register Pair HL now holds the return address and 
the value of the current BASIC program pointer is now at the top of the 
STACK</div></div>
									<div class="assembly-row-combined"><div>2691</div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save length of the variable in Register A to the STACK</div></div>
									<div class="assembly-row-combined"><div>2692</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the current variable table position from DE to the STACK</div></div>
									<div class="assembly-row-combined"><div>2693-2695</div><div>LD DE,24F1H <span class="origrom2">LD DE,VARRET</span>  <span class="opcode2">11 F1 24</span></div><div>Load DE with a VARPTR locator return address of 24F1H</div></div>
									<div class="assembly-row-combined"><div>2696</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now
 we need to check to see if this was a VARPTR or not, so we compare the 
return address in DE with the return address in HL by calling the 
COMPARE DE:HL routine at RST 10H.<br><br>The RST 10H routine parses the 
characters starting at HL+1 for the first non-SPACE,non-09H,non-0BH 
character it finds.  On exit, Register A will hold that character, and 
the C FLAG is set if its alphabetic, and NC FLAG if its alphanumeric.  
All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2697-2698</div><div><a href="#26CFH" class="memory-link">JR Z,26CFH <span class="origrom2">JR Z,VARNOT</span></a><span class="opcode2">28 36</span></div><div>If the Z FLAG is set, then this was a VARPTR call, so JUMP forward to 26CFH.</div></div>
									<div class="assembly-row-combined"><div>2699-269B</div><div>LD DE,2543H <span class="origrom2">LD DE,RETVAR</span>  <span class="opcode2">11 43 25</span></div><div>Next
 we need to see if EVAL called this routine.  Load DE with a return 
address of the find address of variables routine at 2543H</div></div>
									<div class="assembly-row-combined"><div>269C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>We
 need to see if we were called from the 'find address of variable' 
routine so we need to compare the return address in DE with the return 
address in HL, so we call the COMPARE DE:HL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>269D</div><div>POP DE <span class="opcode2">D1</span></div><div>Restore the current variable table position from the STACK and put it in DE</div></div>
									<div class="assembly-row-combined"><div>269E-269F</div><div><a href="#26D5H" class="memory-link">JR Z,26D5H <span class="origrom2">JR Z,FINZER</span></a><span class="opcode2">28 35</span></div><div>If
 this routine is called to locate the variables address, we JUMP to 
26D5H as we do not need to create a new variable, and instead we zero 
out the FAC and skip the RETurn.</div></div>
									<div class="assembly-row-combined"><div>26A0</div><div>POP AF <span class="opcode2">F1</span></div><div>Clear the STACK and put the value of the number type flag for the variable from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>26A1</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Swap (SP) and HL so that the value of the current BASIC program pointer is now in Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>26A2</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>26A3</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the variable's address in BC to the STACK as we are about to use both Register B and Register C</div></div>
									<div class="assembly-row-combined"><div>26A4</div><div>LD C,A <span class="opcode2">4F</span></div><div>Load Register C with the value of the number type flag for the variable in Register A</div></div>
									<div class="assembly-row-combined"><div>26A5-26A6</div><div>LD B,00H <span class="opcode2">06 00</span></div><div>Load Register B with zero so that the number type flag for the variable can be represented in 16 bits</div></div>
									<div class="assembly-row-combined"><div>26A7</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the variable's number type flag in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>26A8</div><div>INC BC <span class="opcode2">03</span></div><div>Bump the value of the variable's number type flag in BC</div></div>
									<div class="assembly-row-combined"><div>26A9</div><div>INC BC <span class="opcode2">03</span></div><div>Bump the value of the variable's number type flag in BC</div></div>
									<div class="assembly-row-combined"><div>26AA</div><div>INC BC <span class="opcode2">03</span></div><div>Bump the value of the variable's number type flag in BC.  Now the variable's length includes room for the addresses as well.</div></div>
									<div class="assembly-row-combined"><div>26AB-26AD</div><div>LD HL,(40FDH) <span class="origrom2">LD HL,(STREND)</span>  <span class="opcode2">2A FD 40</span></div><div>Load HL with the value of the free memory pointer.<br>Note: 40FDH-40FEH holds Free memory pointer</div></div>
									<div class="assembly-row-combined"><div>26AE</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the free memory pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>26AF</div><div>ADD HL,BC <span class="opcode2">09</span></div><div>Add the value of the variable's number type flag in BC to the value of the free memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>26B0</div><div>POP BC <span class="opcode2">C1</span></div><div>Restore the high address from the STACK and put it in BC</div></div>
									<div class="assembly-row-combined"><div>26B1</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the high address pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>26B2-26B4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1955H" class="memory-link">CALL 1955H <span class="origrom2">CALL BLTU</span></a><span class="opcode2">CD 55 19</span></div><div>Block transfer the variable information and make sure we do not overflow the STACK space via a GOSUB to BLTU.</div></div>
									<div class="assembly-row-combined"><div>26B5</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the new free memory pointer (i.e., STREND) from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>26B6-26B8</div><div>LD (40FDH),HL <span class="origrom2">LD (STREND),HL</span>  <span class="opcode2">22 FD 40</span></div><div>Save the value of the new free memory pointer in HL to lock in that variable space.<br><span class="nobottomborder bold">NOTE:</span> 40FDH-40FEH holds Free memory pointer</div></div>
									<div class="assembly-row-combined"><div>26B9</div><div>LD H,B <span class="opcode2">60</span></div><div>Load Register H with the MSB of the new array variables pointer in Register B</div></div>
									<div class="assembly-row-combined"><div>26BA</div><div>LD L,C <span class="opcode2">69</span></div><div>Load
 Register L with the LSB of the new array variables pointer in Register 
C.  HL will now point to the end of the new variable.</div></div>
									<div class="assembly-row-combined"><div>26BB-26BD</div><div>LD (40FBH),HL <span class="origrom2">LD (ARYTAB),HL</span>  <span class="opcode2">22 FB 40</span></div><div>Save
 the value of the new array variables pointer in HL.  40FBH-40FCH holds 
the starting address of the BASIC array variable storage area</div></div>
									<div class="assembly-row-combined" id="26BEH"><div>26BE <span class="origrom2">ZEROER</span></div><div>DEC HL <span class="opcode2">2B</span></div><div>At
 this point, HL is retuned pointing to the end of the variable, so we 
need to zero backwards to DE which points to the start of the variable 
table.  First, decrement the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>26BF-26C0</div><div>LD (HL),00H <span class="opcode2">36 00</span></div><div>Zero the location of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>26C1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now we need to check to see if the variable has been completely zeroed, so we call the COMPARE DE:HL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>26C2-26CJ</div><div><a href="#26BEH" class="memory-link">JR NZ,26BEH <span class="origrom2">R NZ,ZEROER</span></a><span class="opcode2">20 FA</span></div><div>Loop back to 26BEH until the variable has been cleared</div></div>
									<div class="assembly-row-combined"><div>26C4</div><div>POP DE <span class="opcode2">D1</span></div><div>Get the value of the variable's number type flag from the STACK and put it in DE</div></div>
									<div class="assembly-row-combined"><div>26C5</div><div>LD (HL),E <span class="opcode2">73</span></div><div>Save the value of the number type flag in Register E at the location of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>26C6</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>26C7</div><div>POP DE <span class="opcode2">D1</span></div><div>Get the 2nd character of the variable's name from the STACK and put it in DE</div></div>
									<div class="assembly-row-combined"><div>26C8</div><div>LD (HL),E <span class="opcode2">73</span></div><div>Save the first character of the variable's name in Register E at the location of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>26C9</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>26CA</div><div>LD (HL),D <span class="opcode2">72</span></div><div>Save the first character of the variable's name in Register D at the location of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>26CB</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load DE with the value of the variable pointer in from HL</div></div>
									<div class="assembly-row-combined" id="26CCH"><div>26CC <span class="origrom2">FINPTR</span></div><div>INC DE <span class="opcode2">13</span></div><div>Bump the value of the variable pointer in DE so that it points to the value</div></div>
									<div class="assembly-row-combined"><div>26CD</div><div>POP HL <span class="opcode2">E1</span></div><div>Restore the value of the current BASIC program pointer from the STACK into Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>26CE</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
									<div class="assembly-row-combined" id="26CFH"><div>26CF <span class="origrom2">VARNOT</span></div><div>LD D,A <span class="opcode2">57</span></div><div>On entry, the Z FLAG was set, meaning that A=0.  Zero out Register D with the value of Register AA</div></div>
									<div class="assembly-row-combined"><div>26D0</div><div>LD E,A <span class="opcode2">5F</span></div><div>Zero out Register E</div></div>
									<div class="assembly-row-combined"><div>26D1</div><div>POP AF <span class="opcode2">F1</span></div><div>Clean up the STACK (which was the PUSHed DE)</div></div>
									<div class="assembly-row-combined"><div>26D2</div><div>POP AF <span class="opcode2">F1</span></div><div>Clean up the STACK (which was the length)</div></div>
									<div class="assembly-row-combined"><div>26D3</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Swap
 (SP) and HL so that the return return is now at the top of the STACK 
and the pointer in current BASIC program pointer is restored to HL</div></div>
									<div class="assembly-row-combined"><div>26D4</div><div>RET <span class="opcode2">C9</span></div><div>Return to the <span class="code">VARPTR</span> routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="26D5H">26D5 - This routine is ZERO out all variable types and skip any RETurn <span class="origrom">- "FINZER"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="26D5H"><div>26D5-26D7 <span class="origrom2">FINZER</span></div><div>LD (4124H),A <span class="origrom2">LD (FAC),A</span>  <span class="opcode2">32 24 41</span></div><div>Zero ACCumulator so that all single-precision and double-precision variables become zero</div></div>
									<div class="assembly-row-combined"><div>26D8</div><div>POP BC <span class="opcode2">C1</span></div><div>Clean up the STACK (i.e., remove the length of the variable)</div></div>
									<div class="assembly-row-combined"><div>26D9</div><div>LD H,A <span class="opcode2">67</span></div><div>Zero Register H to clear out integers as well</div></div>
									<div class="assembly-row-combined"><div>26DA</div><div>LD L,A <span class="opcode2">6F</span></div><div>Zero Register L to clear out integers as well</div></div>
									<div class="assembly-row-combined"><div>26DB-26DD</div><div>LD (4121H),HL <span class="origrom2">LD (FACLO),HL</span>  <span class="opcode2">22 21 41</span></div><div>Zero the string pointer location in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>26DE</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H <span class="origrom2">GETYPE</span></a><span class="opcode2">E7</span></div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
 The RST 20H routine determines the type of the current value in 
ACCumulator and returns a combination of STATUS flags and unique numeric
 values in the A Register according to the data mode flag (40AFH).  The 
results are returned as follows:<br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>26DF-26E0</div><div><a href="#26E7H" class="memory-link">JR NZ,26E7H <span class="origrom2">JR NZ,POPHR2</span></a><span class="opcode2">20 06</span></div><div>If
 the NZ FLAG is set then we do NOT have a string, in which case we are 
done because we have zeroed out all the number types.  JUMP to 26E7H</div></div>
									<div class="assembly-row-combined"><div>26E1-26E3</div><div>LD HL,1928H <span class="origrom2">LD HL,REDDY-1</span>  <span class="opcode2">21 28 19</span></div><div>If
 we are here, then we have a string, and need to zero that out.  First, 
load HL with the character before the starting address of the Level II 
BASIC READY message, which is a 00H!</div></div>
									<div class="assembly-row-combined"><div>26E4-26E6</div><div>LD (4121H),HL <span class="origrom2">LD (FACLO),HL</span>  <span class="opcode2">22 21 41</span></div><div>Save the value in HL as the current string pointer, which is now null.</div></div>
									<div class="assembly-row-combined" id="26E7H"><div>26E7 <span class="origrom2">POPHR2</span></div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the current BASIC program pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>26E8</div><div>RET <span class="opcode2">C9</span></div><div>RETurn (from the EVAL routine) to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="26E9H">26E9 - This routine handles a subscripted variables <span class="origrom">- "ISARY"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source, ARRAYs have the following format:</p><ul><li>Descriptor - Low Byte - Second Character (200 bit is string)</li><li>Descriptor - High Byte - First character</li><li>Length of array in core in bytes</li><li>Number of dimensions (1 byte)</li><li>Then, for each dimension starting with the first, a list of the max index+1 (2 bytes each)</li><li>The associated value</li></ul>On
 entry D = the type of variable, B = the 1st character of the variable 
name, C = the 2nd character of the variable name, and HL = the current 
position in the input string.<p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="26E9H"><div>26E9 <span class="origrom2">ISARY</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the DIMFLG and VALTYP for recursion</div></div>
									<div class="assembly-row-combined"><div>26EA-26EC</div><div>LD HL,(40AEH) <span class="origrom2">LD HL,(DIMFLG)</span>  <span class="opcode2">2A AE 40</span></div><div>Load HL with the value of the locate/create flag.<br>Note: 40AEH holds LOCATE/CREATE variable flag and will be a 0 if in locate mode and anything other than zero if in create mode</div></div>
									<div class="assembly-row-combined"><div>26ED</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Swap
 (SP) and HL so that the the value of the current BASIC program pointer 
is back into Register Pair HL, and the DIMFLG and VALTYP are moved to 
the top of the STACK</div></div>
									<div class="assembly-row-combined"><div>26EE</div><div>LD D,A <span class="opcode2">57</span></div><div>Zero Register D (which will hold the number of dimension)</div></div>
									<div class="assembly-row-combined" id="26EFH"><div>26EF <span class="origrom2">INDLOP</span></div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the number of dimension (held in Register D) to the STACK</div></div>
									<div class="assembly-row-combined"><div>26F0</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the variable's name in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>26F1-26F3</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E45H" class="memory-link">CALL 1E45H <span class="origrom2">CALL INTIDX</span></a><span class="opcode2">CD 45 1E</span></div><div>Go evaluate the array subscript/index at the location of the current BASIC program pointer in HL up to a <span class="code">)</span> or <span class="code">,</span> . Return with the binary value in DE</div></div>
									<div class="assembly-row-combined"><div>26F4</div><div>POP BC <span class="opcode2">C1</span></div><div>Get the variable's name from the STACK (1st and 2nd character) and put it in BC</div></div>
									<div class="assembly-row-combined"><div>26F5</div><div>POP AF <span class="opcode2">F1</span></div><div>Get the variable's number of dimension so far from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>26F6</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap DE and HL, so that DE will now be the value of the current BASIC program pointer and HL will now hold the array subscript</div></div>
									<div class="assembly-row-combined"><div>26F7</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Swap (SP) and HL so that HL will now hold DIMFLG and VALTYP and the array subscript will be at the stop of the STACK</div></div>
									<div class="assembly-row-combined"><div>26F8</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the DIMGFLG and VALTYP (in HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>26F9</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap
 DE and HL so that the value of the current BASIC program pointer is now
 in Register Pair HL, and the DIMFLG and VALTYP are now in DE.</div></div>
									<div class="assembly-row-combined"><div>26FA</div><div>INC A <span class="opcode2">3C</span></div><div>Bump the number of dimensions evaluated in Register A</div></div>
									<div class="assembly-row-combined"><div>26FB</div><div>LD D,A <span class="opcode2">57</span></div><div>Load Register D with the number of dimensions evaluated in Register A</div></div>
									<div class="assembly-row-combined"><div>26FC</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>26FD-26FE</div><div>CP 2CH <span class="opcode2">FE 2C</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">,</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined" id="2700H"><div>26FF-2700</div><div><a href="#26EFH" class="memory-link">JR Z,26EFH <span class="origrom2">JR Z,INDLOP</span></a><span class="opcode2">28 EE</span></div><div>If the character at the location of the current BASIC program pointer in Register A is a <span class="code">,</span> , then we have more dimensions to process, so JUMP back to INDLOP to process again</div></div>
									<div class="assembly-row-combined"><div>2701-2702</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 29<span class="origrom2">SYNCHK ")"</span></a><span class="opcode2">CF 29</span></div><div>Since the character at the location of the current BASIC program pointer in HL must be a <span class="code">)</span> , call the COMPARE SYMBOL routine at RST 08H.<br><br><span class="bold nobottomborder">NOTE:</span>
 The RST 08H routine compares the symbol in the input string pointed to 
by HL Register to the value in the location following the RST 08 call.<ul><li>If
 there is a match, control is returned to the next execution address 
(i.e, the RST 08H instruction + 2) with the next symbol in the A 
Register and HL incremented by one.</li><li>If the two characters do not match, a syntax error message is given and control returns to the Input Phase).</li></ul></div></div>
									<div class="assembly-row-combined"><div>2703-2705 <span class="origrom2">SUBSOK</span></div><div>LD (40F3H),HL <span class="origrom2">LD (TEMP2),HL</span>  <span class="opcode2">22 F3 40</span></div><div>Save the value of the current BASIC program pointer in HL into the TEMP2 storage area.</div></div>
									<div class="assembly-row-combined"><div>2706</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the DIMFLG and VALTYP from the STACK and put it in HL.</div></div>
									<div class="assembly-row-combined"><div>2707-2709</div><div>LD (40AEH),HL <span class="origrom2">LD (DIMFLG),HL</span>  <span class="opcode2">22 AE 40</span></div><div>Save the value of the DIMFLG and VALTYP into the DIMFLG location in RAM.<br><span class="nobottomborder bold">NOTE:</span> 40AEH holds LOCATE/CREATE variable flag</div></div>
									<div class="assembly-row-combined"><div>270A</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the number of subscripts/dimensions evaluated (held in DE) to the STACK</div></div>
									<p class="debug-note">At this point, Register BC holds the 
variable name, the pointer to the BASIC program is in TEMP2, all of the 
indexes are on the STACK, as is the number of dimensions.</p>
									<div class="assembly-row-combined"><div>270B-270D</div><div>LD HL,(40FBH) <span class="origrom2">LD HL,(ARYTAB)</span>  <span class="opcode2">2A FB 40</span></div><div>We
 are now going to start the serach!  First, load HL with the value of 
the array variables pointer as the starting point.  40FBH-40FCH holds 
the starting address of the BASIC array variable storage area</div></div>
									<div class="assembly-row-combined"><div>270E-270F</div><div>LD A,19H <span class="opcode2">3E 19</span></div><div>Z-80 Trick to skip the next command of ADD HL,DE if falling through</div></div>
									<div class="assembly-row-combined" id="270FH"><div>270F <span class="origrom2">LOPFDA</span></div><div>ADD HL,DE <span class="opcode2">19</span></div><div>Advance past the current array as we know it isn't the correct one. Note: 40FBH-40FCH holds the array variables pointer</div></div>
									<div class="assembly-row-combined"><div>2710</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap DE and HL so that DE holds the current search point.  We don't care about HL.</div></div>
									<div class="assembly-row-combined"><div>2711-2713</div><div>LD HL,(40FDH) <span class="origrom2">LD HL,(STREND)</span>  <span class="opcode2">2A FD 40</span></div><div>Load HL with the place to STOP the search (i.e., the value of the free memory pointer).<br>Note: 40FDH-40FEH holds Free memory pointer</div></div>
									<div class="assembly-row-combined"><div>2714</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap DE and HL so that DE now holds the place to stop the search and HL holds the current search point.</div></div>
									<div class="assembly-row-combined"><div>2715</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now
 we need to see if we have reached the end of the search by comparing 
the END point to the CURRENT point, so we call the COMPARE DE:HL routine
 at RST 10H.<br><br>The RST 10H routine parses the characters starting 
at HL+1 for the first non-SPACE,non-09H,non-0BH character it finds.  On 
exit, Register A will hold that character, and the C FLAG is set if its 
alphabetic, and NC FLAG if its alphanumeric.  All strings must have a 
00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2716-2718</div><div>LD A,(40AFH) <span class="origrom2">LD A,(VALTYP)</span>  <span class="opcode2">3A AF 40</span></div><div>Load Register A with the value of the current number type flag.<br>Note: 40AFH holds Current number type flag</div></div>
									<div class="assembly-row-combined"><div>2719-271A</div><div><a href="#2742H" class="memory-link">JR Z,2742H <span class="origrom2">JR Z,NOTFDD</span></a><span class="opcode2">28 27</span></div><div>If
 the Z FLAG is set, then we have run out of places to search and are 
finished, without finding the array, so JUMP out of this loop to 2742H</div></div>
									<div class="assembly-row-combined"><div>271B</div><div>CP (HL) <span class="opcode2">BE</span></div><div>Compare
 the value of the variable's number type flag in Register A with the 
value of the number type flag at the location of the array variables 
pointer in HL.  If they match, the Z FLAG is set, and otherwise the NZ 
FLAG is set.  If A &lt; the checked value, then the C FLAG is set.  If A
 &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>271C</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>271D-271E</div><div><a href="#2727H" class="memory-link">JR NZ,2727H <span class="origrom2">R NZ,NMARY2</span></a><span class="opcode2">20 08</span></div><div>Jump forward (but still in this loop) to 2727H if the number type flags don't match</div></div>
									<div class="assembly-row-combined"><div>271F</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the first character of the variable name at the location of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2720</div><div>CP C <span class="opcode2">B9</span></div><div>Check
 to see if the first character of the variable at the location of the 
array variable pointer in Register A matches the first character of the 
variable name in Register C.  If they match, the Z FLAG is set, and 
otherwise the NZ FLAG is set.  If A &lt; the checked value, then the C 
FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2721</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2722-2723</div><div><a href="#2728H" class="memory-link">JR NZ,2728H <span class="origrom2">JR NZ,NMARY1</span></a><span class="opcode2">20 04</span></div><div>Jump forward (but still in this loop) to 2728H if the first characters of the variable names don't match</div></div>
									<div class="assembly-row-combined"><div>2724</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the second character of the variable name at the location of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2725</div><div>CP B <span class="opcode2">B8</span></div><div>Compare
 the second character of the variable name at the location of the array 
variables pointer in Register A matches the second character of the 
variable name in Register B.  If they match, the Z FLAG is set, and 
otherwise the NZ FLAG is set.  If A &lt; the checked value, then the C 
FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2726-2727</div><div>LD A,23H <span class="opcode2">3E 23</span></div><div>This part of a Z-80 Trick.  Will load A with 23H if passing through, and not do the following INC HL.</div></div>
									<div class="assembly-row-combined" id="2727H"><div>2727 <span class="origrom2">NMARY2</span></div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined" id="2728H"><div>2728 <span class="origrom2">NMARY1</span></div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL.  HL should now point to the LENGTH entry of the array being looked at</div></div>
									<div class="assembly-row-combined"><div>2729</div><div>LD E,(HL) <span class="opcode2">5E</span></div><div>Load Register E with the LSB of the LENGTH of the array being looked at</div></div>
									<div class="assembly-row-combined"><div>272A</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>272B</div><div>LD D,(HL) <span class="opcode2">56</span></div><div>Load Register D with the MSB of the LENGTH of the array being looked at</div></div>
									<div class="assembly-row-combined"><div>272C</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>272D-272E</div><div><a href="#270FH" class="memory-link">JR NZ,270FH <span class="origrom2">R NZ,LOPFDA</span></a><span class="opcode2">20 E0</span></div><div>If the NZ FLAG is set, then we do not have a match ,and we need to skuip this entry and try again via a JUMP back to 270FH</div></div>
									<div class="assembly-row-combined"><div>272F-2731</div><div>LD A,(40AEH) <span class="origrom2">LD A,(DIMFLG)</span>  <span class="opcode2">3A AE 40</span></div><div>Load Register A with the value of the locate/create flag to see if this was a "DIM" instruction.<br>Note: 40AEH holds LOCATE/CREATE variable flag</div></div>
									<div class="assembly-row-combined"><div>2732</div><div>OR A <span class="opcode2">B7</span></div><div>Since
 a LD command does not set any flags, we must OR A to set the flags 
against A.  In this case, to check the status of the locate/create flag 
in Register A</div></div>
									<div class="assembly-row-combined"><div>2733-2734</div><div>LD E,12H <span class="opcode2">1E 12</span></div><div>Prepare for an error if this routine was NOT called by "DIM" by loading Register E with the <span class="code">?DD ERROR</span> code</div></div>
									<div class="assembly-row-combined"><div>2735-2737</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#19A2H" class="memory-link">JP NZ,19A2H <span class="origrom2">JP NZ,ERROR</span></a><span class="opcode2">C2 A2 19</span></div><div>If the NZ FLAG is set, then this was not called from DIM, and we need to throw a REDIMENTIONED ARRAY error (i.e., <span class="code">?DD ERROR</span> ) since that variable already exists</div></div>
									<p class="debug-note">At this point TEMP2 still holds the 
pointer to the position in the BASIC line being evaluated AND we have 
located the variable we were looking or.  HL will point beyond the 
LENGTH to the number of dimensions.  All indices are on the STACK, 
followed by the number of dimensions.</p>
									<div class="assembly-row-combined"><div>2738</div><div>POP AF <span class="opcode2">F1</span></div><div>Get the number of dimension evaluated from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>2739</div><div>SUB (HL) <span class="opcode2">96</span></div><div>To
 do the actual erasure we need to make suyre that the number given now 
and when the array was set up are the same so we compare the number of 
subscripts evaluated in Register A with the number of subscripts for the
 array at the location of the array variables pointer in HL (meaning, 
the number which was <span class="code">DIM</span> med)</div></div>
									<div class="assembly-row-combined"><div>273A-273C</div><div><a href="#2795H" class="memory-link">JP Z,2795H <span class="origrom2">JP Z,GETDEF</span></a><span class="opcode2">CA 95 27</span></div><div>If they match then we are done so JUMP down to 2795H to read the indices</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="273DH">273D - ?BS ERROR entry point <span class="origrom">- "BSER"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="273DH"><div>273D-273E <span class="origrom2">BSER</span></div><div>LD E,10H <span class="opcode2">1E 10</span></div><div>Load Register E with a <span class="code">?BS ERROR</span> code</div></div>
									<div class="assembly-row-combined"><div>273F-2741</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#19A2H" class="memory-link">JP 19A2H <span class="origrom2">JP ERROR</span></a><span class="opcode2">C3 A2 19</span></div><div>Display a <span class="code">?BS ERROR</span>
 message if the number of subscripts evaluated in Register A doesn't 
match the number of subscripts for the array at the location of the 
array variable pointer in HL</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2742H">2742 - Part of the ARRAY routines.  Jumped here when a variable isn't found in the ARRAY table <span class="origrom">- "NOTFDD"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The original ROM source lays out the steps which the ROM takes to build an entry when a variable isn't found in the array table:</p><li>Put down the descriptor</li><li>Set up the number of dimensions</li><li>Make sure there is room for the new entry</li><li>Remember the VARPTR</li><li>Set the VALTYP</li><li>Hold 2 bytes for the size</li><li>Loop<ol><li>Get an index</li><li>Put number+1 down at the VARPTR</li><li>Increase the VARPTR</li><li>Decmrent the number of DIMs</li><li>Go back to the LOOP until the number of DIMs hits Zero</li></ol></li><li>Call REASON with Register Pair HL holding the last location of the variable</li><li>Update STREND</li><li>Zero out backwards</li><li>Make the tally include MAXDIMS</li><li>Put down TALLY</li><li>If called by DIM, RETurn</li><li>If not called by DIM, then index into the variable as if it was found when initially searched for.</li><p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2742H"><div>2742 <span class="origrom2">NOTFDD</span></div><div>LD (HL),A <span class="opcode2">77</span></div><div>Save the variable type for the array in Register A at the location of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2743</div><div>INC HL <span class="opcode2">23</span></div><div>Bump
 the value of the array variables pointer in HL so it points to the 2nd 
character in the variable name (since they are saved in last, first 
order)</div></div>
									<div class="assembly-row-combined"><div>2744</div><div>LD E,A <span class="opcode2">5F</span></div><div>Load Register E with the variable type flag for the current variable</div></div>
									<div class="assembly-row-combined"><div>2745-2746</div><div>LD D,00H <span class="opcode2">16 00</span></div><div>Zero Register D so that Register Pair DE can be the size of one value of the type VALTYP</div></div>
									<div class="assembly-row-combined"><div>2747</div><div>POP AF <span class="opcode2">F1</span></div><div>Get the number of dimensions evaluated from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>2748</div><div>LD (HL),C <span class="opcode2">71</span></div><div>Save the second character of the variable's name in Register C at the location of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2749</div><div>INC HL <span class="opcode2">23</span></div><div>Bump
 the value of the array variables pointer in HL to now point to the 1st 
character in the variable name (since they are saved in last, first 
order)</div></div>
									<div class="assembly-row-combined"><div>274A</div><div>LD (HL),B <span class="opcode2">70</span></div><div>Save the first character of the variable's name in Register B at the location of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>274B</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL to the LSB of the offset to the next entry</div></div>
									<div class="assembly-row-combined"><div>274C</div><div>LD C,A <span class="opcode2">4F</span></div><div>In preparation for the next CALL, load Register C with the number of two byte entries needed to store the size of each dimension</div></div>
									<div class="assembly-row-combined"><div>274D-274F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1963H" class="memory-link">CALL 1963H <span class="origrom2">CALL GETSTK</span></a><span class="opcode2">CD 63 19</span></div><div>Figure the amount of memory space left between HL and the free memory and get the space needed as set in Register C</div></div>
									<div class="assembly-row-combined"><div>2750</div><div>INC HL <span class="opcode2">23</span></div><div>Next
 we need to make room (i.e., skip over) the size of each dimension so 
... Bump the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2751</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL. These 2 INC's skip over the offset entry</div></div>
									<div class="assembly-row-combined"><div>2752-2754</div><div>LD (40D8H),HL <span class="origrom2">LD (TEMP3),HL</span>  <span class="opcode2">22 D8 40</span></div><div>Next
 we need to secure space for the dimenion entries by saving the location
 in which to put the size (which is the address of the maximum number of
 indices) into a temporary ram location.<br>Note: 40D8H-40D9H holds temporary storage location</div></div>
									<div class="assembly-row-combined"><div>2755</div><div>LD (HL),C <span class="opcode2">71</span></div><div>Save the number of dimension at the location of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2756</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL to point to the first subscript entry in the array table</div></div>
									<div class="assembly-row-combined"><div>2757-2759</div><div>LD A,(40AEH) <span class="origrom2">LD A,(DIMFLG)</span>  <span class="opcode2">3A AE 40</span></div><div>Load Register A with the value of the locate/create flag so we can check to see if this routine was called from a DIM function.<br>Note: 40AEH holds LOCATE/CREATE variable flag</div></div>
									<div class="assembly-row-combined"><div>275A</div><div>RLA <span class="opcode2">17</span></div><div>Set the CARRY flag accordingly</div></div>
									<div class="assembly-row-combined"><div>275B</div><div>LD A,C <span class="opcode2">79</span></div><div>Load Register A with the number of dimension evaluated in Register C</div></div>
									<div class="assembly-row-combined" id="275CH"><div>275C-275E <span class="origrom2">LOPPTA</span></div><div>LD BC,000BH <span class="opcode2">01 0B 00</span></div><div>Top
 of a loop assuming we did not get here from "DIM".  Load BC with the 
default number of 11, which is the most entries an array can have 
without a <span class="code">DIM</span></div></div>
									<div class="assembly-row-combined" id="275FH"><div>275F-2760</div><div><a href="#2763H" class="memory-link">JR NC,2763H <span class="origrom2">JR NC,NOTDIM</span></a><span class="opcode2">30 02</span></div><div>If
 the NC flag is set, then we did not arrive here from DIM, so JUMP 
forward to 2763H if the array is being created because it certainly 
wasn't found</div></div>
									<div class="assembly-row-combined"><div>2761</div><div>POP BC <span class="opcode2">C1</span></div><div>Get a subscript/index from the STACK and put it in BC</div></div>
									<div class="assembly-row-combined"><div>2762</div><div>INC BC <span class="opcode2">03</span></div><div>Bump the value of the subscript in BC by one for the ZERO entry.</div></div>
									<div class="assembly-row-combined"><div>2763 <span class="origrom2">NOTDIM</span></div><div>LD (HL),C <span class="opcode2">71</span></div><div>Top of a loop.  Save the LSB of the subscript's value in Register C at the location of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2764</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2765</div><div>LD (HL),B <span class="opcode2">70</span></div><div>Save the MSB of the subscript's value in Register B at the location of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2766</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2767</div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the number of dimensions evaluated in Register A (and the CARRY aflag results from DIMFLG) to the STACK</div></div>
									<div class="assembly-row-combined"><div>2768-276A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0BAAH" class="memory-link">CALL 0BAAH <span class="origrom2">CALL UMULT</span></a><span class="opcode2">CD AA 0B</span></div><div>Go
 multiply the size of the subscript by the value of the number type flag
 to determine the amount of memory necessary for the subscript</div></div>
									<div class="assembly-row-combined"><div>276B</div><div>POP AF <span class="opcode2">F1</span></div><div>Get the number of domensions that the CARRY FLAG (DIMFLG) from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>276C</div><div>DEC A <span class="opcode2">3D</span></div><div>Decrement the counter of the number of dimensions to check by one</div></div>
									<div class="assembly-row-combined"><div>276D-276E</div><div><a href="#275CH" class="memory-link">JR NZ,275CH <span class="origrom2">JR NZ,LOPPTA</span></a><span class="opcode2">20 ED</span></div><div>Jump back to 275CH if there are anymore subscripts to be evaluated</div></div>
									<div class="assembly-row-combined"><div>276F</div><div>PUSH AF <span class="opcode2">F5</span></div><div>If
 we are here, then all dimensions have been processed and allocation.  
Next, save the number of subscripts evaluated (and the DIMFLG) in 
Register Pair AF to the STACK</div></div>
									<div class="assembly-row-combined"><div>2770</div><div>LD B,D <span class="opcode2">42</span></div><div>Load Register B with the MSB of the array's length in Register D</div></div>
									<div class="assembly-row-combined"><div>2771</div><div>LD C,E <span class="opcode2">4B</span></div><div>Load Register C with the LSB of the array's length in Register E. Now BC = size of the array in bytes</div></div>
									<div class="assembly-row-combined"><div>2772</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap DE and HL so that DE now has the start of the values and HL has the end of the values</div></div>
									<div class="assembly-row-combined"><div>2773</div><div>ADD HL,DE <span class="opcode2">19</span></div><div>Add the length of the array in HL to the value of the array variable pointer in DE</div></div>
									<div class="assembly-row-combined" id="2774H"><div>2774-2775</div><div><a href="#273DH" class="memory-link">JR C,273DH <span class="origrom2">JR C,BSER</span></a><span class="opcode2">38 C7</span></div><div>If that addition triggered the CARRY FLAG then we are out of RAM so JUMP back to 273DH and throw a ?BS ERROR</div></div>
									<div class="assembly-row-combined"><div>2776-2778</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#196CH" class="memory-link">CALL 196CH<br><span class="origrom2">CALL REASON</span></a><span class="opcode2">CD 6C 19</span></div><div>We now know there is room in RAM, so GOSUB to "REASON" to make sure there is room for the values</div></div>
									<div class="assembly-row-combined"><div>2779-277B</div><div>LD (40FDH),HL <span class="origrom2">LD (STREND),HL</span>  <span class="opcode2">22 FD 40</span></div><div>Update the end of storage pointer with the end of the array (held in HL).<br>Note: 40FDH-40FEH holds free memory pointer</div></div>
									<div class="assembly-row-combined" id="277CH"><div>277C <span class="origrom2">ZERITA</span></div><div>DEC HL <span class="opcode2">2B</span></div><div>Now we need to zero the new array.  First, decrement the value of the array pointer in HL</div></div>
									<div class="assembly-row-combined"><div>277D-277E</div><div>LD (HL),00H <span class="opcode2">36 00</span></div><div>Zero the location of the array pointer in HL</div></div>
									<div class="assembly-row-combined"><div>277F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now
 we need to compare the array pointer in HL with the array variables 
pointer in DE, so we call the COMPARE DE:HL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2780-2781</div><div><a href="#277CH" class="memory-link">JR NZ,277CH <span class="origrom2">JR NZ,ZERITA</span></a><span class="opcode2">20 FA</span></div><div>If the NZ FLAG is set, then we have more entries to ZERO, so loop until the array has been cleared</div></div>
									<div class="assembly-row-combined"><div>2782</div><div>INC BC <span class="opcode2">03</span></div><div>Load
 BC with the array's length in bytes plus one so as to make room for the
 byte which holds the number of dimensions for this array variable</div></div>
									<div class="assembly-row-combined"><div>2783</div><div>LD D,A <span class="opcode2">57</span></div><div>Zero Register D</div></div>
									<div class="assembly-row-combined"><div>2784-2786</div><div>LD HL,(40D8H) <span class="origrom2">HL,(TEMP3)</span>  <span class="opcode2">2A D8 40</span></div><div>Load HL with the array variables pointer (=the number of indices).<br>Note: 40D8H-40D9H holds Temporary storage location</div></div>
									<div class="assembly-row-combined"><div>2787</div><div>LD E,(HL) <span class="opcode2">5E</span></div><div>Load Register E with the number of dimension for the array at the location of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2788</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap DE and HL so that HL now holds the number of dimensions and DE holds the value of the array variables pointer</div></div>
									<div class="assembly-row-combined"><div>2789</div><div>ADD HL,HL <span class="opcode2">29</span></div><div>Multiply the number of subscripts for the array in HL by two</div></div>
									<div class="assembly-row-combined"><div>278A</div><div>ADD HL,BC <span class="opcode2">09</span></div><div>Add
 the length of the array in BC (i.e., the size) to the number of 
subscripts times two in HL so that we have the total number of bytes 
used</div></div>
									<div class="assembly-row-combined"><div>278B</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap
 DE and HL so that DE now holds the total number of bytes to be used for
 the array and HL holds the value of the array variables pointer</div></div>
									<div class="assembly-row-combined"><div>278C</div><div>DEC HL <span class="opcode2">2B</span></div><div>We
 now need to insert the size of the array in bytes into the array 
holding area, but that is 2 bytes back so ... decrement the value of the
 array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>278D</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>278E</div><div>LD (HL),E <span class="opcode2">73</span></div><div>Save the LSB of the size of the array in Register E at the location of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>278F</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2790</div><div>LD (HL),D <span class="opcode2">72</span></div><div>Save the MSB of size of the array array in Register D at the location of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2791</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2792</div><div>POP AF <span class="opcode2">F1</span></div><div>Get the value of the DIMFLG (i.e., the CARRY BIT) and a 0 into Register A</div></div>
									<div class="assembly-row-combined" id="2793H"><div>2793-2794</div><div><a href="#27C5H" class="memory-link">JR C,27C5H <span class="origrom2">JR C,FINNNOW</span></a><span class="opcode2">38 30</span></div><div>Jump forward to 27C5H if the array is being created</div></div>
									<p class="debug-note">At this point, HL points beyond the SIZE of the array to the NUMBER OF DIMENSIONS in the array.  So what we need to do next is</p><ul><li>We need NUMDIM to equal the number of dimensions and CURTOL to be 0</li><li>Start a loop:<ul><li>Get a new index value</li><li>Pop the new maximum into CURMAX</li><li>Make sure the index value isn't too big</li><li>Multiply CURTOL by CURMAX</li><li>Add the index to CURTOL</li><li>Reduce NUMDIM by 1</li><li>LOOP BACK if NUMDIM isn't yet 0</li></ul></li><li>Set an OFFSET as CURTOL*4 (which is the VALTYP for extended).</li></ul><p></p>
									<div class="assembly-row-combined" id="2795H"><div>2795 <span class="origrom2">GETDEF</span></div><div>LD B,A <span class="opcode2">47</span></div><div>Zero Register B</div></div>
									<div class="assembly-row-combined"><div>2796</div><div>LD C,A <span class="opcode2">4F</span></div><div>Zero Register C.  Now BC = 0 = CURTOL</div></div>
									<div class="assembly-row-combined"><div>2797</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the number of dimensions for the array at the location of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2798</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL to one entry past the number of dimensions</div></div>
									<div class="assembly-row-combined"><div>2799</div><div>LD D,0E1H <span class="opcode2">16 E1</span></div><div>Z-80 Trick to hide the next instruction (POP HL) if proceeding downward</div></div>
									<div class="assembly-row-combined" id="279AH"><div>279A <span class="origrom2">INLPNM</span></div><div>POP HL <span class="opcode2">E1</span></div><div>Get the array variables pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>279B</div><div>LD E,(HL) <span class="opcode2">5E</span></div><div>Next,
 we want DE to be the maximum for the current index entry, so first load
 Register E with the LSB of the subscript limit at the location of the 
array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>279C</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>279D</div><div>LD D,(HL) <span class="opcode2">56</span></div><div>Load Register D with the MSB of the subscript limit at the location of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>279E</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>279F</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Swap HL and (SP) so that HL now points to the currrent index, and the pointer to the array variable goes to the top of the STACK</div></div>
									<div class="assembly-row-combined"><div>27A0</div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the number of dimensions for the array in Register A to the STACK</div></div>
									<div class="assembly-row-combined"><div>27A1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now
 we need to compare the subscript limit in DE with the subscript for the
 array in HL, so we call the COMPARE DE:HL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined" id="27A2H"><div>27A2-27A4</div><div><a href="#273DH" class="memory-link">JP NC,273DH <span class="origrom2">JP NC,BSER</span></a><span class="opcode2">D2 3D 27</span></div><div>If the current inex is too big, then we need to throw a ?BS ERROR via a JUMP to 273DH</div></div>
									<div class="assembly-row-combined"><div>27A5-27A7</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0BAAH" class="memory-link">CALL 0BAAH <span class="origrom2">CALL UMULT</span></a><span class="opcode2">CD AA 0B</span></div><div>CURTOL = CURTOL * the current maximum subscript</div></div>
									<div class="assembly-row-combined"><div>27A8</div><div>ADD HL,DE <span class="opcode2">19</span></div><div>Add the index to CURTOL</div></div>
									<div class="assembly-row-combined"><div>27A9</div><div>POP AF <span class="opcode2">F1</span></div><div>Get the number of dimensions for the array from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>27AA</div><div>DEC A <span class="opcode2">3D</span></div><div>We checked one, so cross one off the list and see if there are anymore dimensions to be evaluated</div></div>
									<div class="assembly-row-combined"><div>27AB</div><div>LD B,H <span class="opcode2">44</span></div><div>Load Register B with the MSB of the subscript pointer in Register H</div></div>
									<div class="assembly-row-combined"><div>27AC</div><div>LD C,L <span class="opcode2">4D</span></div><div>Load Register C with the LSB of the subscript pointer in Register L.  Now BC = CURTOL for the start of the next loop.</div></div>
									<div class="assembly-row-combined"><div>27AD-27AE</div><div><a href="#279AH" class="memory-link">JR NZ,279AH <span class="origrom2">JR NZ,INLPNM</span></a><span class="opcode2">20 EB</span></div><div>Loop back to 279AH until all of the subscripts have been evaluated</div></div>
									<div class="assembly-row-combined"><div>27AF-27B1</div><div>LD A,(40AFH) <span class="origrom2">LD A,(VALTYP)</span>  <span class="opcode2">3A AF 40</span></div><div>Get the number type flag for the current array; which also doubles for how big the values are<br><span class="nobottomborder bold">NOTE:</span> 40AFH holds Current number type flag</div></div>
									<div class="assembly-row-combined"><div>27B2<br>27B3</div><div>LD B,H<br>LD C,L <span class="opcode2">44</span></div><div>We are going to need to multiply by THREE, so we need to save the original value into BC as well.</div></div>
									<div class="assembly-row-combined"><div>27B4</div><div>ADD HL,HL <span class="opcode2">29</span></div><div>Multiply the subscript pointer in HL by two</div></div>
									<div class="assembly-row-combined"><div>27B5-27B6</div><div>SUB 04H <span class="opcode2">D6 04</span></div><div>Check the value of the number type flag in Register A because we would be done if we have an integer or a string.</div></div>
									<div class="assembly-row-combined" id="27BDH"><div>27B7-27B8</div><div><a href="#27BDH" class="memory-link">JR C,27BDH <span class="origrom2">JR C,DMLVAL</span></a><span class="opcode2">38 04</span></div><div>Jump forward to 27BDH if the current number type is an integer or string</div></div>
									<div class="assembly-row-combined"><div>27B9</div><div>ADD HL,HL <span class="opcode2">29</span></div><div>It isn't an integer or a string so once again multiply the subscript pointer in HL by two (so now it is multiplied by 4)</div></div>
									<div class="assembly-row-combined"><div>27BA-27BB</div><div><a href="#27C2H" class="memory-link">JR Z,27C2H <span class="origrom2">JR Z,DONMUL</span></a><span class="opcode2">28 06</span></div><div>Jump forward to 27C2H if the current number type is single precision as we then have enough bytes.</div></div>
									<div class="assembly-row-combined"><div>27BC</div><div>ADD HL,HL <span class="opcode2">29</span></div><div>It must be double precision, so once again multiply the subscript pointer in HL by two (so now it is multiplied by 8)</div></div>
									<div class="assembly-row-combined" id="27BDH"><div>27BD <span class="origrom2">DMLVAL</span></div><div>OR A <span class="opcode2">B7</span></div><div>Set the flags</div></div>
									<div class="assembly-row-combined"><div>27BE-27C0</div><div><a href="#27C2H" class="memory-link">JP PO,27C2H <span class="origrom2">JP PO,DONMUL</span></a><span class="opcode2">E2 C2 27</span></div><div>Jump forward to 27C2H if the current number type isn't a string</div></div>
									<div class="assembly-row-combined"><div>27C1</div><div>ADD HL,BC <span class="opcode2">09</span></div><div>The current number type is a string so add the value of the original subscript pointer in BC to the subscript pointer in HL</div></div>
									<div class="assembly-row-combined" id="27C2H"><div>27C2 <span class="origrom2">DONMUL</span></div><div>POP BC <span class="opcode2">C1</span></div><div>Get the value of the array variables pointer from the STACK and put it in BC</div></div>
									<div class="assembly-row-combined"><div>27C3</div><div>ADD HL,BC <span class="opcode2">09</span></div><div>Add
 the value of the array variables pointer in BC to the subscript pointer
 in HL to get the place where the size value needs to be stored</div></div>
									<div class="assembly-row-combined"><div>27C4</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load DE with the variable pointer in HL</div></div>
									<div class="assembly-row-combined" id="27C5H"><div>27C5-27C7 <span class="origrom2">FINNNOW</span></div><div>LD HL,(40F3H) <span class="origrom2">LD HL,(TEMP2)</span>  <span class="opcode2">2A F3 40</span></div><div>Get the value of the current BASIC program pointer and put it in HL.<br>Note: 40F3H-40F4H is a temporary storage location</div></div>
									<div class="assembly-row-combined"><div>27C8</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2608H">27C9-27D3 - LEVEL II BASIC MEM ROUTINE <span class="origrom">- "MEM"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the RETURN AMOUNT OF FREE MEMORY routine at 27C9H 
which computes the amount of memory remaining between the end of the 
variable list and the end of the STACK and puts the result in 
ACCumulator as a SINGLE PRECISION number.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="27C9H"><div>27C9 <span class="origrom2">MEM</span></div><div>XOR A <span class="opcode2">AF</span></div><div>Zero Register A and the status flags</div></div>
									<div class="assembly-row-combined"><div>27CA</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>27CB-27CD</div><div>LD (40AFH),A <span class="origrom2">LD (VALTYP),A</span>  <span class="opcode2">32 AF 40</span></div><div>Zero the number type flag.<br><span class="nobottomborder bold">NOTE:</span> 40AFH holds Current number type flag</div></div>
									<div class="assembly-row-combined"><div>27CE-27D0</div><div><a href="#27D4H" class="memory-link">CALL 27D4H <span class="origrom2">CALL FRE</span></a><span class="opcode2">CD D4 27</span></div><div>Determine how much space there is via a GOSUB to the <span class="code">FRE</span> routine at 27D4H</div></div>
									<div class="assembly-row-combined"><div>27D1</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the current BASIC program pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>27D2</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>27D3</div><div>RET <span class="opcode2">C9</span></div><div>Return to BASIC</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="27D4H">27D4-27F4 - LEVEL II BASIC <span class="code">FRE</span> ROUTINE <span class="origrom">- "FRE"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="27D4H"><div>27D4-27D6 <span class="origrom2">FRE</span></div><div>LD HL,(40FDH) <span class="origrom2">LD HL,(STREND)</span>  <span class="opcode2">2A FD 40</span></div><div>Load HL with the start of free memory pointer (which is also the end of the variable and text space).<br><span class="nobottomborder bold">NOTE:</span> 40FDH-40FEH holds Free memory pointer</div></div>
									<div class="assembly-row-combined"><div>27D7</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load DE with the value of the free memory pointer in HL for subtraction</div></div>
									<div class="assembly-row-combined"><div>27D8-27DA</div><div>LD HL,0000H <span class="opcode2">21 00 00</span></div><div>Zero HL</div></div>
									<div class="assembly-row-combined"><div>27DB</div><div>ADD HL,SP <span class="opcode2">39</span></div><div>Add the value in HL (which is zero) to the current value of the STACK pointer so that the STACK pointer is now in HL</div></div>
									<div class="assembly-row-combined"><div>27DC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H <span class="origrom2">GETYPE</span></a><span class="opcode2">E7</span></div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
 The RST 20H routine determines the type of the current value in 
ACCumulator and returns a combination of STATUS flags and unique numeric
 values in the A Register according to the data mode flag (40AFH).  The 
results are returned as follows:<br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>27DD-27DE</div><div><a href="#27ECH" class="memory-link">JR NZ,27ECH <span class="origrom2">JR NZ,GIVDBL</span></a><span class="opcode2">20 0D</span></div><div>If that test shows we do NOT have a STRING (meaning this was really a <span class="code">MEM</span> call, jump to forward to 27ECH</div></div>
									<div class="assembly-row-combined"><div>27DF-27E1</div><div><a href="#29DAH" class="memory-link">CALL 29DAH <span class="origrom2">CALL FREFAC</span></a><span class="opcode2">CD DA 29</span></div><div>Free up the argument and set up to give some free string space</div></div>
									<div class="assembly-row-combined"><div>27E2-27E1</div><div><a href="#28E6H" class="memory-link">CALL 28E6H <span class="origrom2">CALL GARBA2</span></a><span class="opcode2">CD E6 28</span></div><div>Do garbage collection to free up space</div></div>
									<div class="assembly-row-combined"><div>27E5-27E7</div><div>LD HL,(40A0H) <span class="origrom2">LD HL,(STKTOP)</span>  <span class="opcode2">2A A0 40</span></div><div>Load HL with the start of string space pointer / bottom of free space.<br><span class="nobottomborder bold">NOTE:</span> 40A0H-40A1H holds the start of string space pointer</div></div>
									<div class="assembly-row-combined"><div>27E8</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load DE with the start of string space pointer in HL</div></div>
									<div class="assembly-row-combined"><div>27E9-27EB</div><div>LD HL,(40D6H) <span class="origrom2">LD HL,(FRETOP)</span>  <span class="opcode2">2A D6 40</span></div><div>Load HL with the next available location in string space pointer / top of free space.<br><span class="nobottomborder bold">NOTE:</span> 40D6H-40D7H holds the next available location in string space pointer</div></div>
									<p class="debug-note" id="27ECH">The next routine subtracts DE from HL and then floats the result leaving it in FAC.</p>
									<div class="assembly-row-combined"><div>27EC <span class="origrom2">GIVDBL</span></div><div>LD A,L <span class="opcode2">7D</span></div><div>Prepare
 to do HL = HL - DE.  First, load Register A with the LSB of the next 
available location in string space pointer in Register L</div></div>
									<div class="assembly-row-combined"><div>27ED</div><div>SUB E <span class="opcode2">93</span></div><div>Subtract
 the LSB of the start of string space pointer in Register E from the LSB
 of the next available location in string space pointer in Register A</div></div>
									<div class="assembly-row-combined"><div>27EE</div><div>LD L,A <span class="opcode2">6F</span></div><div>Load Register L with the LSB of the amount of string space remaining in Register A</div></div>
									<div class="assembly-row-combined"><div>27EF</div><div>LD A,H <span class="opcode2">7C</span></div><div>Load Register A with the MSB of the next available location in string space pointer in Register H</div></div>
									<div class="assembly-row-combined"><div>27F0</div><div>SBC A,D <span class="opcode2">9A</span></div><div>Subtract
 the MSB of the string space pointer in Register D from the MSB of the 
next available location of string space pointer in Register A</div></div>
									<div class="assembly-row-combined"><div>27F1</div><div>LD H,A <span class="opcode2">67</span></div><div>Load Register H with the MSB of the amount of string space remaining in Register A</div></div>
									<div class="assembly-row-combined"><div>27F2-27F4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0C66H" class="memory-link">JP 0C66H <span class="origrom2">JP INEG2</span></a><span class="opcode2">C3 66 0C</span></div><div>Jump to 0C66H to convert the difference between HL and DE to single precision and then RETurn out of the routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="27F5H">27F5-27FD - LEVEL II BASIC <span class="code">POS(</span> ROUTINE <span class="origrom">- "POS"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>27F5-27F7 <span class="origrom2">POS</span></div><div>LD A,(40A6H) <span class="origrom2">LD A,(TTYPOS)</span>  <span class="opcode2">3A A6 40</span></div><div>Load Register A with the current cursor line position.<br>Note: 40A6H holds the current cursor line position</div></div>
									<div class="assembly-row-combined" id="27F8H"><div>27F8 <span class="origrom2">SNGFLT</span></div><div>LD L,A <span class="opcode2">6F</span></div><div>Load Register L with the value of the current cursor line position in Register A.</div></div>
									<div class="assembly-row-combined"><div>27F9</div><div>XOR A <span class="opcode2">AF</span></div><div>Zero Register A</div></div>
									<div class="assembly-row-combined"><div>27FA <span class="origrom2">GIVINT</span></div><div>LD H,A <span class="opcode2">67</span></div><div>Load Register H with zero, so now HL is 00 + cursor position</div></div>
									<div class="assembly-row-combined"><div>27FB-27FD</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A9AH" class="memory-link">JP 0A9AH <span class="origrom2">JP MAKINT</span></a><span class="opcode2">C3 9A 0A</span></div><div>Jump to 0A9AH to make A an unsigned integer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="27FEH">27FE-2818 - LEVEL II BASIC <span class="code">USR(x)</span> ROUTINE <span class="origrom">- "USRFN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2800H"><div>27FE-2780 <span class="origrom2">USRFN</span></div><div>CALL 41A9H <span class="origrom2">CALL USROUT</span>  <span class="opcode2">CD A9 41</span></div><div>GOSUB to DOS to see if DOS wants to deal with this</div></div>
									<div class="assembly-row-combined"><div>2801</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2802-2804</div><div><a href="#252CH" class="memory-link">CALL 252CH <span class="origrom2">CALL PARCHK</span></a><span class="opcode2">CD 2C 25</span></div><div>GOSUB
 to 252CH to evaluate the expression at the location of the current 
BASIC program pointer in HL and return with the result in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>2805</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL (=the address of the next element in the code string) to the STACK</div></div>
									<div class="assembly-row-combined"><div>2806-2808</div><div>LD HL,0890H <span class="origrom2">LD HL,POPHRT</span>  <span class="opcode2">21 90 08</span></div><div>Load HL with the return address of 0890H which will clear the STACK before returning to BASIC</div></div>
									<div class="assembly-row-combined"><div>2809</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the return address in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>280A-280C</div><div>LD A,(40AFH) <span class="origrom2">LD A,(VALTYP)</span>  <span class="opcode2">3A AF 40</span></div><div>Load Register A with the value of the current number type flag for the argument provided.<br>Note: 40AFH holds Current number type flag</div></div>
									<div class="assembly-row-combined"><div>280D</div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the value of the current number type flag in Register A.<br>(02=INT, 03=STR, 04=SNG, 08=DBL)</div></div>
									<div class="assembly-row-combined"><div>280E-280F</div><div>CP 03H <span class="opcode2">FE 03</span></div><div>Check
 to see if the current value is a string.  If they match, the Z FLAG is 
set, and otherwise the NZ FLAG is set.  If A &lt; the checked value, 
then the C FLAG is set.  If A &gt;= the checked value, the NC FLAG is 
set.</div></div>
									<div class="assembly-row-combined"><div>2810-2812</div><div><a href="#29DAH" class="memory-link">CALL Z,29DAH <span class="origrom2">CALL Z,FREFAC</span></a><span class="opcode2">CC DA 29</span></div><div>If the current result is a string then GOSUB to 29DAH to get the free the space and get the string address into HL</div></div>
									<div class="assembly-row-combined"><div>2813</div><div>POP AF <span class="opcode2">F1</span></div><div>Restore the number type flag into Register A</div></div>
									<div class="assembly-row-combined"><div>2814</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load DE with the (possible) value of the pointer to the string (in HL)</div></div>
									<div class="assembly-row-combined"><div>2815-2817</div><div>LD HL,(408EH) <span class="opcode2">2A 8E 40</span></div><div>Load
 HL with the starting address of the machine language subroutine.  In 
TRSDOS, 408EH is a variable called MAXFIL which holds the value the user
 entered when answering the prompted "FILES?" question.  This would 
definitely NOT be the right address under DOS.</div></div>
									<div class="assembly-row-combined"><div>2818</div><div>JP (HL)<span class="opcode2">E9</span></div><div>Jump to (HL) to run the routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2819H">2819-2827 - CONVERSION ROUTINE <span class="origrom">- "DOCNVF"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Usually called by <span class="code">LET</span> to convert the result of arithmetic routines to the proper destination type.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2819H"><div>2819 <span class="origrom2">DOCNVF</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the pointer to the current character in the BASIC program being evaluated to the STACK</div></div>
									<div class="assembly-row-combined"><div>281A-281B</div><div>AND 07H<span class="origrom2">AND 00000111</span> <span class="opcode2">E6 07</span></div><div>Mask
 the value of the current number type flag in Register A to force the 
formula type to conform to the variable type that it is assigned to</div></div>
									<div class="assembly-row-combined"><div>281C-281E</div><div>LD HL,18A1H <span class="origrom2">LD HL,FRCTBL</span>  <span class="opcode2">21 A1 18</span></div><div>Load HL with the address of the arithmetic conversion routines</div></div>
									<div class="assembly-row-combined"><div>281F</div><div>LD C,A <span class="opcode2">4F</span></div><div>Load Register C with the value of the number type flag in Register A.<br>(02=INT, 03=STR, 04=SNG, 08=DBL)</div></div>
									<div class="assembly-row-combined"><div>2820-2821</div><div>LD B,00H <span class="opcode2">06 00</span></div><div>Zero Register B. Now BC holds 00 + type and will be the two byte offset into the table</div></div>
									<div class="assembly-row-combined"><div>2822</div><div>ADD HL,BC <span class="opcode2">09</span></div><div>Add the offset (of BC) to the base arithmetic conversion routines, to find the right jump point</div></div>
									<div class="assembly-row-combined"><div>2823-2825</div><div><a href="#2586H" class="memory-link">CALL 2586H <span class="origrom2">CALL DISPAT</span></a><span class="opcode2">CD 86 25</span></div><div>GOSUB to 2586H to convert the current result in REG l to its proper number type</div></div>
									<div class="assembly-row-combined"><div>2826</div><div>POP HL <span class="opcode2">E1</span></div><div>Restore the pointer to the current character in the BASIC program being evaluated to HL</div></div>
									<div class="assembly-row-combined"><div>2827</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="27F5H">2828-2835 - Routine to see if we are in DIRECT MODE and ERROR OUT if so <span class="origrom">- "ERRDIR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Usually called from the <span class="code">INPUT</span> routine. On entry HL has the current line number in binary.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2828H"><div>2828 <span class="origrom2">ERRDIR</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save whatever was in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2829-282B</div><div>LD HL,(40A2H) <span class="origrom2">LD HL,(CURLIN)</span>  <span class="opcode2">2A A2 40</span></div><div>Load HL with the value of the current BASIC line number (which is stored at 40A2H-40A3H).</div></div>
									<div class="assembly-row-combined"><div>282C</div><div>INC HL <span class="opcode2">23</span></div><div>Bump
 the value of the current BASIC line number in HL to enable us to test 
for a direct statement.  Direct is 65535 so bumping by 1 will give us a 
ZERo</div></div>
									<div class="assembly-row-combined"><div>282D</div><div>LD A,H <span class="opcode2">7C</span></div><div>Load Register A with the MSB of the current BASIC line number in Register H</div></div>
									<div class="assembly-row-combined"><div>282E</div><div>OR L <span class="opcode2">B5</span></div><div>Combine
 the LSB of the current BASIC line number in Register L with the MSB of 
the current BASIC line number in Register A.  If H and L are both ZERO 
then the Z FLAG will be set.</div></div>
									<div class="assembly-row-combined"><div>282F</div><div>POP HL <span class="opcode2">E1</span></div><div>Restore whatever was in HL on entry back into HL</div></div>
									<div class="assembly-row-combined"><div>2830</div><div>RET NZ <span class="opcode2">C0</span></div><div>Return if there is a line number (i.e., this isn't the command mode) and otherwise fall through to the ?ID ERROR routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2831H">2831 - ID ERROR entry point.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2831-2832</div><div>LD E,16H <span class="opcode2">1E 16</span></div><div>Load Register E with the <span class="code">?ID ERROR</span> code</div></div>
									<div class="assembly-row-combined"><div>2833-2835</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#19A2H" class="memory-link">JP 19A2H <span class="origrom2">JP ERROR</span></a><span class="opcode2">C3 A2 19</span></div><div>Display an <span class="code">?ID ERROR</span> if this is the command mode</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2836H">2836-2856 - STRING ROUTINE - <span class="code">STR$</span> logic <span class="origrom">- "STR$"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2836-2838 <span class="origrom2">STR$</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0FBDH" class="memory-link">CALL 0FBDH <span class="origrom2">CALL FOUT</span></a><span class="opcode2">CD BD 0F</span></div><div>GOSUB to 0FBDH to convert the current result in ACCumulator to an ASCII string</div></div>
									<div class="assembly-row-combined"><div>2839-283B <span class="origrom2">STR$1</span></div><div><a href="#2865H" class="memory-link">CALL 2865H <span class="origrom2">CALL STRLIT</span></a><span class="opcode2">CD 65 28</span></div><div>Scan it and turn it into a string (make a temporary string work area entry)</div></div>
									<div class="assembly-row-combined"><div>283C-283E</div><div><a href="#29DAH" class="memory-link">CALL 29DAH <span class="origrom2">CALL FREFAC</span></a><span class="opcode2">CD DA 29</span></div><div>Load HL with the string's VARPTR and free up the temp</div></div>
									<div class="assembly-row-combined" id="2A2BH"><div>283F-2841</div><div>LD BC,2A2BH <span class="origrom2">LD BC,FINBCK</span>  <span class="opcode2">01 2B 2A</span></div><div>Load BC with a return address of 2A2BH (which cleans the STACK and then jumps to 2884H)</div></div>
									<div class="assembly-row-combined"><div>2842</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the value of the return address in BC to the STACK</div></div>
									<p class="debug-note" id="2843H">The next routine, STRCPY, 
creates a copy of the string pointed to by Register Pair HL.  On exit, 
DE points to DSCTMP which has the string information.</p>
									<div class="assembly-row-combined"><div>2843 <span class="origrom2">STRCPY</span></div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the string's length at the location of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2844</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2845</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the string's VARPTR in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2846-2848</div><div><a href="#28BFH" class="memory-link">CALL 28BFH <span class="origrom2">CALL GETSPA</span></a><span class="opcode2">CD BF 28</span></div><div>GOSUB to 28BFH to test the remaining string area to make sure that the new string will fit</div></div>
									<div class="assembly-row-combined"><div>2849</div><div>POP HL <span class="opcode2">E1</span></div><div>Reload HL with the string's VARPTR.  This is the destination to where the string should be copied.</div></div>
									<div class="assembly-row-combined"><div>284A</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Load Register C with the LSB of the string's address at the location of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>284B</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>284C</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load Register B with the MSB of the string's address at the location of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>284D-284F</div><div><a href="#285AH" class="memory-link">CALL 285AH <span class="origrom2">CALL STRAD2</span></a><span class="opcode2">CD 5A 28</span></div><div>GOSUB to 285AH to save the string's length and the string's address at 40D3H, so as to set up DSCTMP</div></div>
									<div class="assembly-row-combined"><div>2850</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the pointer to STRAD2 (which is 40D3H) to the STACK</div></div>
									<div class="assembly-row-combined"><div>2851</div><div>LD L,A <span class="opcode2">6F</span></div><div>Load Register L with the string's length (from Register A)</div></div>
									<div class="assembly-row-combined"><div>2852-2854</div><div><a href="#29CEH" class="memory-link">CALL 29CEH <span class="origrom2">CALL MOVSTR</span></a><span class="opcode2">CD CE 29</span></div><div>GOSUB to 29CEH to move L characters from the temp area (of BC) to the string data area (in DE)</div></div>
									<div class="assembly-row-combined"><div>2855</div><div>POP DE <span class="opcode2">D1</span></div><div>Restore the pointer to DSCTMP (40D3H) into Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>2856</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2836H">2857-2864 - STRING ROUTINE <span class="origrom">- "STRINI"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2857H"><div>2857-2859 <span class="origrom2">STRINI</span></div><div><a href="#28BFH" class="memory-link">CALL 28BFH <span class="origrom2">CALL GETSPA</span></a><span class="opcode2">CD BF 28</span></div><div>GOSUB
 to 28BFH to make sure that there is enough string space remaining for 
the string length of Register A characters. Get the address of the next 
string area in DE. Then save A and DE at 40D3H-40D5H</div></div>
									<div class="assembly-row-combined" id="285AH"><div>285A <span class="origrom2">STRAD2</span></div><div>LD HL,40D3H <span class="origrom2">LD HL,DSCTMP</span>  <span class="opcode2">21 D3 40</span></div><div>Load HL with the address of the temporary string parameter storage area.<br>Note: 40D3H-40D5H holds Used for temporary string VARPTR's</div></div>
									<div class="assembly-row-combined"><div>285D <span class="origrom2">STRAD1</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the address of the temporary string parameter area in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>285E</div><div>LD (HL),A <span class="opcode2">77</span></div><div>Save the string's length in Register A at the location of the temporary string parameter storage pointer in HL</div></div>
									<div class="assembly-row-combined"><div>285F <span class="origrom2">PUTDEI</span></div><div>INC HL <span class="opcode2">23</span></div><div>The
 next instructions are to set up DE to be the pointer to free space.  
First, bump the value of the temporary string parameter storage pointer 
in HL</div></div>
									<div class="assembly-row-combined"><div>2860</div><div>LD (HL),E <span class="opcode2">73</span></div><div>Save the LSB of the string's address in Register E at the location of the temporary string parameter storage pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2861</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the temporary string parameter storage pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2862</div><div>LD (HL),D <span class="opcode2">72</span></div><div>Save the MSB of the string's address in Register D at the location of the temporary string parameter storage pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2863</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the address of the temporary string parameter storage area from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2864</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2865H">2865-28A5 - STRING ROUTINE <span class="origrom">- "STRLIT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>STRLT2 takes the string literal whose first character is 
pointed by HL+1 and builds a descriptor for it.  Leading quotes should 
be skipped before the CALL to this routine.<br><br>The descriptor is 
initially built in DSCTMP, but PUTNEW transfers it into a temporary RAM 
area and leaves a pointer at the temporary in FACLO.<br><br>All 
characters other than zero (that terminate the string) should be set up 
in Registers B and D.  If the terminator is a quote, the quote is 
skipped over.<br><br>On EXIT, the character after the string literal is pointed to by Register Pair HL and is in Register A.  No flags are set.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2865H"><div>2865 <span class="origrom2">STRLIT</span></div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined" id="2866H"><div>2866-2867 <span class="origrom2">STRLTI</span></div><div>LD B,22H <span class="opcode2">06 22</span></div><div>Load Register B with a <span class="code">"</span> (which is really the end of the quote search character)</div></div>
									<div class="assembly-row-combined" id="2868H"><div>2868 <span class="origrom2">STRLT3</span></div><div>LD D,B <span class="opcode2">50</span></div><div>Load Register D with a <span class="code">"</span> (which is really the ending search character)</div></div>
									<div class="assembly-row-combined" id="2869H"><div>2869 <span class="origrom2">STRLT2</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save
 the address of the current BASIC program pointer in HL to the STACK.  
This is ALSO the pointer to the start of the literal string being worked
 on.</div></div>
									<div class="assembly-row-combined"><div>286A-286B</div><div>LD C,0FFH <span class="opcode2">0E FF</span></div><div>Load Register C with a -1</div></div>
									<div class="assembly-row-combined" id="286CH"><div>286C <span class="origrom2">STRGET</span></div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the current BASIC program pointer in HL to skip over that initial <span class="code">"</span></div></div>
									<div class="assembly-row-combined"><div>286D</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>286E</div><div>INC C <span class="opcode2">0C</span></div><div>Bump the counter in Register C</div></div>
									<div class="assembly-row-combined"><div>286F</div><div>OR A <span class="opcode2">B7</span></div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in Register A is an end of the BASIC line character</div></div>
									<div class="assembly-row-combined"><div>2870-2871</div><div><a href="#2878H" class="memory-link">JR Z,2878H <span class="origrom2">JR Z,STRFIN</span></a><span class="opcode2">28 06</span></div><div>Jump
 to 2878H if the character at the location of the current BASIC program 
pointer in Register A is an end of the BASIC line character</div></div>
									<div class="assembly-row-combined"><div>2872</div><div>CP D <span class="opcode2">BA</span></div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in Register A is the same as the terminating character in 
Register D.  If they match, the Z FLAG is set, and otherwise the NZ FLAG
 is set.  If A &lt; the checked value, then the C FLAG is set.  If A 
&gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2873-2874</div><div><a href="#2878H" class="memory-link">JR Z,2878H <span class="origrom2">JR Z,STRFIN</span></a><span class="opcode2">28 03</span></div><div>Jump
 to 2878H if the character at the location of the current BASIC program 
pointer in Register A is the same as the terminating character in 
Register D</div></div>
									<div class="assembly-row-combined"><div>2875</div><div>CP B <span class="opcode2">B8</span></div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in Register A is the same at the terminating character in 
Register B.  If they match, the Z FLAG is set, and otherwise the NZ FLAG
 is set.  If A &lt; the checked value, then the C FLAG is set.  If A 
&gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2876-2877</div><div><a href="#286CH" class="memory-link">JR NZ,286CH <span class="origrom2">JR NZ,STRGET</span></a><span class="opcode2">20 F4</span></div><div>Loop
 back to 286CH if the character at the location of the current BASIC 
program pointer in Register A isn't the same as the terminating 
character in Register B or D</div></div>
									<div class="assembly-row-combined" id="2878H"><div>2878-2879 <span class="origrom2">STRFIN</span></div><div>CP 22H <span class="opcode2">FE 22</span></div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in Register A is a quote.  If they match, the Z FLAG is set, and
 otherwise the NZ FLAG is set.  If A &lt; the checked value, then the C 
FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>287A-287C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">CALL Z,1D78H <span class="origrom2">CALL Z,CHRGTR</span></a><span class="opcode2">CC 78 1D</span></div><div>If
 it was a quote, then GOSUB to 1D78H to bump the value of the current 
BASIC program pointer in HL until it points to the next character (i.e.,
 skip the quote)</div></div>
									<div class="assembly-row-combined"><div>287D</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Exchange the value of the current BASIC program pointer in HL with the string's address to the STACK</div></div>
									<div class="assembly-row-combined"><div>287E</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the string's address in HL until it points to the first character of the string</div></div>
									<div class="assembly-row-combined"><div>287F</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load DE with the temporary pointer string's address in HL</div></div>
									<div class="assembly-row-combined"><div>2880</div><div>LD A,C <span class="opcode2">79</span></div><div>Load Register A with the string's length from Register C</div></div>
									<div class="assembly-row-combined"><div>2881-2883</div><div><a href="#285AH" class="memory-link">CALL 285AH <span class="origrom2">CALL STRAD2</span></a><span class="opcode2">CD 5A 28</span></div><div>GOSUB to 285AH to save the string's length and the string's address into 40D3H (i.e., DSCTMP)</div></div>
									<div class="assembly-row-combined" id="2884H"><div>2884-2886 <span class="origrom2">PUTNEW</span></div><div>LD DE,40D3H <span class="origrom2">LD DE,DSCTMP</span>  <span class="opcode2">11 D3 40</span></div><div>Load DE with the address of the string parameter storage area.<br>Note: 40D3H-40D5H holds Used for temporary string VARPTR's</div></div>
									<div class="assembly-row-combined" id="2888H"><div>2887-2888</div><div>LD A,D5H <span class="opcode2">3E D5</span></div><div>This
 seems to be garbage, but 2888H is a JUMP point in DOS Basic to process a
 new string in the DEF FN routine.  When JUMPed to 2888H, a PUSH DE is 
processed</div></div>
									<div class="assembly-row-combined"><div>2888 <span class="origrom2">PUTTMP</span></div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save a pointer to the stat of the string to the STACK</div></div>
									<div class="assembly-row-combined"><div>2889-288B</div><div>LD HL,(40B3H) <span class="origrom2">LD HL,(TEMPPT)</span>  <span class="opcode2">2A B3 40</span></div><div>Load
 HL with the first avaialble free location in the temporary string work 
area in HL.  This will serve as the string's VARPTR in ACCumulator.<br>Note: 40B3H-40B4H holds the next available location in the temporary string work area pointer</div></div>
									<div class="assembly-row-combined"><div>288C-288E</div><div>LD (4121H),HL <span class="origrom2">LD (FACLO),HL</span>  <span class="opcode2">22 21 41</span></div><div>Save
 the value of the next available location in the temporary string work 
area in HL.  This is where the result string descriptor will be</div></div>
									<div class="assembly-row-combined"><div>288F-2890</div><div>LD A,03H <span class="opcode2">3E 03</span></div><div>Load Register A with the string number type flag</div></div>
									<div class="assembly-row-combined"><div>2891-2893</div><div>LD (40AFH),A <span class="origrom2">LD (VALTYP),A</span>  <span class="opcode2">32 AF 40</span></div><div>Save the value in Register A as the current number type flag.<br>Note: 40AFH holds current number type flag</div></div>
									<div class="assembly-row-combined"><div>2894-2896</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09D3H" class="memory-link">CALL 09D3H <span class="origrom2">CALL VMOVE</span></a><span class="opcode2">CD D3 09</span></div><div>Move the value into the temporary string work area in HL</div></div>
									<div class="assembly-row-combined"><div>2897-2899</div><div>LD DE,40D6H <span class="origrom2">LD DE,FRETOP</span>  <span class="opcode2">11 D6 40</span></div><div>Depending on how we got here, DE will be different.  If the jump was into PUTTMP, then DE will NOT equal FRETOP.</div></div>
									<div class="assembly-row-combined"><div>289A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>We
 need to do some checking, as FRETOP is just beyond the temporary string
 storage areas, so if TEMPPT points to it, then there are no free 
temporary storage areas left!  To do this we check to see if the updated
 temporary string work area location in HL isn't greater than the ending
 address of the temporary string work area in DE, so we call the COMPARE
 DE:HL routine at RST 10H.<br><br>The RST 10H routine parses the 
characters starting at HL+1 for the first non-SPACE,non-09H,non-0BH 
character it finds.  On exit, Register A will hold that character, and 
the C FLAG is set if its alphabetic, and NC FLAG if its alphanumeric.  
All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>289B-289D</div><div>LD (40B3H),HL <span class="origrom2">LD (TEMPPT),HL</span>  <span class="opcode2">22 B3 40</span></div><div>Save the new temporary string pointer in HL as the next available location in the temporary string work area.<br>Note: 40B3H-40B4H holds the next available location in the temporary string work area pointer</div></div>
									<div class="assembly-row-combined"><div>289E</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the current BASIC program pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>289F</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>28A0</div><div>RET NZ <span class="opcode2">C0</span></div><div>Return
 if the updated temporary string work area location wasn't beyond the 
end of the temporary string work area (meaning it overflowed, because if
 it overflowed .)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="28A1H">28A1 - ST ERROR entry point.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>28A1-28A2</div><div>LD E,1EH <span class="opcode2">1E 1E</span></div><div>Load Register E with a <span class="code">?ST ERROR</span> code</div></div>
									<div class="assembly-row-combined"><div>28A3-28A5</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#19A2H" class="memory-link">JP 19A2H <span class="origrom2">JP ERROR</span></a><span class="opcode2">C3 A2 19</span></div><div>Display a <span class="code">?ST ERROR</span> message if the temporary string work area has overflowed</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="28A6H">28A6-28BE - DISPLAY MESSAGE ROUTINE <span class="origrom">- "STROUI"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source, this routine will print
 the string pointed to by Register Pair HL.  The string MUST be 
terminated by a 00H.  If the string exists below DSCTMP, then it is 
copied into string space first.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>28A6 <span class="origrom2">STROUI</span><p></p></div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the current BASIC program pointer in HL</div></div>
									<p class="debug-note">EXAMPLE: Suppose that we have the following symbolic setup:<br>TITL DEFM 'INSIDE LEVEL II'<br>DEFB 0<br>Then, the instructions:<br>LD HL,TITL<br>CALL 28A7H<br>will cause "INSIDE LEVEL II" to be displayed at the current cursor position and the cursor position to be updated.<br><br></p><li>NOTE:
 If the subroutine at 28A7H is used by an assembly language program that
 is itself entered by a USR call, the return from the assembly language 
program may encounter the embarrassment of a TM error, with control 
passing to the Level II monitor. This occurs because the subroutine at 
28A7H leaves a 3 in location 40AFH, while the USR structure requires a 2
 in 40AFH upon returning. The malady is cured by storing a 2 in 40AFH 
before returning, or by jumping to 0A9AH instead of executing the simple
 RET. The problem would not occur in the first place if the assembly 
language program returns the value of an integer variable to the BASIC 
program, and it might not occur if some other ROM routine is called 
after the subroutine at 28A7H and before returning - if the other 
subroutine produces an integer output. DISK SYSTEM CAUTION: See the DISK
 SYSTEM CAUTION of Section 8.1 regarding the exits to DISK BASIC from 
the subroutine at 28A7H.<p></p>
									<div class="assembly-row-combined" id="28A7H"><div>28A7-28A9H<span class="origrom2">STROUT</span></div><div><a href="#2865H" class="memory-link">CALL 2865H <span class="origrom2">CALL STRLIT</span></a><span class="opcode2">CD 65 28</span></div><div>Go build a temporary string work area entry for the message at FACLOthe location of the current BASIC program pointer in HL</div></div>
									<p class="debug-note" id="28AAH">If the routine entry is at STRPRT, then it just prints the string whose descriptor is held in FACLO</p>
									<div class="assembly-row-combined"><div>28AA-28AC <span class="origrom2">STRPRT</span></div><div><a href="#29DAH" class="memory-link">CALL 29DAH <span class="origrom2">CALL FREFAC</span></a><span class="opcode2">CD DA 29</span></div><div>GOSUB to 29DAH to build a temporary string work area entry for the message pointed to by FACLO</div></div>
									<div class="assembly-row-combined"><div>28AD-28AF</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09C4H" class="memory-link">CALL 09C4H <span class="origrom2">CALL GETBCD</span></a><span class="opcode2">CD C4 09</span></div><div>Go get the string's length in Register D and the string's address in BC</div></div>
									<div class="assembly-row-combined"><div>28B0</div><div>INC D <span class="opcode2">14</span></div><div>Bump the value of the string's length in Register D in preparation for the following loop which starts with a DEC D</div></div>
									<div class="assembly-row-combined"><div>28B1 <span class="origrom2">STRPR2</span></div><div>DEC D <span class="opcode2">15</span></div><div>Top of a loop.  Decrement the value of the string's length in Register D</div></div>
									<div class="assembly-row-combined"><div>28B2</div><div>RET Z <span class="opcode2">C8</span></div><div>Return if all of the characters in the string have been sent to the current output device.</div></div>
									<div class="assembly-row-combined" id="28B3H"><div>28B3</div><div>LD A,(BC) <span class="opcode2">0A</span></div><div>Load Register A with the character at the location of the string pointer in BC</div></div>
									<div class="assembly-row-combined"><div>28B4-28B6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go send the character in Register A to the current output device</div></div>
									<div class="assembly-row-combined"><div>28B7-28B8</div><div>CP 0DH <span class="opcode2">FE 0D</span></div><div>Check to see if the character in Register A is a <kbd>CARRIAGE RETURN</kbd>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>28B9-28BB</div><div><a href="#2103H" class="memory-link">CALL Z,2103H <span class="origrom2">CALL Z,CRFIN</span></a><span class="opcode2">CC 03 21</span></div><div>Jump to 2103H if the character in Register A is a carriage return</div></div>
									<div class="assembly-row-combined"><div>28BC</div><div>INC BC <span class="opcode2">03</span></div><div>Bump the value of the string pointer in BC</div></div>
									<div class="assembly-row-combined"><div>28BD-28BE</div><div><a href="#28B1H" class="memory-link">JR 28B1H <span class="origrom2">JR STRPR2</span></a><span class="opcode2">18 F2</span></div><div>Loop until all of the characters in the string have been sent to the current output device</div></div>
								</li></div>
							</div>

							<h2 class="assembly-section-title" id="28BFH">28BF-28D9 - STRING ROUTINE <span class="origrom">- "GETSPA"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will get space for a character string, and it 
might force garbage collection as well.  The number of characters is in 
Register A.  On exit, DE will point to the string, but if it could not 
allocate space, then an ?OS ERROR is thrown instead.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="28BFH"><div>28BF <span class="origrom2">GETSPA</span></div><div>OR A <span class="opcode2">B7</span></div><div>Make sure A is not zero.  A ZERO FLAG will signal that garbage collection has happened</div></div>
									<div class="assembly-row-combined"><div>28C0-28C1</div><div>LD C,0F1H <span class="opcode2">0E F1</span></div><div>Z-80 Trick.  If passing through, the C just changes and the POP AF which follows is ignored.</div></div>
									<div class="assembly-row-combined"><div>28C1 <span class="origrom2">TRYGI2</span></div><div>POP AF <span class="opcode2">F1</span></div><div>Get the string's length from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>28C2</div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the length of the string in Register A to the STACK</div></div>
									<div class="assembly-row-combined"><div>28C3-28C5</div><div>LD HL,(40A0H) <span class="origrom2">LD HL,(STKTOP)</span>  <span class="opcode2">2A A0 40</span></div><div>Load HL with the poinmter to the bottom of the string space.  40A0H-40A1H holds the start of string space pointer</div></div>
									<div class="assembly-row-combined"><div>28C6</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Move the bottom of the string space pointer into DE. We don't care what happens to HL</div></div>
									<div class="assembly-row-combined"><div>28C7-28C9</div><div>LD HL,(40D6H) <span class="origrom2">LD HL,(FRETOP)</span>  <span class="opcode2">2A D6 40</span></div><div>Load HL with the pointer to the TOP of free space.<br>Note: 40D6H-40D7H holds the next available location in string space pointer</div></div>
									<div class="assembly-row-combined"><div>28CA</div><div>CPL <span class="opcode2">2F</span></div><div>Complement the string's length in Register A so that it is negative</div></div>
									<div class="assembly-row-combined"><div>28CB</div><div>LD C,A <span class="opcode2">4F</span></div><div>The
 next two instructions put the negative of the number of characters into
 Register Pair BC.  First, load Register C with the negative string's 
length in Register A</div></div>
									<div class="assembly-row-combined"><div>28CC-28CD</div><div>LD B,0FFH <span class="opcode2">06 FF</span></div><div>Load Register B with a -1 so that BC will be the negative length of the string</div></div>
									<div class="assembly-row-combined"><div>28CE</div><div>ADD HL,BC <span class="opcode2">09</span></div><div>Add the negative string's length in BC to the top of free space pointer in HL</div></div>
									<div class="assembly-row-combined"><div>28CF</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the adjusted next available location in string space pointer in HL</div></div>
									<div class="assembly-row-combined"><div>28D0</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>We
 need to make sure there is enough room for the string, so we need to 
compare these by checking to see if the adjusted next available location
 in string space pointer in HL is less than the start of string space 
pointer in DE, so we call the COMPARE DE:HL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined" id="28DAH"><div>28D1-28D2</div><div><a href="#28DAH" class="memory-link">JR C,28DAH <span class="origrom2">JR C,GARBAG</span></a><span class="opcode2">38 07</span></div><div>If
 the CARRY FLAG is set then we do not have enough room for the string, 
so lets JUMP forward to 28DAH to do some garbae collection.</div></div>
									<div class="assembly-row-combined"><div>28D3-28D5</div><div>LD (40D6H),HL <span class="origrom2">LD (FRETOP),HL</span>  <span class="opcode2">22 D6 40</span></div><div>Save the value in HL as new bottom of MEMORY</div></div>
									<div class="assembly-row-combined"><div>28D6</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of HL to point to the string</div></div>
									<div class="assembly-row-combined"><div>28D7</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load DE with the pointer to the string</div></div>
									<div class="assembly-row-combined" id="28D8H"><div>28D8 <span class="origrom2">PPSWRT</span></div><div>POP AF <span class="opcode2">F1</span></div><div>Get the string's length from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>28D9</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="28DAH">28DA-298E - STRING ROUTINE <span class="origrom">- "GARBAG"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="28DAH"><div>28DA <span class="origrom2">GARBAG</span></div><div>POP AF <span class="opcode2">F1</span></div><div>Get the garbage collection code which was PUSHed</div></div>
									<div class="assembly-row-combined"><div>28DB-28DC</div><div>LD E,1AH <span class="opcode2">1E 1A</span></div><div>Load Register E with an <span class="code">?OS ERROR</span> code</div></div>
									<div class="assembly-row-combined"><div>28DD-28DF</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#19A2H" class="memory-link">JP Z,19A2H <span class="origrom2">JP Z,ERROR</span></a><span class="opcode2">CA A2 19</span></div><div>If the Z FLAG is set, then we already tried garbage collection and still have no RAM left for the string, so display a <span class="code">?OS ERROR</span> if there isn't enough string space available for the string and we had already reorganized string space</div></div>
									<div class="assembly-row-combined"><div>28E0</div><div>CP A <span class="opcode2">BF</span></div><div>Otherwise,
 set the flags to say that we have already done the garbage collection. 
 If they match, the Z FLAG is set, and otherwise the NZ FLAG is set.  If
 A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>28E1</div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the garbage collection flag to the STACK</div></div>
									<div class="assembly-row-combined" id="28C1H"><div>28E2-28E4</div><div>LD BC,28C1H <span class="origrom2">LD BC,TRYGI2</span>  <span class="opcode2">01 C1 28</span></div><div>Load BC with a return address of 28C1H (which would retry allocation)</div></div>
									<div class="assembly-row-combined"><div>28E5</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save that return address to the STACK</div></div>
									<div class="assembly-row-combined" id="28E6H"><div>28E6-28E8 <span class="origrom2">GARBA2</span></div><div>LD HL,(40B1H) <span class="origrom2">LD HL,(MEMSIZ)</span>  <span class="opcode2">2A B1 40</span></div><div>Load HL with the top of memory pointer.<br>Note: 40B1H-40B2H holds MEMORY SIZE? pointer</div></div>
									<div class="assembly-row-combined" id="28E9H"><div>28E9-28EB <span class="origrom2">FNDVAR</span></div><div>LD (40D6H),HL <span class="origrom2">LD (FRETOP),HL</span>  <span class="opcode2">22 D6 40</span></div><div>Save the top of BASIC memory pointer in HL as the next available location in string space pointer.<br>Note: 40D6H-40D7H holds the next available location in string space pointer</div></div>
									<div class="assembly-row-combined"><div>28EC-28EE</div><div>LD HL,0000H <span class="opcode2">21 00 00</span></div><div>Zero HL</div></div>
									<div class="assembly-row-combined"><div>28EF</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value in HL to the STACK to indicate that we didn't find a variable on this pass</div></div>
									<div class="assembly-row-combined"><div>28F0-28F2</div><div>LD HL,(40A0H) <span class="origrom2">LD HL,(STKTOP)</span>  <span class="opcode2">2A A0 40</span></div><div>Load HL with the start of string space pointer to force DVARS to ignore strings in the program text (literals and data).<br><span class="nobottomborder bold">NOTE:</span> 40A0H-40A1H holds the start of string space pointer</div></div>
									<div class="assembly-row-combined"><div>28F3</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save high address (start of string space pointer in HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>28F4-28F6</div><div>LD HL,40B5H <span class="origrom2">LD HL,TEMPST</span>  <span class="opcode2">21 B5 40</span></div><div>Load HL with the start of the temporary string work area pointer.<br>Note: 40B5H-40D2H holds Temporary string work area</div></div>
									<div class="assembly-row-combined"><div>28F7<br><span class="origrom">"TVAR"</span></div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load DE with the start of the temporary string work area pointer in HL</div></div>
									<div class="assembly-row-combined"><div>28F8-28FA</div><div>LD HL,(40B3H) <span class="origrom2">LD HL,(TEMPPT)</span>  <span class="opcode2">2A B3 40</span></div><div>Load HL with the next available location in the temporary string work area pointer.<br><span class="nobottomborder bold">NOTE:</span> 40B3H-40B4H holds the next available location in the temporary string work area pointer</div></div>
									<div class="assembly-row-combined"><div>28FB</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Exchange
 the start of the temporary string work area pointer in DE with the next
 available location in the temporary string work area pointer in HL</div></div>
									<div class="assembly-row-combined"><div>28FC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>We
 need to see if 40B3H is pointing to the first entry (40B5H) - if the 
start of the temporary string work area pointer in HL is the same as the
 next available location in the temporary string work area pointer, so 
we call the COMPARE DE:HL routine at RST 10H.<br><br>The RST 10H routine
 parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>28FD-28FF</div><div>LD BC,28F7H <span class="origrom2">LD BC,TVAR</span>  <span class="opcode2">01 F7 28</span></div><div>Load BC with a return address of 28F7H</div></div>
									<div class="assembly-row-combined" id="2900H"><div>2900-2902</div><div><a href="#294AH" class="memory-link">JP NZ,294AH <span class="origrom2">JP NZ,DVAR2</span></a><span class="opcode2">C2 4A 29</span></div><div>Jump to 294AH to do the temporary variable garbage collection if the temporary string work area isn't empty</div></div>
									<div class="assembly-row-combined"><div>2903 <span class="origrom2">SVARS</span></div><div>LD HL,(40F9H) <span class="origrom2">LD HL,(VARTAB)</span>  <span class="opcode2">2A F9 40</span></div><div>Load HL with the start of the simple variables pointer.<br><span class="nobottomborder bold">NOTE:</span> 40F9H-40FAH holds the starting address of the simple variable storage area</div></div>
									<div class="assembly-row-combined" id="2906H"><div>2906 <span class="origrom2">SVAR</span></div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load DE with the simple variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2907-2909</div><div>LD HL,(40FBH) <span class="origrom2">LD HL,(ARYTAB)</span>  <span class="opcode2">2A FB 40</span></div><div>Load
 HL with the start of the array variables pointer (which is also the end
 of the simple variables).  40FBH-40FCH holds the starting address of 
the BASIC array variable storage area</div></div>
									<div class="assembly-row-combined"><div>290A</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap DE and HL so that DE holds the end and HL holds the start.</div></div>
									<div class="assembly-row-combined"><div>290B</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now
 we need to check to see if the simple variables pointer in HL is the 
same as the array variables pointer in DE, so we call the COMPARE DE:HL 
routine at RST 10H.<br><br>The RST 10H routine parses the characters 
starting at HL+1 for the first non-SPACE,non-09H,non-0BH character it 
finds.  On exit, Register A will hold that character, and the C FLAG is 
set if its alphabetic, and NC FLAG if its alphanumeric.  All strings 
must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>290C-290D</div><div><a href="#2921H" class="memory-link">JR Z,2921H <span class="origrom2">JR Z,ARYVAR</span></a><span class="opcode2">28 13</span></div><div>If
 the Z FLAG is set then we are at the end of the simple variable.  If 
so, we then need to do the string type variables so we jump forward to 
2921H.</div></div>
									<div class="assembly-row-combined"><div>290E</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with second character of the variable name</div></div>
									<div class="assembly-row-combined"><div>290F</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the simple variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2910</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the simple variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2911</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the simple variables pointer in HL.  HL should now point to the value of the variable.</div></div>
									<div class="assembly-row-combined"><div>2912-2913</div><div>CP 03H <span class="opcode2">FE 03</span></div><div>Check
 to see if the variable at the location of the simple variables pointer 
is a string.  If they match, the Z FLAG is set, and otherwise the NZ 
FLAG is set.  If A &lt; the checked value, then the C FLAG is set.  If A
 &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2914-2915</div><div><a href="#291AH" class="memory-link">JR NZ,291AH <span class="origrom2">JR NZ,SKPVAR</span></a><span class="opcode2">20 04</span></div><div>Jump to 291AH if the variable at the location of the simple variables pointer in HL isn't a string</div></div>
									<div class="assembly-row-combined"><div>2916-2918</div><div><a href="#294BH" class="memory-link">CALL 294BH <span class="origrom2">CALL DVARS</span></a><span class="opcode2">CD 4B 29</span></div><div>GOSUB to 294BH to do collect the string</div></div>
									<div class="assembly-row-combined"><div>2919</div><div>XOR A <span class="opcode2">AF</span></div><div>Zero Register A to indicate that we should not be skipping anything else.</div></div>
									<div class="assembly-row-combined"><div>291A <span class="origrom2">SKPVAR</span></div><div>LD E,A <span class="opcode2">5F</span></div><div>Zero Register E</div></div>
									<div class="assembly-row-combined"><div>291B-291C</div><div>LD D,00H <span class="opcode2">16 00</span></div><div>Zero Register D.  Now DE should be the number of characters to skip.</div></div>
									<div class="assembly-row-combined"><div>291D</div><div>ADD HL,DE <span class="opcode2">19</span></div><div>Add the number of characters to skip (held in DE) to the simple variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>291E-291F</div><div><a href="#2906H" class="memory-link">JR 2906H <span class="origrom2">JR SVAR</span></a><span class="opcode2">18 E6</span></div><div>Loop back to 2906H until all of the simple variables have been checked</div></div>
									<div class="assembly-row-combined" id="2920H"><div>2920 <span class="origrom2">ARYVA2</span></div><div>POP BC <span class="opcode2">C1</span></div><div>Clean up the STACK</div></div>
									<div class="assembly-row-combined" id="2921H"><div>2921 <span class="origrom2">ARYVAR</span></div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load DE with the value of the array variables pointer (ARTVAR) in HL</div></div>
									<div class="assembly-row-combined"><div>2922-2924</div><div>LD HL,(40FDH) <span class="origrom2">LD HL,(STREND)</span>  <span class="opcode2">2A FD 40</span></div><div>Load HL with the end of the arrays / start of free memory pointer.<br>Note: 40FDH-40FEH holds Free memory pointer</div></div>
									<div class="assembly-row-combined"><div>2925</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Exchange the value of the array variables pointer in DE with the value of the free memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2926</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>We
 need to see if we are donee with arrays, so we check to see if the 
array variables pointer in HL is the same as the free memory pointer in 
DE, so we call the COMPARE DE:HL routine at RST 10H.<br><br>The RST 10H 
routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2927-2929</div><div><a href="#296BH" class="memory-link">JP Z,296BH <span class="origrom2">JP Z,GRBPAS</span></a><span class="opcode2">CA 6B 29</span></div><div>Jump if the array variables pointer in Register HL is the same as the start of the free memory pointer in DE</div></div>
									<div class="assembly-row-combined"><div>292A</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the number type flag at the location of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>292B</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>292C-292E</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#09C2H" class="memory-link">CALL 09C2H <span class="origrom2">CALL MOVRM</span></a><span class="opcode2">CD C2 09</span></div><div>Get
 the length of the array into Register Pair BC via a CALL to 09C2H 
(which loads a SINGLE PRECISION value pointed to by HL into Register 
Pairs BC and DE)</div></div>
									<div class="assembly-row-combined"><div>292F</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the pointer to the DIMS to the STACK</div></div>
									<div class="assembly-row-combined"><div>2930</div><div>ADD HL,BC <span class="opcode2">09</span></div><div>Add the value of the offset to the next array in BC to the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2931-2932</div><div>CP 03H <span class="opcode2">FE 03</span></div><div>Check
 to see if the array being examined is a string.  If they match, the Z 
FLAG is set, and otherwise the NZ FLAG is set.  If A &lt; the checked 
value, then the C FLAG is set.  If A &gt;= the checked value, the NC 
FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2933-2934</div><div><a href="#2920H" class="memory-link">JR NZ,2920H <span class="origrom2">JR NZ,ARYVA2</span></a><span class="opcode2">20 EB</span></div><div>If the array being examined isn't a string then skip it via a JUMP to 2920H</div></div>
									<div class="assembly-row-combined"><div>2935-2937</div><div>LD (40D8H),HL <span class="origrom2">LD (TEMP3),HL</span>  <span class="opcode2">22 D8 40</span></div><div>Save the address of the end of the array being examined.<br>Note: 40D8H-40D9H holds Temporary storage location</div></div>
									<div class="assembly-row-combined"><div>2938</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the array variables pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2939</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Load Register C with the number of subscripts for the array at the location of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>293A-293B</div><div>LD B,00H <span class="opcode2">06 00</span></div><div>Zero Register B so that BC holds the number of dimensions</div></div>
									<div class="assembly-row-combined"><div>293C</div><div>ADD HL,BC <span class="opcode2">09</span></div><div>Add the number of subscripts in the array in BC to the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>293D</div><div>ADD HL,BC <span class="opcode2">09</span></div><div>Add
 the number of subscripts in the array in BC to the value of the array 
variables pointer in HL.  Now we should be past the DIMs because we 
added twice the DIMs and they are 2 bytes each.</div></div>
									<div class="assembly-row-combined"><div>293E</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL one more time to account for #DIMs.</div></div>
									<div class="assembly-row-combined"><div>293F <span class="origrom2">ARYSTR</span></div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load DE with the value of the current position in the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2940-2942</div><div>LD HL,(40D8H) <span class="origrom2">LD HL,(TEMP3)</span>  <span class="opcode2">2A D8 40</span></div><div>Load HL with the address of the end of this array.<br>Note: 40D8H-40D9H holds Temporary storage location</div></div>
									<div class="assembly-row-combined"><div>2943</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap DE and HL so that HL now points to the current position</div></div>
									<div class="assembly-row-combined"><div>2944</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>We
 need to test for the end of the array space so we need to check to see 
if the array variables pointer in HL is the same as the address of the 
next array in DE, so we call the COMPARE DE:HL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2945-2946</div><div><a href="#2921H" class="memory-link">JR Z,2921H <span class="origrom2">JR Z,ARYVAR</span></a><span class="opcode2">28 DA</span></div><div>If the Z FLAG is set then we are at the end of an array so JUMP to 2921H to try the next array</div></div>
									<div class="assembly-row-combined" id="293FH"><div>2947-2948</div><div>LD BC,293FH <span class="origrom2">LD BC,ARYSTR</span>  <span class="opcode2">01 3F 29</span></div><div>Load BC with a return address of 293FH</div></div>
									<div class="assembly-row-combined" id="294AH"><div>294A <span class="origrom2">DVAR2</span></div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the value in BC to the STACK</div></div>
									<div class="assembly-row-combined" id="294BH"><div>294B <span class="origrom2">DVAR and DVARS</span></div><div>XOR A <span class="opcode2">AF</span></div><div>Zero Register A so we can test for a null string</div></div>
									<div class="assembly-row-combined"><div>294C</div><div>OR (HL) <span class="opcode2">B6</span></div><div>Load Register A with the length of the string at the location of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>294D</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>294E</div><div>LD E,(HL) <span class="opcode2">5E</span></div><div>Load Register E with the LSB of the string's address at the location of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>294F</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2950</div><div>LD D,(HL) <span class="opcode2">56</span></div><div>Load
 Register D with the MSB of the string's address at the location of the 
array variables pointer in HL.  DE should now point to the value of the 
array.</div></div>
									<div class="assembly-row-combined"><div>2951</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the array variables pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2952</div><div>RET Z <span class="opcode2">C8</span></div><div>Return if the string's length in Register A is equal to zero</div></div>
									<div class="assembly-row-combined" id="2953H"><div>2953<br>2954</div><div>LD B,H<br>LD C,L <span class="opcode2">44</span></div><div>Let BC = HL</div></div>
									<div class="assembly-row-combined"><div>2955-2957</div><div>LD HL,(40D6H) <span class="origrom2">LD HL,(FRETOP)</span>  <span class="opcode2">2A D6 40</span></div><div>Load HL with the location of the the top of string free space.<br><span class="nobottomborder bold">NOTE:</span> 40D6H-40D7H holds the next available location in string space pointer</div></div>
									<div class="assembly-row-combined"><div>2958</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>We
 need to see if this string's pointer is LESS than the top of free 
string space by checking to see if the string's address in DE is in 
string space, so we call the COMPARE DE:HL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2959<br>295A</div><div>LD H,B<br>LD L,C <span class="opcode2">60</span></div><div>Let HL = BC</div></div>
									<div class="assembly-row-combined"><div>295B</div><div>RET C <span class="opcode2">D8</span></div><div>If
 this string's pointer is NOT less than the top of string free space, 
then there is no need to continue working on it, so RETurn</div></div>
									<div class="assembly-row-combined" id="295CH"><div>295C</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the return address from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>295D</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Swap (SP) and HL so that the return address is back on the STACK and HL holds the maximum number seen</div></div>
									<div class="assembly-row-combined"><div>295E</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now
 we need to check to see if the string's address in DE is below the 
start of string space pointer in HL, so we call the COMPARE DE:HL 
routine at RST 10H.<br><br>The RST 10H routine parses the characters 
starting at HL+1 for the first non-SPACE,non-09H,non-0BH character it 
finds.  On exit, Register A will hold that character, and the C FLAG is 
set if its alphabetic, and NC FLAG if its alphanumeric.  All strings 
must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>295F</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Swap (SP) and HL so that the return address is back in HL and the STACK holds the maximum number seen</div></div>
									<div class="assembly-row-combined"><div>2960</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the return address in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2961<br>2962</div><div>LD H,B<br>LD L,C <span class="opcode2">60</span></div><div>Let HL = BC</div></div>
									<div class="assembly-row-combined"><div>2963</div><div>RET NC <span class="opcode2">D0</span></div><div>Return if the string's address in DE is below the string space pointer</div></div>
									<div class="assembly-row-combined" id="2964H"><div>2964</div><div>POP BC <span class="opcode2">C1</span></div><div>Get the return address from the STACK and put it in BC</div></div>
									<div class="assembly-row-combined"><div>2965</div><div>POP AF <span class="opcode2">F1</span></div><div>Clean up the STACK (remove the MAX SEEN)</div></div>
									<div class="assembly-row-combined"><div>2966</div><div>POP AF <span class="opcode2">F1</span></div><div>Clean up the STACK (remove the VARIABLE POINTER)</div></div>
									<div class="assembly-row-combined"><div>2967</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the array variables pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2968</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the new MAX pointer in DE to the STACK</div></div>
									<div class="assembly-row-combined"><div>2969</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the value of the return address in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>296A</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
									<p class="debug-note" id="296BH">If we are here, we have made one complete pass through the string variables.</p>
									<div class="assembly-row-combined"><div>296B <span class="origrom2">GRBPAS</span></div><div>POP DE <span class="opcode2">D1</span></div><div>Load DE with the address of the last string put into the temporary string work area (aka the MAX pointer)</div></div>
									<div class="assembly-row-combined"><div>296C</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the variable pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>296D</div><div>LD A,L <span class="opcode2">7D</span></div><div>Load Register A with the LSB of the variable pointer in Register L</div></div>
									<div class="assembly-row-combined"><div>296E</div><div>OR H <span class="opcode2">B4</span></div><div>Combine
 the MSB of the temporary string work area pointer in Register H with 
the LSB of the temporary string work area pointer in Register A</div></div>
									<div class="assembly-row-combined"><div>296F</div><div>RET Z <span class="opcode2">C8</span></div><div>If HL=0 then we are at the end of the garbage collection, so return</div></div>
									<div class="assembly-row-combined" id="2970H"><div>2970</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the temporary string work area pointer in HL, currently just past the string descriptor</div></div>
									<div class="assembly-row-combined"><div>2971</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load Register B with the MSB of the string's address at the location of the temporary string work area pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2972</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the temporary string work area pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2973</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Load
 Register C with the LSB of the string's address at the location of the 
temporary string work area pointer in HL.  BC will now point to the 
string data.</div></div>
									<div class="assembly-row-combined"><div>2974</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save
 the value of the temporary string work area pointer in HL to the STACK.
  This will be needed to update the pointer after the string is moved.</div></div>
									<div class="assembly-row-combined"><div>2975</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the temporary string work area pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2976</div><div>LD L,(HL) <span class="opcode2">6E</span></div><div>Load Register L with the string's length at the location of the temporary string work area pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2977-2978</div><div>LD H,00H <span class="opcode2">26 00</span></div><div>Zero Register H so that HL is now the string's character count</div></div>
									<div class="assembly-row-combined"><div>2979</div><div>ADD HL,BC <span class="opcode2">09</span></div><div>Add the length of the string in HL to the string's address in BC.  HL now points just beyond the string.</div></div>
									<div class="assembly-row-combined"><div>297A</div><div>LD D,B <span class="opcode2">50</span></div><div>Load Register D with the MSB of the string's address in Register B</div></div>
									<div class="assembly-row-combined"><div>297B</div><div>LD E,C <span class="opcode2">59</span></div><div>Load Register E with the LSB of the string's address in Register C.  DE now is the original pointer to the string.</div></div>
									<div class="assembly-row-combined"><div>297C</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the string's ending address in HL to avoid moving one beyond the string</div></div>
									<div class="assembly-row-combined"><div>297D</div><div>LD B,H <span class="opcode2">44</span></div><div>Load Register B with the MSB of the string's ending address in Register H</div></div>
									<div class="assembly-row-combined"><div>297E</div><div>LD C,L <span class="opcode2">4D</span></div><div>Load Register C with the LSB of the string's ending address in Register L.  BC now points to the top of the string</div></div>
									<div class="assembly-row-combined"><div>297F-2981</div><div>LD HL,(40D6H) <span class="origrom2">LD HL,(FRETOP)</span>  <span class="opcode2">2A D6 40</span></div><div>Load HL with the top of free space.<br><span class="nobottomborder bold">NOTE:</span> 40D6H-40D7H holds the next available location in string space pointer</div></div>
									<div class="assembly-row-combined"><div>2982-2984</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1958H" class="memory-link">CALL 1958H <span class="origrom2">CALL BLTUC</span></a><span class="opcode2">CD 58 19</span></div><div>Move the string from the temporary storage location to string space</div></div>
									<div class="assembly-row-combined"><div>2985</div><div>POP HL <span class="opcode2">E1</span></div><div>Get back the pointer to the description of the variable from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2986</div><div>LD (HL),C <span class="opcode2">71</span></div><div>Save the LSB of the string's permanent address (held in Register C) to (HL)</div></div>
									<div class="assembly-row-combined"><div>2987</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the temporary string work area pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2988</div><div>LD (HL),B <span class="opcode2">70</span></div><div>Save the MSB of the string's permanent address (held in Register C) to (HL)</div></div>
									<div class="assembly-row-combined"><div>2989</div><div>LD L,C <span class="opcode2">69</span></div><div>Load Register L with the LSB of the string's address in Register C</div></div>
									<div class="assembly-row-combined"><div>298A</div><div>LD H,B <span class="opcode2">60</span></div><div>Load Register H with the MSB of the string's address in Register B.  Register Pair HL will now be the new pointer to the string.</div></div>
									<div class="assembly-row-combined"><div>298B</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the string's address in HL to adjust FRETOP</div></div>
									<div class="assembly-row-combined"><div>298C-298E</div><div><a href="#28E9H" class="memory-link">JP 28E9H <span class="origrom2">JP FNDVAR</span></a><span class="opcode2">C3 E9 28</span></div><div>Jump to 28E9H to try to find the high again.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="298FH">298F-29C5 - STRING ADDITION ROUTINE - Concatenate two strings <span class="origrom">- "CAT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine concatenates two strings.  The first is pointed 
to by FACLO and HL points to the character after the "+" sign in on the 
command line.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="298FH"><div>298F <span class="origrom2">CAT</span></div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the precedence/operator value in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>2990</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2991-2993</div><div>LD HL,(4121H) <span class="origrom2">LD HL,(FACLO)</span>  <span class="opcode2">2A 21 41</span></div><div>Load HL with the first string's VARPTR (from ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>2994</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Exchange the value of the first string's VARPTR in HL with the value of the current BASIC program to the STACK</div></div>
									<div class="assembly-row-combined"><div>2995-2997</div><div><a href="#249FH" class="memory-link">CALL 249FH <span class="origrom2">CALL EVAL</span></a><span class="opcode2">CD 9F 24</span></div><div>GOSUB to 249FH to evaluate the expression at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2998</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Exchange the value of the current BASIC program pointer in HL with the value of the first string's VARPTR to the STACK</div></div>
									<div class="assembly-row-combined"><div>2999-299B</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0AF4H" class="memory-link">CALL 0AF4H <span class="origrom2">CALL CHKSTR</span></a><span class="opcode2">CD F4 0A</span></div><div>Go make sure the current result in ACCumulator is a string</div></div>
									<div class="assembly-row-combined"><div>299C</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the first string's length at the location of the first string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>299D</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the first string's descriptor (VARPTR) in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>299E-29A0</div><div>LD HL,(4121H) <span class="origrom2">LD HL,(FACLO)</span>  <span class="opcode2">2A 21 41</span></div><div>Load HL with the second string's VARPTR in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>29A1</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the second string's VARPTR in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>29A2</div><div>ADD A,(HL) <span class="opcode2">86</span></div><div>Add
 the length of the second string at the location of the second string's 
VARPTR in HL to the length of the first string in Register A</div></div>
									<div class="assembly-row-combined"><div>29A3-29A4</div><div>LD E,1CH <span class="opcode2">1E 1C</span></div><div>Load Register E with a <span class="code">?LS ERROR</span> code in case the two string lengths are not less than 256.</div></div>
									<div class="assembly-row-combined"><div>29A5-29A7</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#19A2H" class="memory-link">JP C,19A2H <span class="origrom2">JP C,ERROR</span></a><span class="opcode2">DA A2 19</span></div><div>Display a <span class="code">?LS ERROR</span> message if the combined lengths of the strings is greater than 255</div></div>
									<div class="assembly-row-combined"><div>29A8-29AA</div><div><a href="#2857H" class="memory-link">CALL 2857H <span class="origrom2">CALL STRINI</span></a><span class="opcode2">CD 57 28</span></div><div>Go make sure that there is enough string space for the new string</div></div>
									<div class="assembly-row-combined"><div>29AB</div><div>POP DE <span class="opcode2">D1</span></div><div>Get the second string's VARPTR from the STACK and put it in DE</div></div>
									<div class="assembly-row-combined"><div>29AC-29AE</div><div><a href="#29DEH" class="memory-link">CALL 29DEH <span class="origrom2">CALL FRETMP</span></a><span class="opcode2">CD DE 29</span></div><div>Go update the temporary string work area</div></div>
									<div class="assembly-row-combined"><div>29AF</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Exchange the second string's VARPTR in HL with the first string's VARPTR to the STACK</div></div>
									<div class="assembly-row-combined"><div>29B0-29B2</div><div><a href="#29DDH" class="memory-link">CALL 29DDH <span class="origrom2">CALL FRETM2</span></a><span class="opcode2">CD DD 29</span></div><div>Go update the temporary string work area</div></div>
									<div class="assembly-row-combined"><div>29B3</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the first string's VARPTR in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>29B4-29B6 <span class="origrom2">INCSTR</span></div><div>LD HL,(40D4H) <span class="origrom2">LD HL,(DSCTMP+1)</span>  <span class="opcode2">2A D4 40</span></div><div>Load HL with the pointer to the first string's address</div></div>
									<div class="assembly-row-combined"><div>29B7</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load DE with the first string's address in HL</div></div>
									<div class="assembly-row-combined"><div>29B8-29BA</div><div><a href="#29C6H" class="memory-link">CALL 29C6H <span class="origrom2">CALL MOVINS</span></a><span class="opcode2">CD C6 29</span></div><div>Go move the first string to its temporary storage location</div></div>
									<div class="assembly-row-combined"><div>29BB-29BD</div><div><a href="#29C6H" class="memory-link">CALL 29C6H <span class="origrom2">CALL MOVINS</span></a><span class="opcode2">CD C6 29</span></div><div>Go move the second string to its temporary storage location</div></div>
									<div class="assembly-row-combined"><div>29BE-29C0</div><div>LD HL,2349H <span class="origrom2">LD HL,TSTOP</span>  <span class="opcode2">21 49 23</span></div><div>Load HL with the return address</div></div>
									<div class="assembly-row-combined"><div>29C1</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Exchange the value of the return address in HL with the value of the current BASIC program pointer to the STACK</div></div>
									<div class="assembly-row-combined"><div>29C2</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>29C3-29C5</div><div><a href="#2884H" class="memory-link">JP 2884H <span class="origrom2">JP PUTNEW</span></a><span class="opcode2">C3 84 28</span></div><div>Jump to 2884H to RETurn to TSTOP</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="29C6H">29C6-29D6 - STRING ROUTINE - This will move strings using the STACK <span class="origrom">- "MOVINS"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>On entry, the STACK should have the count/source address and DE should have the destination address</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="29C6H"><div>29C6 <span class="origrom2">MOVINS</span></div><div>POP HL <span class="opcode2">E1</span></div><div>Load HL with the value of the return address to the STACK</div></div>
									<div class="assembly-row-combined"><div>29C7</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Swap
 (SP) and HL so that the return address is now at the top of the STACK 
and the string's descriptor/VARPTR is in Register Pair HL.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="29C8H">29C8 - STRING MOVE ROUTINE<br>On
 entry HL points to the string control block for the string to be moved,
 and DE contains the destination address. All registers are used. The 
string length and address are not moved. String control blocks have the 
format: X=String Length; ADDR = String Address.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>29C8</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the string's length at the location of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>29C9</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>29CA</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Load Register C with the LSB of the string's address at the location of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>29CB</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>29CC</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load
 Register B with the MSB of the string's address at the location of the 
string's VARPTR in HL.  BC now points to the string data.</div></div>
									<div class="assembly-row-combined"><div>29CD</div><div>LD L,A <span class="opcode2">6F</span></div><div>Load Register L with the string's length in Register A</div></div>
									<div class="assembly-row-combined" id="29CEH"><div>29CE <span class="origrom2">MOVSTR</span></div><div>INC L <span class="opcode2">2C</span></div><div>Increment the value of the string's length in Register L in preparation for the next instruction which is a loop.</div></div>
									<div class="assembly-row-combined" id="29CFH"><div>29CF <span class="origrom2">MOVLP</span></div><div>DEC L <span class="opcode2">2D</span></div><div>Decrement the value of the string's length in Register L</div></div>
									<div class="assembly-row-combined"><div>29D0</div><div>RET Z <span class="opcode2">C8</span></div><div>If L hits zero then we have moved all the characters, so RETurn</div></div>
									<div class="assembly-row-combined" id="29D1H"><div>29D1</div><div>LD A,(BC) <span class="opcode2">0A</span></div><div>If
 we are here then we still have characters to move.  First, load 
Register A with the character at the location of the string pointer in 
BC</div></div>
									<div class="assembly-row-combined"><div>29D2</div><div>LD (DE),A <span class="opcode2">12</span></div><div>Save the character in Register A at the location of the string storage pointer in DE</div></div>
									<div class="assembly-row-combined"><div>29D3</div><div>INC BC <span class="opcode2">03</span></div><div>Bump the value of the string pointer in BC</div></div>
									<div class="assembly-row-combined"><div>29D4</div><div>INC DE <span class="opcode2">13</span></div><div>Bump the value of the string storage pointer in DE</div></div>
									<div class="assembly-row-combined"><div>29D5-29D6</div><div><a href="#29CFH" class="memory-link">JR 29CFH <span class="origrom2">JR MOVLP</span></a><span class="opcode2">18 F8</span></div><div>Loop until the string has been completely moved</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="29D7H">29D7-29F4 - STRING ROUTINE <span class="origrom">- "FRESTR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source code, FRETMP is passed a
 pointer to a string descriptor in Register Pair DE and is returned in 
Register Pair HL.  All the other registers are modified.  A check to is 
made to see if the string descriptor in Register Pair DE points to is 
the last temporary descriptor allocated by PUTNEW.  If so, the temporary
 is freed up by the updating of TEMPPT.  If a temporary is freed up, a 
further check is made to see if the string data that that string 
temporary pointed to is the the lowest part of string space in use.  If 
so, FRETMP is updated to reflect the fact that that space is no longer 
in use.<br><br>This routine is a contination of <span class="code">VAL</span> , <span class="code">FRE</span> , and <span class="code">PRINT</span> processing. A jump to here would include the need to get a string's VARPTR and put it in HL.</p><br>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="29D7H"><div>29D7-29D9 <span class="origrom2">FRESTR</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0AF4H" class="memory-link">CALL 0AF4H <span class="origrom2">CALL CHKSTR</span></a><span class="opcode2">CD F4 0A</span></div><div>GOSUB to 0AF4H to make sure that the current result in REG l is a string</div></div>
									<div class="assembly-row-combined" id="29DAH"><div>29DA-29DC <span class="origrom2">FREFAC</span></div><div>LD HL,(4121H) <span class="origrom2">LD HL,(FACLO)</span>  <span class="opcode2">2A 21 41</span></div><div>Load HL with the string's VARPTR in ACCumulator</div></div>
									<div class="assembly-row-combined" id="29DDH"><div>29DD <span class="origrom2">FRETM2</span></div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load DE with the value of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined" id="29DEH"><div>29DE-29E0 <span class="origrom2">FRETMP</span></div><div><a href="#29F5H" class="memory-link">CALL 29F5H <span class="origrom2">CALL FRETMS</span></a><span class="opcode2">CD F5 29</span></div><div>Check to see if the string is the last entry in the temporary string work area</div></div>
									<div class="assembly-row-combined"><div>29E1</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load HL with the value of the string's VARPTR in DE</div></div>
									<div class="assembly-row-combined"><div>29E2</div><div>RET NZ <span class="opcode2">C0</span></div><div>Return if the string isn't the last entry in the temporary string work area</div></div>
									<div class="assembly-row-combined" id="29E3H"><div>29E3</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the value of the string's VARPTR in DE to the STACK</div></div>
									<div class="assembly-row-combined"><div>29E4</div><div>LD D,B <span class="opcode2">50</span></div><div>Load Register D with the MSB of the string's address in Register B</div></div>
									<div class="assembly-row-combined"><div>29E5</div><div>LD E,C <span class="opcode2">59</span></div><div>Load Register E with the LSB of the string's address in Register C.  DE now points to the string.</div></div>
									<div class="assembly-row-combined"><div>29E6</div><div>DEC DE <span class="opcode2">1B</span></div><div>Decrement the value of the string's address in DE</div></div>
									<div class="assembly-row-combined"><div>29E7</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Load Register C with the string's length at the location of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>29E8-29EA</div><div>LD HL,(40D6H) <span class="origrom2">LD HL,(FRETOP)</span>  <span class="opcode2">2A D6 40</span></div><div>Load
 HL with the next available location in string space pointer for the 
purpose of testing to see if this is the FIRST one in the string space.<br>Note: 40D6H-40D7H holds the next available location in string space pointer</div></div>
									<div class="assembly-row-combined"><div>29EB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>We
 need to see if the current string is the last one defined in the string
 area by seeing if the string's address in DE is the same as the next 
available location in string space pointer in HL, so we call the COMPARE
 DE:HL routine at RST 10H.<br><br>The RST 10H routine parses the 
characters starting at HL+1 for the first non-SPACE,non-09H,non-0BH 
character it finds.  On exit, Register A will hold that character, and 
the C FLAG is set if its alphabetic, and NC FLAG if its alphanumeric.  
All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>29EC-29ED</div><div><a href="#29F3H" class="memory-link">JR NZ,29F3H <span class="origrom2">JR NZ,NOTLST</span></a><span class="opcode2">20 05</span></div><div>Jump forward to 29F3H if the string's address in DE isn't the same as the next available location in string space pointer in HL</div></div>
									<div class="assembly-row-combined"><div>29EE</div><div>LD B,A <span class="opcode2">47</span></div><div>If
 is the last one defined then we need to update the current string 
pointer so first we load Register B with the value in Register A</div></div>
									<div class="assembly-row-combined"><div>29EF</div><div>ADD HL,BC <span class="opcode2">09</span></div><div>Add the length of the string in BC to the next available location in string space pointer in HL</div></div>
									<div class="assembly-row-combined"><div>29F0-29F2</div><div>LD (40D6H),HL <span class="origrom2">LD (FRETOP),HL</span>  <span class="opcode2">22 D6 40</span></div><div>Save the adjusted next available location in string space pointer in HL.<br>Note: 40D6H-40D7H holds the next available location in string space pointer</div></div>
									<div class="assembly-row-combined" id="29F3H"><div>29F3 <span class="origrom2">NOTLST</span></div><div>POP HL <span class="opcode2">E1</span></div><div>Get the string's VARPTR from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>29F4</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="298FH">29F5-2A02 - STRING ROUTINE - <span class="origrom">- "FRETMS"</span><br>Test to see if the string in DE is the last string used in the temporary string work area.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="29F5H"><div>29F5-29F7 <span class="origrom2">FRETMS</span></div><div>LD HL,(40B3H) <span class="origrom2">LD HL,(TEMPPT)</span>  <span class="opcode2">2A B3 40</span></div><div>Load HL with the temporary string work area pointer.<br>Note: 40B3H-40B4H holds the next available location in the temporary string work area pointer</div></div>
									<div class="assembly-row-combined"><div>29F8</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the temporary string work area pointer in HL which backs up two words</div></div>
									<div class="assembly-row-combined"><div>29F9</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load Register B with the MSB of the string's address at the location of the temporary string work area pointer in HL</div></div>
									<div class="assembly-row-combined"><div>29FA</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the temporary string work area pointer in HL</div></div>
									<div class="assembly-row-combined"><div>29FB</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Load Register C with the LSB of the string's address at the location of the temporary string work area pointer in HL</div></div>
									<div class="assembly-row-combined"><div>29FC</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the temporary string work area pointer in HL</div></div>
									<div class="assembly-row-combined"><div>29FD</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>We
 want to see if Register Pairr DE points to the last by checking to see 
if the string's VARPTR in DE matches the temporary string work area 
pointer in HL, so we call the COMPARE DE:HL routine at RST 18H.<br><span class="bold">NOTE:</span>  The RST 18H routine The result of the comparison is returned in the status Register as: <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>29FE</div><div>RET NZ <span class="opcode2">C0</span></div><div>If the Z FLAG is set then we are done freeing space, so RETURN</div></div>
									<div class="assembly-row-combined" id="29FFH"><div id="2A00H">29FF-2A01</div><div>LD (40B3H),HL <span class="origrom2">LD (TEMPPT),HL</span>  <span class="opcode2">22 B3 40</span></div><div>Save the value of the temporary string work area pointer in HL.<br>Note: 40B3H-40B4H holds the next available location in the temporary string work area pointer</div></div>
									<div class="assembly-row-combined"><div>2A02</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2A03H">2A03-2A0E - LEVEL II BASIC <span class="code">LEN</span> ROUTINE <span class="origrom">- "LEN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2A03-2A05 <span class="origrom2">LEN</span></div><div>LD BC,27F8H <span class="origrom2">LD BC,SNGFLT</span>  <span class="opcode2">01 F8 27</span></div><div>Load BC with the return address of 27F8H</div></div>
									<div class="assembly-row-combined"><div>2A06</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the return address of 27F8H (in BC) to the STACK</div></div>
									<div class="assembly-row-combined" id="2A07H"><div>2A07-2A09 <span class="origrom2">LEN1</span></div><div><a href="#29D7H" class="memory-link">CALL 29D7H <span class="origrom2">CALL FRESTR</span></a><span class="opcode2">CD D7 29</span></div><div>GOSUB to 29D7H to free up the temporary variable pointed to by FACLO</div></div>
									<div class="assembly-row-combined"><div>2A0A</div><div>XOR A <span class="opcode2">AF</span></div><div>Zero Register A so as to force a numeric flag</div></div>
									<div class="assembly-row-combined"><div>2A0B</div><div>LD D,A <span class="opcode2">57</span></div><div>Zero Register D so that DE can be used when E is set.</div></div>
									<div class="assembly-row-combined"><div>2A0C</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the string's length at the location of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2A0D</div><div>OR A <span class="opcode2">B7</span></div><div>Set the flags according to the string's length in Register A</div></div>
									<div class="assembly-row-combined"><div>2A0E</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2A0FH">2A0F-2A1E - LEVEL II BASIC <span class="code">ASC</span> ROUTINE <span class="origrom">- "ASC"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2A0F-2A11 <span class="origrom2">ASC</span></div><div>LD BC,27F8H <span class="origrom2">LD BC,SNGFLT</span>  <span class="opcode2">01 F8 27</span></div><div>Load BC with the return address of 27F8H</div></div>
									<div class="assembly-row-combined"><div>2A12</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the return address of 27F8H (in BC) to the STACK</div></div>
									<div class="assembly-row-combined" id="2A13H"><div>2A13-2A15 <span class="origrom2">ASC2</span></div><div><a href="#2A07H" class="memory-link">CALL 2A07H <span class="origrom2">CALL LEN1</span></a><span class="opcode2">CD 07 2A</span></div><div>GOSUB to 2A07H (which itself is a GOSUB to 29D7H) to get string's VARPTR into HL and the string's length into Register A</div></div>
									<div class="assembly-row-combined"><div>2A16-2A18</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E4AH" class="memory-link">JP Z,1E4AH <span class="origrom2">JP Z,FCERR</span></a><span class="opcode2">CA 4A 1E</span></div><div>If the Z FLAG is set, then this was a null string (bad argument), so display a <span class="code">?FC ERROR</span></div></div>
									<div class="assembly-row-combined"><div>2A19</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2A1A</div><div>LD E,(HL) <span class="opcode2">5E</span></div><div>Load Register E with the LSB of the address of the string's data at the location of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2A1B</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2A1C</div><div>LD D,(HL) <span class="opcode2">56</span></div><div>Load Register D with the MSB of the address of the string's data at the location of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2A1D</div><div>LD A,(DE) <span class="opcode2">1A</span></div><div>Load Register A with the first character at the location of the string pointer in DE</div></div>
									<div class="assembly-row-combined"><div>2A1E</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2A1FH">2A1F-2A2E - LEVEL II BASIC <span class="code">CHR$</span> ROUTINE <span class="origrom">- "CHR$"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2A1F-2A20 <span class="origrom2">CHR$</span></div><div>LD A,01H <span class="opcode2">3E 01</span></div><div>Load Register A with the length of the string to be created</div></div>
									<div class="assembly-row-combined"><div>2A21-2A23</div><div><a href="#2857H" class="memory-link">CALL 2857H <span class="origrom2">CALL STRINI</span></a><span class="opcode2">CD 57 28</span></div><div>GOSUB to 2857H to save the string's length in Register A and value and set up the string's address</div></div>
									<div class="assembly-row-combined"><div>2A24-2A26</div><div><a href="#2B1FH" class="memory-link">CALL 2B1FH <span class="origrom2">CALL CONINT</span></a><span class="opcode2">CD 1F 2B</span></div><div>GOSUB
 to 2B1FH to evaluate the expression at the location of the current 
BASIC program pointer in HL and return with the integer result in DE</div></div>
									<div class="assembly-row-combined"><div>2A27-2A29 <span class="origrom2">SETSTR</span></div><div>LD HL,(40D4H) <span class="origrom2">LD HL,(DSCTMP+1)</span>  <span class="opcode2">2A D4 40</span></div><div>Load HL with the temporary string's address</div></div>
									<div class="assembly-row-combined"><div>2A2A</div><div>LD (HL),E <span class="opcode2">73</span></div><div>Save the character in Register E at the location of the string pointer in HL</div></div>
									<div class="assembly-row-combined" id="2A2BH"><div>2A2B <span class="origrom2">FINBCK</span></div><div>POP BC <span class="opcode2">C1</span></div><div>Clean up the STACK so that the RETURN address is another one that is next in the STACK.</div></div>
									<div class="assembly-row-combined"><div>2A2C-2A2E</div><div><a href="#2884H" class="memory-link">JP 2884H <span class="origrom2">JP PUTNEW</span></a><span class="opcode2">C3 84 28</span></div><div>Jump to 2884H</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2A2FH">2A2F-2A60 - LEVEL II BASIC <span class="code">STRING$</span> ROUTINE <span class="origrom">- "STRNG$"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2A2FH"><div>2A2F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We have the <span class="code">STRING$</span>
 command, but now we need the next character so we call a RST 10H to 
bump the value of the current BASIC program pointer until it points to 
the next character, call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2A30-2A31</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 28<span class="origrom2">SYNCHK "("</span></a><span class="opcode2">CF 28</span></div><div>Since the character at the location of the current BASIC program pointer in HL must be a <span class="code">(</span> , call the COMPARE SYMBOL routine at RST 08H.<br><br><span class="bold nobottomborder">NOTE:</span>
 The RST 08H routine compares the symbol in the input string pointed to 
by HL Register to the value in the location following the RST 08 call.<ul><li>If
 there is a match, control is returned to the next execution address 
(i.e, the RST 08H instruction + 2) with the next symbol in the A 
Register and HL incremented by one.</li><li>If the two characters do not match, a syntax error message is given and control returns to the Input Phase).</li></ul></div></div>
									<div class="assembly-row-combined"><div>2A32-2A34</div><div><a href="#2B1CH" class="memory-link">CALL 2B1CH <span class="origrom2">CALL GETBYT</span></a><span class="opcode2">CD 1C 2B</span></div><div>This
 will get the string length required (which we will call "N") via a 
GOSUB to 2B1CH to evaluate the expression at the location of the current
 BASIC program pointer in HL and return with the integer result in DE</div></div>
									<div class="assembly-row-combined"><div>2A34</div><div>DEC HL <span class="opcode2">2B</span></div><div>Backspace the code string. This is a Z-80 trick because this code was part of the above call instruction</div></div>
									<div class="assembly-row-combined"><div>2A35</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the string's length ("N") (currently in DE) to the STACK</div></div>
									<div class="assembly-row-combined"><div>2A36-2A37</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08 ‚áí 2C<span class="origrom2">SYNCHK ","</span></a><span class="opcode2">CF 2C</span></div><div>Now we have <span class="code">STRING$(nnn</span> so the next character needs to be a <span class="code">,</span> . To test for the character at the location of the current BASIC program pointer in HL being a <span class="code">,</span>
 , call the COMPARE SYMBOL routine which compares the symbol in the 
input string pointed to by HL Register to the value in the location 
following the RST 08 call. If there is a match, control is returned to 
address of the RST 08 instruction + 2 with the next symbol in the A 
Register and HL incremented by one. If the two characters do not match, a
 syntax error message is given and control returns to the Input Phase)</div></div>
									<div class="assembly-row-combined"><div>2A38-2A3A</div><div><a href="#2337H" class="memory-link">CALL 2337H <span class="origrom2">CALL FRMEVL</span></a><span class="opcode2">CD 37 23</span></div><div>Now we have <span class="code">STRING$(xxx,</span>
 and an expression so GOSUB to 2337H to evaluate the expression at the 
location of the current BASIC program pointer in HL and return with the 
result in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>2A3B-2A3C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 29<span class="origrom2">SYNCHK ")"</span></a><span class="opcode2">CF 29</span></div><div>Now we have <span class="code">STRING$(nnn,X</span> . Since the character at the location of the current BASIC program pointer in HL must be a <span class="code">)</span> , call the COMPARE SYMBOL routine at RST 08H.<br><br><span class="bold nobottomborder">NOTE:</span>
 The RST 08H routine compares the symbol in the input string pointed to 
by HL Register to the value in the location following the RST 08 call.<ul><li>If
 there is a match, control is returned to the next execution address 
(i.e, the RST 08H instruction + 2) with the next symbol in the A 
Register and HL incremented by one.</li><li>If the two characters do not match, a syntax error message is given and control returns to the Input Phase).</li></ul></div></div>
									<div class="assembly-row-combined"><div>2A3D</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>We are now done with getting <span class="code">STRING$(nnn,X)</span> . Next we must exchange the value of the current BASIC program pointer in HL with the string's length ("N") in the STACK</div></div>
									<div class="assembly-row-combined"><div>2A3E</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the string's length ("N") in HL to the STACK so that we can test it to make sure it is an integer</div></div>
									<div class="assembly-row-combined"><div>2A3F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#25D9H" class="memory-link">RST 20H <span class="origrom2">GETYPE</span></a><span class="opcode2">E7</span></div><div>We need to check the value of the current data type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
 The RST 20H routine determines the type of the current value in 
ACCumulator and returns a combination of STATUS flags and unique numeric
 values in the A Register according to the data mode flag (40AFH).  The 
results are returned as follows:<br><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined"><div>2A40-2A41</div><div><a href="#2A47H" class="memory-link">JR Z,2A47H <span class="origrom2">JR Z,STRSTR</span></a><span class="opcode2">28 05</span></div><div>If that test shows "N" is a a STRING, jump to down to 2A47H</div></div>
									<div class="assembly-row-combined"><div>2A42-2A44</div><div><a href="#2B1FH" class="memory-link">CALL 2B1FH <span class="origrom2">CALL CONINT</span></a><span class="opcode2">CD 1F 2B</span></div><div>We
 now know that "N" is at least a number, so we GOSUB to 2B1FH to convert
 the current result in ACCumulator to an integer and return with the 
8-bit result in Register A</div></div>
									<div class="assembly-row-combined"><div>2A45-2A46</div><div><a href="#2A4AH" class="memory-link">JR 2A4AH <span class="origrom2">JR CALSPA</span></a><span class="opcode2">18 03</span></div><div>Skip the next instruction (which would load the string address and 1st character) by jumping to 2A4AH</div></div>
									<div class="assembly-row-combined" id="2A47H"><div>2A47-2A49 <span class="origrom2">STRSTR</span></div><div><a href="#2A13H" class="memory-link">CALL 2A13H <span class="origrom2">CALL ASC2</span></a><span class="opcode2">CD 13 2A</span></div><div>Go get the first character in the string and return with it in Register A. This is the character that will be repeated</div></div>
									<div class="assembly-row-combined" id="2A4AH"><div>2A4A <span class="origrom2">CALSPA</span></div><div>POP DE <span class="opcode2">D1</span></div><div>Get the "N" from the STACK and put it in DE (well, actually, Register E)</div></div>
									<div class="assembly-row-combined"><div>2A4B</div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the character for the string (held in Register A) to the STACK</div></div>
									<div class="assembly-row-combined"><div>2A4C <span class="origrom2">SPACE2</span></div><div>PUSH AF <span class="opcode2">F5</span></div><div>and then save it to the STACK again</div></div>
									<div class="assembly-row-combined"><div>2A4D</div><div>LD A,E <span class="opcode2">7B</span></div><div>Load Register A with "N" (held in Register E)</div></div>
									<div class="assembly-row-combined"><div>2A4E-2A4F</div><div><a href="#2857H" class="memory-link">CALL 2857H <span class="origrom2">CALL STRINI</span></a><span class="opcode2">CD 57 28</span></div><div>GOSUB to 2857H to allocate N bytes in the temporary string work area</div></div>
									<div class="assembly-row-combined"><div>2A51</div><div>LD E,A <span class="opcode2">5F</span></div><div>Load Register E with "N" (held in Register A)</div></div>
									<div class="assembly-row-combined"><div>2A52</div><div>POP AF <span class="opcode2">F1</span></div><div>Get the character for the string ("X") from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>2A53</div><div>INC E <span class="opcode2">1C</span></div><div>To set the status flags we need to increase and then decrease E. First, bump the value of the string's length in Register E</div></div>
									<div class="assembly-row-combined"><div>2A54</div><div>DEC E <span class="opcode2">1D</span></div><div>. and then decrement the string's length in Register E</div></div>
									<div class="assembly-row-combined"><div>2A55-2A56</div><div><a href="#2A2BH" class="memory-link">JR Z,2A2BH <span class="origrom2">JR Z,FINBCK</span></a><span class="opcode2">28 D4</span></div><div>If "N" was zero (so that the string is now complete), jump back to 2A2BH</div></div>
									<div class="assembly-row-combined"><div>2A57-2A59</div><div>LD HL,(40D4H) <span class="origrom2">LD HL,(DSCTMP+1)</span>  <span class="opcode2">2A D4 40</span></div><div>If we are here, we have not finished building the <span class="code">STRING$</span> string so now we load HL with the string's address and get ready to loop</div></div>
									<div class="assembly-row-combined" id="2A5AH"><div>2A5A <span class="origrom2">SPLP$</span></div><div>LD (HL),A <span class="opcode2">77</span></div><div>Save the character in Register A ("X") at the location of the string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2A5B</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2A5C</div><div>DEC E <span class="opcode2">1D</span></div><div>Decrement the string's length in Register E</div></div>
									<div class="assembly-row-combined"><div>2A5D-2A5E</div><div><a href="#2A5AH" class="memory-link">JR NZ,2A5AH</a><span class="opcode2">20 FB</span></div><div>Loop back to 2A5AH to keep filling (HL) until the string of X's has been completed</div></div>
									<div class="assembly-row-combined"><div>2A5F-2A60</div><div><a href="#2A2BH" class="memory-link">JR 2A2BH <span class="origrom2">JR FINBCK</span></a><span class="opcode2">18 CA</span></div><div>Jump back to 2A2BH to put the temp description to finish</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2A61H">2A61-2A90 - LEVEL II BASIC <span class="code">LEFT$(</span> ROUTINE <span class="origrom">- "LEFT$"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>On entry, HL=address of LEFT$$, the STACK = string address, STACK+1 = n, and DE = code string address.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2A61-2A63 <span class="origrom2">LEFT$</span></div><div><a href="#2ADFH" class="memory-link">CALL 2ADFH <span class="origrom2">CALL PREAM</span></a><span class="opcode2">CD DF 2A</span></div><div>Go check the syntax. The character at the location of the current BASIC program pointer in HL must be a <span class="code">)</span></div></div>
									<div class="assembly-row-combined"><div>2A64</div><div>XOR A <span class="opcode2">AF</span></div><div>Zero Register A because the string pointer never changes</div></div>
									<div class="assembly-row-combined" id="2A65H"><div>2A65 <span class="origrom2">LEFT3</span></div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Exchange the value of the current BASIC program pointer in HL with the string's VARPTR to the STACK</div></div>
									<div class="assembly-row-combined"><div>2A66</div><div>LD C,A <span class="opcode2">4F</span></div><div>Zero Register C</div></div>
									<div class="assembly-row-combined"><div>2A67-2A68</div><div>LD A,0E5H <span class="opcode2">3E E5</span></div><div>Z-80 Trick. By adding a 3E at 2A67, it masks out 2A68H if passing through by making the Z-80 think the instruction is <span class="code">LD A,0E5H</span></div></div>
									<div class="assembly-row-combined" id="2A68H"><div>2A68 <span class="origrom2">LEFTUS</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save
 the value of the string's VARPTR in HL to the STACK.  This is actually a
 dummy push to offset for the extra POP command in PUTNEW</div></div>
									<div class="assembly-row-combined"><div>2A69 <span class="origrom2">LEFT2</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the string's VARPTR in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2A6A</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the string's length at the location of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2A6B</div><div>CP B <span class="opcode2">B8</span></div><div>Check
 to see if the new string's length in Register B is greater than the 
string's length in Register A.  If they match, the Z FLAG is set, and 
otherwise the NZ FLAG is set.  If A &lt; the checked value, then the C 
FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined" id="2A70H"><div>2A6C-2A6D</div><div><a href="#2A70H" class="memory-link">JR C,2A70H <span class="origrom2">JR C,ALLSTR</span></a><span class="opcode2">38 02</span></div><div>Jump to 2A70H if the new string's length in Register B is greater than the string's length in Register A</div></div>
									<div class="assembly-row-combined"><div>2A6E</div><div>LD A,B <span class="opcode2">78</span></div><div>Load Register A with the new string's TRUNCATED length in Register B</div></div>
									<div class="assembly-row-combined"><div>2A6F-2A71</div><div>LD DE,000EH <span class="opcode2">11 0E 00</span></div><div>Z-80 Trick. This is a <span class="code">LD DE,000EH</span>
 which is irrelevant and only executed if continuing through. If, 
however, one was to jump to 2A70H instead, a proper opcode would occur</div></div>
									<div class="assembly-row-combined" id="2A70H"><div>2A70-2A7l <span class="origrom2">ALLSTR</span></div><div>LD C,00H <span class="opcode2">0E 00</span></div><div>Since Register C tracks the offset, Zero Register C</div></div>
									<div class="assembly-row-combined"><div>2A72</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the offset in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>2A73-2A75</div><div><a href="#28BFH" class="memory-link">CALL 28BFH <span class="origrom2">CALL GETSPA</span></a><span class="opcode2">CD BF 28</span></div><div>Go see if there is enough string space for the new string</div></div>
									<div class="assembly-row-combined"><div>2A76</div><div>POP BC <span class="opcode2">C1</span></div><div>Get the offset from the STACK and put it in BC</div></div>
									<div class="assembly-row-combined"><div>2A77</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the string's VARPTR from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2A78</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the string's VARPTR in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2A79</div><div>INC HL <span class="opcode2">23</span></div><div>Bump HL to now point to the address of the string</div></div>
									<div class="assembly-row-combined"><div>2A7A</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load Register B with the LSB of the string's address at the location of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2A7B</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2A7C</div><div>LD H,(HL) <span class="opcode2">66</span></div><div>Load Register H with the MSB of the string's address at the location of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2A7D</div><div>LD L,B <span class="opcode2">68</span></div><div>Load Register L with the LSB of the string's address in Register B</div></div>
									<div class="assembly-row-combined"><div>2A7E-2A7F</div><div>LD B,00H <span class="opcode2">06 00</span></div><div>Zero Register B so that BC can be used</div></div>
									<div class="assembly-row-combined"><div>2A80</div><div>ADD HL,BC <span class="opcode2">09</span></div><div>Add the string's length in BC to the string's address in HL</div></div>
									<div class="assembly-row-combined"><div>2A81</div><div>LD B,H <span class="opcode2">44</span></div><div>Load Register B with the MSB of the string's ending address in Register H</div></div>
									<div class="assembly-row-combined"><div>2A82</div><div>LD C,L <span class="opcode2">4D</span></div><div>Load Register C with the LSB of the string's ending address in Register L</div></div>
									<div class="assembly-row-combined"><div>2A83-2A85</div><div><a href="#285AH" class="memory-link">CALL 285AH <span class="origrom2">CALL STRAD2</span></a><span class="opcode2">CD 5A 28</span></div><div>Go save the string's length (held in A) and the string's starting address (held in DE)</div></div>
									<div class="assembly-row-combined"><div>2A86</div><div>LD L,A <span class="opcode2">6F</span></div><div>Load Register L with the string's length (i.e., the number of characters to move) held in Register A</div></div>
									<div class="assembly-row-combined"><div>2A87-2A89</div><div><a href="#29CEH" class="memory-link">CALL 29CEH <span class="origrom2">CALL MOVSTR</span></a><span class="opcode2">CD CE 29</span></div><div>Go move L characers frm BC to DE</div></div>
									<div class="assembly-row-combined"><div>2A8A</div><div>POP DE <span class="opcode2">D1</span></div><div>Clean up the STACK</div></div>
									<div class="assembly-row-combined"><div>2A8B-2A8D</div><div><a href="#29DEH" class="memory-link">CALL 29DEH <span class="origrom2">CALL FRETMP</span></a><span class="opcode2">CD DE 29</span></div><div>Go update the temporary string work area</div></div>
									<div class="assembly-row-combined"><div>2A8E-2A90</div><div><a href="#2884H" class="memory-link">JP 2884H <span class="origrom2">JP PUTNEW</span></a><span class="opcode2">C3 84 28</span></div><div>Jump to 2884H to put the temp variable in the temp list</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2A91H">2A91-2A99 - LEVEL II BASIC RIGHT$ ROUTINE <span class="origrom">- "RIGHT$"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2A91-2A93</div><div><a href="#2ADFH" class="memory-link">CALL 2ADFH <span class="origrom2">CALL PREAM</span></a><span class="opcode2">CD DF 2A</span></div><div>Go check the syntax. The character at the location of the current BASIC program pointer in HL must be a <span class="code">)</span></div></div>
									<div class="assembly-row-combined"><div>2A94</div><div>POP DE <span class="opcode2">D1</span></div><div>Get the string's VARPTR from the STACK and put it in DE</div></div>
									<div class="assembly-row-combined"><div>2A95</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the string's VARPTR in DE to the STACK</div></div>
									<div class="assembly-row-combined"><div>2A96</div><div>LD A,(DE) <span class="opcode2">1A</span></div><div>Load Register A with the string's length (held at the location of the string's VARPTR in DE)</div></div>
									<div class="assembly-row-combined"><div>2A97</div><div>SUB B <span class="opcode2">90</span></div><div>Subtract the new string's length in Register B from the string's length in Register A to isolate the number of bytes</div></div>
									<div class="assembly-row-combined"><div>2A98-2A99</div><div><a href="#2A65H" class="memory-link">JR 2A65H <span class="origrom2">JR LEFT3</span></a><span class="opcode2">18 CB</span></div><div>Jump to the <span class="code">LEFT$(</span> code</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2A9AH">2A9A-2AC4 - LEVEL II BASIC MID$ ROUTINE <span class="origrom">- "MID$"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The original ROM source code clarifies that if the number 
provided is greater than the actual length of the string, a NULL value 
is returned.  If the second number (the number of characters) exceeds 
the end of the string, the maximum amount of available characters are 
returned.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2A9A <span class="origrom2">MID$</span></div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load HL with the value of the current BASIC program pointer (held in DE)</div></div>
									<div class="assembly-row-combined"><div>2A9B</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the terminal character, currently held at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2A9C-2A9E</div><div><a href="#2AE2H" class="memory-link">CALL 2AE2H <span class="origrom2">CALL PREAM2</span></a><span class="opcode2">CD E2 2A</span></div><div>GOSUB to 2AE2H to get the offset in Register B and the string's VARPTR in DE</div></div>
									<div class="assembly-row-combined"><div>2A9F</div><div>INC B <span class="opcode2">04</span></div><div>We
 need to set the status flags to correspond to the offset position value
 so we first bump the value of the string's position in Register B</div></div>
									<div class="assembly-row-combined"><div>2AA0</div><div>DEC B <span class="opcode2">05</span></div><div>... and then we decrement the value of the string's offset position in Register B</div></div>
									<div class="assembly-row-combined"><div>2AA1-2AA3</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E4AH" class="memory-link">JP Z,1E4AH <span class="origrom2">JP Z,FCERR</span></a><span class="opcode2">CA 4A 1E</span></div><div>If the starting position (held in B) is 0, display <span class="code">?FC ERROR</span></div></div>
									<div class="assembly-row-combined"><div>2AA4</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the value of the offset position (held in Register B) to the STACK</div></div>
									<div class="assembly-row-combined"><div>2AA5-2AA6</div><div>LD E,0FFH <span class="opcode2">1E FF</span></div><div>Load Register E with the default string's length of 256 in case no number of bytes are given</div></div>
									<div class="assembly-row-combined"><div>2AA7-2AA8</div><div>CP 29H <span class="origrom2">CP ")"</span>  <span class="opcode2">FE 29</span></div><div>More syntax checking. Here we need to test for a <span class="code">)</span>
 at the location of the current BASIC program pointer.  If they match, 
the Z FLAG is set, and otherwise the NZ FLAG is set.  If A &lt; the 
checked value, then the C FLAG is set.  If A &gt;= the checked value, 
the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2AA9-2AAA</div><div><a href="#2AB0H" class="memory-link">JR Z,2AB0H <span class="origrom2">JR Z,MID2</span></a><span class="opcode2">28 05</span></div><div>Jump to 2AB0H if the character at the location of the current BASIC program pointer in Register A is a <span class="code">)</span></div></div>
									<div class="assembly-row-combined"><div>2AAB-2AAC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 2C<span class="origrom2">SYNCHK ","</span></a><span class="opcode2">CF 2C</span></div><div>If it wasn't a <span class="code">)</span> , it had best be a <span class="code">,</span>
 so we need to test the character at the location of the current BASIC 
program pointer in HL by calling the COMPARE SYMBOL routine at RST 08H.<br><br><span class="bold nobottomborder">NOTE:</span>
 The RST 08H routine compares the symbol in the input string pointed to 
by HL Register to the value in the location following the RST 08 call.<ul><li>If
 there is a match, control is returned to the next execution address 
(i.e, the RST 08H instruction + 2) with the next symbol in the A 
Register and HL incremented by one.</li><li>If the two characters do not match, a syntax error message is given and control returns to the Input Phase).</li></ul></div></div>
									<div class="assembly-row-combined"><div>2AAD-2AAF</div><div><a href="#2B1CH" class="memory-link">CALL 2B1CH <span class="origrom2">CALL GETBYT</span></a><span class="opcode2">CD 1C 2B</span></div><div>Go
 evaluate the expression at the location of the current BASIC program 
pointer in HL and return with the integer result in DE. Now the byte 
count is in DE as an integer</div></div>
									<div class="assembly-row-combined"><div>2AB0-2AB1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 29<span class="origrom2">SYNCHK ")"</span></a><span class="opcode2">CD 29</span></div><div>Since the character at the location of the current BASIC program pointer in HL must be a <span class="code">)</span> , call the COMPARE SYMBOL routine at RST 08H.<br><br><span class="bold nobottomborder">NOTE:</span>
 The RST 08H routine compares the symbol in the input string pointed to 
by HL Register to the value in the location following the RST 08 call.<ul><li>If
 there is a match, control is returned to the next execution address 
(i.e, the RST 08H instruction + 2) with the next symbol in the A 
Register and HL incremented by one.</li><li>If the two characters do not match, a syntax error message is given and control returns to the Input Phase).</li></ul></div></div>
									<div class="assembly-row-combined"><div>2AB2</div><div>POP AF <span class="opcode2">F1</span></div><div>Get the offset from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>2AB3</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Exchange the value of the current BASIC program pointer in HL with the value of the string's VARPTR to the STACK</div></div>
									<div class="assembly-row-combined" id="2A69H"><div>2AB4-2AB6</div><div>LD BC,2A69H <span class="origrom2">LD BC,LEFT2</span>  <span class="opcode2">01 69 2A</span></div><div>Load BC with 2A69H as the return address (which is in the <span class="code">LEFT$</span> routine)</div></div>
									<div class="assembly-row-combined"><div>2AB7</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the return address in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>2AB8</div><div>DEC A <span class="opcode2">3D</span></div><div>Decrement the value of the requested offset in Register A so that we have a starting position minus 1</div></div>
									<div class="assembly-row-combined"><div>2AB9</div><div>CP (HL) <span class="opcode2">BE</span></div><div>Compare
 the string's length at the location of the string's VARPTR in HL with 
the value of the offset in Register A.  If they match, the Z FLAG is 
set, and otherwise the NZ FLAG is set.  If A &lt; the checked value, 
then the C FLAG is set.  If A &gt;= the checked value, the NC FLAG is 
set.</div></div>
									<div class="assembly-row-combined"><div>2ABA-2ABB</div><div>LD B,00H <span class="opcode2">06 00</span></div><div>Zero Register B</div></div>
									<div class="assembly-row-combined"><div>2ABC</div><div>RET NC <span class="opcode2">D0</span></div><div>If the offset pointer ispast the end of the string we are going to return a null</div></div>
									<div class="assembly-row-combined" id="2ABDH"><div>2ABD</div><div>LD C,A <span class="opcode2">4F</span></div><div>Load Register C with the offset in Register A</div></div>
									<div class="assembly-row-combined"><div>2ABE</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the string's length at the location of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2ABF</div><div>SUB C <span class="opcode2">91</span></div><div>Subtract the index (the second argument) in Register C from the string's length in Register A</div></div>
									<div class="assembly-row-combined"><div>2AC0</div><div>CP E <span class="opcode2">BB</span></div><div>Compare
 the new string's length in Register E with the adjusted string's length
 in Register A to see if we are going to truncate.  If they match, the Z
 FLAG is set, and otherwise the NZ FLAG is set.  If A &lt; the checked 
value, then the C FLAG is set.  If A &gt;= the checked value, the NC 
FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2AC1</div><div>LD B,A <span class="opcode2">47</span></div><div>Load Register B with the calculated string's length in Register A</div></div>
									<div class="assembly-row-combined"><div>2AC2</div><div>RET C <span class="opcode2">D8</span></div><div>If we are not going to truncate, then just use the partial string we already have and Return to 2A69H</div></div>
									<div class="assembly-row-combined" id="2AC3H"><div>2AC3</div><div>LD B,E <span class="opcode2">43</span></div><div>Load Register B with the new string's truncated length in Register E</div></div>
									<div class="assembly-row-combined"><div>2AC4</div><div>RET <span class="opcode2">C9</span></div><div>Return to 2A69H aka LEFT2</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2A2FH">2AC5-2ADE - LEVEL II BASIC <span class="code">VAL</span> ROUTINE <span class="origrom">- "VAL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2AC5-2AC7 <span class="origrom2">VAL</span></div><div><a href="#2A07H" class="memory-link">CALL 2A07H <span class="origrom2">CALL LEN1</span></a><span class="opcode2">CD 07 2A</span></div><div>Go get the string's length in Register A and the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2AC8-2ACA</div><div><a href="#27F8H" class="memory-link">JP Z,27F8H <span class="origrom2">JP Z,SNGFLT</span></a><span class="opcode2">CA F8 27</span></div><div>Jump to 27F8H if the string's length in Register A is equal to zero</div></div>
									<div class="assembly-row-combined"><div>2ACB</div><div>LD E,A <span class="opcode2">5F</span></div><div>Load Register E with the string's length at the location of the string's VARPTR in HL.</div></div>
									<p class="debug-note">The original ROM source explains that we 
need to do some fancy footwork here to handle the case where the two 
strings are stored next to each other.</p>
									<div class="assembly-row-combined"><div>2ACC</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2ACD</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the LSB of the string's address at the location of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2ACE</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2ACF</div><div>LD H,(HL) <span class="opcode2">66</span></div><div>Load Register H with the MSB of the string's address at the location of the string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2AD0</div><div>LD L,A <span class="opcode2">6F</span></div><div>Load Register L with the LSB of the string's address in Register A</div></div>
									<div class="assembly-row-combined"><div>2AD1</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the string's address in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2AD2</div><div>ADD HL,DE <span class="opcode2">19</span></div><div>Add the string's length in DE to the string's address in HL</div></div>
									<div class="assembly-row-combined"><div>2AD3</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load Register B with the last character of the string at the location of the string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2AD4</div><div>LD (HL),D <span class="opcode2">72</span></div><div>Save the zero in Register D at the location of the string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2AD5</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Exchange the string's ending address in HL with the string's address to the STACK</div></div>
									<div class="assembly-row-combined"><div>2AD6</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the last character of the string in Register B to the STACK</div></div>
									<div class="assembly-row-combined"><div>2AD7</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the first character of the argument</div></div>
									<div class="assembly-row-combined"><div>2AD8-2ADA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0E65H" class="memory-link">CALL 0E65H <span class="origrom2">CALL FINDBL</span></a><span class="opcode2">CD 65 0E</span></div><div>Call
 the ASCII TO DOUBLE routine at 0E65H (which converts the ASCII string 
pointed to by HL to its double precision equivalent; with output left in
 ACCumulator)</div></div>
									<div class="assembly-row-combined"><div>2ADB</div><div>POP BC <span class="opcode2">C1</span></div><div>Get the modified character of the next string into Register B</div></div>
									<div class="assembly-row-combined"><div>2ADC</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the pointer to the modified character back into HL</div></div>
									<div class="assembly-row-combined"><div>2ADD</div><div>LD (HL),B <span class="opcode2">70</span></div><div>Restore the character.</div></div>
									<div class="assembly-row-combined"><div>2ADE</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2ADFH">2ADF-2A6 - STRING ROUTINE <span class="origrom">- "PREAM"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is called by <span class="code">LEFT$</span> , <span class="code">MID$</span> , and <span class="code">RIGHT$</span>
 to test for the ending ")" character. On entry, the STACK has the 
string address, byte count, and return address. On exit the STACK has 
the string address, DE and B each have the byte count.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2ADFH"><div>2ADF <span class="origrom2">PREAM</span></div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load HL with the value of the current BASIC program pointer in DE</div></div>
									<div class="assembly-row-combined"><div>2AE0-2AE1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 29<span class="origrom2">SYNCHK ")"</span></a><span class="opcode2">CF 29</span></div><div>Since the character at the location of the current BASIC program pointer in HL must be a <span class="code">)</span> , call the COMPARE SYMBOL routine at RST 08H.<br><br><span class="bold nobottomborder">NOTE:</span>
 The RST 08H routine compares the symbol in the input string pointed to 
by HL Register to the value in the location following the RST 08 call.<ul><li>If
 there is a match, control is returned to the next execution address 
(i.e, the RST 08H instruction + 2) with the next symbol in the A 
Register and HL incremented by one.</li><li>If the two characters do not match, a syntax error message is given and control returns to the Input Phase).</li></ul></div></div>
									<div class="assembly-row-combined" id="2AE2H"><div>2AE2 <span class="origrom2">PREAM2</span></div><div>POP BC <span class="opcode2">C1</span></div><div>Get the return address from the STACK and put it in BC</div></div>
									<div class="assembly-row-combined"><div>2AE3</div><div>POP DE <span class="opcode2">D1</span></div><div>Get the number of bytes to isolate from the string (from the STACK) and put it in DE</div></div>
									<div class="assembly-row-combined"><div>2AE4</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the return address in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>2AE5</div><div>LD B,E <span class="opcode2">43</span></div><div>Load Register B with the number of bytes in Register E</div></div>
									<div class="assembly-row-combined"><div>2AE6</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2AE7H">2AE7H-2AEE - Process a LEFT-HAND-SIDE MID$ <span class="origrom">- "ISMID$"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2AE7H"><div>2AE7-2AE8 <span class="origrom2">ISMID$</span></div><div>CP 7AH <span class="origrom2">CP MIDTK-$END</span>  <span class="opcode2">FE 7A</span></div><div>This
 routine is designed to handle a left-size MID$ call.  So check to see 
if the character at the location of the current BASIC program pointer in
 Register A is trying to process a left hand side MID$.  If they match, 
the Z FLAG is set, and otherwise the NZ FLAG is set.  If A &lt; the 
checked value, then the C FLAG is set.  If A &gt;= the checked value, 
the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2AE9-2AEB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1997H" class="memory-link">JP NZ,1997H <span class="origrom2">JP NZ,SNERR</span></a><span class="opcode2">C2 97 19</span></div><div>Display a <span class="code">?SN ERROR</span> message if that is not what is going on.</div></div>
									<div class="assembly-row-combined"><div>2AEC-2AEE</div><div>JP 41D9H <span class="origrom2">JP DLHSMD</span><span class="opcode2">C3 D9 41</span></div><div>JUMP to DOS to see if DOS wants to deal with this.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2AEFH">2AEF-2AF7 - LEVEL II BASIC <span class="code">INP</span> ROUTINE <span class="origrom">- "FNINP"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2AEF-2AF1 <span class="origrom2">FNINP</span><p></p></div><div><a href="#2B1FH" class="memory-link">CALL 2B1FH <span class="origrom2">CALL CONINT</span></a><span class="opcode2">CD 1F 2B</span></div><div>Go
 evaluate the expression at the location of the current BASIC program 
pointer in HL and return with the port number in Register A</div></div>
									<div class="assembly-row-combined"><div>2AF2-2AF4</div><div>LD (4094H),A <span class="origrom2">LD (STAINP+1),A</span>  <span class="opcode2">32 94 40</span></div><div>Save the value of the port number (from Register A) into 4094H, which is in the middle of a routine.</div></div>
									<div class="assembly-row-combined"><div>2AF5-2AF1</div><div>CALL 4093H <span class="origrom2">CALL STAINP</span>  <span class="opcode2">CD 1F 2B</span></div><div>Perform in INP on the channel held in Register A</div></div>
									<div class="assembly-row-combined"><div>2AF8-2AFA</div><div><a href="#27F8H" class="memory-link">JP 27F8H <span class="origrom2">JP SNGFLT</span></a><span class="opcode2">C3 F8 27</span></div><div>Evaluate the results and return them</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2AFBH">2AFB-2B00 - LEVEL II BASIC <span class="code">OUT</span> ROUTINE <span class="origrom">- "FNOUT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2AFB-2AFD <span class="origrom2">FNOUT</span><p></p></div><div><a href="#2B0EH" class="memory-link">CALL 2B0EH <span class="origrom2">CALL SETIO</span></a><span class="opcode2">CD 0E 2B</span></div><div>Get the I/O Port Ready</div></div>
									<div class="assembly-row-combined" id="2B00H"><div>2AFE-2B00</div><div>JP 4096H <span class="origrom2">JP OUTWRD</span><span class="opcode2">CD 0E 2B</span></div><div>Do the OUT and RETurn</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2B01H">2B01-2B0D - EVALUATE EXPRESSION ROUTINE <span class="origrom2">- "GETINT"</span><br>This evaluates an expression and leaves the result in DE as an integer.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2B01 <span class="origrom2">GETINT</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined" id="2B02H"><div>2B02-2B04 <span class="origrom2">GETIN2</span></div><div><a href="#2337H" class="memory-link">CALL 2337H <span class="origrom2">CALL FRMEVL</span></a><span class="opcode2">CD 37 23</span></div><div>Go evaluate the expression at the location of the current BASIC program pointer in HL and return with the result in ACCumulator</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2B05H">2B05 - This routine
 takes the value from the ACC, converts it to an integer value and 
places the result in the DE Register Pair. The Z flag will be set if the
 result in DE is smaller than or equal to 255 (FFH). (DE = INT (ACC)).<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2B05H"><div>2B05 <span class="origrom2">INTFR2</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2B06-2B08</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A7FH" class="memory-link">CALL 0A7FH <span class="origrom2">CALL FRCINT</span></a><span class="opcode2">CD 7F 0A</span></div><div>Call
 the CONVERT TO INTEGER routine at 0A7FH (where the contents of 
ACCumulator are converted from single or double precision to integer and
 deposited into HL)</div></div>
									<div class="assembly-row-combined"><div>2B09</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load DE with the integer result in HL</div></div>
									<div class="assembly-row-combined"><div>2B0A</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the current BASIC program pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2B0B</div><div>LD A,D <span class="opcode2">7A</span></div><div>Load Register A with the MSB of the integer result in Register D</div></div>
									<div class="assembly-row-combined"><div>2B0C</div><div>OR A <span class="opcode2">B7</span></div><div>Test the value of the MSB in Register A</div></div>
									<div class="assembly-row-combined"><div>2B0D</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2B0EH">2B0E-2B16 - EVALUATE EXPRESSION ROUTINE - <span class="code">OUT</span> continues here <span class="origrom">- "SETIO"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2B0EH"><div>2B0E-2B10 <span class="origrom2">SETIO</span></div><div><a href="#2B1CH" class="memory-link">CALL 2B1CH <span class="origrom2">CALL GETBYT</span></a><span class="opcode2">CD 1C 2B</span></div><div>GOSUB
 to 2B1CH to evaluate the expression at the location of the current 
BASIC program pointer in HL and return with the 8-bit value in Register A</div></div>
									<div class="assembly-row-combined"><div>2B11-2B13</div><div>LD (4094H),A <span class="origrom2">LD (STAINP+1),A</span>  <span class="opcode2">32 94 40</span></div><div>Save the 8-bit value in Register A in the DOS address of 4094H to set up for WAIT</div></div>
									<div class="assembly-row-combined"><div>2B14-2B16</div><div>LD (4097H),A <span class="origrom2">LD (OUTWRD+1),A</span>  <span class="opcode2">32 97 40</span></div><div>Save the 8-bit value in Register A in the DOS address of 4097H to set up for OUT</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2Bl7H">2B17-2B1A - CHECK SYNTAX ROUTINE - This checks to see if the next character is a <span class="code">"</span> and contnues on to 2B1CH if it is, and errors out if it isn't.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2B17-2B18</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 2E<span class="origrom2">SYNCHK ","</span></a><span class="opcode2">CF 2E</span></div><div>Since
 the character at the location of the current BASIC program pointer in 
HL must be a ",", call the COMPARE SYMBOL routine at RST 08H.<br><br><span class="bold nobottomborder">NOTE:</span>
 The RST 08H routine compares the symbol in the input string pointed to 
by HL Register to the value in the location following the RST 08 call.<ul><li>If
 there is a match, control is returned to the next execution address 
(i.e, the RST 08H instruction + 2) with the next symbol in the A 
Register and HL incremented by one.</li><li>If the two characters do not match, a syntax error message is given and control returns to the Input Phase).</li></ul></div></div>
									<div class="assembly-row-combined"><div>2B19-2B1A</div><div><a href="#2B1CH" class="memory-link">JR 2B1CH <span class="origrom2">JR GETBYT</span></a><span class="opcode2">18 01</span></div><div>Jump forward to 2B1CH</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2BlBH">2B1B-2B28 - EVALUATE EXPRESSION ROUTINE - This is called by <span class="code">PRINT TAB</span>  <span class="origrom">- "GTBYTC"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2B1B <span class="origrom2">GTBYTC</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2B1CH">2B1C - Common Conversion Routine <span class="origrom">- "GETBYT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine converts a numeric ASCII string pointed to by 
the HL into a hexadecimal value and places the result in the A register.
 If the result is larger than 255 (FFH) then an FC ERROR (Illegal 
function call) will be generated. After execution the HL will point to 
the delimiter. If the delimiter is a zero byte or a colon (3AH) then the
 Z flag will be set. Any other delimiter will cause the Z flag to be 
reset.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2B1C-2B1E <span class="origrom2">GETBYT</span></div><div><a href="#2337H" class="memory-link">CALL 2337H <span class="origrom2">CALL FRMEVL</span></a><span class="opcode2">CD 37 23</span></div><div>GOSUB
 to 2337H to evaluate the formula/expression at the location of the 
current BASIC program pointer in HL and return with the result in REG l</div></div>
									<div class="assembly-row-combined"><div>2B1F-2B21 <span class="origrom2">CONINT</span></div><div><a href="#2B05H" class="memory-link">CALL 2B05H <span class="origrom2">CALL INTFR2</span></a><span class="opcode2">CD 05 2B</span></div><div>GOSUB
 to 2B05H to convert the result in ACCumulator to an integer and return 
with the integer result in DE.  Flags are set based on Register D.</div></div>
									<div class="assembly-row-combined"><div>2B22-2B24</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E4AH" class="memory-link">JP NZ,1E4AH <span class="origrom2">JP NZ,FCERR</span></a><span class="opcode2">C2 4A 1E</span></div><div>If the result is greater than 255, display a <span class="code">?FC ERROR</span> message</div></div>
									<div class="assembly-row-combined"><div>2B25</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2B26</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2B27</div><div>LD A,E <span class="opcode2">7B</span></div><div>Load Register A with the 8-bit result in Register E so that both A and E have the result.</div></div>
									<div class="assembly-row-combined"><div>2B28</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2B29H">2B29-2B2D - LEVEL II BASIC <span class="code">LLIST</span> ROUTINE <span class="origrom">- "LLIST"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine sets the output device flag to PRINTER and then flows through to the <span class="code">LIST</span> command.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2B29-2B2A <span class="origrom2">LLIST</span></div><div>LD A,01H <span class="opcode2">3E 01</span></div><div>Load Register A with the printer output device code</div></div>
									<div class="assembly-row-combined"><div>2B2B-2B2D</div><div>LD (409CH),A <span class="origrom2">LD (PRTFLG),A</span>  <span class="opcode2">32 9C 40</span></div><div>Save the value in Register A as the current output device flag.<br>Note: 409CH holds the current output device flag: -1=cassette, 0=video and 1=printer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2B2EH">2B2E-2B74 - LEVEL II BASIC <span class="code">LIST</span> ROUTINE <span class="origrom">- "LIST"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>On entry the STACK has the return address, then the first 
basic line number to be listed, then the last basic line number to be 
listed.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2B2E <span class="origrom2">LIST</span></div><div>POP BC <span class="opcode2">C1</span></div><div>Get rid of the the return address on the STACK</div></div>
									<div class="assembly-row-combined"><div>2B2F-2B31</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1B10H" class="memory-link">CALL 1B10H <span class="origrom2">CALL SCNLIN</span></a><span class="opcode2">CD 10 1B</span></div><div>Go evaluate the range of line numbers given at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2B32</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the address of the first BASIC line (held in BC) to the STACK</div></div>
									<div class="assembly-row-combined" id="2B33H"><div>2B33-2B35 <span class="origrom2">LIST4</span></div><div>LD HL,FFFFH <span class="opcode2">21 FF FF</span></div><div>Load HL with a -1. This is because the below loop starts with a INC HL, so as to turn the first line number into 0</div></div>
									<div class="assembly-row-combined"><div>2B36-2B38</div><div>LD (40A2H),HL <span class="origrom2">LD (CURLIN),HL</span>  <span class="opcode2">22 A2 40</span></div><div>Save the value in HL as the current BASIC line number (which is stored at 40A2H-40A3H).</div></div>
									<div class="assembly-row-combined"><div>2B39</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the address of the first BASIC line to be listed (from the STACK) and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2B3A</div><div>POP DE <span class="opcode2">D1</span></div><div>Get the value of the last BASIC line number to be listed (from the STACK) and put it in DE</div></div>
									<div class="assembly-row-combined"><div>2B3B</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Load Register C with the LSB of the next BASIC line pointer at the location of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2B3C</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2B3D</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load Register B with the MSB of the next BASIC line pointer at the location of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2B3E</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2B3F</div><div>LD A,B <span class="opcode2">78</span></div><div>Load Register A with the MSB of the next BASIC line pointer in Register B</div></div>
									<div class="assembly-row-combined"><div>2B40</div><div>OR C <span class="opcode2">B1</span></div><div>Combine
 the LSB of the next BASIC line pointer in Register C with the MSB of 
the next BASIC line pointer in Register A. This will let us test for the
 end of the BASIC program</div></div>
									<div class="assembly-row-combined"><div>2B41-2B43</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1A19H" class="memory-link">JP Z,1A19H <span class="origrom2">JP Z,READY</span></a><span class="opcode2">CA 19 1A</span></div><div>If we are at the elast line, then STOP and JUMP to 1A19H to the READY PROMPT.</div></div>
									<div class="assembly-row-combined"><div>2B44-2B46</div><div>CALL 41DFH <span class="origrom2">CALL EXCHDS</span><span class="opcode2">CD DF 41</span></div><div>GOSUB to DOS to see if DOS wants to do anything here.</div></div>
									<div class="assembly-row-combined"><div>2B47-2B49</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D9BH" class="memory-link">CALL 1D9BH <span class="origrom2">CALL ISCNTC</span></a><span class="opcode2">CD 9B 1D</span></div><div>Go scan the keyboard to see if the <kbd>BREAK</kbd> key or the <span class="code">shift</span> - <span class="code">@</span> key was pressed</div></div>
									<div class="assembly-row-combined"><div>2B4A</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the address of the next BASIC line in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>2B4B</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>We
 now want to push the line number, but we have to load BC with it first.
  Load Register C with the LSB of the BASIC line number at the location 
of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2B4C</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2B4D</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load Register B with the MSB of the BASIC line number at the location of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2B4E</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2B4F</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the BASIC line number in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>2B50</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Swap (SP) and HL so that the line number is now in HL</div></div>
									<div class="assembly-row-combined"><div>2B51</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap DE and HL so that the last BASIC line number is now in HL</div></div>
									<div class="assembly-row-combined"><div>2B52</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>We
 need to see if we are outside the last number in the specified range so
 compare the BASIC line number in DE with the last BASIC line number in 
HL, so we call the COMPARE DE:HL routine at RST 10H.<br><br>The RST 10H 
routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2B53</div><div>POP BC <span class="opcode2">C1</span></div><div>Get the pointer to the location on the BASIC program line being processed and put it in BC</div></div>
									<div class="assembly-row-combined"><div>2B54-2B56</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1A18H" class="memory-link">JP C,1A18H <span class="origrom2">JP C,STPRDY</span></a><span class="opcode2">DA 18 1A</span></div><div>If
 the BASIC line number in DE is greater than the last BASIC line number 
in HL then we have gone past the end, so we are done processing!</div></div>
									<div class="assembly-row-combined"><div>2B57</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Swap (SP) and HL so that the last BASIC line number is now on the STACK</div></div>
									<div class="assembly-row-combined"><div>2B58</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the address of the next BASIC line in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2B59</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the pointer to the location on the BASIC program line being processed to the STACK</div></div>
									<div class="assembly-row-combined"><div>2B5A</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load HL with the BASIC line number (from DE)</div></div>
									<div class="assembly-row-combined"><div>2B5B-2B5D</div><div>LD (40ECH),HL <span class="origrom2">LD (DOT),HL</span>  <span class="opcode2">22 EC 40</span></div><div>Save the BASIC line number in HL into DOT for use later in EDIT or LIST.<br>Note: 40ECH-40EDH holds EDIT line number</div></div>
									<div class="assembly-row-combined"><div>2B5E-2B60</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0FAFH" class="memory-link">CALL 0FAFH <span class="origrom2">CALL LINPRT</span></a><span class="opcode2">CD AF 0F</span></div><div>Call
 the HL TO ASCII routine at 0FAFH (which converts the value in the HL 
(assumed to be an integer) to ASCII and display it at the current cursor
 position on the video screen) to display the current BASIC line number</div></div>
									<div class="assembly-row-combined"><div>2B61-2B62</div><div>LD A,20H <span class="opcode2">3E 20</span></div><div>Load Register A with a space</div></div>
									<div class="assembly-row-combined"><div>2B63</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the memory pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2B64-2B66</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go send the space in Register A to the current output device</div></div>
									<div class="assembly-row-combined"><div>2B67-2B69</div><div><a href="#2B7EH" class="memory-link">CALL 2B7EH <span class="origrom2">CALL BUFLIN</span></a><span class="opcode2">CD 7E 2B</span></div><div>GOSUB
 to 2B7EH move the BASIC line at the location of the memory pointer in 
HL into the input buffer and untokenize the BASIC line</div></div>
									<div class="assembly-row-combined"><div>2B6A-2B6C</div><div>LD HL,(40A7H) <span class="origrom2">LD HL,(BUFPNT)</span>  <span class="opcode2">2A A7 40</span></div><div>Load HL with the starting address of the input buffer.<br>Note: 40A7H-40A8H holds the input Buffer pointer</div></div>
									<div class="assembly-row-combined"><div>2B6D-2B6F</div><div><a href="#2B75H" class="memory-link">CALL 2B75H <span class="origrom2">CALL LISPRT</span></a><span class="opcode2">CD 75 2B</span></div><div>Since
 we need to send the BASIC line in the input buffer to the current 
output device we call the PRINT MESSAGE routine at 2B75H which writes 
string pointed to by HL to the current output device</div></div>
									<div class="assembly-row-combined"><div>2B70-2B72</div><div><a href="#20FEH" class="memory-link">CALL 20FEH <span class="origrom2">CALL CRDO</span></a><span class="opcode2">CD FE 20</span></div><div>Go send a carriage return to the current output device</div></div>
									<div class="assembly-row-combined"><div>2B73-2B74</div><div><a href="#2B33H" class="memory-link">JR 2B33H <span class="origrom2">JR LIST4</span></a><span class="opcode2">18 BE</span></div><div>Loop back to 2B33H until the listing is complete</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2B75H">2B75-2B7D - DISPLAY MESSAGE ROUTINE <span class="origrom">- "LISPRT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the PRINT MESSAGE routine which writes string pointed
 to by HL to the current output device. String must be terminated by a 
byte of zeros. This call is different from 28A7H because it does not use
 the literal string pool area, but it does use the same display routine 
and it takes the same DOS Exit at 41C1H. Uses all registers. This 
routine can be called without loading the BASIC utility, if a C9H (RET) 
is stored in 41C1H.<br><br>This routine outputs a string to device 
indicated by device type flag stored at 409CH. String must end with zero
 byte. On entry, HL registers must point to address of start of string. 
Calls routine at 032AH.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2B75H"><div>2B75 <span class="origrom">"LISPRT"</span><p></p></div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2B76</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if the character in Register A is an end of the string character (00H)</div></div>
									<div class="assembly-row-combined"><div>2B77</div><div>RET Z <span class="opcode2">C8</span></div><div>Return if the character in Register A is an end of the string character</div></div>
									<div class="assembly-row-combined" id="2B78H"><div>2B78-2B7A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go send the character in Register A to the current output device</div></div>
									<div class="assembly-row-combined"><div>2B7B</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2B7C-2B7D</div><div><a href="#2B75H" class="memory-link">JR 2B75H <span class="origrom2">JR LISPRT</span></a><span class="opcode2">18 F7</span></div><div>Loop back to 2B75H until all of the characters have been sent to the current output device</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2B7EH">2B7E-2BC5 - UNTOKENIZE ROUTINE <span class="origrom">- "BUFLIN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine is called by <span class="code">LIST</span> and <span class="code">EDIT</span> . It moves the line pointed to by HL to the input buffer area and then expands each token into the appropriate key word.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2B7EH"><div>2B7E <span class="origrom2">BUFLIN</span><p></p></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the BASIC line pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2B7F-2B81</div><div>LD HL,(40A7H) <span class="origrom2">LD HL,(BUFPNT)</span>  <span class="opcode2">2A A7 40</span></div><div>Load HL with the starting address of the input buffer.<br>Note: 40A7H-40A8H holds the input Buffer pointer</div></div>
									<div class="assembly-row-combined"><div>2B82<br>2B83</div><div>LD B,H<br>LD C,L <span class="opcode2">44</span></div><div>LET Register Pair BC = Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>2B84</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the BASIC line pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2B85-2B86</div><div>LD D,FFH <span class="origrom2">LD D,BUFLEN</span>  <span class="opcode2">16 FF</span></div><div>Load Register D with the maximum length of an untokenized line</div></div>
									<div class="assembly-row-combined"><div>2B87-2B88</div><div><a href="#2B8CH" class="memory-link">JR 2B8CH <span class="origrom2">JR PLOOP2</span></a><span class="opcode2">18 03</span></div><div>Jump forward to 2B8CH into the middle of the move/expand code</div></div>
									<div class="assembly-row-combined" id="2B89H"><div>2B89 <span class="origrom2">PLOOP</span></div><div>INC BC <span class="opcode2">03</span></div><div>Top of a loop.  Bump the value of the input buffer pointer in BC</div></div>
									<div class="assembly-row-combined"><div>2B8A</div><div>DEC D <span class="opcode2">15</span></div><div>Decrement the character count in Register D</div></div>
									<div class="assembly-row-combined"><div>2B8B</div><div>RET Z <span class="opcode2">C8</span></div><div>Return if 256 characters have been moved into the input buffer</div></div>
									<div class="assembly-row-combined" id="2B8CH"><div>2B8C <span class="origrom2">PLOOP2</span></div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the BASIC line pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2B8D</div><div>OR A <span class="opcode2">B7</span></div><div>Set
 the status flags to enable us to check to see if the character in 
Register A is a reserved word (in which case the P FLAG will be set) or 
an end of the BASIC line character (in which case the Z FLAG will be 
set)</div></div>
									<div class="assembly-row-combined"><div>2B8E</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the BASIC line pointer in HL to the next character in the code string</div></div>
									<div class="assembly-row-combined"><div>2B8F</div><div>LD (BC),A <span class="opcode2">02</span></div><div>Save
 the character at the location of the input buffer pointer (held in 
Register A)to the memory location held by BC.  If the character was a 
00H terminator, then the terminator will also be copied.</div></div>
									<div class="assembly-row-combined"><div>2B90</div><div>RET Z <span class="opcode2">C8</span></div><div>Return if the character in Register A is an end of the BASIC line character</div></div>
									<div class="assembly-row-combined" id="2B91H"><div>2B91-2B93</div><div><a href="#2B89H" class="memory-link">JP P,2B89H <span class="origrom2">JP P,PLOOP</span></a><span class="opcode2">F2 89 2B</span></div><div>If the character in A is just a regular character (i.e., not a token), then JUMP back to 2B89H</div></div>
									<div class="assembly-row-combined"><div>2B94-2B95</div><div>CP 0FBH <span class="origrom2">CP SNGQTK</span>  <span class="opcode2">FE FB</span></div><div>Check to see if the character in Register A is a <span class="code">'</span>
 token.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2B96-2B97</div><div><a href="#2BA0H" class="memory-link">JR NZ,2BA0H <span class="origrom2">JR NZ,NTQTTK</span></a><span class="opcode2">20 08</span></div><div>Jump forward to 2BA0H if the character in Register A isn't a <span class="code">'</span> token</div></div>
									<p class="debug-note">This is where the infamous ROM bug which can crash Level II sits.  It assumes that a <span class="code">'</span> has room to move backwards 4 characters, which it might not!</p>
									<div class="assembly-row-combined"><div>2B98-2B9B</div><div>DEC BC<br>DEC BC<br>DEC BC<br>DEC BC <span class="opcode2">0B</span></div><div>First,
 backspace 4 characters to compensat for ":REM" which is otherwise 
hidden from the user's view.  Decrement the value of the input buffer 
pointer in BC</div></div>
									<div class="assembly-row-combined"><div>2B9C-2B9F</div><div>INC D<br>INC D<br>INC D<br>INC D <span class="opcode2">14</span></div><div>Then, bump the value of the character counter in Register D 4 times</div></div>
									<p class="debug-note">A REM isn't the only TOKEN with a hidden add-on.  ELSE also has a hidden colon in front of it.  So let's now deal with that.</p>
									<div class="assembly-row-combined" id="2BA0H"><div>2BA0-2BA1 <span class="origrom2">NRQTTK</span></div><div>CP 95H <span class="origrom2">CP $ELSE</span>  <span class="opcode2">FE 95</span></div><div>Check to see if the character in Register A is an <span class="code">ELSE</span>
 token.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is 
set.  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= 
the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2BA2-2BA4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0B24H" class="memory-link">CALL Z,0B24H <span class="origrom2">CALL Z,DCXVBRT</span></a><span class="opcode2">CC 24 0B</span></div><div>If it was an <span class="code">ELSE</span>
 we need to backspace the expanded buffer pointer to NOT print the 
hidden ":".  To do this, go back to 0B24H to decrement the value of the 
input buffer pointer if the character in Register A is an ELSE token</div></div>
									<div class="assembly-row-combined" id="2BA4H"><div>2BA4</div><div>DEC BC <span class="opcode2">0B</span></div><div>This
 is NOT executed in the regular process of the ROM.  This is a 
mid-instruction jump point from DOS BASIC if the DOS routine which 
analyzes the INPUT command determines that the routine which called the 
DOS VECTOR was &gt; the location in ROM for the LIST command</div></div>
									<div class="assembly-row-combined"><div>2BA5-2BA6</div><div>SUB 7FH <span class="opcode2">D6 7F</span></div><div>Next,
 we need to get rid of the SIGN BIT and add one, so subtract 7F to get 
the number of the entry we are looking for in token list</div></div>
									<div class="assembly-row-combined"><div>2BA7</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the BASIC line pointer in HL to the STACK.  Register L holds the reserved word number at this point.</div></div>
									<div class="assembly-row-combined"><div>2BA8</div><div>LD E,A <span class="opcode2">5F</span></div><div>Load Register E with the character in Register A</div></div>
									<div class="assembly-row-combined"><div>2BA9-2BAB</div><div>LD HL,1650H <span class="origrom2">LD HL,RESLST</span>  <span class="opcode2">21 50 16</span></div><div>Load HL with the starting address of the reserved words list</div></div>
									<div class="assembly-row-combined" id="2BACH"><div>2BAC <span class="origrom2">LOPRES</span></div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the reserved words list pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2BAD</div><div>OR A <span class="opcode2">B7</span></div><div>Test
 the value of the character in Register A.  The P FLAG will be set on 
the first character of each TOKEN because it has the high bit set.</div></div>
									<div class="assembly-row-combined"><div>2BAE</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the reserved words list pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2BAF-2BB1</div><div><a href="#2BACH" class="memory-link">JP P,2BACH <span class="origrom2">JP P,LOPRES</span></a><span class="opcode2">F2 AC 2B</span></div><div>If the character at the location of the reserved words pointer in Register A doesn't have bit 7 set then Jump back to 2BACH.</div></div>
									<div class="assembly-row-combined"><div>2BB2</div><div>DEC E <span class="opcode2">1D</span></div><div>Decrement the counter</div></div>
									<div class="assembly-row-combined"><div>2BB3-2BB4</div><div><a href="#2BACH" class="memory-link">JR NZ,2BACH <span class="origrom2">JR NZ,LOPRES</span></a><span class="opcode2">20 F7</span></div><div>Jump back to 2BACH if this isn't the reserved word for the token</div></div>
									<div class="assembly-row-combined"><div>2BB5-2BB6</div><div>AND 7FH<span class="origrom2">AND 01111111</span> <span class="opcode2">E6 7F</span></div><div>Reset
 bit 7 of the character in Register A by ANDing it against 0111 1111.  
This is to eliminate the MSB for "EDIT" and for disk I/O</div></div>
									<div class="assembly-row-combined" id="2BB7H"><div>2BB7 <span class="origrom2">MORPUR</span></div><div>LD (BC),A <span class="opcode2">02</span></div><div>Save the character in Register A at the location of the input buffer pointer in BC</div></div>
									<div class="assembly-row-combined"><div>2BB8</div><div>INC BC <span class="opcode2">03</span></div><div>Bump the value of the input buffer pointer in BC</div></div>
									<div class="assembly-row-combined"><div>2BB9</div><div>DEC D <span class="opcode2">15</span></div><div>Decrement the value of the character counter in Register D</div></div>
									<div class="assembly-row-combined"><div>2BBA-2BBC</div><div><a href="#28D8H" class="memory-link">JP Z,28D8H <span class="origrom2">JP Z,PPSWRT</span></a><span class="opcode2">CA D8 28</span></div><div>If
 the Z FLAG has been set, then the character counter for the buffer has 
been exhausted and the buffer is now full, so JUMP back to 28D8H</div></div>
									<div class="assembly-row-combined"><div>2BBD</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the reserved words pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2BBE</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the reserved words pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2BBF</div><div>OR A <span class="opcode2">B7</span></div><div>Test the value of the character in Register A</div></div>
									<div class="assembly-row-combined"><div>2BC0-2BC2</div><div><a href="#2BB7H" class="memory-link">JP P,2BB7H <span class="origrom2">JP P,MORPUR</span></a><span class="opcode2">F2 B7 2B</span></div><div>Keep getting characters in this reserved word until we hit the next reserved word</div></div>
									<div class="assembly-row-combined"><div>2BC3</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the BASIC line pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2BC4-2BC5</div><div><a href="#2B8CH" class="memory-link">JR 2B8CH <span class="origrom2">JR PLOOP2</span></a><span class="opcode2">18 C6</span></div><div>Jump back to 2B8CH to continue processing the BASIC line being interpreted</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2BC6H">2BC6-2BF4 - LEVEL II BASIC DELETE ROUTINE <span class="origrom">- "DELETE"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2BC6-2BC8 <span class="origrom2">DELETE</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1B10H" class="memory-link">CALL 1B10H <span class="origrom2">CALL SCNLIN</span></a><span class="opcode2">CD 10 1B</span></div><div>GOSUB to 1B10H to evaluate the line numbers at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2BC9</div><div>POP DE <span class="opcode2">D1</span></div><div>Get the value of the last BASIC line number to be deleted (in binary) from the STACK and put it in DE</div></div>
									<div class="assembly-row-combined"><div>2BCA</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the address of the first BASIC line to be deleted in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>2BCB</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the address of the first BASIC line to be deleted in BC to the STACK AGAIN!</div></div>
									<div class="assembly-row-combined"><div>2BCC-2BCE</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1B2CH" class="memory-link">CALL 1B2CH <span class="origrom2">CALL FNDLIN</span></a><span class="opcode2">CD 2C 1B</span></div><div>GOSUB
 to 1B2CH to the SEARCH FOR LINE NUMBER routine which looks for the line
 number specified in DE so as to get the address of the last line to be 
deleted.Returns C/Z with the line found in BC, NC/Z with line number is 
too large and HL/BC having the next available location, or NC/NZ with 
line number not found, and BC has the first available one after that</div></div>
									<div class="assembly-row-combined" id="2BD6H"><div>2BCF-2BD0</div><div><a href="#2BD6H" class="memory-link">JR NC,2BD6H <span class="origrom2">JR NC,FCERRG</span></a><span class="opcode2">30 05</span></div><div>Since
 the first line number provided MUST be found, if FNDLIN returns with 
the NC FLAG set (i.e., not found) we must JUMP to 2BD6H to show a <span class="code">?FC ERROR</span></div></div>
									<div class="assembly-row-combined"><div>2BD1<br>2BD2</div><div>LD D,H<br>LD E,L <span class="opcode2">54</span></div><div>Let Register Pair DE = Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>2BD3</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Exchange the last BASIC line's address in HL with the first BASIC line's address to the STACK</div></div>
									<div class="assembly-row-combined"><div>2BD4</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the pointer to the first line in range to the STACK</div></div>
									<div class="assembly-row-combined"><div>2BD5</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>We
 need to check to see if the first BASIC line's address in HL is greater
 than or equal to the last BASIC line's address in DE, so we call the 
COMPARE DE:HL routine at RST 10H.<br><br>The RST 10H routine parses the 
characters starting at HL+1 for the first non-SPACE,non-09H,non-0BH 
character it finds.  On exit, Register A will hold that character, and 
the C FLAG is set if its alphabetic, and NC FLAG if its alphanumeric.  
All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined" id="2BD6H"><div>2BD6-2BD8 <span class="origrom2">FCERRG</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E4AH" class="memory-link">JP NC,1E4AH <span class="origrom2">JP NC,FCERR</span></a><span class="opcode2">D2 4A 1E</span></div><div>Display a <span class="code">?FC ERROR</span> message if the first BASIC lines address in HL is greater than or equal to the last BASIC line's address in DE</div></div>
									<div class="assembly-row-combined"><div>2BD9-2BDB</div><div>LD HL,1929H <span class="origrom2">LD HL,REDDY</span>  <span class="opcode2">21 29 19</span></div><div>Load HL with the starting address of the BASIC READY message</div></div>
									<div class="assembly-row-combined"><div>2BDC-2BDE</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#28A7H" class="memory-link">CALL 28A7H <span class="origrom2">CALL STROUT</span></a><span class="opcode2">CD A7 28</span></div><div>Call the WRITE MESSAGE routine at 28A7H to print the message pointed to by HL.</div></div>
									<div class="assembly-row-combined"><div>2BDF</div><div>POP BC <span class="opcode2">C1</span></div><div>Get the first BASIC line's address from the STACK and put it in BC</div></div>
									<div class="assembly-row-combined"><div>2BE0-2BE2</div><div>LD HL,1AE8H <span class="origrom2">LD HL,FINI</span>  <span class="opcode2">21 E8 1A</span></div><div>Load HL with the return address</div></div>
									<div class="assembly-row-combined"><div>2BE3</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Swap (SP) and HL so that HL now points to the next BASIC line's address ...</div></div>
									<div class="assembly-row-combined" id="2BE4H"><div>2BE4 <span class="origrom2">DEL</span></div><div>EX DE,HL <span class="opcode2">EB</span></div><div>and then put it into DE</div></div>
									<div class="assembly-row-combined"><div>2BE5-2BE7</div><div>LD HL,(40F9H) <span class="origrom2">LD HL,(VARTAB)</span>  <span class="opcode2">2A F9 40</span></div><div>Load HL with the end of the BASIC program pointer.<br><ul><li>Note: 40F9H-40FAH holds the starting address of the simple variable storage area.</li></ul></div></div>
									<div class="assembly-row-combined" id="2BE8H"><div>2BE8 <span class="origrom2">MLOOP</span></div><div>LD A,(DE) <span class="opcode2">1A</span></div><div>Load Register A with the character at the location of the memory pointer in DE</div></div>
									<div class="assembly-row-combined"><div>2BE9</div><div>LD (BC),A <span class="opcode2">02</span></div><div>Save the character in Register A at the location of the memory pointer in BC</div></div>
									<div class="assembly-row-combined"><div>2BEA</div><div>INC BC <span class="opcode2">03</span></div><div>Bump the value of the memory pointer in BC</div></div>
									<div class="assembly-row-combined"><div>2BEB</div><div>INC DE <span class="opcode2">13</span></div><div>Bump the value of the memory pointer in DE</div></div>
									<div class="assembly-row-combined"><div>2BEC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now
 we need to check to see if the memory pointer in DE equals the end of 
the BASIC program pointer in HL, so we call the COMPARE DE:HL routine at
 RST 10H.<br><br>The RST 10H routine parses the characters starting at 
HL+1 for the first non-SPACE,non-09H,non-0BH character it finds.  On 
exit, Register A will hold that character, and the C FLAG is set if its 
alphabetic, and NC FLAG if its alphanumeric.  All strings must have a 
00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2BED-2BEE</div><div><a href="#2BE8H" class="memory-link">JR NZ,2BE8H <span class="origrom2">JR NZ,MLOOP</span></a><span class="opcode2">20 F9</span></div><div>Loop back to 2BE8H until the memory pointer in DE equals the end of the BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2BEF</div><div>LD H,B <span class="opcode2">60</span></div><div>Load Register H with the MSB of the memory pointer in Register B</div></div>
									<div class="assembly-row-combined"><div>2BF0</div><div>LD L,C <span class="opcode2">69</span></div><div>Load Register L with the LSB of the memory pointer in Register C</div></div>
									<div class="assembly-row-combined"><div>2BF1-2BF3</div><div>LD (40F9H),HL <span class="origrom2">LD (VARTAB),HL</span>  <span class="opcode2">22 F9 40</span></div><div>Save the value in HL as the new end of the BASIC program pointer.<br><ul><li>Note: 40F9H-40FAH holds the starting address of the simple variable storage area.</li></ul></div></div>
									<div class="assembly-row-combined"><div>2BF4</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2BF5H">2BF5-2C1E - LEVEL II BASIC CSAVE ROUTINE <span class="origrom">- "CSAVE"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The original ROM source code says that the CSAVE command 
dump's BASIC's core.  Three D3H's are written, followed by a 1 character
 filename.  At the end 3 zeros in a row are written.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2BF5-2BF7 <span class="origrom2">CSAVE</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0284H" class="memory-link">CALL 0284H <span class="origrom2">CALL CWRTON</span></a><span class="opcode2">CD 84 02</span></div><div>Calls the WRITE LEADER routine at 0284H (which writes a Level II leader on the cassette unit set in Register A)</div></div>
									<div class="assembly-row-combined"><div>2BF8</div><div><a href="#2337H" class="memory-link">CALL 2337H <span class="origrom2">CALL FRMEVL</span></a><span class="opcode2">CD 37 23</span></div><div>2BFAH Go evaluate the rest of the <span class="code">CSAVE</span> expression at the location of the current BASIC program pointer in HL and return with the result in REG l</div></div>
									<div class="assembly-row-combined"><div>2BFB</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL to the STACK so we can get it back at the end of the routine</div></div>
									<div class="assembly-row-combined"><div>2BFC-2BFE</div><div><a href="#2A13H" class="memory-link">CALL 2A13H <span class="origrom2">CALL ASC2</span></a><span class="opcode2">CD 13 2A</span></div><div>Go get the starting address of the filename into DE</div></div>
									<div class="assembly-row-combined" id="2C00H"><div>2BFF-2C00</div><div>LD A,D3H <span class="opcode2">3E D3</span></div><div>Load Register A with the filename header byte (=D3H which is a "S" with the sign bit on)</div></div>
									<div class="assembly-row-combined"><div>2C01-2C03</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0264H" class="memory-link">CALL 0264H <span class="origrom2">CALL CASOUT</span></a><span class="opcode2">CD 64 02</span></div><div>the
 WRITE ONE BYTE TO CASSETTE routine at 0264H (which writes the byte in 
the A Register to the cassette drive selected in the A register), which 
in this case the filename header byte</div></div>
									<div class="assembly-row-combined"><div>2C04-2C06</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0261H" class="memory-link">CALL 0261H <span class="origrom2">CALL TWOCSO</span></a><span class="opcode2">CD 61 02</span></div><div>Go write the filename header byte in Register A twice more</div></div>
									<div class="assembly-row-combined"><div>2C07</div><div>LD A,(DE) <span class="opcode2">1A</span></div><div>Load Register A with the first character of the filename at the location of the filename pointer in DE</div></div>
									<div class="assembly-row-combined"><div>2C08-2C0A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0264H" class="memory-link">CALL 0264H <span class="origrom2">CALL CASOUT</span></a><span class="opcode2">CD 64 02</span></div><div>the
 WRITE ONE BYTE TO CASSETTE routine at 0264H (which writes the byte in 
the A Register to the cassette drive selected in the A register), which 
in this case is the filename</div></div>
									<div class="assembly-row-combined"><div>2C0B-2C0D</div><div>LD HL,(40A4H) <span class="origrom2">LD HL,(TXTTAB)</span>  <span class="opcode2">2A A4 40</span></div><div>Load HL with the start of the BASIC program pointer.<br><ul><li>Note: 40A4H-40A5H holds the starting address of BASIC program text also known as the PROGRAM STATEMENT TABLE (PST).</li></ul></div></div>
									<div class="assembly-row-combined"><div>2C0E</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load DE with the start of the BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2C0F-2C11</div><div>LD HL,(40F9H) <span class="origrom2">LD HL,(VARTAB)</span>  <span class="opcode2">2A F9 40</span></div><div>Load HL with the end of the BASIC program pointer.<br><ul><li>Note: 40F9H-40FAH holds the starting address of the simple variable storage area.</li></ul></div></div>
									<div class="assembly-row-combined" id="2C12H"><div>2C12 <span class="origrom2">LOPSCO</span></div><div>LD A,(DE) <span class="opcode2">1A</span></div><div>Top
 of a loop.  We are going to loop from DE (start of program) to HL (end 
of program) now.  Load Register A with the character at the location of 
the memory pointer in DE</div></div>
									<div class="assembly-row-combined"><div>2C13</div><div>INC DE <span class="opcode2">13</span></div><div>Bump the value of the memory pointer in DE</div></div>
									<div class="assembly-row-combined"><div>2C14-2C16</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0264H" class="memory-link">CALL 0264H <span class="origrom2">CALL CASOUT</span></a><span class="opcode2">CD 64 02</span></div><div>the
 WRITE ONE BYTE TO CASSETTE routine at 0264H (which writes the byte in 
the A Register to the cassette drive selected in the A register)</div></div>
									<div class="assembly-row-combined"><div>2C17</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C90H" class="memory-link">RST 18H <span class="origrom2">COMPAR</span></a><span class="opcode2">DF</span></div><div>Now
 we need to check to see if the memory pointer in DE is equal to the end
 of the BASIC program pointer in HL, so we call the COMPARE DE:HL 
routine at RST 10H.<br><br>The RST 10H routine parses the characters 
starting at HL+1 for the first non-SPACE,non-09H,non-0BH character it 
finds.  On exit, Register A will hold that character, and the C FLAG is 
set if its alphabetic, and NC FLAG if its alphanumeric.  All strings 
must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2C18-2C19</div><div><a href="#2C12H" class="memory-link">JR NZ,2C12H <span class="origrom2">JR NZ,LOPCSO</span></a><span class="opcode2">20 F8</span></div><div>Loop back to 2C12H until the memory pointer in DE is equal to the end of the BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2C1A-2C1C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#01F8H" class="memory-link">CALL 01F8H <span class="origrom2">CALL CTOFF</span></a><span class="opcode2">CD F8 01</span></div><div>All done!  GOSUB 01F8H to turn the cassette recorder off</div></div>
									<div class="assembly-row-combined"><div>2C1D</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the current BASIC program pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2C1E</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2C1FH">2C1F-2CA4 - LEVEL II BASIC CLOAD ROUTINE - ROM v1.0 <span class="origrom">- "CLOAD"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2C1F-2C21 <span class="origrom2">CLOAD</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0293H" class="memory-link">CALL 0293H <span class="origrom2">CALL CSRDON</span></a><span class="opcode2">CD 93 02</span></div><div>Go turn on the cassette recorder</div></div>
									<div class="assembly-row-combined"><div>2C22</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2C23-2C24</div><div>SUB 0B2H <span class="origrom2">SUB $PRINT</span>  <span class="opcode2">D6 B2</span></div><div>Check to see if the character at the location of the current BASIC program pointer in Register A is a <span class="code">?</span> , meaning that <span class="code">CLOAD?</span> was requested.</div></div>
									<div class="assembly-row-combined" id="2C25H"><div>2C25-2C26</div><div><a href="#2C29H" class="memory-link">JR Z,2C29H <span class="origrom2">JR Z,CLOADP</span></a><span class="opcode2">28 02</span></div><div>Jump to the <span class="code">CLOAD?</span> routine at 2C29H if the character at the location of the current BASIC program pointer in Register A is a <span class="code">?</span></div></div>
									<div class="assembly-row-combined"><div>2C27</div><div>XOR A <span class="opcode2">AF</span></div><div>OK - So this is now a straight <span class="code">CLOAD</span> .  First, zero Register A</div></div>
									<div class="assembly-row-combined"><div>2C28</div><div>LD BC,232F <span class="opcode2">01 2F 23</span></div><div>Z-80 Trick! The next instruction would set the flag for a <span class="code">CLOAD?</span>
 which we don't want if we are passing through because we need A to be 
0, so 2C28H starts with a 01H which would be a meaningless LOAD 
statement and assumes that the following instruction at 2C29H is what to
 load it with, effectively skipping 2C29H.  BUT, if you jump to 2C29H 
you get the actual XOR command and keep going</div></div>
									<div class="assembly-row-combined" id="2C29H"><div>2C29 <span class="origrom2">CLOADP</span></div><div>CPL <span class="opcode2">2F</span></div><div>Load Register A with a -1 for <span class="code">CLOAD?</span> .  It will still be a 0 if this is <span class="code">CLOAD</span></div></div>
									<div class="assembly-row-combined"><div>2C2A</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the current BASIC program pointer in HL until it points to the next character after the <span class="code">?</span> in <span class="code">CLOAD?</span></div></div>
									<div class="assembly-row-combined"><div>2C2B</div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the <span class="code">CLOAD</span> / <span class="code">CLOAD?</span> flag in Register A to the STACK</div></div>
									<div class="assembly-row-combined"><div>2C2C</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the current BASIC program pointer in HL so we can see if we are at the end</div></div>
									<div class="assembly-row-combined"><div>2C2D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2C2E-2C2F</div><div>LD A,00H <span class="opcode2">3E 00</span></div><div>Zero Register A to allow for any filename</div></div>
									<div class="assembly-row-combined"><div>2C30-2C31</div><div><a href="#2C39H" class="memory-link">JR Z,2C39H <span class="origrom2">JR Z,CLNONM</span></a><span class="opcode2">28 07</span></div><div>Jump if the character at the location of the current BASIC program pointer in HL is an end of the BASIC statement character</div></div>
									<div class="assembly-row-combined"><div>2C32-2C34</div><div><a href="#2337H" class="memory-link">CALL 2337H <span class="origrom2">CALL FRMEVL</span></a><span class="opcode2">CD 37 23</span></div><div>To
 get the filename we need to GOSUB to 2337H to evaluate the expression 
at the location of the current BASIC program pointer in HL and return 
with the result in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>2C35-2C37</div><div><a href="#2A13H" class="memory-link">CALL 2A13H <span class="origrom2">CALL ASC2</span></a><span class="opcode2">CD 13 2A</span></div><div>Make sure the length is good, and save the pointer to the filename to Register Pair DE</div></div>
									<div class="assembly-row-combined"><div>2C38</div><div>LD A,(DE) <span class="opcode2">1A</span></div><div>Load Register A with the first character of the filename at the location of the filename pointer in DE</div></div>
									<div class="assembly-row-combined" id="2C39H"><div>2C39 <span class="origrom2">CLNONM</span></div><div>LD L,A <span class="opcode2">6F</span></div><div>Load Register L with the filename in Register A</div></div>
									<div class="assembly-row-combined"><div>2C3A</div><div>POP AF <span class="opcode2">F1</span></div><div>Get the value of the <span class="code">CLOAD</span> / <span class="code">CLOAD?</span> flag from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>2C3B</div><div>OR A <span class="opcode2">B7</span></div><div>Test the value of the <span class="code">CLOAD</span> / <span class="code">CLOAD?</span> flag in Register A (since CPL doesn't set any flags)</div></div>
									<div class="assembly-row-combined"><div>2C3C</div><div>LD H,A <span class="opcode2">67</span></div><div>Load Register H with the value of the <span class="code">CLOAD</span> / <span class="code">CLOAD?</span> flag in Register A</div></div>
									<div class="assembly-row-combined"><div>2C3D-2C3F</div><div>LD (4121H),HL <span class="origrom2">LD (FACLO),HL</span>  <span class="opcode2">22 21 41</span></div><div>Save the value of the <span class="code">CLOAD</span> / <span class="code">CLOAD?</span> flag and the filename in HL in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>2C40-2C42</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1B4DH" class="memory-link">CALL Z,1B4DH <span class="origrom2">CALL Z,SCRTCH</span></a><span class="opcode2">CC 4D 1B</span></div><div>Call the <span class="code">NEW</span> routine at 1B4D if it is a <span class="code">CLOAD</span></div></div>
									<div class="assembly-row-combined"><div>2C43-2C45</div><div>LD HL,(4121H) <span class="origrom2">LD HL,(FACLO)</span>  <span class="opcode2">2A 21 41</span></div><div>Load HL with the <span class="code">CLOAD</span> / <span class="code">CLOAD?</span> flag and the filename in ACCumulator</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="*2C1FH">*2C1F-2CA4 - LEVEL II BASIC CLOAD ROUTINE - ROM v1.3<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>*2C1F</div><div>SUB 0B2H</div><div>Test for CLOAD?</div></div>
									<div class="assembly-row-combined"><div>*2C21</div><div><a href="#2C25H" class="memory-link">JR Z,2C25H</a></div><div>Jump to 2C25H if it is CLOAD?</div></div>
									<div class="assembly-row-combined"><div>*2C23</div><div>XOR A</div><div>So we know that we have a CLOAD and not a CLOAD?, so clear Register A and continue</div></div>
									<div class="assembly-row-combined"><div>*2C24</div><div>01</div><div>Z-80 Trick! The next instruction would set the flag for a <span class="code">CLOAD?</span>
 which we don't want if we are passing through because we need A to be 
0, so 2C28H starts with a 01H which would be a meaningless LOAD 
statement and assumes that the following instruction at 2C29H is what to
 load it with, effectively skipping 2C29H.  BUT, if you jump to 2C29H 
you get the actual XOR command and keep going</div></div>
									<div class="assembly-row-combined" id="2C25H"><div>*2C25</div><div>CPL</div><div>Since A is Zero going into this command, once this complement code is exected, A=-1 if CLOAD?, 0000 if CLOAD</div></div>
									<div class="assembly-row-combined"><div>*2C26</div><div>INC HL</div><div>Increment HL to the filname of the <span class="code">CLOAD</span> / <span class="code">CLOAD?</span> flag</div></div>
									<div class="assembly-row-combined"><div>*2C27</div><div>PUSH AF</div><div>Save the <span class="code">CLOAD</span> / <span class="code">CLOAD?</span> flag in Register A to the STACK</div></div>
									<div class="assembly-row-combined"><div>*2C28</div><div>LD A,(HL)</div><div>Set the next element from the code string, which should be the filename</div></div>
									<div class="assembly-row-combined"><div>*2C29</div><div>OR A</div><div>Set status flags</div></div>
									<div class="assembly-row-combined"><div>*2C2A</div><div><a href="#2C33H" class="memory-link">JR Z,2C33H</a></div><div>If it is the EOL, jump to 2C33H</div></div>
									<div class="assembly-row-combined"><div>*2C2C</div><div><a href="#2337H" class="memory-link">CALL 2337H <span class="origrom2">CALL FRMEVL</span></a></div><div>Call 2337H to get the filename</div></div>
									<div class="assembly-row-combined"><div>*2C2F</div><div><a href="#2A13H" class="memory-link">CALL 2A13H <span class="origrom2">CALL ASC2</span></a></div><div>Call 2A13H to get the address of the filename into DE</div></div>
									<div class="assembly-row-combined"><div>*2C32</div><div>LD A,(DE)</div><div>Get the filename</div></div>
									<div class="assembly-row-combined"><div>*2C33</div><div>LD L,A</div><div>Move the filename into Register L</div></div>
									<div class="assembly-row-combined"><div>*2C34</div><div>POP AF</div><div>Restore the <span class="code">CLOAD</span> / <span class="code">CLOAD?</span> flag</div></div>
									<div class="assembly-row-combined"><div>*2C35</div><div>OR A</div><div>Set the status Register according to that flag</div></div>
									<div class="assembly-row-combined"><div>*2C36</div><div>LD H,A</div><div>H will now hold <span class="code">CLOAD</span> / <span class="code">CLOAD?</span> flag, and L will hold the filename</div></div>
									<div class="assembly-row-combined"><div>*2C37</div><div>LD (4121H),HL <span class="origrom2">LD (FACLO),HL</span></div><div>Put the flag and filename into ACCumulator</div></div>
									<div class="assembly-row-combined"><div>*2C3A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1B4DH" class="memory-link">CALL Z,1B4DH <span class="origrom2">CALL Z,SCRTCH</span></a></div><div>If the flag is a CLOAD, call the NEW routine at 1B4DH</div></div>
									<div class="assembly-row-combined"><div>*2C3D</div><div>LD HL,0000H</div><div>Cause the drive to be selected</div></div>
									<div class="assembly-row-combined"><div>*2C40</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0293H" class="memory-link">CALL 0293H <span class="origrom2">CALL CSRDON</span></a></div><div>Call 2093H to get the leader and sync byte from the cassette</div></div>
									<div class="assembly-row-combined"><div>*2C43</div><div>LD HL,(4121H) <span class="origrom2">LD HL,(FACLO)</span></div><div>Restore the <span class="code">CLOAD</span> / <span class="code">CLOAD?</span> flag and filename</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="common-code-between">Common code between ROM v1.0 and v1.2 continues here.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2C46</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load D with the CLOAD/CLOAD? flag and load Register E with the filename</div></div>
									<div class="assembly-row-combined" id="2C47H"><div>2C47-2C48 <span class="origrom2">LOPCLK</span></div><div>LD B,03H <span class="opcode2">06 03</span></div><div>Load Register B with the number of header bytes</div></div>
									<div class="assembly-row-combined" id="2C49H"><div>2C49-2C4B <span class="origrom2">LOPCL2</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0235H" class="memory-link">CALL 0235H <span class="origrom2">CALL CASIN</span></a><span class="opcode2">CD 35 02</span></div><div>Calls
 the READ ONE BYTE FROM CASSETTE routine at 0235H (which reads one byte 
from the cassette drive specified in Register A, and returns the byte in
 Register A)</div></div>
									<div class="assembly-row-combined"><div>2C4C-2C4D</div><div>SUB 0D3H <span class="opcode2">D6 D3</span></div><div>Check to see if the character in Register A is a filename header byte</div></div>
									<div class="assembly-row-combined"><div>2C4E-2C4F</div><div><a href="#2C47H" class="memory-link">JR NZ,2C47H <span class="origrom2">JR NZ,LOPCLK</span></a><span class="opcode2">20 F7</span></div><div>Loop if the character in Register A isn't a filename header byte</div></div>
									<div class="assembly-row-combined"><div>2C50-2C51</div><div><a href="#2C49H" class="memory-link">DJNZ 2C49H <span class="origrom2">DJNZ LOPCL2</span></a><span class="opcode2">10 F7</span></div><div>Loop back to 2C49H until three filename header bytes have been read</div></div>
									<div class="assembly-row-combined"><div>2C52-2C54</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0235H" class="memory-link">CALL 0235H <span class="origrom2">CALL CASIN</span></a><span class="opcode2">CD 35 02</span></div><div>Now
 that the header is out of the way, let's start working on the filename.
  GOSUB to 0235H to the READ ONE BYTE FROM CASSETTE (which reads one 
byte from the cassette drive specified in Register A, and returns the 
byte in Register A)</div></div>
									<div class="assembly-row-combined"><div>2C55</div><div>INC E <span class="opcode2">1C</span></div><div>We
 need to test to see if a filename was even given so we have to increase
 and decrease E to set flags . Bump the value of the filename in 
Register E</div></div>
									<div class="assembly-row-combined"><div>2C56</div><div>DEC E <span class="opcode2">1D</span></div><div>Decrement the value of the filename in Register E</div></div>
									<div class="assembly-row-combined"><div>2C57-2C58</div><div><a href="#2C5CH" class="memory-link">JR Z,2C5CH <span class="origrom2">JR Z,NONAMC</span></a><span class="opcode2">28 03</span></div><div>Jump to 2C5CH (to pretend the filename matched) if no filename was specified</div></div>
									<div class="assembly-row-combined"><div>2C59</div><div>CP E <span class="opcode2">BB</span></div><div>If
 we are here, then the user has supplied a filename which is held in 
Register E AND we have the first byte from the tape in Register A, so we
 need to compare the filename specified in Register E with the character
 in Register A.  If they match, the Z FLAG is set, and otherwise the NZ 
FLAG is set.  If A &lt; the checked value, then the C FLAG is set.  If A
 &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2C5A-2C5B</div><div><a href="#2C93H" class="memory-link">JR NZ,2C93H <span class="origrom2">JR NZ,SKPFIL</span></a><span class="opcode2">20 37</span></div><div>Jump
 to 2C93H (to skip to the end of that file) if the filename specified in
 Register E doesn't match the byte read from tape in Register A</div></div>
									<div class="assembly-row-combined" id="2C5CH"><div>2C5C-2C5E <span class="origrom2">NONAMC</span></div><div>LD HL,(40A4H) <span class="origrom2">LD HL,(TXTTAB)</span>  <span class="opcode2">2A A4 40</span></div><div>If
 we are here, the filename on tape matches the filename given so lets 
start loading.  Load HL with the start of the BASIC program pointer.<br><ul><li>Note: 40A4H-40A5H holds the starting address of BASIC program text also known as the PROGRAM STATEMENT TABLE (PST).</li></ul></div></div>
									<p class="debug-note">This loop is going to read a byte, 
compare it to the next byte in the program memory, jump away if it 
doesn't match AND CLOAD? was chosen, write (or overwrite) that byte to 
memory, check for a zero, and loop back if no zero was found.</p>
									<div class="assembly-row-combined" id="2C5FH"><div>2C5F-2C60 <span class="origrom2">DOCRS</span></div><div>LD B,03H <span class="opcode2">06 03</span></div><div>Load Register B with the number of zeros to look for to stop the load (which is 3)</div></div>
									<div class="assembly-row-combined" id="2C61H"><div>2C61-2C63 <span class="origrom2">DOCSMR</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0235H" class="memory-link">CALL 0235H <span class="origrom2">CALL CASIN</span></a><span class="opcode2">CD 35 02</span></div><div>Calls
 the READ ONE BYTE FROM CASSETTE routine at 0235H (which reads one byte 
from the cassette drive specified in Register A, and returns the byte in
 Register A)</div></div>
									<div class="assembly-row-combined"><div>2C64</div><div>LD E,A <span class="opcode2">5F</span></div><div>Preserve the character that was just read from tape into Register E</div></div>
									<div class="assembly-row-combined"><div>2C65</div><div>SUB (HL) <span class="opcode2">96</span></div><div>Compare
 the character we just read from the tape (held in Register A) with the 
character at the location of the memory pointer in HL by subtracting 
them</div></div>
									<div class="assembly-row-combined"><div>2C66</div><div>AND D <span class="opcode2">A2</span></div><div>Combine the subtracted result in Register A with the value of the <span class="code">CLOAD</span> / <span class="code">CLOAD?</span>
 flag in Register D.  Why is this tricky?  Because D is always 0 for a 
CLOAD, so when you AND against 0, you always get 0.  If this was CLOAD?,
 nothing would happen as a result of this.</div></div>
									<div class="assembly-row-combined"><div>2C67-2C68</div><div><a href="#2C8AH" class="memory-link">JR NZ,2C8AH <span class="origrom2">JR NZ,NOGOOD</span></a><span class="opcode2">20 21</span></div><div>Jump to 2C8AH if <span class="code">CLOAD?</span> was selected but the bytes don't match</div></div>
									<div class="assembly-row-combined"><div>2C69</div><div>LD (HL),E <span class="opcode2">73</span></div><div>At this point either <span class="code">CLOAD?</span> was selected and the bytes match, or <span class="code">CLOAD</span>
 was selected.  Either way, save the character we read from the tape 
(held in Register E) to the location of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2C6A-2C6C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#196CH" class="memory-link">CALL 196CH<br><span class="origrom2">CALL REASON</span></a><span class="opcode2">CD 6C 19</span></div><div>Make sure there is more room, and toss a <span class="code">?OM ERROR</span> if there isn't.</div></div>
									<div class="assembly-row-combined"><div>2C6D</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2C6E</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if the byte just read in Register A is equal to zero</div></div>
									<div class="assembly-row-combined"><div>2C6F</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2C70-2C71</div><div><a href="#2C5FH" class="memory-link">JR NZ,2C5FH <span class="origrom2">JR NZ,DOCRS</span></a><span class="opcode2">20 ED</span></div><div>Loop if the byte in Register A isn't equal to zero (meaning that it isn't end of program or end of statement)</div></div>
									<div class="assembly-row-combined"><div>2C72-2C74</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#022CH" class="memory-link">CALL 022CH <span class="origrom2">CALL BCASIN</span></a><span class="opcode2">CD 2C 02</span></div><div>Call
 the BLINK ASTERISK routine at 022CH which alternatively displays and 
clears an asterisk in the upper right hand corner of the video display</div></div>
									<div class="assembly-row-combined"><div>2C75-2C76</div><div><a href="#2C61H" class="memory-link">DJNZ 2C61H <span class="origrom2">DJNZ DOCSMR</span></a><span class="opcode2">10 EA</span></div><div>Do that loop until three zeros in a row have been read from the cassette recorder</div></div>
									<div class="assembly-row-combined"><div>2C77-2C79</div><div>LD (40F9H),HL <span class="origrom2">LD (VARTAB),HL</span>  <span class="opcode2">22 F9 40</span></div><div>By
 this point, HL will have been incremented all the way through the 
program.  Save the value of the memory pointer in HL as the new end of 
the BASIC program pointer.<br><ul><li>Note: 40F9H-40FAH holds the starting address of the simple variable storage area.</li></ul></div></div>
									<div class="assembly-row-combined"><div>2C7A-2C7C <span class="origrom2">OKCASS</span></div><div>LD HL,1929H <span class="origrom2">LD HL,REDDY</span>  <span class="opcode2">21 29 19</span></div><div>Load HL with the starting address of the BASIC READY message</div></div>
									<div class="assembly-row-combined"><div>2C75-2C76</div><div><a href="#2C61H" class="memory-link">DJNZ 2C61H <span class="origrom2">DJNZ DOCSMR</span></a><span class="opcode2">10 EA</span></div><div>Do that loop until three zeros in a row have been read from the cassette recorder</div></div>
									<div class="assembly-row-combined"><div>2C80-2C82</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#01F8H" class="memory-link">CALL 01F8H <span class="origrom2">CALL CTOFF</span></a><span class="opcode2">CD F8 01</span></div><div>Go turn off the cassette recorder</div></div>
									<div class="assembly-row-combined"><div>2C83-2C85</div><div>LD HL,(40A4H) <span class="origrom2">LD HL,(TXTTAB)</span>  <span class="opcode2">2A A4 40</span></div><div>Load HL with the start of the BASIC program pointer.<br><ul><li>Note: 40A4H-40A5H holds the starting address of BASIC program text also known as the PROGRAM STATEMENT TABLE (PST).</li></ul></div></div>
									<div class="assembly-row-combined"><div>2C86</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the start of the BASIC program pointer in HL to the STACK.  FINI will need this value there.</div></div>
									<div class="assembly-row-combined"><div>2C87-2C89</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1AE8H" class="memory-link">JP 1AE8H <span class="origrom2">JP FINI</span></a><span class="opcode2">C3 E8 1A</span></div><div>Jump to 1AE8H to reinitialize the BASIC interpreter and continue</div></div>
									<div class="assembly-row-combined" id="2C8AH"><div>2C8A-2C8C <span class="origrom2">NOGOOD</span></div><div>LD HL,2CA5H <span class="origrom2">LD HL,NOOKCS</span>  <span class="opcode2">21 A5 2C</span></div><div>Load HL with the starting address of the <span class="code">BAD</span> message</div></div>
									<div class="assembly-row-combined"><div>2C8D-2C8F</div><div>CALL 28A7H <span class="origrom2">CALL STROUT</span><span class="opcode2">CD A7 28</span></div><div>Call the WRITE MESSAGE routine at 28A7H to print the message pointed to by HL.<br><span class="bold">NOTE:</span><br><ul><li>The routine at 28A7 displays the message pointed to by HL on current system output device (usually video).</li><li>The string to be displayed must be terminated by a byte of machine zeros or a carriage return code 0D.</li><li>If terminated with a carriage return, control is returned to the caller after taking the DOS exit at 41D0H (JP 5B99H).</li></ul></div></div>
									<div class="assembly-row-combined"><div>2C90-2C92</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1AE8H" class="memory-link">JP 1A18 <span class="origrom2">JP STPRDY</span></a><span class="opcode2">C3 18 1A</span></div><div>JUMP to STPRDY to pop NEWSTT from the STACK and then fall into the READY routine</div></div>
									<div class="assembly-row-combined" id="2C93H"><div>2C93-2C95 <span class="origrom2">SKPFIL</span></div><div>LD (3C3EH),A <span class="opcode2">32 3E 3C</span></div><div>Go display the filename on the video display</div></div>
									<div class="assembly-row-combined" id="2C96H"><div>2C96-2C97 <span class="origrom2">ZERSRF</span></div><div>LD B,03H <span class="opcode2">06 03</span></div><div>Load Register B with the number of zeros to be found to stop the search</div></div>
									<div class="assembly-row-combined" id="2C98H"><div>2C98-2C9A <span class="origrom2">GETCHZ</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0235H" class="memory-link">CALL 0235H <span class="origrom2">CALL CASIN</span></a><span class="opcode2">CD 35 02</span></div><div>Calls
 the READ ONE BYTE FROM CASSETTE routine at 0235H (which reads one byte 
from the cassette drive specified in Register A, and returns the byte in
 Register A)</div></div>
									<div class="assembly-row-combined"><div>2C9B</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if the character in Register A is equal to zero</div></div>
									<div class="assembly-row-combined"><div>2C9C-2C9D</div><div><a href="#2C96H" class="memory-link">JR NZ,2C96H <span class="origrom2">JR NZ,ZERSRF</span></a><span class="opcode2">20 F8</span></div><div>Loop if the character in Register A isn't equal to zero</div></div>
									<div class="assembly-row-combined"><div>2C9E-2C9F</div><div><a href="#2C98H" class="memory-link">DJNZ 2C98H <span class="origrom2">DJNZ GETCHZ</span></a><span class="opcode2">10 F8</span></div><div>Loop until three zeros in a row have been read from the cassette recorder</div></div>
									<div class="assembly-row-combined"><div>2CA0-2CA2</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0296H" class="memory-link">CALL 0296H <span class="origrom2">CALL CSRDON + 3</span></a><span class="opcode2">CD 96 02</span></div><div>Calls
 the READ CASSETTE LEADER routine at 0296 (which reads from the cassette
 recorder selected in Register A until the end-of-leader marker of A5H 
is found; and flashes the cursor while doing this)</div></div>
									<div class="assembly-row-combined"><div>2CA3-2CA4</div><div><a href="#2C47H" class="memory-link">JR 2C47H <span class="origrom2">JR LOPCLK</span></a><span class="opcode2">18 A2</span></div><div>Jump back to 2C47H</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2CA5H">2CA5-2CA9 - MESSAGE STORAGE LOCATION <span class="origrom">- "NOOKCS"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2CA5-2CA9 <span class="origrom2">NOOKCS</span></div><div>"BAD" + 0DH + 00H <span class="opcode2">42</span></div><div>The BAD message is stored here</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2CAAH">2CAA-2CB0 - LEVEL II BASIC <span class="code">PEEK</span> ROUTINE <span class="origrom">- "PEEK"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The original ROM source code says that PEEK only accepts 
positive numbers up to 32767 and POKE will only take an address up to 
32767.  Negative numbers can be used to refer to locations higher than 
32767, the correspondence is given by subtracting 65536 from locations 
higher than 32767 or by specifying a positive number up to 65535<br><br>On entry, ACCumulator to have the peek location, and on exit ACCumulator to have the peeked value.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2CAA-2CAC <span class="origrom2">PEEK</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A7FH" class="memory-link">CALL 0A7FH <span class="origrom2">CALL FRCINT</span></a><span class="opcode2">CD 7F 0A</span></div><div>Call
 the CONVERT TO INTEGER routine at 0A7FH (where the contents of 
ACCumulator are converted from single or double precision to integer and
 deposited into HL)</div></div>
									<div class="assembly-row-combined"><div>2CAD</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the value at the location of the memory pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2CAE-2CB0</div><div><a href="#27F8H" class="memory-link">JP 27F8H <span class="origrom2">JP SNGFLT</span></a><span class="opcode2">C3 F8 27</span></div><div>Go save the 8-bit value in Register A as the current result in ACCumulator</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2CB1H">2CB1-2CBC - LEVEL II BASIC <span class="code">POKE</span> ROUTINE <span class="origrom">- "POKE"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2CB1-2CB3 <span class="origrom2">POKE</span></div><div><a href="#2B02H" class="memory-link">CALL 2B02H <span class="origrom2">CALL GETIN2</span></a><span class="opcode2">CD 02 2B</span></div><div>Go evaluate the expression at the location of the current BASIC program pointer in HL and return with the integer result in DE</div></div>
									<div class="assembly-row-combined"><div>2CB4</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the address the user wants to POKE to (held in DE) to the STACK</div></div>
									<div class="assembly-row-combined"><div>2CB5-2CB6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 2E<span class="origrom2">SYNCHK ","</span></a><span class="opcode2">CF 2E</span></div><div>Since the character at the location of the current BASIC program pointer in HL must be a <span class="code">,</span> , call the COMPARE SYMBOL routine at RST 08H.<br><br><span class="bold nobottomborder">NOTE:</span>
 The RST 08H routine compares the symbol in the input string pointed to 
by HL Register to the value in the location following the RST 08 call.<ul><li>If
 there is a match, control is returned to the next execution address 
(i.e, the RST 08H instruction + 2) with the next symbol in the A 
Register and HL incremented by one.</li><li>If the two characters do not match, a syntax error message is given and control returns to the Input Phase).</li></ul></div></div>
									<div class="assembly-row-combined"><div>2CB7-2CB9</div><div><a href="#2B1CH" class="memory-link">CALL 2B1CH <span class="origrom2">CALL GETBYT</span></a><span class="opcode2">CD 1C 2B</span></div><div>GOSUB
 to 2B1CH to evaluate the expression at the location of the current 
BASIC program pointer in HL and return with the 8-bit value in Register A</div></div>
									<div class="assembly-row-combined"><div>2CBA</div><div>POP DE <span class="opcode2">D1</span></div><div>Get the address the user wants to POKE to from the STACK and put it in DE</div></div>
									<div class="assembly-row-combined"><div>2CBB</div><div>LD (DE),A <span class="opcode2">12</span></div><div>Save the value the user wanted to poke (held in Register A) in the location that the user wants to POKE to (held in DE)</div></div>
									<div class="assembly-row-combined"><div>2CBC</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2CBDH">2CBD-2E52 - LEVEL II BASIC <span class="code">USING</span> ROUTINE <span class="origrom">- "PRINUS"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The original ROM source code says that we wind up here after 
the "USING" clause in a PRINT statement is recognized.  The idea is to 
scan the using string until the value list is exhausted, finding string 
and numeric fields to print values out of the list in, and just 
outputing any characters that aren't part of a print field<br><br> 
Vernon Hester has reported an error in the PRINT USING routine.  A PRINT
 USING statement with a negative sign at the end of the field prints a 
negative sign after negative numbers and prints a space for positive 
numbers. However, if the field specifiers in the string also has two 
asterisks at the beginning of the field, the ROM prints an asterisk 
instead of a space after a positive number.<br><br> &nbsp;&nbsp;&nbsp;Example:  PRINT USING "**####-";1234 will display **1234* instead of **1234 <kbd>SPACE</kbd> </p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2CBDH"><div>2CBD-2CBF <span class="origrom2">PRINUS</span></div><div><a href="#2338H" class="memory-link">CALL 2338H <span class="origrom2">CALL FRMCHK</span></a><span class="opcode2">CD 38 23</span></div><div>Go evaluate the string expression at the location of the current BASIC program pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2CC0-2CC2</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0AF4H" class="memory-link">CALL 0AF4H <span class="origrom2">CALL CHKSTR</span></a><span class="opcode2">CD F4 0A</span></div><div>Go make sure the expression that was just evaluated was a string</div></div>
									<div class="assembly-row-combined"><div>2CC3-2CC4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C96H" class="memory-link">RST 08H ‚áí 3B<span class="origrom2">SYNCHK ";"</span></a><span class="opcode2">CF 3B</span></div><div>Since
 the character at the location of the current BASIC program pointer in 
HL must be a ";", call the COMPARE SYMBOL routine at RST 08H.<br><br><span class="bold nobottomborder">NOTE:</span>
 The RST 08H routine compares the symbol in the input string pointed to 
by HL Register to the value in the location following the RST 08 call.<ul><li>If
 there is a match, control is returned to the next execution address 
(i.e, the RST 08H instruction + 2) with the next symbol in the A 
Register and HL incremented by one.</li><li>If the two characters do not match, a syntax error message is given and control returns to the Input Phase).</li></ul></div></div>
									<div class="assembly-row-combined"><div>2CC5</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap DE and HL so that DE now holds the current BASIC program pointer</div></div>
									<div class="assembly-row-combined"><div>2CC6-2CC8</div><div>LD HL,(4121H) <span class="origrom2">LD HL,(FACLO)</span>  <span class="opcode2">2A 21 41</span></div><div>Load HL with the USING string's VARPTR</div></div>
									<div class="assembly-row-combined"><div>2CC9-2CCA</div><div><a href="#2CD3H" class="memory-link">JR 2CD3H <span class="origrom2">JR INIUS</span></a><span class="opcode2">18 08</span></div><div>Jump down to 2CD3H to continue</div></div>
									<div class="assembly-row-combined" id="2CCBH"><div>2CCB-2CCD <span class="origrom2">REUSST</span></div><div>LD A,(40DEH) <span class="origrom2">LD A,(FLGINP)</span>  <span class="opcode2">3A DE 40</span></div><div>Load
 Register A with the value of the READ/INPUT flag, which is being used 
here to track if we printed out a value on the prior scan.</div></div>
									<div class="assembly-row-combined"><div>2CCE</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if that flag indivates that we did, or did not, print out a value last time.</div></div>
									<div class="assembly-row-combined"><div>2CCF-2CD0</div><div><a href="#2CDDH" class="memory-link">JR Z,2CDDH <span class="origrom2">JR Z,FCERR3</span></a><span class="opcode2">28 0C</span></div><div>If we did not print out a value last time, we have an error, so JUMP down to 2CDDH</div></div>
									<div class="assembly-row-combined"><div>2CD1</div><div>POP DE <span class="opcode2">D1</span></div><div>Restore the pointer to the "USING" string decription from the STACK into DE</div></div>
									<div class="assembly-row-combined"><div>2CD2</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap
 DE and HL so that HL will hold the pointer to the "USING" string 
descriptor and DE will hold the pointer to the position on the BASIC 
line being evaluated.</div></div>
									<div class="assembly-row-combined" id="2CD3H"><div>2CD3 <span class="origrom2">INIUS</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the pointer to the "USING" string descriptor (i.e., the USING string's VARPTR) in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2CD4</div><div>XOR A <span class="opcode2">AF</span></div><div>Zero Register A and all the flags.</div></div>
									<div class="assembly-row-combined"><div>2CD5-2CD7</div><div>LD (40DEH),A <span class="origrom2">LD (FLGINP),A</span>  <span class="opcode2">32 DE 40</span></div><div>Clear the flag we are using to see if we printed the values or not.</div></div>
									<div class="assembly-row-combined"><div>2CD8</div><div>CP D <span class="opcode2">BA</span></div><div>Turn
 the Z FLAG off so as to indicate the value list has not ended yet.  
This is accomplished by checking to see if the value in D is equal to 
zero by checking it against A which was XOR'd to 0 above.  If they 
match, the Z FLAG is set, and otherwise the NZ FLAG is set.  If A &lt; 
the checked value, then the C FLAG is set.  If A &gt;= the checked 
value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2CD9</div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the flag indicating if the value list has ended or not to the STACK</div></div>
									<div class="assembly-row-combined"><div>2CDA</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the pointer into the value list to the STACK</div></div>
									<div class="assembly-row-combined"><div>2CDB</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load Register B with the USING string's length</div></div>
									<div class="assembly-row-combined"><div>2CDC</div><div>OR B <span class="opcode2">B0</span></div><div>Check to see if the USING string's length in Register B is equal to zero</div></div>
									<div class="assembly-row-combined" id="2CDDH"><div>2CDD-2CDF <span class="origrom2">FCERR3</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E4AH" class="memory-link">JP Z,1E4AH <span class="origrom2">JP Z,FCERR</span></a><span class="opcode2">CA 4A 1E</span></div><div>If the USING string is NULL then display a <span class="code">?FC ERROR</span></div></div>
									<div class="assembly-row-combined"><div>2CE0</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the pointer to the USING string's data in HL by 1</div></div>
									<div class="assembly-row-combined"><div>2CE1</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Load Register C with the LSB of the USING string's address at the location of the USING string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2CE2</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the USING string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2CE3</div><div>LD H,(HL) <span class="opcode2">66</span></div><div>Load Register H with the MSB of the USING string's address at the location of the USING string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2CE4</div><div>LD L,C <span class="opcode2">69</span></div><div>Load Register L with the LSB of the USING string's address in Register C</div></div>
									<div class="assembly-row-combined"><div>2CE5-2CE6</div><div><a href="#2D03H" class="memory-link">JR 2D03H <span class="origrom2">JR PRCCHR</span></a><span class="opcode2">18 1C</span></div><div>Jump down to 2D03H to loop to scan the USING string</div></div>
									<div class="assembly-row-combined" id="2CE7H"><div>2CE7 <span class="origrom2">BGSTRF</span></div><div>LD E,B <span class="opcode2">58</span></div><div>Load Register E with the USING string's length</div></div>
									<div class="assembly-row-combined"><div>2CE8</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the pointer to the USING string pointer in HL to the top of the STACK</div></div>
									<div class="assembly-row-combined"><div>2CE9-2CEA</div><div>LD C,02H <span class="opcode2">0E 02</span></div><div>Since the \\ string field length is two plus number of enclosed spaces, add two</div></div>
									<div class="assembly-row-combined" id="2CEBH"><div>2CEB <span class="origrom2">LPSTRF</span></div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the USING string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2CEC</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the USING string data pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2CED-2CEE</div><div>CP 25H <span class="origrom2">CP CSTRNG</span>  <span class="opcode2">FE 25</span></div><div>Check
 to see if the character in Register A is a %, which acts as a field 
terminator.  If they match, the Z FLAG is set, and otherwise the NZ FLAG
 is set.  If A &lt; the checked value, then the C FLAG is set.  If A 
&gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2CEF-2CF1</div><div><a href="#2E17H" class="memory-link">JP Z,2E17H <span class="origrom2">JP Z,ISSTRF</span></a><span class="opcode2">CA 17 2E</span></div><div>If it is a "%" then JUMP to 2E17H to evaluate a string and print</div></div>
									<div class="assembly-row-combined"><div>2CF2-2CF3</div><div>CP 20H <span class="opcode2">FE 20</span></div><div>Check
 to see if the character in Register A is a " ", which acts as a field 
extender.  If they match, the Z FLAG is set, and otherwise the NZ FLAG 
is set.  If A &lt; the checked value, then the C FLAG is set.  If A 
&gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2CF4-2CF5</div><div><a href="#2CF9H" class="memory-link">JR NZ,2CF9H <span class="origrom2">JR NZ,NOSTRF</span></a><span class="opcode2">20 03</span></div><div>If the character is not a field extender, then it isn't a string field, so JUMP down a few opcodes to 2CF9H</div></div>
									<div class="assembly-row-combined"><div>2CF6</div><div>INC C <span class="opcode2">0C</span></div><div>Increment the field width (tracked in in Register C)</div></div>
									<div class="assembly-row-combined"><div>2CF7-2CF8</div><div><a href="#2CEBH" class="memory-link">DJNZ 2CEBH <span class="origrom2">DJNZ LPSTRF</span></a><span class="opcode2">10 F2</span></div><div>Decrement the USING string's length in Register B and loop back to keep scanning for the field terminator or more characters</div></div>
									<p class="debug-note" id="2CF9H">If we are here, then a string 
field was not found.  The "USING" string character count and the pointer
 into its data MUST be restored and the "\" printed.</p>
									<div class="assembly-row-combined"><div>2CF9 <span class="origrom2">NOSTRF</span></div><div>POP HL <span class="opcode2">E1</span></div><div>Restore the pointer to the "USING" string's data into Register Pair HL</div></div>
									<div class="assembly-row-combined"><div>2CFA</div><div>LD B,E <span class="opcode2">43</span></div><div>Load Register B with the USING string's length</div></div>
									<div class="assembly-row-combined"><div>2CFB-2CFC</div><div>LD A,25H <span class="origrom2">LD A,CSTRNG</span>  <span class="opcode2">3E 25</span></div><div>Restore the character into Register Adiv&gt;</div></div>
									<p class="debug-note">At this point we need to print the character held in Register A since it wasn't part of any field</p>
									<div class="assembly-row-combined" id="2CFDH"><div>2CFD-2CFF <span class="origrom2">NEWUCH</span></div><div><a href="#2E49H" class="memory-link">CALL 2E49H <span class="origrom2">CALL PLSPRT</span></a><span class="opcode2">CD 49 2E</span></div><div>If a <span class="code">+</span> came before the character, make sure to print it</div></div>
									<div class="assembly-row-combined" id="2D00H"><div>2D00-2D02</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Once that has been printed, now we print the character in Register A since we know it isn't part of a field</div></div>
									<div class="assembly-row-combined" id="2D03H"><div>2D03 <span class="origrom2">PRCCHR</span></div><div>XOR A <span class="opcode2">AF</span></div><div>We
 need to set Register Pair DE to 0 so that if we jump away, some of the 
flags are already ZERO, thus preventing us from printing a second "+".  
To do this, first zero Register A and clear the flags</div></div>
									<div class="assembly-row-combined"><div>2D04</div><div>LD E,A <span class="opcode2">5F</span></div><div>Zero Register E</div></div>
									<div class="assembly-row-combined"><div>2D05</div><div>LD D,A <span class="opcode2">57</span></div><div>Zero Register D</div></div>
									<div class="assembly-row-combined" id="2D06H"><div>2D06-2D08 <span class="origrom2">PLSFIN</span></div><div><a href="#2E49H" class="memory-link">CALL 2E49H <span class="origrom2">CALL PLSPRT</span></a><span class="opcode2">CD 49 2E</span></div><div>Go print a leading <span class="code">+</span> if necessary (i.e., to allow for multiple plusses)</div></div>
									<div class="assembly-row-combined"><div>2D09</div><div>LD D,A <span class="opcode2">57</span></div><div>Set
 the "plus flag" in Register D based on Register A.  Note, since this is
 a loop, A could (and is) set to different values below.</div></div>
									<div class="assembly-row-combined"><div>2D0A</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the next field description character in the USING string</div></div>
									<div class="assembly-row-combined"><div>2D0B</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the USING string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2D0C-2D0D</div><div>CP 21H <span class="origrom2">CP "!"</span>  <span class="opcode2">FE 21</span></div><div>Check to see if the character in Register A is a <span class="code">!</span>
 (which represents a single string character).  If they match, the Z 
FLAG is set, and otherwise the NZ FLAG is set.  If A &lt; the checked 
value, then the C FLAG is set.  If A &gt;= the checked value, the NC 
FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2D0E-2D10</div><div><a href="#2E14H" class="memory-link">JP Z,2E14H <span class="origrom2">JP Z,SMSTRF</span></a><span class="opcode2">CA 14 2E</span></div><div>Jump if the character in Register A is a <span class="code">!</span></div></div>
									<div class="assembly-row-combined"><div>2D11-2D12</div><div>CP 23H <span class="origrom2">CP "#"</span>  <span class="opcode2">FE 23</span></div><div>Check to see if the character in Register A is a <span class="code">#</span>
 (which represents the start of a numeric field).  If they match, the Z 
FLAG is set, and otherwise the NZ FLAG is set.  If A &lt; the checked 
value, then the C FLAG is set.  If A &gt;= the checked value, the NC 
FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2D13-2D14</div><div><a href="#2D4CH" class="memory-link">JR Z,2D4CH <span class="origrom2">JR Z,NUMNUM</span></a><span class="opcode2">28 37</span></div><div>Jump if the character in Register A is a <span class="code">#</span></div></div>
									<div class="assembly-row-combined"><div>2D15</div><div>DEC B <span class="opcode2">05</span></div><div>Since
 every other possibility is actually a two character field, decrement 
the value of the string's length in Register B onem ore time</div></div>
									<div class="assembly-row-combined"><div>2D16-2D18</div><div><a href="#2DFEH" class="memory-link">JP Z,2DFEH <span class="origrom2">JP Z,REUSIN</span></a><span class="opcode2">CA FE 2D</span></div><div>If the USING list is exhausted (because we have a Z from that DEC), JUMP to REUSIN to reuse the USING string.</div></div>
									<p class="debug-note">Now we parse all the 2 character USING fields.</p>
									<div class="assembly-row-combined"><div>2D19-2D1A</div><div>CP 2BH <span class="origrom2">CP "+"</span>  <span class="opcode2">FE 2B</span></div><div>Check to see if the character in Register A is a <span class="code">+</span>
 (i.e., a leading PLUS).  If they match, the Z FLAG is set, and 
otherwise the NZ FLAG is set.  If A &lt; the checked value, then the C 
FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2D1B-2D1C</div><div>LD A,08H <span class="opcode2">3E 08</span></div><div>Set Register A to feed Register D (at the top of the loop) with an 08H to force a leading <span class="code">+</span> in case a numeric field starts</div></div>
									<div class="assembly-row-combined"><div>2D1D-2D1E</div><div><a href="#2D06H" class="memory-link">JR Z,2D06H <span class="origrom2">JR Z,PLSFIN</span></a><span class="opcode2">28 E7</span></div><div>Jump if the character in Register A was a <span class="code">+</span></div></div>
									<div class="assembly-row-combined"><div>2D1F</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the USING string pointer so we can re-get the character.</div></div>
									<div class="assembly-row-combined"><div>2D20</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the (current) character at the location of the USING string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2D21</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the USING string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2D22-2D23</div><div>CP 2EH <span class="origrom2">CP "."</span>  <span class="opcode2">FE 2E</span></div><div>Check to see if the character in Register A is a <span class="code">.</span>
 (i.e., a numeric field with trailing digits).  If they match, the Z 
FLAG is set, and otherwise the NZ FLAG is set.  If A &lt; the checked 
value, then the C FLAG is set.  If A &gt;= the checked value, the NC 
FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2D24-2D25</div><div><a href="#2D66H" class="memory-link">JR Z,2D66H <span class="origrom2">JR Z,DOTNUM</span></a><span class="opcode2">28 40</span></div><div>Jump if the character in Register A is a <span class="code">.</span> to scan with Register E holding the number of digits before the "." as 0</div></div>
									<div class="assembly-row-combined"><div>2D26-2D27</div><div>CP 25H <span class="origrom2">CP CSTRNG</span>  <span class="opcode2">FE 25</span></div><div>Check to see if the character in Register A is a <span class="code">%</span>
 (i.e., a really big string field).  If they match, the Z FLAG is set, 
and otherwise the NZ FLAG is set.  If A &lt; the checked value, then the
 C FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2D28-2D29</div><div><a href="#2CE7H" class="memory-link">JR Z,2CE7H <span class="origrom2">JR Z,BGSTRF</span></a><span class="opcode2">28 BD</span></div><div>Jump to see if it is really a string field if the character in Register A is a <span class="code">%</span></div></div>
									<div class="assembly-row-combined"><div>2D2A</div><div>CP (HL) <span class="opcode2">BE</span></div><div>Check
 to see if the next character matches the current character in the the 
USING string.  If they match, the Z FLAG is set, and otherwise the NZ 
FLAG is set.  If A &lt; the checked value, then the C FLAG is set.  If A
 &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2D2B-2D2C</div><div><a href="#2CFDH" class="memory-link">JR NZ,2CFDH <span class="origrom2">JR NZ,NEWUCH</span></a><span class="opcode2">20 D0</span></div><div>If the NZ flag is set, then we can't have a <span class="code">$$</span> or a <span class="code">**</span> , so all remaining possibilities are exhausted, so JUMP to NEWUCH</div></div>
									<div class="assembly-row-combined"><div>2D2D-2D2E</div><div>CP 24H <span class="origrom2">CP "$"</span>  <span class="opcode2">FE 24</span></div><div>Check to see if the double character is a <span class="code">$</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2D2F-2D30</div><div><a href="#2D45H" class="memory-link">JR Z,2D45H <span class="origrom2">JR Z,DOLRNM</span></a><span class="opcode2">28 14</span></div><div>Jump to set up the flag bit if the match is <span class="code">$$</span></div></div>
									<div class="assembly-row-combined"><div>2D31-2D32</div><div>CP 2AH <span class="origrom2">CP "*"</span>  <span class="opcode2">FE 2A</span></div><div>Check to see if the double character is a <span class="code">**</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2D33-2D34</div><div><a href="#2CFDH" class="memory-link">JR NZ,2CFDH <span class="origrom2">JR NZ,NEWUCH</span></a><span class="opcode2">20 C8</span></div><div>If
 the NZ FLAG is set, then the character is simply not part of a field 
since all the possibilties have been tested.  If so, JUMP</div></div>
									<div class="assembly-row-combined"><div>2D35</div><div>LD A,B <span class="opcode2">78</span></div><div>Prepare to test to see if the "USING" string is long enough for a <span class="code">**$</span> by first loading Register A with the USING string's length</div></div>
									<div class="assembly-row-combined"><div>2D36-2D37</div><div>CP 02H <span class="opcode2">FE 02</span></div><div>Check
 to see if the USING string's length in Register A is at least two.  If 
they match, the Z FLAG is set, and otherwise the NZ FLAG is set.  If A 
&lt; the checked value, then the C FLAG is set.  If A &gt;= the checked 
value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2D38</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the USING string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2D39-2D3A</div><div><a href="#2D3EH" class="memory-link">JR C,2D3EH <span class="origrom2">JR C,NOTSPC</span></a><span class="opcode2">38 03</span></div><div>Jump to 2D3EH if the USING string's length in Register A isn't at least two</div></div>
									<div class="assembly-row-combined"><div>2D3B</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the USING string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2D3C-2D3D</div><div>CP 24H <span class="origrom2">CP "$"</span>  <span class="opcode2">FE 24</span></div><div>Check to see if the character in Register A is a <span class="code">$</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined" id="2D3EH"><div>2D3E-2D3F <span class="origrom2"><br>NOTSPC</span></div><div>LD A,20H <span class="opcode2">3E 20</span></div><div>Set the <span class="code">*</span> bit in Register A</div></div>
									<div class="assembly-row-combined"><div>2D40-2D41</div><div><a href="#2D49H" class="memory-link">JR NZ,2D49H <span class="origrom2">JR NZ,SPCNUM</span></a><span class="opcode2">20 07</span></div><div>If we did not ultimately get a <span class="code">**$</span> then JUMP (noting we do NOT set the dollar sign flag)</div></div>
									<div class="assembly-row-combined"><div>2D42</div><div>DEC B <span class="opcode2">05</span></div><div>Decrement the value of the USING string's length to take the <span class="code">$</span> into account</div></div>
									<div class="assembly-row-combined"><div>2D43</div><div>INC E <span class="opcode2">1C</span></div><div>Bump the field width tracker to account for the floating dollar sign</div></div>
									<div class="assembly-row-combined"><div>2D44-2D45</div><div>CP 0AFH <span class="opcode2">FE AF</span></div><div>Z-80 Trick to skip over a <span class="code">XOR A</span> if passing through by processing it as a <span class="code">CP AFH</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined" id="2D45H"><div>2D45 <span class="origrom2">DOLRNM</span></div><div>XOR A <span class="opcode2">AF</span></div><div>This is <span class="code">$</span> processing for PRINT USING.  Clear Register A.</div></div>
									<div class="assembly-row-combined"><div>2D46-2D47</div><div>ADD A,10H <span class="opcode2">C6 10</span></div><div>Mask Register A to set the bit for a floating dollar sign flag.</div></div>
									<div class="assembly-row-combined"><div>2D48</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the USING string pointer in HL to go past the special characters</div></div>
									<div class="assembly-row-combined" id="2D49H"><div>2D49 <span class="origrom2">SPCNUM</span></div><div>INC E <span class="opcode2">1C</span></div><div>Since two characters specify the field size, start off with E=1</div></div>
									<div class="assembly-row-combined"><div>2D4A</div><div>ADD A,D <span class="opcode2">82</span></div><div>Combine the bits in Register D into the flag tracker</div></div>
									<div class="assembly-row-combined"><div>2D4B</div><div>LD D,A <span class="opcode2">57</span></div><div>Preserve the modified flag tracker into Register D.</div></div>
									<div class="assembly-row-combined" id="2D4CH"><div>2D4C <span class="origrom2">NUMNUM</span></div><div>INC E <span class="opcode2">1C</span></div><div>Bump the number of characters to the left of the decimal point in Register E</div></div>
									<div class="assembly-row-combined"><div>2D4D-2D4E</div><div>LD C,00H <span class="opcode2">0E 00</span></div><div>Set the number of digits to the right of the decimal point (tracked in Register C) to 0</div></div>
									<div class="assembly-row-combined"><div>2D4F</div><div>DEC B <span class="opcode2">05</span></div><div>Check to see if there are any more characters by decrementing the value of the string's length in Register B</div></div>
									<div class="assembly-row-combined"><div>2D50-2D51</div><div><a href="#2D99H" class="memory-link">JR Z,2D99H <span class="origrom2">JR Z,ENDNUS</span></a><span class="opcode2">28 47</span></div><div>If
 the Z FLAG is set because we ran out of the characters to scan, then 
JUMP to ENDNUS because we are done scanning this particular numeric 
field.</div></div>
									<div class="assembly-row-combined"><div>2D52</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the next character at the location of the USING string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2D53</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the USING string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2D54-2D55</div><div>CP 2EH <span class="origrom2">CP "."</span>  <span class="opcode2">FE 2E</span></div><div>Check to see if the character in Register A is a <span class="code">.</span>
 (i.e., a trailing digit).  If they match, the Z FLAG is set, and 
otherwise the NZ FLAG is set.  If A &lt; the checked value, then the C 
FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2D56-2D57</div><div><a href="#2D70H" class="memory-link">JR Z,2D70H <span class="origrom2">JR Z,AFTDOT</span></a><span class="opcode2">28 18</span></div><div>If yes, then need to use a special scan loop to scan after the decimal point, so JUMP to AFTDOT</div></div>
									<div class="assembly-row-combined"><div>2D58-2D59</div><div>CP 23H <span class="origrom2">CP "#"</span>  <span class="opcode2">FE 23</span></div><div>Check to see if the character in Register A is a <span class="code">#</span>
 (i.e., a leading digit).  If they match, the Z FLAG is set, and 
otherwise the NZ FLAG is set.  If A &lt; the checked value, then the C 
FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2D5A-2D</div><div><a href="#2D4CH" class="memory-link">JR Z,2D4CH <span class="origrom2">JR Z,NUMNUM</span></a><span class="opcode2">28 F0</span></div><div>If yes, increment the count and keep scanning via a JUMP to NUMNUM</div></div>
									<div class="assembly-row-combined"><div>2D5C-2D5D</div><div>CP 2CH <span class="origrom2">CP ","</span>  <span class="opcode2">FE 2C</span></div><div>Check to see if the character in Register A is a <span class="code">,</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2D5E-2D5F</div><div><a href="#2D7AH" class="memory-link">JR NZ,2D7AH <span class="origrom2">JR NZ,FINNUM</span></a><span class="opcode2">20 1A</span></div><div>If there is no comma, then JUMP to FINNUM because there are no more leading digits and we need to check for "^^^"</div></div>
									<div class="assembly-row-combined"><div>2D60</div><div>LD A,D <span class="opcode2">7A</span></div><div>If we are here, then a comma was requested.  Turn on the COMMA bit</div></div>
									<div class="assembly-row-combined"><div>2D61-2D62</div><div>OR 40H <span class="opcode2">F6 40</span></div><div>Mask the flag in Register A for <span class="code">,</span></div></div>
									<div class="assembly-row-combined"><div>2D63</div><div>LD D,A <span class="opcode2">57</span></div><div>Load Register D with the value of the flag in Register A</div></div>
									<div class="assembly-row-combined"><div>2D64-2D65</div><div><a href="#2D4CH" class="memory-link">JR 2D4CH <span class="origrom2">JR NUMNUM</span></a><span class="opcode2">18 E6</span></div><div>Jump to 2D4CH to keep scanning</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2D66H">2D66 - Part of the PRINT USING Routine <span class="origrom">- "DOTNUM"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Jumped here when a "." is seen in the USING string.  THis 
means that we are starting a numeric field ONLY if it is followed by a 
"#"</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2D66 <span class="origrom2">DOTNUM</span></div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the next character of the USING string</div></div>
									<div class="assembly-row-combined"><div>2D67-2D68</div><div>CP 23H <span class="opcode2">FE 23</span></div><div>Check to see if the character in Register A is a <span class="code">#</span>
 (i.e., a numeric field following a ".").  If they match, the Z FLAG is 
set, and otherwise the NZ FLAG is set.  If A &lt; the checked value, 
then the C FLAG is set.  If A &gt;= the checked value, the NC FLAG is 
set.</div></div>
									<div class="assembly-row-combined"><div>2D69-2D6A</div><div>LD A,2EH <span class="origrom2">LD A,"."</span>  <span class="opcode2">3E 2E</span></div><div>Load Register A with a decimal point</div></div>
									<div class="assembly-row-combined"><div>2D6B-2D6C</div><div><a href="#2CFDH" class="memory-link">JR NZ,2CFDH <span class="origrom2">JR NZ,NEWUCH</span></a><span class="opcode2">20 90</span></div><div>If it isn't a "." then JUMP AWAY to NEWUCH with A holding a "." so that a "." will get printed</div></div>
									<div class="assembly-row-combined"><div>2D6D-2D6E</div><div>LD C,01H <span class="opcode2">0E 01</span></div><div>If
 it was a "." then we have a numeric field to process.  First, set C 
with the number of characters to the right of the decimal point</div></div>
									<div class="assembly-row-combined"><div>2D6F</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the USING string pointer in HL</div></div>
									<div class="assembly-row-combined" id="2D70H"><div>2D70 <span class="origrom2">AFTDOT</span></div><div>INC C <span class="opcode2">0C</span></div><div>Bump the number of digits to the right of the decimal point (tracked in Register C)</div></div>
									<div class="assembly-row-combined"><div>2D71</div><div>DEC B <span class="opcode2">05</span></div><div>Decrement the value of the USING STRING's length to test to see if there are more characters</div></div>
									<div class="assembly-row-combined"><div>2D72-2D73</div><div><a href="#2D99H" class="memory-link">JR Z,2D99H <span class="origrom2">JR Z,ENDNUS</span></a><span class="opcode2">28 25</span></div><div>If the USING string length is now ZERO, JUMP to ENDNUS to stop scanning</div></div>
									<div class="assembly-row-combined"><div>2D74</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the USING string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2D75</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the USING string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2D76-2D77</div><div>CP 23H <span class="opcode2">FE 23</span></div><div>Check to see if the character in Register A is a <span class="code">#</span>
 ; meaning that there are more digits after the decimal point.  If they 
match, the Z FLAG is set, and otherwise the NZ FLAG is set.  If A &lt; 
the checked value, then the C FLAG is set.  If A &gt;= the checked 
value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2D78-2D79</div><div><a href="#2D70H" class="memory-link">JR Z,2D70H <span class="origrom2">JR Z,AFTDOT</span></a><span class="opcode2">28 F6</span></div><div>If there are more digits, JUMP to AFTDOT to increment the count and keep scanning</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2D7AH">2D7A - Part of the PRINT USING Routine <span class="origrom">- "FINNUM"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Now we move on to check the "^^^^" that indicates scientific notation</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2D7AH"><div>2D7A <span class="origrom2">FINNUM</span></div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the value of the flag (tracked in D) and the number of leading digits (tracked in E) to the STACK</div></div>
									<div class="assembly-row-combined"><div>2D7B-2D7D</div><div>LD DE,2D97H <span class="origrom2">LD DE,NOTSCI</span>  <span class="opcode2">11 97 2D</span></div><div>Load DE with the return address in case this is not a scientific notation</div></div>
									<div class="assembly-row-combined"><div>2D7E</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the value of the return address in DE to the STACK</div></div>
									<div class="assembly-row-combined"><div>2D7F<br>2D80</div><div>LD D,H<br>LD E,L <span class="opcode2">54</span></div><div>Let DE = HL in case we need to rememer HL</div></div>
									<div class="assembly-row-combined"><div>2D81-2D82</div><div>CP 5BH <span class="opcode2">FE 5B</span></div><div>Check
 to see if the character in Register A is an up arrow.  If they match, 
the Z FLAG is set, and otherwise the NZ FLAG is set.  If A &lt; the 
checked value, then the C FLAG is set.  If A &gt;= the checked value, 
the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2D83</div><div>RET NZ <span class="opcode2">C0</span></div><div>Return if the character in Register A isn't an up arrow</div></div>
									<div class="assembly-row-combined" id="2D84H"><div>2D84</div><div>CP (HL) <span class="opcode2">BE</span></div><div>Check
 to see if the character at the location of the USING string pointer in 
HL is an up arrow.  If they match, the Z FLAG is set, and otherwise the 
NZ FLAG is set.  If A &lt; the checked value, then the C FLAG is set.  
If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2D85</div><div>RET NZ <span class="opcode2">C0</span></div><div>Return to 2D97 if the character at the location of the USING string pointer in HL isn't an up arrow (meaning we do not have a <span class="code">^^</span> format)</div></div>
									<div class="assembly-row-combined" id="2D86H"><div>2D86</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the USING string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2D87</div><div>CP (HL) <span class="opcode2">BE</span></div><div>Check
 to see if there is a third up arrow at the location of the USING string
 pointer in HL.  If they match, the Z FLAG is set, and otherwise the NZ 
FLAG is set.  If A &lt; the checked value, then the C FLAG is set.  If A
 &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2D88</div><div>RET NZ <span class="opcode2">C0</span></div><div>Return to 2D97 if the character at the location of the USING string pointer in HL isn't an up arrow (meaning we do not have a <span class="code">^^^</span> format)</div></div>
									<div class="assembly-row-combined" id="2D89H"><div>2D89</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the USING string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2D8A</div><div>CP (HL) <span class="opcode2">BE</span></div><div>Check
 to see if the character at the location of the USING string pointer in 
HL is a fourth up arrow.  If they match, the Z FLAG is set, and 
otherwise the NZ FLAG is set.  If A &lt; the checked value, then the C 
FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2D8B</div><div>RET NZ <span class="opcode2">C0</span></div><div>Return to 2D97 if the character at the location of the USING string pointer in HL isn't an up arrow (meaning we do not have a <span class="code">^^^^</span> format)</div></div>
									<div class="assembly-row-combined" id="2D8CH"><div>2D8C</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the USING string pointer in HL.  If we are here we have a <span class="code">#.^^^^</span> format</div></div>
									<div class="assembly-row-combined"><div>2D8D</div><div>LD A,B <span class="opcode2">78</span></div><div>Now we need to check if there were enough characters for a <span class="code">^^^^</span> .  First load Register A with the value of the USING string's length in Register B</div></div>
									<div class="assembly-row-combined"><div>2D8E-2D8F</div><div>SUB 04H <span class="opcode2">D6 04</span></div><div>Check to see if there are at least 4 characters left in the USING string</div></div>
									<div class="assembly-row-combined"><div>2D90</div><div>RET C <span class="opcode2">D8</span></div><div>Return to 2D97 if there aren't at least four characters left in the USING string</div></div>
									<div class="assembly-row-combined" id="2D91H"><div>2D91</div><div>POP DE <span class="opcode2">D1</span></div><div>If there are at least 4 characters left, then clean up the STACK by removing the NOTSCI return address</div></div>
									<div class="assembly-row-combined"><div>2D92</div><div>POP DE <span class="opcode2">D1</span></div><div>Get the flag and the count of the characters to the left of the decimal point from the STACK and put it in DE</div></div>
									<div class="assembly-row-combined"><div>2D93</div><div>LD B,A <span class="opcode2">47</span></div><div>Load Register B with the new USING string's length in Register A</div></div>
									<div class="assembly-row-combined"><div>2D94</div><div>INC D <span class="opcode2">14</span></div><div>Set the exponential notation flag (tracked in Register D)</div></div>
									<div class="assembly-row-combined"><div>2D95</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the USING string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2D96</div><div>JP Z,0D1EBH <span class="opcode2">CA EB D1</span></div><div>Z-80
 Trick! If passing through this won't do anything because the Z FLAG 
won't be set AND the EX DE,HL won't be executed because it doesn't see 
that instruction.</div></div>
									<div class="assembly-row-combined"><div>2D97 <span class="origrom">"NOTSCI"</span></div><div>EX DE,HL <span class="opcode2">EB</span></div><div>(Ignored if passing through) Restore the old HL into HL</div></div>
									<div class="assembly-row-combined"><div>2D98</div><div>POP DE <span class="opcode2">D1</span></div><div>(Ignored if passing through) Restore the flags into Register D and the number of leading digits into Register E</div></div>
									<div class="assembly-row-combined" id="2D99H"><div>2D99 <span class="origrom2">ENDNUS</span></div><div>LD A,D <span class="opcode2">7A</span></div><div>We need to test to see if the 'leading plus' flag is on, so we load Register A with the value of the edit flag in Register D</div></div>
									<div class="assembly-row-combined"><div>2D9A</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the USING string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2D9B</div><div>INC E <span class="opcode2">1C</span></div><div>Bump the number of characters to the left of the decimal point in Register E to take into account the leading plus</div></div>
									<div class="assembly-row-combined"><div>2D9C-2D9D</div><div>AND 08H<span class="origrom2">AND 00001000</span> <span class="opcode2">E6 08</span></div><div>Mask Register A to NOT check for a trailing sign</div></div>
									<div class="assembly-row-combined"><div>2D9E-2D9F</div><div><a href="#2DB5H" class="memory-link">JR NZ,2DB5H <span class="origrom2">JR NZ,ENDNUM</span></a><span class="opcode2">20 15</span></div><div>If that AND leaves us with a NZ, then we are all done with the field, so JUMP to ENDNUM</div></div>
									<div class="assembly-row-combined"><div>2DA0</div><div>DEC E <span class="opcode2">1D</span></div><div>Otherwise,
 since we don't have a leading plus, we don't increment the number of 
digits before the decimal point ... so decrement the number of 
characters to the left of the decimal point in Register E</div></div>
									<div class="assembly-row-combined"><div>2DA1</div><div>LD A,B <span class="opcode2">78</span></div><div>Check to see if there are more characters by first loading Register A with the USING string's length from Register B</div></div>
									<div class="assembly-row-combined"><div>2DA2</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if this is the end of the USING string</div></div>
									<div class="assembly-row-combined"><div>2DA3-2DA4</div><div><a href="#2DB5H" class="memory-link">JR Z,2DB5H <span class="origrom2">JR Z,ENDNUM</span></a><span class="opcode2">28 10</span></div><div>If we are out of characters, then we are all done, so JUMP to ENDNUM</div></div>
									<div class="assembly-row-combined"><div>2DA5</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>If there ARE more characters, then fill Register A with the character at the location of the USING string pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2DA6-2DA7</div><div>SUB 2DH <span class="origrom2">SUB "-"</span>  <span class="opcode2">D6 2D</span></div><div>Check to see if the character in Register A is a <span class="code">-</span> (i.e., a trailing minus)</div></div>
									<div class="assembly-row-combined"><div>2DA8-2DA9</div><div><a href="#2DB0H" class="memory-link">JR Z,2DB0H <span class="origrom2">JR Z,SGNTRL</span></a><span class="opcode2">28 06</span></div><div>If it is, then JUMP to SGNTRL to set the trailing sign flag</div></div>
									<div class="assembly-row-combined"><div>2DAA-2DAB</div><div>CP 0FEH <span class="origrom2">CP "+" - "-"</span>  <span class="opcode2">FE FE</span></div><div>Check to see if the character in Register A is a <span class="code">+</span>
 (i.e., a trailing plus).  If they match, the Z FLAG is set, and 
otherwise the NZ FLAG is set.  If A &lt; the checked value, then the C 
FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2DAC-2DAD</div><div><a href="#2DB5H" class="memory-link">JR NZ,2DB5H <span class="origrom2">JR NZ,ENDNUM</span></a><span class="opcode2">20 07</span></div><div>If its NOT, then we are done scanning, so JUMP to ENDNUM</div></div>
									<div class="assembly-row-combined"><div>2DAE-2DAF</div><div>LD A,08H <span class="opcode2">3E 08</span></div><div>If we are here then we did have a trailing "+" so first set the flag for a POSITIVE "+"</div></div>
									<div class="assembly-row-combined" id="2DB0H"><div>2DB0-2DB1 <span class="origrom2">SGNTRL</span></div><div>ADD A,04H <span class="opcode2">C6 04</span></div><div>Then set the flag for a trailing sign</div></div>
									<div class="assembly-row-combined"><div>2DB2</div><div>ADD A,D <span class="opcode2">82</span></div><div>Combine the value of the flag in Register D with the value of the flag in Register A</div></div>
									<div class="assembly-row-combined"><div>2DB3</div><div>LD D,A <span class="opcode2">57</span></div><div>Load Register D with the current flags</div></div>
									<div class="assembly-row-combined"><div>2DB4</div><div>DEC B <span class="opcode2">05</span></div><div>Decrement the value of the USING string's length in Register B by 1 to account for the trailing sign</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2DB5H">2DB5 - Part of the PRINT USING Routine <span class="origrom">- "ENDNUM"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Jump point for when we figure out that we are at the end of a string of digits within a USING string</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2DB5 <span class="origrom2">ENDNUM</span></div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the current BASIC program pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2DB6</div><div>POP AF <span class="opcode2">F1</span></div><div>Load Register A with the flag that tells us whether there are more values to process in the value list.</div></div>
									<div class="assembly-row-combined"><div>2DB7-2DB8</div><div><a href="#2E09H" class="memory-link">JR Z,2E09H <span class="origrom2">JR Z,FLDFIN</span></a><span class="opcode2">28 50</span></div><div>If there are no more values in the value list to process, then JUMP to FLDFIN because we are done with the PRINT</div></div>
									<div class="assembly-row-combined"><div>2DB9</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save
 the number of characters remaining to be processed in the USING string 
(held in B) and the trailing digits (held in C) to the STACK</div></div>
									<div class="assembly-row-combined"><div>2DBA</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the flags (held in D) and the number of leading digits (held in E) to the STACK</div></div>
									<div class="assembly-row-combined"><div>2DBB-2DBD</div><div><a href="#2337H" class="memory-link">CALL 2337H <span class="origrom2">CALL FRMEVL</span></a><span class="opcode2">CD 37 23</span></div><div>Read
 a value from the value list by CALLING the routine to evaluate the 
expression at the location of the current BASIC program pointer and 
return with the result in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>2DBE</div><div>POP DE <span class="opcode2">D1</span></div><div>Restore the flags (held in D) and the number of leading digits (held in E) from the STACK</div></div>
									<div class="assembly-row-combined"><div>2DBF</div><div>POP BC <span class="opcode2">C1</span></div><div>Restore
 the number of characters remaining to be processed in the USING string 
(held in B) and the trailing digits (held in C) from the STACK</div></div>
									<div class="assembly-row-combined"><div>2DC0</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save
 the number of characters remaining to be processed in the USING string 
(held in B) and the trailing digits (held in C) to the STACK</div></div>
									<div class="assembly-row-combined"><div>2DC1</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2DC2</div><div>LD B,E <span class="opcode2">43</span></div><div>Set Register B to hold the number of leading digits (i.e., the number of characters to the left of the decimal point)</div></div>
									<div class="assembly-row-combined"><div>2DC3</div><div>LD A,B <span class="opcode2">78</span></div><div>We
 need to test to make sure the total number if digits does not exceed 
24, so first load Register A with the number of characters to the left 
of the decimal point in Register B</div></div>
									<div class="assembly-row-combined"><div>2DC4</div><div>ADD A,C <span class="opcode2">81</span></div><div>Then
 add the number of characters to the right of the decimal point in 
Register C to the number of characters to the left of the decimal point 
in Register A</div></div>
									<div class="assembly-row-combined"><div>2DC5-2DC6</div><div>CP 19H <span class="opcode2">FE 19</span></div><div>Check
 to see if the total number of characters in Register A is greater than 
24.  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set.
  If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2DC7-2DC9</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E4AH" class="memory-link">JP NC,1E4AH <span class="origrom2">JP NC,FCERR</span></a><span class="opcode2">D2 4A 1E</span></div><div>Display a FC ERROR message if the total number of digits is greater than 24</div></div>
									<div class="assembly-row-combined"><div>2DCA</div><div>LD A,D <span class="opcode2">7A</span></div><div>Load Register A with the flags (held in Register D)</div></div>
									<div class="assembly-row-combined"><div>2DCB-2DCC</div><div>OR 80H <span class="opcode2">F6 80</span></div><div>Turn on the "USING" bit in the flags</div></div>
									<div class="assembly-row-combined"><div>2DCD-2DCF</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0FBEH" class="memory-link">CALL 0FBEH <span class="origrom2">CALL PUFOUT</span></a><span class="opcode2">CD BE 0F</span></div><div>Prepare
 to print by calling the FLOATING TO ASCII routine at 0FBEH (whcih 
converts a single or double precision number in ACCumulator to its ASCII
 equivalent which will be stored at the buffer pointed to by HL using 
the format codes in the A, B, and C registers</div></div>
									<div class="assembly-row-combined"><div>2DD0-2DD2</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#28A7H" class="memory-link">CALL 28A7H <span class="origrom2">CALL STROUT</span></a><span class="opcode2">CD A7 28</span></div><div>Call the WRITE MESSAGE routine at 28A7H to print the message pointed to by HL.<br><span class="bold">NOTE:</span><br><ul><li>The routine at 28A7 displays the message pointed to by HL on current system output device (usually video).</li><li>The string to be displayed must be terminated by a byte of machine zeros or a carriage return code 0D.</li><li>If terminated with a carriage return, control is returned to the caller after taking the DOS exit at 41D0H (JP 5B99H).</li></ul></div></div>
									<div class="assembly-row-combined" id="2DD3H"><div>2DD3 <span class="origrom2">FNSTRF</span></div><div>POP HL <span class="opcode2">E1</span></div><div>Top of a loop.  Get the value of the current BASIC program pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2DD4</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the current BASIC program pointer in HL so we can test to see what the terminator was</div></div>
									<div class="assembly-row-combined"><div>2DD5</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined"><div>2DD6</div><div>SCF <span class="opcode2">37</span></div><div>Set the Carry flag to indicate that a CRLF is desired</div></div>
									<div class="assembly-row-combined"><div>2DD7-2DD8</div><div><a href="#2DE6H" class="memory-link">JR Z,2DE6H <span class="origrom2">JR Z,CRDNUS</span></a><span class="opcode2">28 0D</span></div><div>If
 the character at the location of the current BASIC program pointer in 
Register A is an end of the BASIC statement character, then we need to 
print a CRLF, so JUMP to CRDNUS</div></div>
									<div class="assembly-row-combined"><div>2DD9-2DDB</div><div>LD (40DEH),A <span class="origrom2">LD (FLGINP),A</span>  <span class="opcode2">32 DE 40</span></div><div>Set the flag that the value HAS been printed!</div></div>
									<div class="assembly-row-combined"><div>2DDC-2DDD</div><div>CP 3BH <span class="origrom2">CP ";"</span>  <span class="opcode2">FE 3B</span></div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in Register A is a semicolon.  If they match, the Z FLAG is set,
 and otherwise the NZ FLAG is set.  If A &lt; the checked value, then 
the C FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2DDE-2DDF</div><div><a href="#2DE5H" class="memory-link">JR Z,2DE5H <span class="origrom2">JR Z,SEMUSN</span></a><span class="opcode2">28 05</span></div><div>If so, then we have a legal delimiter, so JUMP to SEMUSN</div></div>
									<div class="assembly-row-combined"><div>2DE0-2DE1</div><div>CP 2CH <span class="origrom2">CP ","</span>  <span class="opcode2">FE 2C</span></div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in Register A is a comma.  If they match, the Z FLAG is set, and
 otherwise the NZ FLAG is set.  If A &lt; the checked value, then the C 
FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2DE2-2DE4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1997H" class="memory-link">JP NZ,1997H <span class="origrom2">JP NZ,SNERR</span></a><span class="opcode2">C2 97 19</span></div><div>If
 not a comma, then we have no more valid delimiters (it wasnt a ";" or a
 ",") so go to the Level II BASIC error routine and display an SN ERROR 
message if the character at the location of the current BASIC program 
pointer in Register A isn't a comma</div></div>
									<div class="assembly-row-combined" id="2DE5H"><div>2DE5 <span class="origrom2">SEMUSN</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D78H" class="memory-link">RST 10H <span class="origrom2">CHRGET</span></a><span class="opcode2">D7</span></div><div>We need the next character in the BASIC program so call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><br>The
 RST 10H routine parses the characters starting at HL+1 for the first 
non-SPACE,non-09H,non-0BH character it finds.  On exit, Register A will 
hold that character, and the C FLAG is set if its alphabetic, and NC 
FLAG if its alphanumeric.  All strings must have a 00H at the end.</div></div>
									<div class="assembly-row-combined" id="2DE6H"><div>2DE6 <span class="origrom2">CRDNUS</span></div><div>POP BC <span class="opcode2">C1</span></div><div>Restore the number of characters remaining to be procesed in the USING string into Register B</div></div>
									<div class="assembly-row-combined"><div>2DE7</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap DE and HL so that DE will point to the location of the current BASIC program pointer.  We don't care about HL.</div></div>
									<div class="assembly-row-combined"><div>2DE8</div><div>POP HL <span class="opcode2">E1</span></div><div>Restore the position in the USING string from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2DE9</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the position in the USING string (held in HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>2DEA</div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the flag that indicates whether or not the value list has terminated to the STACK</div></div>
									<div class="assembly-row-combined"><div>2DEB</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the value of the current BASIC program pointer (held in DE) to the STACK</div></div>
									<p class="debug-note">The original ROM source code indicates 
that since FRMEVL may have forced some garbage collection, we cannot 
rely on the pointer of characters remaining to be scanned.  Instead, we 
have to use the number of characters scanned prior to calling FRMEVL as 
an offset to the "USING" string's data after FRMEVL.</p>
									<div class="assembly-row-combined"><div>2DEC</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the USING string's length at the location of the USING string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2DED</div><div>SUB B <span class="opcode2">90</span></div><div>Subtract the number of characers which were already scanned</div></div>
									<div class="assembly-row-combined"><div>2DEE</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the pointer to the "USING" strings string data</div></div>
									<div class="assembly-row-combined"><div>2DEF</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Load Register C with the LSB of the USING string's address at the location of the USING string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2DF0</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the USING string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2DF1</div><div>LD H,(HL) <span class="opcode2">66</span></div><div>Load Register H with the MSB of the USING string's address at the location of the USING string's VARPTR in HL</div></div>
									<div class="assembly-row-combined"><div>2DF2</div><div>LD L,C <span class="opcode2">69</span></div><div>Load Register L with the LSB of the USING string's address in Register C</div></div>
									<div class="assembly-row-combined"><div>2DF3-2DF4</div><div>LD D,00H <span class="opcode2">16 00</span></div><div>Zero Register D so that Register Pair DE can be a 16 bit offset of whatever is held in A.</div></div>
									<div class="assembly-row-combined"><div>2DF5</div><div>LD E,A <span class="opcode2">5F</span></div><div>Load Register E with the USING string's offset in Register A</div></div>
									<div class="assembly-row-combined"><div>2DF6</div><div>ADD HL,DE <span class="opcode2">19</span></div><div>Add
 the USING string's offset in DE to the USING string's address in HL to 
get us the new pointer into the USING string's string data into HL</div></div>
									<div class="assembly-row-combined"><div>2DF7</div><div>LD A,B <span class="opcode2">78</span></div><div>Load Register A with the number of characters left to scan</div></div>
									<div class="assembly-row-combined"><div>2DF8</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if this is the end of the USING string</div></div>
									<div class="assembly-row-combined"><div>2DF9-2DFB</div><div><a href="#2D03H" class="memory-link">JP NZ,2D03H <span class="origrom2">JP NZ,PRCCHR</span></a><span class="opcode2">C2 03 2D</span></div><div>If there are still more string characters to scan, JUMP to PRCCHR to do so</div></div>
									<div class="assembly-row-combined"><div>2DFC-2DFD</div><div><a href="#2E04H" class="memory-link">JR 2E04H <span class="origrom2">JR FINUSI</span></a><span class="opcode2">18 06</span></div><div>Jump to 2E04H if this is the actual end of the entire USING string</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2DFEH">2DFE-2E00 - Part of the PRINT USING Routine <span class="origrom">- "REUSIN"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>We will wind up here when we are done processing a numeric field</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2E00H"><div>2DFE-2E00 <span class="origrom2">REUSIN</span></div><div><a href="#2E49H" class="memory-link">CALL 2E49H <span class="origrom2">CALL PLSPRT</span></a><span class="opcode2">CD 49 2E</span></div><div>GOSUB to 2E49H print a <span class="code">+</span> if necessary</div></div>
									<div class="assembly-row-combined"><div>2E01-2E03</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go send the FINAL character (held in Register A) to the current output device</div></div>
									<div class="assembly-row-combined" id="2E04H"><div>2E04 <span class="origrom2">FINUSI</span></div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the current BASIC program pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2E05</div><div>POP AF <span class="opcode2">F1</span></div><div>Restore the flag which indicates whether or not the value list has ended into Register A</div></div>
									<div class="assembly-row-combined"><div>2E06-2E08</div><div><a href="#2CCBH" class="memory-link">JP NZ,2CCBH <span class="origrom2">JP NZ,REUSST</span></a><span class="opcode2">C2 CB 2C</span></div><div>If the value list has NOT ended, JUMP back to REUSST to reuse the USING string</div></div>
									<div class="assembly-row-combined" id="20FEH"><div>2E09-2E0B <span class="origrom2">FLDFIN</span></div><div><a href="#20FEH" class="memory-link">CALL C,20FEH <span class="origrom2">CALL C,CRDO</span></a><span class="opcode2">DC FE 20</span></div><div>If we are here, then we didn't have a <span class="code">,</span> or <span class="code">;</span> after the PRINT USING, so we GOSUB to 20FEH to send a carriage return to the current output device if necessary</div></div>
									<div class="assembly-row-combined"><div>2E0C</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Swap
 (SP) with HL so that HL will now point to the "USING" string's 
descriptor and (SP) will hold the value of the current BASIC program 
pointer</div></div>
									<div class="assembly-row-combined"><div>2E0D-2E0F</div><div><a href="#29DDH" class="memory-link">CALL 29DDH <span class="origrom2">CALL FRETM2</span></a><span class="opcode2">CD DD 29</span></div><div>Free the RAM holding the USING string</div></div>
									<div class="assembly-row-combined"><div>2E10</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the current BASIC program pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2E11-2E13</div><div><a href="#2169H" class="memory-link">JP 2169H <span class="origrom2">JP FINPRT</span></a><span class="opcode2">C3 69 21</span></div><div>Return to 2169H</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2E14H">2E14-2E15 - Part of the PRINT USING Routine <span class="origrom">- "SMSTRF"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>We will wind up here when the "!" indicating a single character string field has been scanned</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2E14H"><div>2E14-2E15 <span class="origrom2">SMSTRF</span></div><div>LD C,01H <span class="opcode2">0E 01</span></div><div>Set the field width to 1</div></div>
									<div class="assembly-row-combined"><div>2E16-2E17</div><div>LD A,0F1H <span class="opcode2">3E F1</span></div><div>Z-80 Trick.  By putting a 3E in front of the F1 (which is <span class="code">POP AF</span> , to clear the STACK) that <span class="code">POP AF</span> gets skipped if flowing down in the code</div></div>
									<div class="assembly-row-combined" id="2E17H"><div>2E17 <span class="origrom2">ISSTRF</span></div><div>POP AF <span class="opcode2">F1</span></div><div>(Skipped
 if passing down) Clear the STACK *dumping the HL that was being saved 
in case it turned out that this wasn't actually a string)</div></div>
									<div class="assembly-row-combined"><div>2E18</div><div>DEC B <span class="opcode2">05</span></div><div>Decrement the USING string character count (tracked in Register B)</div></div>
									<div class="assembly-row-combined"><div>2E19-2E1B</div><div><a href="#2E49H" class="memory-link">CALL 2E49H <span class="origrom2">CALL PLSPRT</span></a><span class="opcode2">CD 49 2E</span></div><div>If there was a "+" before the field, then print it</div></div>
									<div class="assembly-row-combined"><div>2E1C</div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the current BASIC program pointer from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2E1D</div><div>POP AF <span class="opcode2">F1</span></div><div>Get the flag which indicates whether there are more values in the value list into Register A</div></div>
									<div class="assembly-row-combined"><div>2E1E-2E1F</div><div><a href="#2E09H" class="memory-link">JR Z,2E09H <span class="origrom2">JR Z,FLDFIN</span></a><span class="opcode2">28 E9</span></div><div>If there are no more values in the value list, then we are done so JUMP back to 2E09H</div></div>
									<div class="assembly-row-combined"><div>2E20</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the number of characters still to be scanned from the USING string (tracked in B) to the STACK</div></div>
									<div class="assembly-row-combined"><div>2E21-2E23</div><div><a href="#2337H" class="memory-link">CALL 2337H <span class="origrom2">CALL FRMEVL</span></a><span class="opcode2">CD 37 23</span></div><div>Read
 a value by GOSUBing to FRMEVL which will evaluate the expression at the
 location of the current BASIC program pointer in HL and return with the
 result in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>2E24-2E26</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0AF4H" class="memory-link">CALL 0AF4H <span class="origrom2">CALL CHKSTR</span></a><span class="opcode2">CD F4 0A</span></div><div>Go make sure the current result in ACCumulator is a string</div></div>
									<div class="assembly-row-combined"><div>2E27</div><div>POP BC <span class="opcode2">C1</span></div><div>Restore the field width (a/k/a the number of characters to be printed) into Register C</div></div>
									<div class="assembly-row-combined"><div>2E28</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the USING string's length and the number of characters to be printed in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>2E29</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the current BASIC program pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2E2A-2E2C</div><div>LD HL,(4121H) <span class="origrom2">LD HL,(FACLO)</span>  <span class="opcode2">2A 21 41</span></div><div>Load HL with the string's VARPTR in ACCumulator</div></div>
									<div class="assembly-row-combined"><div>2E2D</div><div>LD B,C <span class="opcode2">41</span></div><div>Load Register B with field width (a/k/a the number of characters to be printed)</div></div>
									<div class="assembly-row-combined"><div>2E2E-2E2F</div><div>LD C,00H <span class="opcode2">0E 00</span></div><div>Zero Register C so that we can use the LEFT$ routine</div></div>
									<div class="assembly-row-combined"><div>2E30</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the length of the string to be printed in Register B to the STACK (as we will need that for space padding)</div></div>
									<div class="assembly-row-combined"><div>2E31-2E33</div><div><a href="#2A68H" class="memory-link">CALL 2A68H <span class="origrom2">CALL LEFTUS</span></a><span class="opcode2">CD 68 2A</span></div><div>Truncate the string to B characters via a call to the LEFT$ routine</div></div>
									<div class="assembly-row-combined"><div>2E34-2E36</div><div><a href="#28AAH" class="memory-link">CALL 28AAH <span class="origrom2">CALL STRPRT</span></a><span class="opcode2">CD AA 28</span></div><div>Print the string to the current output device</div></div>
									<div class="assembly-row-combined"><div>2E37-2E39</div><div>LD HL,(4121H) <span class="origrom2">LD HL,(FACLO)</span>  <span class="opcode2">2A 21 41</span></div><div>Load HL with the string's VARPTR in ACCumulator so we can see if we need to pad the string</div></div>
									<div class="assembly-row-combined"><div>2E3A</div><div>POP AF <span class="opcode2">F1</span></div><div>Get the field width (a/k/a the length of the string to be printed) from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>2E3B</div><div>SUB (HL) <span class="opcode2">96</span></div><div>Determine
 the amount of padding needed into Register A by subtracting the 
string's length at the location of the string's VARPTR in HL from the 
length of the string to be printed in Register A</div></div>
									<div class="assembly-row-combined"><div>2E3C</div><div>LD B,A <span class="opcode2">47</span></div><div>Save the amount of padding needed into Register B</div></div>
									<div class="assembly-row-combined"><div>2E3D-2E3E</div><div>LD A,20H <span class="opcode2">3E 20</span></div><div>Load Register A with a <kbd>SPACE</kbd> </div></div>
									<div class="assembly-row-combined"><div>2E3F</div><div>INC B <span class="opcode2">04</span></div><div>Bump the number of spaces in Register B because the loop startes with a DEC B</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="this-loop-will">This loop will print all the spaces needed and then jump to 2DD3H.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2E40H"><div>2E40 <span class="origrom2">UPRTSP</span></div><div>DEC B <span class="opcode2">05</span></div><div>Top of a loop.  Decrement the number of spaces in Register B</div></div>
									<div class="assembly-row-combined"><div>2E41-2E43</div><div><a href="#2DD3H" class="memory-link">JP Z,2DD3H <span class="origrom2">JP Z,FNSTRF</span></a><span class="opcode2">CA D3 2D</span></div><div>If all of the spaces have been printed, Jump back to 2DD3H to see if the value list ended and to resume scanning</div></div>
									<div class="assembly-row-combined"><div>2E44-2E46</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go send a space to the current output device</div></div>
									<div class="assembly-row-combined"><div>2E47-2E48</div><div><a href="#2E40H" class="memory-link">JR 2E40H <span class="origrom2">JR UPRTSP</span></a><span class="opcode2">18 F7</span></div><div>LOOP back to 2E40H to print all the spaces</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2E49H">2E49 - Part of the PRINT USING Routine <span class="origrom">- "PLSPRT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>When a "+" is detected in the "USING" string and a numeric field follows, a bit in Register D should be set, otherwise <span class="code">+</span>
 should be printed.  Since deciding whether a numeric field follows is 
very difficult, the bit is always set in Register D.  At the point it is
 decided a character is not part of a numeric field, this routine is 
called to see if the bit in Register D is set, which means a plus 
preceded the character and should be printed</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2E49 <span class="origrom2">PLSPRT</span></div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the current character (held in Register A) to the STACK</div></div>
									<div class="assembly-row-combined"><div>2E4A</div><div>LD A,D <span class="opcode2">7A</span></div><div>We need to test the PLUS BIT in D, so first load Register A with the value in Register D</div></div>
									<div class="assembly-row-combined"><div>2E4B</div><div>OR A <span class="opcode2">B7</span></div><div>Check
 to see if Register A is equal to zero as that would be the ONLY bit 
which could be turned on at this particular point in the routine.</div></div>
									<div class="assembly-row-combined"><div>2E4C-2E4D</div><div>LD A,2BH <span class="origrom2">LD A,"+"</span>  <span class="opcode2">3E 2B</span></div><div>Prepare to print the <span class="code">+</span> by loading Register A with a <span class="code">+</span></div></div>
									<div class="assembly-row-combined"><div>2E4E-2E50</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL NZ,032AH <span class="origrom2">CALL NZ,OUTDO</span></a><span class="opcode2">C4 2A 03</span></div><div>If the bit was set (i.e., A was non-zero), then send a <span class="code">+</span> to the current output device</div></div>
									<div class="assembly-row-combined"><div>2E51</div><div>POP AF <span class="opcode2">F1</span></div><div>Get the current character from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>2E52</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2E53H">2E53-2FFA - LEVEL II BASIC <span class="code">EDIT</span> ROUTINE <span class="origrom">- "ERREDT"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>According to the original ROM source, the EDIT command takes a
 single line number as its argument.  If that line doesn't exist, and 
error is thrown.  If the line does exist, the line number is then typed,
 and the system waits for the user to enter any of the valid commands.<br><br>Register
 C holds the number of characters in the line, Register B holds the 
current character position (with 0 being the first character) and 
Register Pair HL points to the current character</p>
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2E53H"><div>2E53-2E55 <span class="origrom2">ERREDT</span></div><div>LD (409AH),A <span class="origrom2">LD (ERRFLG),A</span>  <span class="opcode2">32 9A 40</span></div><div>Reset the EDIT flag.<br>Note: 409AH holds the ERROR/RESUME flag</div></div>
									<div class="assembly-row-combined"><div>2E56-2E58</div><div>LD HL,(40EAH) <span class="origrom2">LD HL,(ERRLIN)</span>  <span class="opcode2">2A EA 40</span></div><div>Load HL with the line number to be edited.<br>Note: 40EAH-40EBH holds the line number with error</div></div>
									<div class="assembly-row-combined"><div>2E59</div><div>OR H <span class="opcode2">B4</span></div><div>OR Register A with the MSB of the error line number in Register H</div></div>
									<div class="assembly-row-combined"><div>2E5A</div><div>AND L <span class="opcode2">A5</span></div><div>Combine
 the LSB of the error line number in Register L with the MSB of the line
 number in Register A.  It will be FFH if this was a direct command 
rather than being part of a program</div></div>
									<div class="assembly-row-combined"><div>2E5B</div><div>INC A <span class="opcode2">3C</span></div><div>Bump
 the combined value of the error line number in Register A.  If this was
 a direct call from the command line, this will turn A from FFH into 00H</div></div>
									<div class="assembly-row-combined"><div>2E5C</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Swap DE and HL so that DE now holds the line number to edit.</div></div>
									<div class="assembly-row-combined"><div>2E5D</div><div>RET Z <span class="opcode2">C8</span></div><div>If there was no line number, return if Level II BASIC</div></div>
									<div class="assembly-row-combined" id="2E5EH"><div>2E5E-2E5F</div><div><a href="#2E64H" class="memory-link">JR 2E64H <span class="origrom2">JR EREDIT</span></a><span class="opcode2">18 04</span></div><div>otherwise, continue via a JUMP to 2E64H</div></div>
									<p class="debug-note" id="2E60H">Now that the above code is out
 of the way (it was the code which would enter EDIT if there was an 
error in a line number), let us actually process the <span class="code">EDIT</span> command</p>
									<div class="assembly-row-combined"><div>2E60-2E62 <span class="origrom2">EDIT</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E4FH" class="memory-link">CALL 1E4FH <span class="origrom2">CALL LINSPC</span></a><span class="opcode2">CD 4F 1E</span></div><div>Get the first line number by calling 1E4F - returns in in DE</div></div>
									<div class="assembly-row-combined"><div>2E63</div><div>RET NZ <span class="opcode2">C0</span></div><div>If the zero flag got set, there was no line number, so return</div></div>
									<div class="assembly-row-combined" id="2E64H"><div>2E64 <span class="origrom2">EREDIT</span></div><div>POP HL <span class="opcode2">E1</span></div><div>Clean up the STACK (i.e., discard the NEWSTT return address)</div></div>
									<div class="assembly-row-combined" id="2E65H"><div>2E65 <span class="origrom2">EEDITS</span></div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load HL with the line number to be edited in DE</div></div>
									<div class="assembly-row-combined"><div>2E66-2E68</div><div>LD (40ECH),HL <span class="origrom2">LD (DOT),HL</span>  <span class="opcode2">22 EC 40</span></div><div>Save the value of the line number to be edited (in HL) to the memory location that cares about such things.<br>Note: 40ECH-40EDH holds EDIT/LIST line number</div></div>
									<div class="assembly-row-combined"><div>2E69</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load HL with the line number to be edited</div></div>
									<div class="assembly-row-combined"><div>2E6A-2E6C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1B2CH" class="memory-link">CALL 1B2CH <span class="origrom2">CALL FNDLIN</span></a><span class="opcode2">CD 2C 1B</span></div><div>Find
 that line number via a GOSUB to the SEARCH FOR LINE NUMBER routine at 
1B2CH which looks for the line number specified in DE. Returns C/Z with 
the line found in BC, NC/Z with line number is too large and HL/BC 
having the next available location, or NC/NZ with line number not found,
 and BC has the first available one after that</div></div>
									<div class="assembly-row-combined"><div>2E6D-2E6F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1ED9H" class="memory-link">JP NC,1ED9H <span class="origrom2">JP NC,USERR</span></a><span class="opcode2">D2 D9 1E</span></div><div>If the BASIC line number doesn't exist, display a <span class="code">?UL ERROR</span></div></div>
									<div class="assembly-row-combined"><div>2E70<br>2E71</div><div>LD H,B<br>LD L,C <span class="opcode2">60</span></div><div>At
 this point, the line number has been found.  Let HL=BC so that HL also 
points to the location in RAM of the line number being edited</div></div>
									<div class="assembly-row-combined"><div>2E72<br>2E73</div><div>INC HL<br>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL twice to now point to the first byte of the line.</div></div>
									<div class="assembly-row-combined"><div>2E74</div><div>LD C,(HL) <span class="opcode2">4E</span></div><div>Load Register C with first byte of the line number being edited</div></div>
									<div class="assembly-row-combined"><div>2E75</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL to point to the second byte of the line being edited</div></div>
									<div class="assembly-row-combined"><div>2E76</div><div>LD B,(HL) <span class="opcode2">46</span></div><div>Load Register B with second byte of the line number being edited</div></div>
									<div class="assembly-row-combined"><div>2E77</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the memory pointer in HL to now point to the first byte of the actual line</div></div>
									<div class="assembly-row-combined"><div>2E78</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the line number to the STACK</div></div>
									<div class="assembly-row-combined"><div>2E79-2E7B</div><div><a href="#2B7EH" class="memory-link">CALL 2B7EH <span class="origrom2">CALL BUFLIN</span></a><span class="opcode2">CD 7E 2B</span></div><div>GOSUB
 to 2B7EH move the BASIC line at the location of the memory pointer in 
HL into a memory buffer and untokenize the BASIC line</div></div>
									<div class="assembly-row-combined" id="2E7CH"><div>2E7C <span class="origrom2">LLED</span></div><div>POP HL <span class="opcode2">E1</span></div><div>Get the value of the line number from the STACK and put it in HL</div></div>
									<div class="assembly-row-combined"><div>2E7D <span class="origrom2">INLED</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the line number in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2E7E-2E80</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0FAFH" class="memory-link">CALL 0FAFH <span class="origrom2">CALL LINPRT</span></a><span class="opcode2">CD AF 0F</span></div><div>Convert
 the line number to ASCII and print it out by calling the HL TO ASCII 
routine at 0FAFH (which converts the value in the HL (assumed to be an 
integer) to ASCII and display it at the current cursor position on the 
video screen)</div></div>
									<div class="assembly-row-combined"><div>2E81-2E82</div><div>LD A,20H <span class="opcode2">3E 20</span></div><div>Load Register A with a space</div></div>
									<div class="assembly-row-combined"><div>2E83-2E85</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go display the space in Register A</div></div>
									<div class="assembly-row-combined"><div>2E86-2E88</div><div>LD HL,(40A7H) <span class="origrom2">LD HL,(BUFPNT)</span>  <span class="opcode2">2A A7 40</span></div><div>Load HL with the starting address of the expanded version of the current line from the input buffer.<br>Note: 40A7H-40A8H holds the input Buffer pointer</div></div>
									<div class="assembly-row-combined"><div>2E89-2E8A</div><div>LD A,0EH <span class="opcode2">3E 0E</span></div><div>Load Register A with the "turn on the cursor" character</div></div>
									<div class="assembly-row-combined"><div>2E8B-2E8D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go turn on the cursor</div></div>
									<div class="assembly-row-combined"><div>2E8E</div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the input buffer pointer (in HL) to the STACK</div></div>
									<div class="assembly-row-combined"><div>2E8F-2E90</div><div>LD C,FFH <span class="opcode2">0E FF</span></div><div>Load
 Register C with the number of characters examined so far with FFH 
because the next line is going to INC it by 1 to make it 0</div></div>
									<div class="assembly-row-combined" id="2E91H"><div>2E91 <span class="origrom2">LENLP</span></div><div>INC C <span class="opcode2">0C</span></div><div>Bump the number of characters examined so far in Register C</div></div>
									<div class="assembly-row-combined"><div>2E92</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2E93</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if the character in Register A is an end of the BASIC line character</div></div>
									<div class="assembly-row-combined"><div>2E94</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2E95-2E96</div><div><a href="#2E91H" class="memory-link">JR NZ,2E91H <span class="origrom2">JR NZ,LENLP</span></a><span class="opcode2">20 FA</span></div><div>Loop back to 2E91H until the end of the BASIC line has been found</div></div>
									<div class="assembly-row-combined"><div>2E97</div><div>POP HL <span class="opcode2">E1</span></div><div>At this point, C will be the maximum number of characters in the line at issue.  Put the start of the expanded buffer into HL</div></div>
									<div class="assembly-row-combined"><div>2E98</div><div>LD B,A <span class="opcode2">47</span></div><div>Set the current position in the BASIC line being edited (tracked by Register B) to ZERO</div></div>
									<div class="assembly-row-combined"><div>2E99-2E9A <span class="origrom2">DISPED</span></div><div>LD D,00H <span class="opcode2">16 00</span></div><div>Assume the repetition count for the upcoming command (tracked by Register D) is zero</div></div>
									<div class="assembly-row-combined" id="2E9BH"><div>2E9B-2E9D <span class="origrom2">DISPI</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0384H" class="memory-link">CALL 0384H <span class="origrom2">CALL INCHR</span></a><span class="opcode2">CD 84 03</span></div><div>Go scan the keyboard to wait for the user command</div></div>
									<div class="assembly-row-combined"><div>2D9E-2E9F <span class="origrom2">DISP</span></div><div>SUB 30H <span class="opcode2">20 15</span></div><div>We need to test to see if the character was alphabetic or alphanumeric so we subtract 30H from it</div></div>
									<div class="assembly-row-combined" id="2EB0H"><div>2EA0-2EA1</div><div><a href="#2EB0H" class="memory-link">JR C,2EB0H <span class="origrom2">JR C,NOTDGI</span></a><span class="opcode2">38 0E</span></div><div>Jump down to 2EB0H if the character in Register A is alphabetic</div></div>
									<div class="assembly-row-combined"><div>2EA2-2EA3</div><div>CP 0AH <span class="opcode2">FE 0A</span></div><div>Check
 to see if the character is Register A is numeric.  If they match, the Z
 FLAG is set, and otherwise the NZ FLAG is set.  If A &lt; the checked 
value, then the C FLAG is set.  If A &gt;= the checked value, the NC 
FLAG is set.</div></div>
									<div class="assembly-row-combined" id="2EB0H"><div>2EA4-2EA5</div><div><a href="#2EB0H" class="memory-link">JR NC,2EB0H <span class="origrom2">JR NC,NOTDGI</span></a><span class="opcode2">30 0A</span></div><div>Jump to 2EB0H if the character in Register A isn't numeric</div></div>
									<div class="assembly-row-combined"><div>2EA6</div><div>LD E,A <span class="opcode2">5F</span></div><div>Load Register E with the binary value of the character in Register A</div></div>
									<div class="assembly-row-combined"><div>2EA7</div><div>LD A,D <span class="opcode2">7A</span></div><div>Put the repetition value into Register A</div></div>
									<div class="assembly-row-combined"><div>2EA8</div><div>RLCA <span class="opcode2">07</span></div><div>Multiply the value in Register A by two (so now A has multiplied by 2)</div></div>
									<div class="assembly-row-combined"><div>2EA9</div><div>RLCA <span class="opcode2">07</span></div><div>Multiply the value in Register A by two (so now A has multiplied by 4)</div></div>
									<div class="assembly-row-combined"><div>2EAA</div><div>ADD A,D <span class="opcode2">82</span></div><div>Add the value in Register D to the value in Register A (so now A has multiplied by 5)</div></div>
									<div class="assembly-row-combined"><div>2EAB</div><div>RLCA <span class="opcode2">07</span></div><div>Multiply the value in Register A by two (so now A has multiplied by 10).  Now the "ones place" is empty.</div></div>
									<div class="assembly-row-combined"><div>2EAC</div><div>ADD A,E <span class="opcode2">83</span></div><div>Add the value in Register E to the value in Register A in the "ones place"</div></div>
									<div class="assembly-row-combined"><div>2EAD</div><div>LD D,A <span class="opcode2">57</span></div><div>Load Register D with the value in Register A</div></div>
									<div class="assembly-row-combined"><div>2EAE-2EAF</div><div><a href="#2E9BH" class="memory-link">JR 2E9BH <span class="origrom2">JR DISPI</span></a><span class="opcode2">18 EB</span></div><div>Loop until a nonnumeric character is pressed</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2EB0H">2EB0H - LEVEL II BASIC <span class="code">EDIT</span> ROUTINE <span class="origrom">- "NOTDGI"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>While getting user command input within an edit, we wind up 
here if the user enters a non-numeric character (i.e., the actual 
command, and not just the repetition number which precedes it)</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2EB0 <span class="origrom2">NOTDGI</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the input buffer pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2EB1-2EB3</div><div>LD HL,2E99H <span class="origrom2">LD HL,DISPED</span>  <span class="opcode2">21 99 2E</span></div><div>Load HL with the return address of 2E99H</div></div>
									<div class="assembly-row-combined"><div>2EB4</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Exchange the value of the return address in HL with the value of the input buffer pointer to the STACK</div></div>
									<div class="assembly-row-combined"><div>2EB5</div><div>DEC D <span class="opcode2">15</span></div><div>We
 need to test if the command was preceded by a number so we need to set 
the flags by first decrementing the numeric value in Register D</div></div>
									<div class="assembly-row-combined"><div>2EB6</div><div>INC D <span class="opcode2">14</span></div><div>... and then incrementing the numeric value in Register D to set the flags</div></div>
									<div class="assembly-row-combined"><div>2EB7-2EB9</div><div><a href="#2EBBH" class="memory-link">JP NZ,2EBBH <span class="origrom2">JP NZ,NTZERD</span></a><span class="opcode2">C2 BB 2E</span></div><div>If we had a received a repetition count already, then JUMP to 2EBBH</div></div>
									<div class="assembly-row-combined"><div>2EBA</div><div>INC D <span class="opcode2">14</span></div><div>Otherwise, set the repetition count (held in Register D) to be one</div></div>
									<div class="assembly-row-combined" id="2EBBH"><div>2EBB-2EBC <span class="origrom2">NTZERD</span></div><div>CP 0D8H <span class="opcode2">FE D8</span></div><div>Check to see if the character in Register A is a <kbd>BACKSPACE</kbd>
 character.  If they match, the Z FLAG is set, and otherwise the NZ FLAG
 is set.  If A &lt; the checked value, then the C FLAG is set.  If A 
&gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2EBD-2EBF</div><div><a href="#2FD2H" class="memory-link">JP Z,2FD2H <span class="origrom2">JP Z,DELED</span></a><span class="opcode2">CA D2 2F</span></div><div>If the character in Register A is a <kbd>BACKSPACE</kbd> character, JUMP to DELED</div></div>
									<div class="assembly-row-combined"><div>2EC0-2EC1</div><div>CP 0DDH <span class="opcode2">FE DD</span></div><div>Check to see if the character in Register A is a <kbd>CARRIAGE RETURN</kbd>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2EC2-2EC4</div><div><a href="#2FE0H" class="memory-link">JP Z,2FE0H <span class="origrom2">JP Z,CRED</span></a><span class="opcode2">CA E0 2F</span></div><div>If the character in Register A is a <kbd>CARRIAGE RETURN</kbd> , JUMP to CRED</div></div>
									<div class="assembly-row-combined"><div>2EC5-2EC6</div><div>CP 0F0H <span class="opcode2">FE F0</span></div><div>Check to see if the character in Register A is a <kbd>SPACE</kbd>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2EC7-2EC8</div><div><a href="#2F0AH" class="memory-link">JR Z,2F0AH <span class="origrom2">JR Z,SPED</span></a><span class="opcode2">28 41</span></div><div>If the character in Register A is a <kbd>SPACE</kbd> , JUMP to SPED</div></div>
									<p class="debug-note">That's it for non-alphabetic instructions, so we need to need to convert a lower case command to upper case</p>
									<div class="assembly-row-combined"><div>2EC9-2ECA</div><div>CP 31H <span class="opcode2">FE 31</span></div><div>Check
 to see if the character in Register A is lowercase.  If they match, the
 Z FLAG is set, and otherwise the NZ FLAG is set.  If A &lt; the checked
 value, then the C FLAG is set.  If A &gt;= the checked value, the NC 
FLAG is set.</div></div>
									<div class="assembly-row-combined" id="2ECFH"><div>2ECB-2ECC</div><div><a href="#2ECFH" class="memory-link">JR C,2ECFH <span class="origrom2">JR C,NOTLW4</span></a><span class="opcode2">38 02</span></div><div>Jump if the character in Register A isn't lowercase</div></div>
									<div class="assembly-row-combined"><div>2ECD-2ECE</div><div>SUB 20H <span class="opcode2">D6 20</span></div><div>Convert the lowercase character in Register A to uppercase</div></div>
									<div class="assembly-row-combined" id="2ECFH"><div>2ECF-2ED0 <span class="origrom2">NOTLW4</span></div><div>CP 21H <span class="opcode2">FE 21</span></div><div>Check to see if the character in Register A is a <kbd>Q</kbd>
 (i.e., QUIT the edit).  If they match, the Z FLAG is set, and otherwise
 the NZ FLAG is set.  If A &lt; the checked value, then the C FLAG is 
set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2ED1-2ED3</div><div><a href="#2FF6H" class="memory-link">JP Z,2FF6H <span class="origrom2">JP Z,QED</span></a><span class="opcode2">CA F6 2F</span></div><div>Jump if the character in Register A is a <kbd>Q</kbd> (i.e., QUIT)</div></div>
									<div class="assembly-row-combined"><div>2ED4-2ED5</div><div>CP 1CH <span class="opcode2">FE 1C</span></div><div>Check to see if the character in Register A is an <kbd>L</kbd>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2ED6-2ED7</div><div><a href="#2F40H" class="memory-link">JP Z,2F40H <span class="origrom2">JP Z,LED</span></a><span class="opcode2">CA 40 2F</span></div><div>Jump if the character in Register A is an <kbd>L</kbd> (i.e., BRANCH)</div></div>
									<div class="assembly-row-combined"><div>2ED9-2EDA</div><div>CP 23H <span class="opcode2">FE 23</span></div><div>Check to see if the character in Register A is an <kbd>S</kbd>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2EDB-2EDC</div><div><a href="#2F1CH" class="memory-link">JR Z,2F1CH <span class="origrom2">JR Z,SED</span></a><span class="opcode2">28 3F</span></div><div>Jump if the character in Register A is an <kbd>S</kbd> (i.e., SEARCH)</div></div>
									<div class="assembly-row-combined"><div>2EDD-2EDE</div><div>CP 19H <span class="opcode2">FE 19</span></div><div>Check to see if the character in Register A is an <kbd>I</kbd>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2EDF-2EE1</div><div><a href="#2F7DH" class="memory-link">JP Z,2F7DH <span class="origrom2">JP Z,IED</span></a><span class="opcode2">CA 7D 2F</span></div><div>Jump if the character in Register A is an <kbd>I</kbd> (i.e., INSERT)</div></div>
									<div class="assembly-row-combined"><div>2EE2-2EE3</div><div>CP 14H <span class="opcode2">FE 14</span></div><div>Check to see if the character in Register A is a <kbd>D</kbd>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2EE4-2EE6</div><div><a href="#2F4AH" class="memory-link">JP Z,2F4AH <span class="origrom2">JP Z,DED</span></a><span class="opcode2">CA 4A 2F</span></div><div>Jump if the character in Register A is a <kbd>D</kbd> (i.e., DELETE)</div></div>
									<div class="assembly-row-combined"><div>2EE7-2EE8</div><div>CP 13H <span class="opcode2">FE 13</span></div><div>Check to see if the character in Register A is a <kbd>C</kbd>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2EE9-2EEB</div><div><a href="#2F65H" class="memory-link">JP Z,2F65H <span class="origrom2">JP Z,CED</span></a><span class="opcode2">CA 65 2F</span></div><div>Jump if the character in Register A is a <kbd>C</kbd> (i.e., CHANGE)</div></div>
									<div class="assembly-row-combined"><div>2EEC-2EED</div><div>CP 15H <span class="opcode2">FE 15</span></div><div>Check to see if the character in Register A is an <kbd>E</kbd>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2EEE-2EF0</div><div><a href="#2FE3H" class="memory-link">JP Z,2FE3H <span class="origrom2">JP Z,EED</span></a><span class="opcode2">CA E3 2F</span></div><div>Jump if the character in Register A is an <kbd>E</kbd> (i.e., END)</div></div>
									<div class="assembly-row-combined"><div>2EF1-2EF2</div><div>CP 28H <span class="opcode2">FE 28</span></div><div>Check to see if the character in Register A is an <kbd>X</kbd>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2EF3-2EF5</div><div><a href="#2F78H" class="memory-link">JP Z,2F78H <span class="origrom2">JP Z,XED</span></a><span class="opcode2">CA 78 2F</span></div><div>Jump if the character in Register A is an <kbd>X</kbd> (i.e., EXTEND)</div></div>
									<div class="assembly-row-combined"><div>2EF6-2EF7</div><div>CP 1BH <span class="opcode2">FE 1B</span></div><div>Check to see if the character in Register A is a <kbd>K</kbd>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2EF8-2EF9</div><div><a href="#2F16H" class="memory-link">JR Z,2F16H <span class="origrom2">JR Z,KED</span></a><span class="opcode2">28 1C</span></div><div>Jump if the character in Register A is a <kbd>K</kbd> (i.e., KILL)</div></div>
									<div class="assembly-row-combined"><div>2EFA-2EFB</div><div>CP 18H <span class="opcode2">FE 18</span></div><div>Check to see if the character in Register A is an <kbd>H</kbd>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2EFC-2EFE</div><div><a href="#2F75H" class="memory-link">JP Z,2F75H <span class="origrom2">JP Z,HED</span></a><span class="opcode2">CA 75 2F</span></div><div>Jump if the character in Register A is an <kbd>H</kbd> (i.e., HACK off the rest of the line and then enter INSERT mode)</div></div>
									<div class="assembly-row-combined" id="2F00H"><div>2EFF-2F00</div><div>CP 11H <span class="opcode2">FE 11</span></div><div>Check to see if the character in Register A is an <kbd>A</kbd>
 (i.e., AGAIN).  If they match, the Z FLAG is set, and otherwise the NZ 
FLAG is set.  If A &lt; the checked value, then the C FLAG is set.  If A
 &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2F01</div><div>RET NZ <span class="opcode2">C0</span></div><div>Return if the character in Register A isn't an <kbd>A</kbd> </div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2F02H">2F02 - <span class="code">EDIT</span> Command - Cancel and Restore Logic.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2F02</div><div>POP BC <span class="opcode2">C1</span></div><div>Clean up the STACK (i.e., remove the DISPI return address)</div></div>
									<div class="assembly-row-combined"><div>2F03</div><div>POP DE <span class="opcode2">D1</span></div><div>Get the BASIC line number from the STACK and put it in DE</div></div>
									<div class="assembly-row-combined"><div>2F04-2F06</div><div><a href="#20FEH" class="memory-link">CALL 20FEH <span class="origrom2">CALL CRDO</span></a><span class="opcode2">CD FE 20</span></div><div>Go print a carriage return on the video display if necessary</div></div>
									<div class="assembly-row-combined"><div>2F07-2F09</div><div><a href="#2E65H" class="memory-link">JP 2E65H <span class="origrom2">JP EEDITS</span></a><span class="opcode2">C3 65 2E</span></div><div>Jump back to 2E65H to re-enter the <span class="code">EDIT</span> routine</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2F0AH">2F0A - This routine prints a string of text to the display, printer or tape <span class="origrom">- "SPED"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine it uses 032AH to do this.  HL must point to the 
first character of the string. (409CH must be set before calling this 
routine, see 32AH). String must be delimited with a zero byte.<br>Note: 409CH holds the current output device flag: -1=cassette, 0=video and 1=printer</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2F0A <span class="origrom2">SPED</span></div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2F0B</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if the character in Register A is an end of the BASIC line character</div></div>
									<div class="assembly-row-combined"><div>2F0C</div><div>RET Z <span class="opcode2">C8</span></div><div>Return if the character in Register A is an end of the BASIC line character</div></div>
									<div class="assembly-row-combined"><div>2F0D</div><div>INC B <span class="opcode2">04</span></div><div>Bump the character position in Register B</div></div>
									<div class="assembly-row-combined"><div>2F0E-2F10</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go display the character in Register A</div></div>
									<div class="assembly-row-combined"><div>2F11</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2F12</div><div>DEC D <span class="opcode2">15</span></div><div>Decrement the number of times to perform the operation in Register D</div></div>
									<div class="assembly-row-combined"><div>2F13-2F14</div><div><a href="#2F0AH" class="memory-link">JR NZ,2F0AH <span class="origrom2">JR NZ,SPED</span></a><span class="opcode2">20 F5</span></div><div>Loop until done</div></div>
									<div class="assembly-row-combined"><div>2F15</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2F16H">2F16 - <span class="code">EDIT</span> Command - KILL Logic <span class="origrom">- "KED"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2F16H"><div>2F16 <span class="origrom2">KED</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the current character position in the buffer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2F17-2F19</div><div>LD HL,2F5FH <span class="origrom2">LD HL,TYPSLH</span>  <span class="opcode2">21 5F 2F</span></div><div>Load HL with the return address of 2F5FH (which will print the final <span class="code">!</span></div></div>
									<div class="assembly-row-combined"><div>2F1A</div><div>EX (SP),HL <span class="opcode2">E3</span></div><div>Exchange the value of the return address in HL with the value of the input buffer pointer to the STACK</div></div>
									<div class="assembly-row-combined"><div>2F1B</div><div>SCF <span class="opcode2">37</span></div><div>Set the KILL/SEARCH flag for KILL since CARRY flag signals KILL</div></div>
									<div class="assembly-row-combined" id="2F1CH"><div>2F1C <span class="origrom2">SED</span></div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the KILL/SEARCH flag to the STACK</div></div>
									<div class="assembly-row-combined"><div>2F1D-2F1F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0384H" class="memory-link">CALL 0384H <span class="origrom2">CALL INCHR</span></a><span class="opcode2">CD 84 03</span></div><div>Go scan the keyboard for the character the user wants to SEARCH for</div></div>
									<div class="assembly-row-combined"><div>2F20</div><div>LD E,A <span class="opcode2">5F</span></div><div>Save the character the user wants to SEARCH for into Register E</div></div>
									<div class="assembly-row-combined"><div>2F21</div><div>POP AF <span class="opcode2">F1</span></div><div>Get the KILL/SEARCH flag from the STACK</div></div>
									<div class="assembly-row-combined"><div>2F22</div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the KILL/SEARCH flag to the STACK</div></div>
									<div class="assembly-row-combined"><div>2F23-2F25</div><div><a href="#2F5FH" class="memory-link">CALL C,2F5FH <span class="origrom2">CALL C,TYPSLH</span></a><span class="opcode2">DC 5F 2F</span></div><div>If KILL (because the CARRY flag was set) then GOSUB to 2F5FH to print a <span class="code">!</span></div></div>
									<div class="assembly-row-combined" id="2F26H"><div>2F26 <span class="origrom2">SRCALP</span></div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2F27</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if the character in Register A is an end of the BASIC line character</div></div>
									<div class="assembly-row-combined"><div>2F28-2F2A</div><div><a href="#2F3EH" class="memory-link">JP Z,2F3EH <span class="origrom2">JP Z,POPART</span></a><span class="opcode2">CA 3E 2F</span></div><div>Jump down to 2F3EH if the character in Register A is an end of the BASIC line character</div></div>
									<div class="assembly-row-combined"><div>2F2B-2F2D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go display the character in Register A</div></div>
									<div class="assembly-row-combined"><div>2F2E</div><div>POP AF <span class="opcode2">F1</span></div><div>Get the KILL/SEARCH flag from the STACK</div></div>
									<div class="assembly-row-combined"><div>2F2F</div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the KILL/SEARCH flag to the STACK</div></div>
									<div class="assembly-row-combined"><div>2F30-2F32</div><div><a href="#2FA1H" class="memory-link">CALL C,2FA1H <span class="origrom2">CALL C,DELCHR</span></a><span class="opcode2">DC A1 2F</span></div><div>If the CARRY flag is set, that means we are in KILL mode so GOSUB to 2FA1H to delete the character from the input buffer</div></div>
									<div class="assembly-row-combined"><div>2F33-2F34</div><div><a href="#2F37H" class="memory-link">JR C,2F37H <span class="origrom2">JR C,NOTSRC</span></a><span class="opcode2">38 02</span></div><div>Jump to 2F37H if KILL.  Note, we do not move the HL pointer in this case because DELCHR already moved it.</div></div>
									<div class="assembly-row-combined"><div>2F35</div><div>INC HL <span class="opcode2">23</span></div><div>If we are here, it must be SEARCH!  So bump to the next character</div></div>
									<div class="assembly-row-combined"><div>2F36</div><div>INC B <span class="opcode2">04</span></div><div>Bump the value of the character position in Register B</div></div>
									<div class="assembly-row-combined" id="2F37H"><div>2F37 <span class="origrom2">NOTSRC</span></div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Regardless
 of whether we are SEARCH or KILL, load Register A with the character at
 the location of the current input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2F38</div><div>CP E <span class="opcode2">BB</span></div><div>Check
 to see if the character in Register A is the same as the character to 
be located (i.e., the one specified by the user) in Register E.  If they
 match, the Z FLAG is set, and otherwise the NZ FLAG is set.  If A &lt; 
the checked value, then the C FLAG is set.  If A &gt;= the checked 
value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2F39-2F3A</div><div><a href="#2F26H" class="memory-link">JR NZ,2F26H <span class="origrom2">JR NZ,SRCALP</span></a><span class="opcode2">20 EB</span></div><div>Loop back to 2F26H until the character to be located is found</div></div>
									<div class="assembly-row-combined"><div>2F3B</div><div>DEC D <span class="opcode2">15</span></div><div>Decrement
 the number of times to perform the operation in Register D (as 
initially specified by the user by entering a number before the command)</div></div>
									<div class="assembly-row-combined"><div>2F3C-2F3D</div><div><a href="#2F26H" class="memory-link">JR NZ,2F26H <span class="origrom2">JR NZ,SRCALP</span></a><span class="opcode2">20 E8</span></div><div>Loop until done</div></div>
									<div class="assembly-row-combined" id="2F3EH"><div>2F3E <span class="origrom2">POPART</span></div><div>POP AF <span class="opcode2">F1</span></div><div>Get the KILL/SEARCH flag from the STACK</div></div>
									<div class="assembly-row-combined"><div>2F3F</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2F40H">2F40 - <span class="code">EDIT</span> Command - LIST Logic <span class="origrom">- "LED"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2F40H"><div>2F40-2F42 <span class="origrom2">LED</span></div><div><a href="#2B75H" class="memory-link">CALL 2B75H <span class="origrom2">CALL LISPRT</span></a><span class="opcode2">CD 75 2B</span></div><div>Since
 we need to display the line being edited we call the PRINT MESSAGE 
routine at 2B75H which writes string pointed to by HL to the current 
output device</div></div>
									<div class="assembly-row-combined"><div>2F43-2F45</div><div><a href="#20FEH" class="memory-link">CALL 20FEH <span class="origrom2">CALL CRDO</span></a><span class="opcode2">CD FE 20</span></div><div>Go display a carriage return if necessary</div></div>
									<div class="assembly-row-combined"><div>2F46</div><div>POP BC <span class="opcode2">C1</span></div><div>Clear off the RETURN address to DISPED</div></div>
									<div class="assembly-row-combined"><div>2F47-2F49</div><div><a href="#2E7CH" class="memory-link">JP 2E7CH <span class="origrom2">JP LLED</span></a><span class="opcode2">C3 7C 2E</span></div><div>Jump to 2E7CH (to display the current line number and await the next EDIT command)</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2F4AH">2F4A - <span class="code">EDIT</span> Command - DELETE Logic <span class="origrom">- "DED"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2F4AH"><div>2F4A <span class="origrom2">DED</span></div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2F4B</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if the character in Register A is an end of the BASIC line character</div></div>
									<div class="assembly-row-combined"><div>2F5C</div><div>RET Z <span class="opcode2">15</span></div><div>Return if the character in Register A is an end of the BASIC line character</div></div>
									<div class="assembly-row-combined" id="2F4DH"><div>2F4D-2F4E</div><div>LD A,21H <span class="origrom2">LD A,"!"</span>  <span class="opcode2">3E 21</span></div><div>Load Register A with an <span class="code">!</span></div></div>
									<div class="assembly-row-combined"><div>2F4F-2F51</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go display the <span class="code">!</span> in Register A</div></div>
									<div class="assembly-row-combined" id="2F52H"><div>2F52 <span class="origrom2">DELLP</span></div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2F53</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if the character in Register A is an end of the BASIC line character</div></div>
									<div class="assembly-row-combined"><div>2F54-2F5B</div><div><a href="#2F5FH" class="memory-link">JR Z,2F5FH <span class="origrom2">JR Z,TYPSLH</span></a><span class="opcode2">28 09</span></div><div>Jump to 2F5FH if the character in Register A is an end of the BASIC line character</div></div>
									<div class="assembly-row-combined"><div>2F56-2F58</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go display the character in Register A</div></div>
									<div class="assembly-row-combined"><div>2F59-2F5B</div><div><a href="#2FA1H" class="memory-link">CALL 2FA1H <span class="origrom2">CALL DELCHR</span></a><span class="opcode2">CD A1 2F</span></div><div>Go delete the character from the input buffer</div></div>
									<div class="assembly-row-combined"><div>2F5C</div><div>DEC D <span class="opcode2">15</span></div><div>Decrement
 the number of times to perform the operation in Register D (as 
initially specified by the user by entering a number before the command)</div></div>
									<div class="assembly-row-combined"><div>2F5D-2F5E</div><div><a href="#2F52H" class="memory-link">JR NZ,2F52H <span class="origrom2">JR NZ,DELLP</span></a><span class="opcode2">20 F3</span></div><div>Loop until done</div></div>
									<div class="assembly-row-combined" id="2F5FH"><div>2F5F-2F60 <span class="origrom2">TYPSLH</span></div><div>LD A,21H <span class="origrom2">LD A,"!"</span>  <span class="opcode2">3E 21</span></div><div>Load Register A with an <span class="code">!</span></div></div>
									<div class="assembly-row-combined"><div>2F61-2F63</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go display the ! in Register A</div></div>
									<div class="assembly-row-combined"><div>2F64</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2F65H">2F65 - <span class="code">EDIT</span> Command - CHANGE Logic <span class="origrom">- "CED"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2F65 <span class="origrom2">CED</span></div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2F66</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if the character in Register A is an end of the BASIC line character</div></div>
									<div class="assembly-row-combined"><div>2F67</div><div>RET Z <span class="opcode2">C8</span></div><div>Return if the character in Register A is an end of the BASIC line character</div></div>
									<div class="assembly-row-combined" id="2F68H"><div>2F68-2F6A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0384H" class="memory-link">CALL 0384H <span class="origrom2">CALL INCHR</span></a><span class="opcode2">CD 84 03</span></div><div>Go get the character to put in the input buffer from the keyboard</div></div>
									<div class="assembly-row-combined"><div>2F6B</div><div>LD (HL),A <span class="opcode2">77</span></div><div>Save the character in Register A at the memory location of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2F6C-2F6E</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go display the character in Register A</div></div>
									<div class="assembly-row-combined"><div>2F6F</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2F70</div><div>INC B <span class="opcode2">04</span></div><div>Bump the character position in Register B</div></div>
									<div class="assembly-row-combined"><div>2F71</div><div>DEC D <span class="opcode2">15</span></div><div>Decrement
 the number of times to perform the operation in Register D (as 
initially specified by the user by entering a number before the command)</div></div>
									<div class="assembly-row-combined"><div>2F72-2F73</div><div><a href="#2F65H" class="memory-link">JR NZ,2F65H <span class="origrom2">JR NZ,CED</span></a><span class="opcode2">20 F1</span></div><div>Loop until done</div></div>
									<div class="assembly-row-combined"><div>2F74</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2F75H">2F75 - <span class="code">EDIT</span> Command - HACK/INSERT Logic <span class="origrom">- "HED"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2F75-2F76 <span class="origrom2">HED</span></div><div>LD (HL),00H <span class="opcode2">36 00</span></div><div>Set the line end to be the current position.</div></div>
									<div class="assembly-row-combined"><div>2F77</div><div>LD C,B <span class="opcode2">48</span></div><div>Load Register C with the character position in Register B which will now be the line length</div></div>
									<div class="assembly-row-combined" id="2F78H"><div>2F78-2F79 <span class="origrom2">XED</span></div><div>LD D,0FFH <span class="opcode2">16 FF</span></div><div>Prepare for the next CALL to find the end of the line by loading Register D with the number of times to perform the operation</div></div>
									<div class="assembly-row-combined"><div>2F7A-2F7C</div><div><a href="#2F0AH" class="memory-link">CALL 2F0AH <span class="origrom2">CALL SPED</span></a><span class="opcode2">CD 0A 2F</span></div><div>GOSUB to 2F0AH to display the Register BASIC line if necessary</div></div>
									<div class="assembly-row-combined" id="2F7DH"><div>2F7D-2F7F <span class="origrom2">IED</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0384H" class="memory-link">CALL 0384H <span class="origrom2">CALL INCHR</span></a><span class="opcode2">CD 84 03</span></div><div>Go get the character to be inserted from the keyboard</div></div>
									<div class="assembly-row-combined"><div>2F80</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if a key was pressed</div></div>
									<div class="assembly-row-combined"><div>2F81-2F83</div><div><a href="#2F7DH" class="memory-link">JP Z,2F7DH <span class="origrom2">JP Z,IED</span></a><span class="opcode2">CA 7D 2F</span></div><div>Loop back to 2F7DH until a key is pressed</div></div>
									<div class="assembly-row-combined"><div>2F84-2F85</div><div>CP 08H <span class="opcode2">FE 08</span></div><div>Check to see if the character in Register A is a <span class="code">backspace character</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2F86-2F87</div><div><a href="#2F92H" class="memory-link">JR Z,2F92H <span class="origrom2">JR Z,TYPARW</span></a><span class="opcode2">28 0A</span></div><div>Jump to 2F92H if the character in Register A is a <span class="code">backspace character</span></div></div>
									<div class="assembly-row-combined"><div>2F88-2F89</div><div>CP 0DH <span class="opcode2">FE 0D</span></div><div>Check to see if the character in Register A is a <span class="code">carriage return</span>
 .  If they match, the Z FLAG is set, and otherwise the NZ FLAG is set. 
 If A &lt; the checked value, then the C FLAG is set.  If A &gt;= the 
checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2F8A-2F8C</div><div><a href="#2FE0H" class="memory-link">JP Z,2FE0H <span class="origrom2">JP Z,CRED</span></a><span class="opcode2">CA E0 2F</span></div><div>Jump to 2FE0H if the character in Register A is a <span class="code">carriage return</span></div></div>
									<div class="assembly-row-combined"><div>2F8D-2F8E</div><div>CP 1BH <span class="opcode2">FE 1B</span></div><div>Check to see if the character in Register A is a <span class="code">shift up arrow</span>
 (also known as an ESCape).  If they match, the Z FLAG is set, and 
otherwise the NZ FLAG is set.  If A &lt; the checked value, then the C 
FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined"><div>2F8F</div><div>RET Z <span class="opcode2">C8</span></div><div>Return if the character in Register A is <span class="code">shift up arrow</span></div></div>
									<div class="assembly-row-combined" id="2F90H"><div>2F90-2F91</div><div><a href="#2FB0H" class="memory-link">JR NZ,2FB0H <span class="origrom2">JR NZ,NTARRW</span></a><span class="opcode2">20 1E</span></div><div>Jump to 2FB0H to add the new character to the current line</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2F92H">2F92 - <span class="code">EDIT</span> Command - BACKSPACE CURSOR Logic <span class="origrom">- "TYPARW"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2F92H"><div>2F92-2F93 <span class="origrom2">TYPARW</span></div><div>LD A,08H <span class="opcode2">3E 08</span></div><div>Load Register A with a backspace the cursor character</div></div>
									<div class="assembly-row-combined"><div>2F94 <span class="origrom2">TYPAR1</span></div><div>DEC B <span class="opcode2">05</span></div><div>Decrement the character position in Register B</div></div>
									<div class="assembly-row-combined"><div>2F95</div><div>INC B <span class="opcode2">04</span></div><div>Bump the character position in Register B</div></div>
									<div class="assembly-row-combined"><div>2F96-2F97</div><div><a href="#2FB7H" class="memory-link">JR Z,2FB7H <span class="origrom2">JR Z,DINGI</span></a><span class="opcode2">28 1F</span></div><div>If this is the first character of the BASIC line Jump forward to 2FB7H</div></div>
									<div class="assembly-row-combined"><div>2F98-2F9A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go backspace the cursor on the video display</div></div>
									<div class="assembly-row-combined"><div>2F9B</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2F9C</div><div>DEC B <span class="opcode2">05</span></div><div>Decrement the character position in Register B</div></div>
									<div class="assembly-row-combined"><div>2F9D-2F9F</div><div>LD DE,2F7DH <span class="origrom2">LD DE,IED</span>  <span class="opcode2">11 7D 2F</span></div><div>Load DE with a return address of 2F7DH</div></div>
									<div class="assembly-row-combined"><div>2FA0</div><div>PUSH DE <span class="opcode2">D5</span></div><div>Save the value of the return address in DE to the STACK</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2FA1H">2FA1 - LEVEL II BASIC <span class="code">EDIT</span> ROUTINE <span class="origrom">- "DELCHR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This subroutine will delete the character pointed to by Register Pair HL and will correct Register C</p>
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2FA1 <span class="origrom2">DELCHR</span></div><div>PUSH HL <span class="opcode2">E5</span></div><div>Save the value of the input buffer pointer in HL to the STACK</div></div>
									<div class="assembly-row-combined"><div>2FA2</div><div>DEC C <span class="opcode2">0D</span></div><div>Decrement the character position in Register C</div></div>
									<div class="assembly-row-combined" id="2FA3H"><div>2FA3 <span class="origrom2">CMPRSS</span></div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2FA4</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if the character in Register A is an end of the BASIC line character</div></div>
									<div class="assembly-row-combined"><div>2FA5</div><div>SCF <span class="opcode2">37</span></div><div>Set the Carry flag to signal that DELCHR was called</div></div>
									<div class="assembly-row-combined"><div>2FA6-2FA8</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0890H" class="memory-link">JP Z,0890H <span class="origrom2">JP Z,POPHRT</span></a><span class="opcode2">CA 90 08</span></div><div>If the character in Register A is an end of the BASIC line character then we are done compressing so Jump to 0890H</div></div>
									<div class="assembly-row-combined"><div>2FA9</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2FAA</div><div>LD A,(HL) <span class="opcode2">7E</span></div><div>Load Register A with the character at the location of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2FAB</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2FAC</div><div>LD (HL),A <span class="opcode2">77</span></div><div>Save the character in Register A at the location of the current input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2FAD</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2FAE-2FAF</div><div><a href="#2FA3H" class="memory-link">JR 2FA3H <span class="origrom2">JR CMPRSS</span></a><span class="opcode2">18 F3</span></div><div>Loop back to 2FA3H to keep crunching the line</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2FB0H">2FB0 - <span class="code">EDIT</span> Command - ADD A CHARACTER Logic <span class="origrom">- "NTARRW"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2FB0H"><div>2FB0 <span class="origrom2">NTARRW</span></div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the character to be inserted in Register A to the STACK</div></div>
									<div class="assembly-row-combined"><div>2FB1</div><div>LD A,C <span class="opcode2">79</span></div><div>Load Register A with the number of characters in the input buffer (i.e., the length of the line) in Register C</div></div>
									<div class="assembly-row-combined"><div>2FB2-2FB3</div><div>CP FFH <span class="origrom2">CP BUFLEN</span>  <span class="opcode2">FE FF</span></div><div>We
 need to make sure we aren't trying to make the line too long, so check 
for the maximum BASIC line length.  If they match, the Z FLAG is set, 
and otherwise the NZ FLAG is set.  If A &lt; the checked value, then the
 C FLAG is set.  If A &gt;= the checked value, the NC FLAG is set.</div></div>
									<div class="assembly-row-combined" id="2FB9H"><div>2FB4-2FB5</div><div><a href="#2FB9H" class="memory-link">JR C,2FB9H <span class="origrom2">JR C,OKINS</span></a><span class="opcode2">38 03</span></div><div>Jump forward to 2FB9H if the maximum BASIC line length hasn't been reached</div></div>
									<div class="assembly-row-combined"><div>2FB6</div><div>POP AF <span class="opcode2">F1</span></div><div>Get the character to be inserted from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined" id="2FB7H"><div>2FB7-2FB8 <span class="origrom2">DINGI</span></div><div><a href="#2F7DH" class="memory-link">JR 2F7DH <span class="origrom2">JR IED</span></a><span class="opcode2">18 C4</span></div><div>The character needs to be ESCape, so jump back to 2F7DH</div></div>
									<div class="assembly-row-combined" id="2FB9H"><div>2FB9 <span class="origrom2">OKINS</span></div><div>SUB B <span class="opcode2">90</span></div><div>Subtract
 the character position in Register B from the number of characters in 
the input buffer in Register A.  This should give the current byte 
position</div></div>
									<div class="assembly-row-combined"><div>2FBA</div><div>INC C <span class="opcode2">0C</span></div><div>Bump the number of characters in the input buffer in Register C</div></div>
									<div class="assembly-row-combined"><div>2FBB</div><div>INC B <span class="opcode2">04</span></div><div>Bump the character position in Register B</div></div>
									<div class="assembly-row-combined"><div>2FBC</div><div>PUSH BC <span class="opcode2">C5</span></div><div>Save the character position and the number of characters in the input buffer in BC to the STACK</div></div>
									<div class="assembly-row-combined"><div>2FBD</div><div>EX DE,HL <span class="opcode2">EB</span></div><div>Load DE with the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2FBE</div><div>LD L,A <span class="opcode2">6F</span></div><div>Load Register L with the number of bytes to move</div></div>
									<div class="assembly-row-combined"><div>2FBF-2FC0</div><div>LD H,00H <span class="opcode2">26 00</span></div><div>Zero Register H so that the number of bytes to move can be done in a 16 bit Register Pair.</div></div>
									<div class="assembly-row-combined"><div>2FC1</div><div>ADD HL,DE <span class="opcode2">19</span></div><div>Add the value of the input buffer pointer in DE to the character count in HL</div></div>
									<div class="assembly-row-combined"><div>2FC2</div><div>LD B,H <span class="opcode2">44</span></div><div>Load Register B with the MSB of the end of the BASIC line pointer in Register H</div></div>
									<div class="assembly-row-combined"><div>2FC3</div><div>LD C,L <span class="opcode2">4D</span></div><div>Load Register C with the LSB of the end of the BASIC line pointer in Register L</div></div>
									<div class="assembly-row-combined"><div>2FC4</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the end of the BASIC line pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2FC5-2FC7</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1958H" class="memory-link">CALL 1958H <span class="origrom2">CALL BLTUC</span></a><span class="opcode2">CD 58 19</span></div><div>Go move the line up out character</div></div>
									<div class="assembly-row-combined"><div>2FC8</div><div>POP BC <span class="opcode2">C1</span></div><div>Get the character position and the number of characters in the input buffer from the STACK and put it in BC</div></div>
									<div class="assembly-row-combined"><div>2FC9</div><div>POP AF <span class="opcode2">F1</span></div><div>Get the character to be inserted from the STACK and put it in Register A</div></div>
									<div class="assembly-row-combined"><div>2FCA</div><div>LD (HL),A <span class="opcode2">77</span></div><div>Save the character in Register A at the location of the current input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2FCB-2FCD</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Go display the character in Register A</div></div>
									<div class="assembly-row-combined"><div>2FCE</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2FCF-2FD1</div><div><a href="#2F7DH" class="memory-link">JP 2F7DH <span class="origrom2">JP IED</span></a><span class="opcode2">C3 7D 2F</span></div><div>Jump back to 2F7DH to get more characters</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2FD2H">2FD2 - <span class="code">EDIT</span> Command - BACKSPACE Logic <span class="origrom">- "DELED"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined" id="2FD2H"><div>2FD2 <span class="origrom2">DELED</span></div><div>LD A,B <span class="opcode2">78</span></div><div>Top
 of a loop.  Test to see if we are moving back past the first character 
by first loading Register A with the number of times to backspace in 
Register B</div></div>
									<div class="assembly-row-combined"><div>2FD3</div><div>OR A <span class="opcode2">B7</span></div><div>Check to see if this is the start of the BASIC line</div></div>
									<div class="assembly-row-combined"><div>2FD4</div><div>RET Z <span class="opcode2">C8</span></div><div>Return if this is the start of the BASIC line</div></div>
									<div class="assembly-row-combined" id="2FD5H"><div>2FD5</div><div>DEC B <span class="opcode2">05</span></div><div>Decrement the character position in Register B</div></div>
									<div class="assembly-row-combined"><div>2FD6</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2FD7-2FD8</div><div>LD A,08H <span class="opcode2">3E 08</span></div><div>Load Register A with a backspace the cursor character</div></div>
									<div class="assembly-row-combined"><div>2FD9-2FDB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#032AH" class="memory-link">CALL 032AH <span class="origrom2">CALL OUTDO</span></a><span class="opcode2">CD 2A 03</span></div><div>Backspace the cursor on the video display</div></div>
									<div class="assembly-row-combined"><div>2FDC</div><div>DEC D <span class="opcode2">15</span></div><div>Decrement the number of times to perform the operation in Register D</div></div>
									<div class="assembly-row-combined"><div>2FDD-2FDE</div><div><a href="#2FD2H" class="memory-link">JR NZ,2FD2H <span class="origrom2">JR NZ,DELED</span></a><span class="opcode2">20 F3</span></div><div>Loop until done</div></div>
									<div class="assembly-row-combined"><div>2FDF</div><div>RET <span class="opcode2">C9</span></div><div>RETurn to CALLer</div></div>
									<div class="assembly-row-combined" id="2FE0H"><div>2FE0-2FE2 <span class="origrom2">CRED</span></div><div><a href="#2B75H" class="memory-link">CALL 2B75H <span class="origrom2">CALL LISPRT</span></a><span class="opcode2">CD 75 2B</span></div><div>Since
 we need to display the rest of the BASIC line, we call the PRINT 
MESSAGE routine at 2B75H which writes string pointed to by HL to the 
current output device</div></div>
									<div class="assembly-row-combined" id="2FE3H"><div>2FE3-2FE5 <span class="origrom2">EED</span></div><div><a href="#20FEH" class="memory-link">CALL 20FEH <span class="origrom2">CALL CRDO</span></a><span class="opcode2">CD FE 20</span></div><div>Go display a carriage return if necessary</div></div>
									<div class="assembly-row-combined"><div>2FE6</div><div>POP BC <span class="opcode2">C1</span></div><div>Clean up the STACK (to remove the DISPED return address)</div></div>
									<div class="assembly-row-combined"><div>2FE7</div><div>POP DE <span class="opcode2">D1</span></div><div>Get the BASIC line number (in binary) from the STACK and put it in DE</div></div>
									<div class="assembly-row-combined"><div>2FE8</div><div>LD A,D <span class="opcode2">7A</span></div><div>Load Register A with the MSB of the BASIC line number in Register D</div></div>
									<div class="assembly-row-combined"><div>2FE9</div><div>AND E <span class="opcode2">A3</span></div><div>Combine the LSB of the BASIC line number in Register E with the MSB of the BASIC line number in Register A</div></div>
									<div class="assembly-row-combined"><div>2FEA</div><div>INC A <span class="opcode2">3C</span></div><div>Bump the combined BASIC line number in Register A</div></div>
									<div class="assembly-row-combined" id="2FEBH"><div>2FEB-2FED <span class="origrom2">EDITRT</span></div><div>LD HL,(40A7H) <span class="origrom2">LD HL,(BUFPNT)</span>  <span class="opcode2">2A A7 40</span></div><div>Load HL with the starting address of the input buffer.<br>Note: 40A7H-40A8H holds the input Buffer pointer</div></div>
									<div class="assembly-row-combined"><div>2FEE</div><div>DEC HL <span class="opcode2">2B</span></div><div>Decrement the value of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2FEF</div><div>RET Z <span class="opcode2">C8</span></div><div>Return if this is the Level II BASIC command mode</div></div>
									<div class="assembly-row-combined" id="2FF0H"><div>2FF0</div><div>SCF <span class="opcode2">37</span></div><div>Set the Carry flag to to fool the INSERT code; this flags the line number has having been seen</div></div>
									<div class="assembly-row-combined"><div>2FF1</div><div>INC HL <span class="opcode2">23</span></div><div>Bump the value of the input buffer pointer in HL</div></div>
									<div class="assembly-row-combined"><div>2FF2</div><div>PUSH AF <span class="opcode2">F5</span></div><div>Save the command mode flag in AF to the STACK</div></div>
									<div class="assembly-row-combined"><div>2FF3-2FF5</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1A98H" class="memory-link">JP 1A98H <span class="origrom2">JP EDENT</span></a><span class="opcode2">C3 98 1A</span></div><div>Jump to entry point in the main Level II processing code</div></div>
								</div>
							</div>

							<h2 class="assembly-section-title" id="2FF6H">2FF6 - <span class="code">EDIT</span> Command - QUIT Logic <span class="origrom">- "QED"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>2FF6 <span class="origrom2">QED</span></div><div>POP BC <span class="opcode2">C1</span></div><div>Get rid of the DISPED return address</div></div>
									<div class="assembly-row-combined"><div>2FF7</div><div>POP DE <span class="opcode2">D1</span></div><div>Get the line number off of the stack</div></div>
									<div class="assembly-row-combined"><div>2FF8-2FFA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1A19H" class="memory-link">JP 1A19H <span class="origrom2">JP READY</span></a><span class="opcode2">C3 19 1A</span></div><div>Jump to the Level II BASIC READY routine</div></div>
									<div class="assembly-row-combined"><div>2FFB-2FFF</div><div>NOP <span class="opcode2">00</span></div><div>THE END OF THE LEVEL II BASIC ROMS</div></div>
									<div class="assembly-row-combined"><div>2FFB-2FFF</div><div>NOP <span class="opcode2">00</span></div><div>Nothing here</div></div>
									<div class="assembly-row-combined"><div>*2FFB-2FFC</div><div>SBC A,0C3H</div><div>In ROM v1.2 this is just garbage</div></div>
									<div class="assembly-row-combined"><div>2FF8-2FFA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1A19H" class="memory-link">JP 1A19H <span class="origrom2">JP READY</span></a><span class="opcode2">C3 19 1A</span></div><div>Jump to the Level II BASIC READY routine</div></div>
								</div>
							</div>
						</div>

						<div class="section-wrapper">
							<h2 id="pagenav">Disassembly Navigation<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="section-content">
								<div class="top-menu-shorter">
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0000H">0000</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0100H">0100</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0200H">0200</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0300H">0300</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0400H">0400</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0500H">0500</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0600H">0600</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0700H">0700</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0800H">0800</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0900H">0900</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0A00H">0A00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0B00H">0B00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0C00H">0C00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0D00H">0D00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0E00H">0E00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm#0F00H">0F00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1000H">1000</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1100H">1100</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1200H">1200</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1300H">1300</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1400H">1400</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1500H">1500</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1600H">1600</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1608H">Reserved Words</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#18C9H">Error Messages</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1900H">1900</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1A00H">1A00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1B00H">1B00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1C00H">1C00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1D00H">1D00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1E00H">1E00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-2.htm#1F00H">1F00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2000H">2000</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2100H">2100</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2200H">2200</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2300H">2300</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2400H">2400</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2500H">2500</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2600H">2600</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2700H">2700</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2800H">2800</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2900H">2900</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2A00H">2A00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2B00H">2B00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2C00H">2C00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2D00H">2D00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2E00H">2E00</a>
									<a href="https://www.trs-80.com/sub-disassem-rom-m1-part-3.htm#2F00H">2F00</a>
								</div>
							</div>
						</div>
					</div>
				</div>

			</main>
		</div>
	</div>
	<!-- Fancybox JavaScript -->
	<script src="Model%20I%20ROM%20Explained%20-%20Part%203_files/fancybox.umd.js"></script>
	<!-- Initialize Fancybox -->
	<script>
		Fancybox.bind("[data-fancybox]", {
			Toolbar: {
				display: {
					left: ["infobar"],
					middle: [],
					right: ["slideshow", "thumbs", "close"],
				},
			},
			Thumbs: {
				autoStart: false,
			},
		});
	</script>
	<script>
	document.addEventListener('DOMContentLoaded', function() {
	    // OpCode Toggle
	    const opCodeToggle = document.getElementById('OpCodeToggle');
	    if (opCodeToggle) {
	        opCodeToggle.addEventListener('change', function() {
	            const opcodes = document.querySelectorAll('.opcode2');
	            opcodes.forEach(el =>{
	                el.style.display = this.checked ? 'inline' : 'none';
	            });
	        });
	    }
	    // Labels Toggle
	    const labelsToggle = document.getElementById('LabelsToggle');
	    if (labelsToggle) {
	        labelsToggle.addEventListener('change', function() {
	            const labels = document.querySelectorAll('.origrom2');
	            labels.forEach(el =>{
	                el.style.display = this.checked ? 'inline' : 'none';
	            });
	        });
	    }
	});
	</script>
	<!-- Last Modified Date -->
	<script>
		document.write("<p style='text-align:right; padding: 10px 20px; font-style: italic; font-size: 0.85em; color: #666;'>Last edited: " + document.lastModified + "</p>");
	</script><p style="text-align:right; padding: 10px 20px; font-style: italic; font-size: 0.85em; color: #666;">Last edited: 01/17/2026 14:51:56</p>

<div id="mobile-overlay" class="mobile-menu-overlay"></div></body></html>