<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="TRS-80 Revived Site by Ira Goldklang's is an archive of everything related to the Tandy Radio Shack TRS-80 microcomputer lines. Site contains emulators, programs, manuals, books, patches, games, hints, discussions, and tons more.">
	<meta name="author" content="Ira Goldklang">
	<meta name="robots" content="index, follow">
	<link rel="icon" href="https://www.trs-80.com/icon.ico" type="image/x-icon">
	<link rel="canonical" href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm">
	<meta property="og:title" content="TRS-80 Revived Site - Ira Goldklang's TRS-80 Archive">
	<meta property="og:description" content="Complete archive of TRS-80 emulators, programs, manuals, books, and games for Tandy Radio Shack TRS-80 computers.">
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm">
	<meta name="twitter:card" content="summary">
	<meta name="twitter:title" content="TRS-80 Revived Site">
	<meta name="twitter:description" content="Complete archive of TRS-80 emulators, programs, and resources.">
	<title>Model III ROM Explained - Part 2</title>
	<!-- Load your existing CSS file -->
	<link rel="stylesheet" href="Model%20III%20ROM%20Explained%20-%20Part%202_files/trs80-css.css">
	<link rel="stylesheet" href="Model%20III%20ROM%20Explained%20-%20Part%202_files/trs80-hamburger.css">
	<!-- Fancybox CSS -->
	<link rel="stylesheet" href="Model%20III%20ROM%20Explained%20-%20Part%202_files/fancybox.css">
	<!-- Load the component loader -->
	<script src="Model%20III%20ROM%20Explained%20-%20Part%202_files/trs80-loader.js"></script>
	<script src="Model%20III%20ROM%20Explained%20-%20Part%202_files/trs80-hamburger.js"></script>
</head>
<body class="trs80-loaded"><button id="hamburger-btn" class="hamburger-menu" aria-label="Toggle menu">
            <span></span>
            <span></span>
            <span></span>
        </button>
	<div class="site-container">
		<!-- Header will be loaded here -->
		<div id="header"><style>
    .trs80-header-grid {
        display: grid;
        /* 'auto' lets the images take only needed space, '1fr' gives the rest to the text */
        grid-template-columns: auto 1fr auto;
        grid-template-rows: 1fr;
        grid-column-gap: 20px;
        grid-row-gap: 0;
        background-color: #003399;
        margin-top: 10px;
        padding: 10px;
        /* This ensures all items in the grid (images and text) are aligned to the top */
        align-items: start;
    }

    .trs80-header-left { grid-area: 1 / 1 / 2 / 2; display: flex; align-items: start; }
    .trs80-header-center { grid-area: 1 / 2 / 2 / 3; text-align: center; }
    .trs80-header-right { grid-area: 1 / 3 / 2 / 4; display: flex; align-items: start; justify-content: flex-end; }

    .trs80-title { color: white !important; font-size: 170%; text-align: center; margin: 0 0 10px 0; font-weight: bold; }

    .trs80-description {
        color: white !important;
        font-size: 120%;
        text-align: center;
        margin: 0 auto 15px auto;
        padding: 0 10px;
        line-height: 1.4;
    }

    .trs80-header-grid img { border: 0 !important; margin: 0 2px; }
    .trs80-img-60 { width: 60px; }
    .trs80-img-80 { width: 80px; }
    .trs80-img-90 { width: 90px; }
    .trs80-img-100 { width: 100px; }

    /* Search Button Styling */
    .header-search-container {
        margin-bottom: 10px;
    }

    .header-search-link {
        display: inline-block;
        background: #ffcc00; /* Retro TRS-80 Amber */
        color: #003399 !important;
        padding: 6px 15px;
        border-radius: 4px;
        font-weight: bold;
        font-size: 0.9em;
        text-decoration: none;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        transition: transform 0.2s, background 0.2s;
    }

    .header-search-link:hover {
        background: #ffe066;
        transform: scale(1.05);
        text-decoration: none;
    }

    @media screen and (max-width: 768px) {
        .trs80-header-grid {
            grid-template-columns: 1fr;
            grid-template-rows: auto auto auto;
            text-align: center;
            justify-items: center;
        }
        .trs80-header-left { grid-area: 1 / 1 / 2 / 2; justify-content: center; }
        .trs80-header-center { grid-area: 2 / 1 / 3 / 2; }
        .trs80-header-right { grid-area: 3 / 1 / 4 / 2; justify-content: center; }
        .trs80-title { font-size: 130%; }
        .trs80-description { font-size: 100%; text-align: center; }
        .trs80-img-60 { width: 50px; }
        .trs80-img-80 { width: 65px; }
        .trs80-img-90 { width: 75px; }
        .trs80-img-100 { width: 80px; }
    }
</style>

<div class="trs80-header-grid">
    <div class="trs80-header-left">
        <img src="Model%20III%20ROM%20Explained%20-%20Part%202_files/computer-model1-keyboardandscreen-100.png" alt="[Model I]" class="trs80-img-60">
        <img src="Model%20III%20ROM%20Explained%20-%20Part%202_files/computer-model3-rsc05-blur-x100.png" alt="[Model III]" class="trs80-img-60">
        <img src="Model%20III%20ROM%20Explained%20-%20Part%202_files/computer-model4-rsc10-x100.png" alt="[Model 4]" class="trs80-img-90">
    </div>

    <div class="trs80-header-center">
        <p class="trs80-title">Welcome To Ira Goldklang's TRS-80 Revived Site</p>

        <p class="trs80-description">
            TRS-80 Revived Site is an archive of everything related to 
the Tandy Radio Shack TRS-80 home microcomputer lines. Site contains 
emulators, programs, manuals, books, patches, games, hints, discussions,
 and tons more.
        </p>

        <div class="header-search-container">
            <a href="https://www.trs-80.com/main-search-site.htm" class="header-search-link">
                <span class="search-icon">üîç</span> SEARCH THIS SITE
            </a>
        </div>
    </div>

    <div class="trs80-header-right">
        <img src="Model%20III%20ROM%20Explained%20-%20Part%202_files/computer-model-4p-sideways-view-x100.png" alt="[Model 4P]" class="trs80-img-90">
        <img src="Model%20III%20ROM%20Explained%20-%20Part%202_files/computer-model100-ccf836-x100.png" alt="[Model 100]" class="trs80-img-80">
        <img src="Model%20III%20ROM%20Explained%20-%20Part%202_files/computer-pc2-rsc07-x100.png" alt="[Pocket Computer]" class="trs80-img-100">
    </div>
</div>
</div>
		<!-- Content wrapper with sidebar and main content -->
		<div class="content-wrapper">
			<!-- Left Navigation will be loaded here -->
			<aside class="sidebar" id="navbar"><div class="navigationpanelv2">
	<div class="nav-entry-block">
		<h2>FIRST TIME VISITORS</h2>
		<p style="font-size:150%; margin-top:0; text-align:center; color:red;"><a href="https://www.trs-80.com/main-welcome.htm">Visit the WELCOME page</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>Services</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-faq-reading-disks.htm" style="color:red !important;">Do you have TRS-80 Disks?  Send them in for Preservation and Conversion for use in an Emulator</a></li>
			<li><a href="https://www.trs-80.com/main-disketterequest.htm">Request Real DOS Disks</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>General</h2>
		<ul>
			<li><a href="https://www.trs-80.com/index.html">Site News</a></li>
			<li><a href="https://www.trs-80.com/main-introduction-to-emulators.htm">Intro to Emulation</a></li>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-interviews.htm">Interviews</a></span>
				<ul>
					<li><a href="https://americanhistory.si.edu/comphist/gates.htm">Bill Gates</a></li>
					<li><a href="http://www.trs-80.org/interview-bill-hogue/">Bill Hogue</a></li>
					<li><a href="http://www.trs-80.org/interview-dan-gookin/">Dan Gookin</a></li>
					<li><a href="https://www.trs-80.com/sub-interview-don-french.htm">Don French</a></li>
					<li><a href="https://bluebilby.com/dubois-mcnamara/">Dubouis &amp; McNamara</a></li>
					<li><a href="http://www.trs-80.org/interview-j-weaver/">J. Weaver Jr.</a></li>
					<li><a href="http://www.trs-80.org/interview-jack-crenshaw/">Jack Crenshaw</a></li>
					<li><a href="http://www.trs-80.org/interview-jim-stutsman/">Jim Stutsman</a></li>
					<li><a href="http://www.48k.ca/JoshLavinsky.html">Josh Lavinsky</a></li>
					<li><a href="http://www.trs-80.org/interview-kevin-tschudi/">Kevin Tschudi</a></li>
					<li><a href="http://www.trs-80.org/interview-paul-andreasen/">Paul Andreasen</a></li>
					<li><a href="https://www.trs-80.com/sub-interview-steve-leininger.htm">Steven W. Leininger</a></li>
					<li><a href="https://www.trs-80.com/sub-interview-bill-demas.htm">William Demas</a></li>
				</ul>
			</li>
			<li><a href="https://www.trs-80.com/main-shipping.htm">Shipping a TRS-80</a></li>
			<li><a href="https://www.trs-80.com/main-lore.htm">Radio Shack Lore</a></li>
			<li><a href="https://www.trs-80.com/main-fun-stuff.htm">Fun Stuff</a></li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>Help The Site!</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-missing-software.htm">Missing Software</a></li>
			<li><a href="https://www.trs-80.com/main-missing-magazines.htm">Missing Magazines</a></li>
			<li><a href="https://www.trs-80.com/main-faq-reading-disks.htm">Send in Your Disks for Archiving</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Searches</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-search-site.htm">Site-Wide Search</a></li>
			<li><a href="https://www.trs-80.com/main-search-software.htm">Software Search</a></li>
			<li><a href="https://www.trs-80.com/main-search-magazines.htm">Magazine Search</a></li>
			<li><a href="https://www.trs-80.com/main-search-rs-catalogs.htm">Catalog Search</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Emulation and Virtual Media</h2>
		<span>Info and Downloads:</span>
		<ul>
			<li><a href="https://www.trs-80.com/main-emulators.htm">Emulators</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-tape-utilities.htm">Virtual Tape Utilities</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-disk-utilities.htm">Virtual Disk Utilities</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-misc-utilities.htm">Misc TRS-80 Utilities</a></li>
		</ul>
		<span>How To Convert:</span>
		<ul>
			<li><a href="https://www.trs-80.com/main-emulation-conversion-tapes.htm">Tapes to Virtual</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-conversion-disks.htm">Disks to Virtual</a></li>
			<li><a href="https://www.classic-computers.org.nz/system-80/software_esf_archive-imaging.htm">Stringy Floppy to Virtual</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Advanced</h2>
		<span>Internal Operations</span>
		<ul>
			<li>
				<span class="submenu-toggle">ROM/Z-80 Info</span>
				<ul>
					<li><a href="https://www.trs-80.com/main-internal-rom-related.htm#compared">ROMs Compared</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-level-1.htm">Model I Level 1 ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm">Model I Level II ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm">Model III Level II ROM</a></li>
					<li><a href="https://github.com/kiwisincebirth/TRS-80">Model III Level II Compilable Source</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4.htm">Model 4 ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4-xdrom-main.htm">Model 4 XDROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4p.htm">Model 4P Boot ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-network-4.htm">Network 4 ROM</a></li>
					<li><a href="https://www.gatesnotes.com/microsoft-original-source-code">Orig Source Code</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-bugs.htm">Bugs</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-rom-addresses.htm">Memory map and address reference</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-entry-points.htm">Entry Points to routines</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-io-and-misc-routines.htm">I/O and Misc ROM routines</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-math-calls.htm">Math Routines</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-rst-vectors.htm">RST vectors and Disk BASIC entry points</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-z80-info.htm">Reference for Z-80 opcodes and undocumented command</a></li>
				</ul>
			</li>
			<li><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm">RAM Addresses/Routines</a></li>
			<li><a href="https://www.trs-80.com/main-internal-ports-and-i-o.htm">Ports and I/O Devices</a></li>
			<li><a href="https://www.trs-80.com/sub-rom-dcbs.htm">Device Control Blocks (DCB's)</a></li>
			<li><a href="https://www.trs-80.com/main-internal-keyboard-map.htm">Keyboard Map</a></li>
		</ul>

		<span>Disassemblies</span>
		<ul>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-disassemblies.htm">Disassemblies</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-level-1.htm">Level I ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm">Level II ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm">Model III ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-4-durda.htm">Frank Durda Modified C-ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4.htm">Model 4 ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4p.htm">Model 4P Bootstrap ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4-xdrom-main.htm">XDROM - Frank Durda's Model 4 ROM C replacement</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-dos-nd80-m1-main.htm">NEWDOS/80 v2.0</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-dos-td13-main.htm">TRSDOS v1.3</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-dos-td23-main.htm">TRSDOS v2.3</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-network-4.htm">Network 4 Transporter ROM code analysis</a></li>
				</ul>
			</li>
		</ul>

		<span>Zaps/Patches/Fixes</span>
		<ul>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-zaps-and-patches.htm">Zaps and Patches</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/main-zaps-and-patches.htm#dos">DOS</a></li>
					<li><a href="https://www.trs-80.com/sub-zaps-sw-electric-pencil.htm">Electric Pencil</a></li>
					<li><a href="https://www.trs-80.com/sub-zaps-sw-general.htm">Other Software</a></li>
					<li><a href="https://www.trs-80.com/main-zaps-and-patches.htm#software-zaps-and">ZIPs of Patches</a></li>
				</ul>
			</li>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-tips-and-tricks.htm">Tips and Tricks</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/sub-tips-hard-drive.htm">Hard Drive Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-packing.htm">String Packing and USR Routines</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-level2.htm">Level II Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-reference-dos-newdos80-main.htm#tips">NEWDOS/80 Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-dos.htm">Other DOS Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-graphics.htm">TRS-80 Graphics</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-file-formats.htm">Tape and File Formats/Structures</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-easter-eggs.htm">Bugs and Easter Eggs</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-misc.htm">Misc Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-model-3.htm">Model III Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-model-4.htm">Model 4 Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-model-4p.htm">Model 4P Tips and Tricks</a></li>
				</ul>
			</li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>TRS-80 Models</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-models.htm">Timeline</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model1.htm">Model I</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model2.htm">Model II</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model3.htm">Model III</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model4.htm">Model 4/4P/4D</a></li>
			<li><a href="https://www.trs-80.com/sub-models-coco.htm">Color (Coco 1-3, MC-10)</a></li>
			<li><a href="https://www.trs-80.com/sub-models-laptops.htm">Laptops (100/200/600)</a></li>
			<li><a href="https://www.trs-80.com/sub-models-pocket.htm">Pocket (PC-1 to PC-8)</a></li>
			<li><a href="https://www.trs-80.com/sub-models-clones.htm">Clones</a></li>
			<li><a href="https://www.trs-80.com/sub-models-printers.htm">Printers</a></li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>Reference</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-reference-dos-trsdos-main.htm">TRSDOS</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-dos-dosplus.htm">DOSPlus</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-dos-newdos80-main.htm">NEWDOS/80</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-multidos.htm">MULTIDOS</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-dos-cpm.htm">CP/M</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-level-2-basic.htm">Level II BASIC Ref</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Detailed Products</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-details-orchestra.htm">ORCH-80/85/90</a></li>
			<li><a href="https://www.trs-80.com/sub-details-speed-up-boards.htm">Speed-Up Boards</a></li>
			<li><a href="https://www.trs-80.com/sub-details-scott-adams.htm">Scott Adams Adventures</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Tandy Publications</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-rs-csbs.htm">Customer Service Bulletins</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-memos.htm">Memos / Bulletins / Releases</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-cc-answers.htm">Comp Center Answers</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-catalogs.htm">Catalogs</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-comics.htm">Comic Books</a></li>
		</ul>
		<span>Microcomputer News</span>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-rs-micronewsletter-usa.htm">USA Edition</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-micronewsletter-aus.htm">Australian Edition</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-micronewsletter-other.htm">Other Editions</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Publications</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-books.htm">Books</a></li>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-magazine-main-menu.htm">Magazines (Non-Tandy)</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/sub-mag-80micro-main.htm">80 Microcomputing</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-80-notebook.htm">80 Notebook</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-80us-detail.htm">80 U.S. Journal</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-alternatesource-detail.htm">The Alternate Source</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-baron.htm">Baron's Microcomputing</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-cie.htm">C.I.E.</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-cload.htm">CLOAD</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-codeworks.htm">CodeWorks</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-computernews80.htm">Computer News 80</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-computer-user.htm">Computer User</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-creative.htm">Creative Computing</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-hecomputronics-detail.htm">H&amp;E Computronics</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-lsi-journal.htm">LDOS / LSI</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-micro80.htm">Micro-80</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-misosys-notes.htm">Misosys Notes</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-misosys-quarterly.htm">Misosys Quarterly</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-softside-detail.htm">Softside</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-the8ighty.htm">The 8ighty</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-trace.htm">Trace</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-trs8bit.htm">TRS8Bit</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-trstimes.htm">TRSTimes</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-other.htm">Other Magazines</a></li>
				</ul>
			</li>
			<li><a href="https://www.trs-80.com/sub-publications-manuals-software-1.htm">Software Manuals</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-user-groups-1.htm">User's Group Newsletters</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-catalogs.htm">Catalogs (Non-Tandy)</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-flyers.htm">Product Flyers</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-company-news.htm">Company Newsletters</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>This Section for TRS-80 Hardware Owners</h2>
		<span>TRS-80 Upgrades/Parts:</span>
		<ul>
			<li><a href="https://www.trs-80.com/main-upgrades.htm">Upgrades and Parts</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-parts-thingverse.htm">Schematics/3-D Printable Parts</a></li>
		</ul>
		<span>TRS-80 Repairs:</span>
		<ul>
			<li class="navbumpv2"><a href="https://www.trs-80.com/main-repairs.htm">Main Repair Page</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-repair-people.htm">Repair People</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-how-to-open.htm">Opening a TRS-80</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-eprom.htm">Using an EPROM</a></li>
		</ul>
		<span>Hardware Mods and Hacks:</span>
		<ul>
			<li><a href="https://www.trs-80.com/sub-tips-modifications-model-1.htm">Model I</a></li>
			<li><a href="https://www.trs-80.com/sub-tips-modifications-model-3.htm">Model III</a></li>
			<li><a href="https://www.trs-80.com/sub-tips-modifications-model-4.htm">Model 4</a></li>
		</ul>
		<span>Other Items ...</span>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-manuals-hardware-1.htm">Hardware Manuals</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-manuals-service.htm">Service Manuals</a></li>
			<li><a href="https://voidstar.blog/tandy-radio-shack-computer-cassette-recorder-trs-ccr-usage/">Using a Computer / Tablet / Smartphone for Cassette I/O</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Misc</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-emailme.htm">Send Me Email</a></li>
			<li><a href="https://www.trs-80.com/main-old-news.htm">Archived News and Guestbook</a></li>
			<li><a href="https://www.trs-80.com/main-personalstories.htm">Personal Stories Submitted</a></li>
			<li><a href="https://www.trs-80.com/main-emaillinks.htm">Email and other TRS-80 Sites</a></li>
			<li><a href="https://www.trs-80.com/main-copyrights.htm">Copyrights</a></li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>
</div></aside>
			<!-- Main Content -->
			<main class="main-content">
				<div class="main-page-container">
					<h1>Model III ROM Explained - Part 2</h1>
					<div class="section-wrapper">
						<h2 id="continuation">... continuation<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
						<div class="section-content">
							<p>This page covers 1001H-2002H of the Model III ROM.  The ONLY 
difference between the Model I v1.3 ROM and the Model III ROM in this 
entire range is located at 1B5DH-1B5FH.  On the Model I, that address 
loaded HL with the contents of memory location 40A4H, the start of data.
  On the Model III, that adress is a GOSUB to unprotect the screen and 
load HL with the start of data.</p>
							<p>There is no difference between the early Model III ROM and the
 later Model III ROM in this range.  The Model 4 ROM is also identical 
to the Model III ROM in this range.</p>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1001-1002</div><div><a href="#100A" class="memory-link">JR Z,100AH</a></div><div>Jump if leading * aren't to be included in the ASCII string.</div></div>
									<div class="assembly-row-combined model1"><div>1003</div><div>LD A,B</div><div>Load register A with the character at the location of the input buffer pointer in register B.</div></div>
									<div class="assembly-row-combined model1"><div>1004</div><div>CP C</div><div>Check to see if the character at the location of the input buffer pointer in register A is a space.</div></div>
									<div class="assembly-row-combined model1"><div>1005-1006</div><div>LD C,2AH</div><div>Load register C with an <span class="code">*</span> character.</div></div>
									<div class="assembly-row-combined model1"><div>1007-1008</div><div><a href="#100A" class="memory-link">JR NZ,100AH</a></div><div>Skip the next opcode (which loads B with a <span class="code">*</span>, if the character at the location of the input buffer pointer in register A isn't a space.</div></div>
									<div class="assembly-row-combined model1"><div>1009</div><div>LD B,C</div><div>Load register B with the * character in register C.</div></div>
									<div class="assembly-row-combined model1" id="100A"><div>100A</div><div>LD (HL),C</div><div>Save the <span class="code">*</span> character in register C at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>100B</div><div>RST 10H</div><div>Since
 we need to bump the current input buffer pointer in register pair HL 
until it points to the next character, call the EXAMINE NEXT SYMBOL 
routine at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>100C-100D</div><div><a href="#1022" class="memory-link">JR Z,1022H</a></div><div>Jump
 down to 1022H if the character at the location of the input buffer 
pointer in register pair HL is the end of the input buffer character 
(00H).</div></div>
									<div class="assembly-row-combined model1"><div>100E-100F</div><div>CP 45H</div><div>Check to see if the character at the location of the input buffer pointer in register A is an <span class="code">E</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1010-1011</div><div><a href="#1022" class="memory-link">JR Z,1022H</a></div><div>Jump down to 1022H if the character at the location of the input buffer pointer in register A is an <span class="code">E</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1012-1013</div><div>CP 44H</div><div>Check to see if the character at the location of the input buffer pointer in register A is a <span class="code">D</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1014-1015</div><div><a href="#1022" class="memory-link">JR Z,1022H</a></div><div>Jump down to 1022H if the character at the location of the input buffer pointer in register A is a <span class="code">D</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1016-1017</div><div>CP 30H</div><div>Check to see if the character at the location of the input buffer pointer in register A is a <span class="code">0</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1018-1019</div><div><a href="#100A" class="memory-link">JR Z,100AH</a></div><div>Jump back to 100AH if the character at the location of the input buffer pointer in register A is a <span class="code">0</span>.</div></div>
									<div class="assembly-row-combined model1"><div>101A-101B</div><div>CP 2CH</div><div>Check to see if the character at the location of the input buffer pointer in register A is a <span class="code">,</span>.</div></div>
									<div class="assembly-row-combined model1"><div>101C-101D</div><div><a href="#100A" class="memory-link">JR Z,100AH</a></div><div>Jump back to 100AH if the character at the location of the input buffer pointer in register A is a <span class="code">,</span>.</div></div>
									<div class="assembly-row-combined model1"><div>101E-101F</div><div>CP 2EH</div><div>Check to see if the character at the location of the input buffer pointer in register A is a <span class="code">.</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1020-1021</div><div><a href="#1025" class="memory-link">JR NZ,1025H</a></div><div>Jump down to 1025H if the character at the location of the input buffer pointer in register A isn't a <span class="code">.</span>.</div></div>
									<div class="assembly-row-combined model1" id="1022"><div>1022</div><div>DEC HL</div><div>Now we know we have an <span class="code">E</span>, <span class="code">D</span>, <span class="code">0</span>, <span class="code">,</span>, or <span class="code">.</span> so we need to backspace it out by decrementing the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1023-1024</div><div>LD (HL),"0"</div><div>Save a zero character (0) at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1" id="1025"><div>1025</div><div>LD A,E</div><div>Load register A with the value of the edit flag in register E.</div></div>
									<div class="assembly-row-combined model1"><div>1026-1027</div><div>AND 10H</div><div>MASK A against 10H (Binary: 0001 0000) to leave only Bit 5 so as to check to see if a <span class="code">$</span> is to be included in the ASCII string.</div></div>
									<div class="assembly-row-combined model1"><div>1028-1029</div><div><a href="#102D" class="memory-link">JR Z,102DH</a></div><div>Skip the next 2 instructions (which put in a $) if a <span class="code">$</span> isn't to be included in the ASCII string.</div></div>
									<div class="assembly-row-combined model1"><div>102A</div><div>DEC HL</div><div>Need to add a <span class="code">$</span>, so first we decrement the value of the input buffer pointer in register pair HL ...</div></div>
									<div class="assembly-row-combined model1"><div>102B-102C</div><div>LD (HL),24H</div><div>... and then put a <span class="code">$</span> there.</div></div>
									<div class="assembly-row-combined model1" id="102D"><div>102D</div><div>LD A,E</div><div>Load register A with the value of the input flag in register E.</div></div>
									<div class="assembly-row-combined model1"><div>102E-102F</div><div>AND 04H</div><div>Check to see if the sign is to follow the ASCII string.</div></div>
									<div class="assembly-row-combined model1"><div>1030</div><div>RET NZ</div><div>Return if the sign isn't to follow the ASCII string.</div></div>
									<div class="assembly-row-combined model1"><div>1031</div><div>DEC HL</div><div>Decrement the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1032</div><div>LD (HL),B</div><div>Save the character in register B at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1033</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<h2 id="1034H">1034 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUINI"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine initializes the input buffer for an ASCII 
conversion.  It is called by the FLOATING to ASCII Conversion Routine 
(at 0FBEH) and by the BINARY to ASCII Conversion Routine (at 0FAFH).</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1034-1036</div><div>LD (40D8H),A</div><div>Save the value of the edit flag (stored at 40D8H) in register A.<br><b>NOTE:</b> 40D8H-40D9H holds the temporary storage location.</div></div>
									<div class="assembly-row-combined model1"><div>1037-1039</div><div>LD HL,4130H</div><div>Load register pair HL with the starting address of the input buffer (which is 4130H).<br><b>NOTE:</b> 4130H-4149H holds Internal print buffer.</div></div>
									<div class="assembly-row-combined model1"><div>103A-103B</div><div>LD (HL),20H</div><div>Save a space at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>103C</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<h2 id="103DH">103D - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUFRV"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine gets called by the FLOATING to ASCII Conversion 
Routine (0FBEH-0FC0H) if the value being converted is either Single 
Precision or Double Precision.  This will print a single or double 
precision number in free format</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>103D-103E</div><div>CP 05H</div><div>Set
 the CARRY FLAG according to whether the current value in REG 1 is 
single precision or double precision (Carry set if double precision).</div></div>
									<div class="assembly-row-combined model1"><div>103F</div><div>PUSH HL</div><div>Save the value in register pair HL to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1040-1041</div><div>SBC A,00H</div><div>Adjust the value of the number type in register A.  It will be 04H if SINGLE PRECISION and it will be 08H if DOUBLE precision.</div></div>
									<div class="assembly-row-combined model1"><div>1042</div><div>RLA</div><div>Multiply
 the value of the number type in register A by two, so now A will be 08H
 if SINGLE precision and 0AH if DOUBLE precision.</div></div>
									<div class="assembly-row-combined model1"><div>1043</div><div>LD D,A</div><div>Load register D with the adjusted value of the number type in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1044</div><div>INC D</div><div>Bump the value of the number type in register D (so D will be 09H if SINGLE precision and 0BH if DOUBLE precision).</div></div>
									<div class="assembly-row-combined model1"><div>1045-1047</div><div><a href="#1201" class="memory-link">CALL 1201H</a></div><div>GOSUB
 to 1201H to scale the current value in REG 1 to be 99,999 &lt;= X &lt;=
 999,999.  Returns wihth A being the number of times the DOUBLE 
precision value was scaled up or down.</div></div>
									<div class="assembly-row-combined model1"><div>1048-104A</div><div>LD BC,0300H</div><div>Load register pair BC with 300H (Decimal: 768).</div></div>
									<div class="assembly-row-combined model1"><div>104B</div><div>ADD A,D</div><div>Add the value in register D to the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>104C-104E</div><div><a href="#1057" class="memory-link">JP M,1057H</a></div><div>Jump to 1057H if the number of digits in register A is too large (i.e., if scaled down more than 9 or 11 places).</div></div>
									<div class="assembly-row-combined model1"><div>104F</div><div>INC D</div><div>Bump the value in register D (so D will be 0AH if SINGLE precision or 0CH if DOUBLE precision).</div></div>
									<div class="assembly-row-combined model1"><div>1050</div><div>CP D</div><div>Check
 to see if the number of digits in register A is equal to the value in 
register D (meaning that the number wasn't scaled at all).<br><b>NOTE:</b> Results from a CP:<ul><li>Z: A and * are the same</li><li>NZ: A and * are NOT the same</li><li>C: A &lt; *</li><li>NC: A =&gt; *</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1051-1052</div><div><a href="#1057" class="memory-link">JR NC,1057H</a></div><div>If the number was scaled up or down (meaning that A and D are the same or A is greater than D), jump to 1057H.</div></div>
									<div class="assembly-row-combined model1"><div>1053</div><div>INC A</div><div>Now
 we know the number was scaled, so we must bump the number of digits in 
register A so that it holds the number of digits in the value.</div></div>
									<div class="assembly-row-combined model1"><div>1054</div><div>LD B,A</div><div>Load register B with the number of digits in the value (stored in register A).</div></div>
									<div class="assembly-row-combined model1"><div>1055-1056</div><div>LD A,02H</div><div>Load register A with a two because the next step (which is a common code jump point) will force the exponent to be zero.</div></div>
									<div class="assembly-row-combined model1" id="1057"><div>1057-1058</div><div>SUB A,02H</div><div>Compute the exponent value (which will be a zero if we were passing through).</div></div>
									<div class="assembly-row-combined model1"><div>1059</div><div>POP HL</div><div>Get the value from the stack (the Program Buffer) and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>105A</div><div>PUSH AF</div><div>Save the exponent value (currently in register pair AF) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>105B-105D</div><div><a href="#1291" class="memory-link">CALL 1291H</a></div><div>Go put a comma or decimal point in the input buffer if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>105E-105F</div><div>LD (HL),"0"</div><div>Save a <span class="code">0</span> character at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1060-1062</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09C9" class="memory-link">CALL Z,09C9H</a></div><div>If there was no scaling, GOSUB to 09C9H to bump the value of the input buffer pointer in register pair HL if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>1063-1065</div><div><a href="#12A4" class="memory-link">CALL 12A4H</a></div><div>Go convert the binary value in REG 1 to ASCII, the result being stored in the input buffer pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1066</div><div>DEC HL</div><div>Backspace the last character by decrementing the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1067</div><div>LD A,(HL)</div><div>Load
 register A with the value at the location of the input buffer pointer 
in register pair HL (which is the previous character).</div></div>
									<div class="assembly-row-combined model1"><div>1068-1069</div><div>CP 30H</div><div>Check to see if the value in register A is a <span class="code">0</span> (which is 30H).</div></div>
									<div class="assembly-row-combined model1"><div>106A-106B</div><div><a href="#1066" class="memory-link">JR Z,1066H</a></div><div>Loop until the character at the location of the input buffer pointer in register pair HL is not a zero character.</div></div>
									<div class="assembly-row-combined model1"><div>106C-106D</div><div>CP "."</div><div>Check to see if the character at the location of the input buffer pointer in register A is a <span class="code">.</span>.<br><b>NOTE:</b> Results from a CP:<ul><li>Z: A and * are the same</li><li>NZ: A and * are NOT the same</li><li>C: A &lt; *</li><li>NC: A =&gt; *</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>106E-1070</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09C9" class="memory-link">CALL NZ,09C9H</a></div><div>If its NOT a decimal point, GOSUB to bump the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1071</div><div>POP AF</div><div>Get the value from the stack (i.e., the exponent) and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1072-10731</div><div><a href="#1093" class="memory-link">JR Z,1093H</a></div><div>If the exponent is zero, jump to 1093H.</div></div>
									<div class="assembly-row-combined model1" id="1074"><div>1074</div><div>PUSH AF</div><div>Save the exponent (stored in AF) back to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1075</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>1076-1077</div><div>LD A,22H</div><div>Load register A with the starting value for a D or E character.</div></div>
									<div class="assembly-row-combined model1"><div>1078</div><div>ADC A,A</div><div>Multiply
 the value of the character in register A by two and add in the value of
 the CARRY FLAG from the number type flag test.  This will result with A
 it being a D if the value is SINGLE precision and an E if the value is 
DOUBLE precision.</div></div>
									<div class="assembly-row-combined model1"><div>1079</div><div>LD (HL),A</div><div>Save the exponent designation (the D or E in register A) at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>107A</div><div>INC HL</div><div>Bump the value of the input buffer pointer in register pair HL, which is the first position of the exponent in the buffer.</div></div>
									<div class="assembly-row-combined model1"><div>107B</div><div>POP AF</div><div>Get the value of the exponent from the stack and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>107C-107D</div><div>LD (HL),2BH</div><div>Save a <span class="code">+</span> (=2BH) at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>107E-1080</div><div><a href="#1085" class="memory-link">JP P,1085H</a></div><div>Skip the next 3 instructions (by jumping to 1085H) if the exponent is positive.</div></div>
									<div class="assembly-row-combined model1"><div>1081-1082</div><div>LD (HL),2DH</div><div>Save a <span class="code">-</span> (which is 2DH) at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1083</div><div>CPL</div><div>Convert the negative exponent to positive by reversing the value of the exponent in register A and ...</div></div>
									<div class="assembly-row-combined model1"><div>1084</div><div>INC A</div><div>... bumping the value of the exponent in register A.</div></div>
									<div class="assembly-row-combined model1" id="1085"><div>1085-1086</div><div>LD B,2FH</div><div>At this point, the exponent is positive.  Next step is to load register B with a <span class="code">0</span> minus one (which is a <span class="code">/</span>).</div></div>
									<div class="assembly-row-combined model1"><div>1087</div><div>INC B</div><div>Bump the value of the ASCII character in register B (so now it is an <span class="code">0</span>).  This is the start of a 3 Opcode routine to divide by 10 using compound subtraction.</div></div>
									<div class="assembly-row-combined model1"><div>1088-1089</div><div>SUB A,0AH</div><div>Subtract ten from the value of the exponent in register A.</div></div>
									<div class="assembly-row-combined model1"><div>108A-108B</div><div><a href="#1087" class="memory-link">JR NC,1087H</a></div><div>Loop
 until the value of the exponent in register A is less than ten.  B 
holds the quotient (e.g., the number of times the subtraction had to 
occur to get to a remainder less than 10).</div></div>
									<div class="assembly-row-combined model1"><div>108C-108D</div><div>ADD A,3AH</div><div>Since A is holding the remainder of the 'divide-by-10' routine above, add 3AH to it so that it will be an ASCII digit.</div></div>
									<div class="assembly-row-combined model1"><div>108E</div><div>INC HL</div><div>Bump the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>108F</div><div>LD (HL),B</div><div>Save
 the ASCII character in register B (which is the first digit of the 
exponent in ASCII) at the location of the input buffer pointer in 
register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1090</div><div>INC HL</div><div>Bump the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1091</div><div>LD (HL),A</div><div>Save
 the value of the ASCII character in register A (which is the second 
digit of the exponent in ASCII) at the location of the input buffer 
pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1092</div><div>INC HL</div><div>Bump the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1093-1094</div><div>LD (HL),00H</div><div>Save an end of the ASCII string character (designated as 00H) at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1095</div><div>EX DE,HL</div><div>Load register pair DE with the ending address of the input buffer pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1096-1098</div><div>LD HL,4130H</div><div>Load register pair HL with the starting address of the input buffer pointer.<br><b>NOTE:</b> 4130H-4149H holds Internal print buffer.</div></div>
									<div class="assembly-row-combined model1"><div>1099</div><div>RET</div><div>Return.</div></div>
									<div class="assembly-row-combined model1" id="109A"><div>109A</div><div>INC HL</div><div>Bump the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>109B</div><div>PUSH BC</div><div>Save the value in register pair BC to the stack (currently B has the number of <span class="code">#</span>'s before the current vale of the input buffer pointer and C has the number of #'s after).</div></div>
									<div class="assembly-row-combined model1"><div>109C-109D</div><div>CP 04H</div><div>Check to see if the current number type in REG 1 is single or double precision.  Results:<ul><li>If A=04H it sets the ZERO FLAG</li><li>If A&lt;04H then the CARRY FLAG will be set</li><li>If A&gt;=04H then the NO CARRY FLAG will be set</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>109E</div><div>LD A,D</div><div>Load register A with the value of the edit flag in register D.</div></div>
									<div class="assembly-row-combined model1"><div>109F-10A1</div><div><a href="#1109" class="memory-link">JP NC,1109H</a></div><div>Jump
 to 1109H if the current value in REG 1 is either single precision or 
double precision (i.e., A&gt;=04H since 4=Single precision and 8=Double 
precision</div></div>
									<div class="assembly-row-combined model1"><div>10A2</div><div>RRA</div><div>Rotate A right one bit to put the value of the exponential notation flag into the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>10A3-10A5</div><div><a href="#11A3" class="memory-link">JP C,11A3H</a></div><div>JUMP to 11A3H if exponential notation is requested.<br>Alternative interpretation is Jump to 11A3H if the variable is a string; which will leave us now with only an integer value.</div></div>
								</div>
							</div>

							<br><h2 id="10A6">10A6 - This is where the PRINT USING routine will edit for INTEGER values.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>10A6-10A8</div><div>LD BC,0603H</div><div>Load
 register pair BC with a default value of 0603H (so that Register B has 
the number of leading digits of 6 and Register C has the comma counter 
of 3).</div></div>
									<div class="assembly-row-combined model1"><div>10A9-10AB</div><div><a href="#1289" class="memory-link">CALL 1289H</a></div><div>Go check to see if commas are requested.  If no comma is requested, set Register C to zero.</div></div>
									<div class="assembly-row-combined model1"><div>10AC</div><div>POP DE</div><div>Get
 the value from the stack and put it in register pair DE.  This will put
 the number of #'s to the left of the decimal point into D.</div></div>
									<div class="assembly-row-combined model1"><div>10AD</div><div>LD A,D</div><div>Load register A with the number of digits requested to the left of the decimal point in register D.</div></div>
									<div class="assembly-row-combined model1"><div>10AE-10AF</div><div>SUB A,05H</div><div>Since
 the maximim number of digits allowed for an integer to the left of the 
decimal point is 5, subtract 5 from the number of digits to the left of 
the decimal point requested.</div></div>
									<div class="assembly-row-combined model1"><div>10B0-10B2</div><div><a href="#1269" class="memory-link">CALL P,1269H</a></div><div>Go
 put leading zeros into the input buffer if the number of digits to the 
left of the decimal point requested is greater than the number of digits
 to the left of the decimal point for the maximum length of an integer 
value (meaning, the POSITIVE flag has been set).</div></div>
									<div class="assembly-row-combined model1"><div>10B3-10B5</div><div><a href="#132F" class="memory-link">CALL 132FH</a></div><div>Call
 the INTEGER TO ASCII routine at 1232F (which converts the integer in 
REG 1 to ASCII and stores the ASCII string in the buffer pointed to in 
HL).</div></div>
									<div class="assembly-row-combined model1" id="10B6"><div>10B6</div><div>LD A,E</div><div>Load register A with the number of digits to the right of the decimal point requested (which is stored in register E).</div></div>
									<div class="assembly-row-combined model1"><div>10B7</div><div>OR A</div><div>Check to see if there are any digits to the right of the decimal point requested and set the status flags accordingly.</div></div>
									<div class="assembly-row-combined model1"><div>10B8-10BA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#092F" class="memory-link">CALL Z,092FH</a></div><div>Go
 decrement the value of the input buffer pointer in register pair HL if 
there are no digits to the right of the decimal point requested.</div></div>
									<div class="assembly-row-combined model1"><div>10BB</div><div>DEC A</div><div>Decrement the number of digits to the right of the decimal point in register A.  This tests to see if no count was given.</div></div>
									<div class="assembly-row-combined model1"><div>10BC-10BE</div><div><a href="#1269" class="memory-link">CALL P,1269H</a></div><div>If the POSITIVE flag is set, gosub to 1269H to add trailing zeros to the ASCII string if necessary.</div></div>
									<div class="assembly-row-combined model1" id="10BF"><div>10BF</div><div>PUSH HL</div><div>Save the current input buffer pointer (stored in register pair HL) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>10C0-10C2</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0FF5" class="memory-link">CALL 0FF5H</a></div><div>Go edit the ASCII string in the input buffer.</div></div>
									<div class="assembly-row-combined model1"><div>10C3</div><div>POP HL</div><div>Get the saved input buffer pointer value from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>10C4-10C5</div><div><a href="#10C8" class="memory-link">JR Z,10C8H</a></div><div>Jump to 10C8H if the sign follows the ASCII string.</div></div>
									<div class="assembly-row-combined model1"><div>10C6</div><div>LD (HL),B</div><div>So
 now we know a sign does not follow the value so we save the character 
in register B (which should be a space) at the location of the input 
buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>10C7</div><div>INC HL</div><div>Bump the value of the input buffer pointer in register pair HL</div></div>
									<div class="assembly-row-combined model1"><div>10C8-10C9</div><div>LD (HL),00H</div><div>Terminate
 the buffer by saving an end of the ASCII string character (=00H) at the
 location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>10CA-10CC</div><div>LD HL,412FH</div><div>Load
 register pair HL with the starting address of the input buffer pointer 
(which is 412FH) minus 1 (because the first instruction of the following
 common code is add 1 to HL).</div></div>
									<div class="assembly-row-combined model1" id="10CD"><div>10CD</div><div>INC HL</div><div>Bump the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1" id="10CE"><div>10CE-10D0</div><div>LD A,(40F3H)</div><div>Load register A with the LSB of the address of the decimal point for the ASCII string.<br><b>NOTE:</b> 40F3H-40F4H holds the temporary storage location.</div></div>
									<div class="assembly-row-combined model1"><div>10D1</div><div>SUB A,L</div><div>Subtract the LSB of the input buffer pointer address in register L from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>10D2</div><div>SUB A,D</div><div>Subtract the number of digits to the left of the decimal point in register D from the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>10D3</div><div>RET Z</div><div>Return if the input buffer pointer in register pair HL points to the start of the ASCII string.</div></div>
									<div class="assembly-row-combined model1"><div>10D4</div><div>LD A,(HL)</div><div>So
 now we know we are not at the start of the field, so we fetch the 
character at the location of the input buffer pointer in register pair 
HL into Register A.</div></div>
									<div class="assembly-row-combined model1"><div>10D5-10D6</div><div>CP 20H</div><div>Check to see if the character at the location of the input buffer pointer in register A is a space (which is a blank).</div></div>
									<div class="assembly-row-combined model1"><div>10D7-10D8</div><div><a href="#10CD" class="memory-link">JR Z,10CDH</a></div><div>Jump
 back to 10CDH if the character at the location of the input buffer 
pointer in register pair HL is a space so that we keep looking until we 
are either at the start of the field, or a "+", "-", or "$" is found.</div></div>
									<div class="assembly-row-combined model1"><div>10D9-10DA</div><div>CP "*"</div><div>Check to see if the character at the location of the input buffer pointer in register A is a <span class="code">*</span>.</div></div>
									<div class="assembly-row-combined model1"><div>10DD</div><div>DEC HL</div><div>Since we want to ignore "*"'s decrement the value of the input buffer pointer in register pair HL so it will get re-tested.</div></div>
									<div class="assembly-row-combined model1"><div>10DE</div><div>PUSH HL</div><div>Save the value of the input buffer pointer in register pair HL to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>10DF</div><div>PUSH AF</div><div>Save the value in register pair AF (which is the current character) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>10E0-10E2</div><div>LD BC,10DFH</div><div>Load register pair BC with the return address for use in case we have a <span class="code">-</span>, a <span class="code">+</span>, or a <span class="code">$</span>.</div></div>
									<div class="assembly-row-combined model1"><div>10E3</div><div>PUSH BC</div><div>Save the return address in register pair BC to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>10E4</div><div>RST 10H</div><div>Since
 we need to bump the current input buffer pointer in register pair HL 
until it points to the next character, call the EXAMINE NEXT SYMBOL 
routine at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>10E5-10E6</div><div>CP "-"</div><div>Check to see if the character at the location of the input buffer pointer in register A is a <span class="code">-</span>.</div></div>
									<div class="assembly-row-combined model1"><div>10E7</div><div>RET Z</div><div>Return (to 10DFH) if the character at the location of the input buffer pointer in register A is a <span class="code">-</span>.</div></div>
									<div class="assembly-row-combined model1"><div>10E8-10E9</div><div>CP "+"</div><div>Check to see if the character at the location of the input buffer pointer in register A is a <span class="code">+</span>.</div></div>
									<div class="assembly-row-combined model1"><div>10EA</div><div>RET Z</div><div>Return (to 10DFH) if the character at the location of the input buffer pointer in register A is a <span class="code">+</span>.</div></div>
									<div class="assembly-row-combined model1" id="10EB"><div>10EB-10EC</div><div>CP "$"</div><div>Check to see if the character at the location of the input buffer pointer in register A is a <span class="code">$</span>.</div></div>
									<div class="assembly-row-combined model1"><div>10ED</div><div>RET Z</div><div>Return (to 10DFH) if the character at the location of the input buffer pointer in register A is a <span class="code">$</span>.</div></div>
									<div class="assembly-row-combined model1" id="10EE"><div>10EE</div><div>POP BC</div><div>We
 don't need a shortcut to jump to 10DFH anymore, so let's get the real 
return address from the stack and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>10EF-10F0</div><div>CP "0"</div><div>Check to see if the character at the location of the input buffer pointer in register A is a <span class="code">0</span>.</div></div>
									<div class="assembly-row-combined model1"><div>10F1-10F2</div><div><a href="#1102" class="memory-link">JR NZ,1102H</a></div><div>Jump to 1102H if the character at the location of the input buffer pointer in register A isn't a <span class="code">0</span>.</div></div>
									<div class="assembly-row-combined model1"><div>10F3</div><div>INC HL</div><div>Bump the value of the input buffer pointer in register pair HL so that we skip to the next character.</div></div>
									<div class="assembly-row-combined model1"><div>10F4</div><div>RST 10H</div><div>Since
 we need to bump the current input buffer pointer in register pair HL 
until it points to the next character, call the EXAMINE NEXT SYMBOL 
routine at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>10F5-10F6</div><div><a href="#1102" class="memory-link">JR NC,1102H</a></div><div>Jump to 1102H if the character at the location of the input buffer pointer in register A isn't a numeric character.</div></div>
									<div class="assembly-row-combined model1"><div>10F7</div><div>DEC HL</div><div>Decrement the value of the input buffer pointer in register pair HL to backspace to the last character examined.</div></div>
									<div class="assembly-row-combined model1" id="10F8"><div>10F8</div><div>01 2B 77</div><div>Z-80
 Trick! The byte at this memory location, 01H, is there to turn the real
 instruction that follows in 10F9H into a harmless LD BC,xxxx.  This 
way, if you are processing straight down in order, it skips the next 
command at 10F9H (in this case a <span class="code">DEC HL</span>) 
because it wasn't a command, it was a hex number to be loaded into BC!  
Instead, if you jump to 10F9H, you skip this byte and it is an <span class="code">DEC HL</span>.</div></div>
									<div class="assembly-row-combined model1"><div>10F9</div><div>DEC HL</div><div>Decrement
 the value of the input buffer pointer in register pair HL (we needed 
that Z-80 trick to avoid a double backspace in passing through).</div></div>
									<div class="assembly-row-combined model1"><div>10FA</div><div>LD (HL),A</div><div>Save the character in register A at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>10FB</div><div>POP AF</div><div>Get the value from the stack and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>10FC-10FD</div><div><a href="#10F9" class="memory-link">JR Z,10F9H</a></div><div>Loop until the end of the field is reached (by finding a 00H).</div></div>
									<div class="assembly-row-combined model1"><div>10FE</div><div>POP BC</div><div>Clear the stack.</div></div>
									<div class="assembly-row-combined model1"><div>10FF-1101</div><div><a href="#10CE" class="memory-link">JP 10CEH</a></div><div>Jump back to 10CEH to restart the scan.</div></div>
									<div class="assembly-row-combined model1" id="1102"><div>1102</div><div>POP AF</div><div>Restore the character at the start of the field from the stack and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>1103-1104</div><div><a href="#1102" class="memory-link">JR Z,1102H</a></div><div>Loop until the beginning of the field is found.</div></div>
									<div class="assembly-row-combined model1"><div>1105</div><div>POP HL</div><div>Get the starting address of the field from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1106-1107</div><div>LD (HL),25H</div><div>Save a <span class="code">%</span> character at the location of the input buffer pointer in register pair HL (which is the starting address).</div></div>
									<div class="assembly-row-combined model1"><div>1108</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="1109">1109 - This is where the PRINT USING routine will edit for FLOATING POINT values.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1109</div><div>PUSH HL</div><div>Save the current input buffer pointer in register pair HL to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>110A</div><div>RRA</div><div>Rotate
 A right one bit, with Bit 0 going to the CARRY FLAG.  This will allow 
us to test bit 0 of the edit flags to see if exponential notation is 
requested by the edit flag in register A.</div></div>
									<div class="assembly-row-combined model1"><div>110B-110D</div><div><a href="#11AA" class="memory-link">JP C,11AAH</a></div><div>Jump to 11AAH if exponential notation is requested by the edit flag in register A on a floating point number.</div></div>
									<div class="assembly-row-combined model1"><div>110E-110F</div><div><a href="#1124" class="memory-link">JR Z,1124H</a></div><div>Jump to 1124H if the current value in REG 1 is single precision.</div></div>
									<div class="assembly-row-combined model1"><div>1110-1112</div><div>LD DE,1384H</div><div>Load
 register pair DE with the address of the DOUBLE PRECISION value to be 
compared to the current value in REG 1.  Register pair DE points to a 
double precision constant equal to 1el6.</div></div>
									<div class="assembly-row-combined model1"><div>1113-1115</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0A49" class="memory-link">CALL 0A49H</a></div><div>Go compare the double precision constant pointed to by register pair DE (which is 1el6) to the double precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>1116-1117</div><div>LD D,10H</div><div>Load register D with the maximum length of a double precision value (which is 16).</div></div>
									<div class="assembly-row-combined model1"><div>1118-111A</div><div><a href="#1132" class="memory-link">JP M,1132H</a></div><div>Jump to 1132H if the double precision value in REG 1 is less than or equal to 1el6.</div></div>
									<div class="assembly-row-combined model1" id="111B"><div>111B</div><div>POP HL</div><div>So
 now we know the double precision value in REG 1 exceeds 1x10^16.  Get 
the current input buffer pointer from the stack and put it in register 
pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>111C</div><div>POP BC</div><div>Get the value from the stack and put it in register pair BC, resulting in B containing the number of <span class="code">#</span>'s before and C containing the number of <span class="code">#</span>'s after.</div></div>
									<div class="assembly-row-combined model1"><div>111D-111F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0FBD" class="memory-link">CALL 0FBDH</a></div><div>Go
 convert the double precision value in REG 1 to an ASCII string.  The 
goal is to reenter the edit routine until the double precision value is 
less than 1x10^16.</div></div>
									<div class="assembly-row-combined model1"><div>1120</div><div>DEC HL</div><div>Decrement the input buffer pointer in register pair HL to get it back to the current position.</div></div>
									<div class="assembly-row-combined model1"><div>1121-1122</div><div>LD (HL),"%"</div><div>Save a <span class="code">%</span> character at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1123</div><div>RET</div><div>Return.</div></div>
									<p class="debug-note" id="1124">1124H - Continuation point if the current value in REG 1 is single precision.</p>
									<div class="assembly-row-combined model1"><div>1124-1126</div><div>LD BC,B60EH</div><div>Load register pair BC with the exponent and the MSB of a single precision constant.</div></div>
									<div class="assembly-row-combined model1"><div>1127-1129</div><div>LD DE,1BCAH</div><div>Load
 register pair DE with the NMSB and the LSB of a single precision 
constant. Register pairs BC and DE now hold a single precision constant 
equal to 1x10^16.</div></div>
									<div class="assembly-row-combined model1"><div>112A-112C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0A0C" class="memory-link">CALL 0A0CH</a></div><div>Call the SINGLE PRECISION COMPARISON routine at 0A0CH.<br><br><span class="nobottomborder bold">NOTE:</span>  The routine at 0A0CH algebraically compares the single precision value in BC/DE to the single precision value REG 1.<br>The results are stored in A as follows:<ul><li>A=00H if REG 1 = BCDE</li><li>A=01H if REG 1&gt;BCDE; and </li><li>A=FFH if REG 1&lt;BCDE.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>112D-112F</div><div><a href="#111B" class="memory-link">JP P,111BH</a></div><div>Jump back to 111BH if the the POSITIVE flag is set (meaning the single precision value in REG 1 is greater than 1x10^16).</div></div>
									<div class="assembly-row-combined model1"><div>1130-1131</div><div>LD D,06H</div><div>Now
 we know that the SINGLE precision value in REG 1 is less than 1x10^16. 
 Load register D with the maximum length of a single precision value 
(which is 6).</div></div>
									<div class="assembly-row-combined model1" id="1132"><div>1132-1134</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0955" class="memory-link">CALL 0955H</a></div><div>Go check the sign of the value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>1135-1137</div><div><a href="#1201" class="memory-link">CALL NZ,1201H</a></div><div>GOSUB
 to 1201H to adjust the current value of REG 1 so that the single 
precision value is 99,999 &lt; X &lt; 999,999.  On the return from that 
GOSUB, A will equal the number of times the value was scaled up or down 
as a + or -.</div></div>
									<div class="assembly-row-combined model1"><div>1138</div><div>POP HL</div><div>Get the origin of the ASCII buffer from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1139</div><div>POP BC</div><div>Get the value from the stack and put it in register pair BC, resulting in B containing the number of <span class="code">#</span>'s before and C containing the number of <span class="code">#</span>'s after.</div></div>
									<div class="assembly-row-combined model1"><div>113A-113C</div><div><a href="#1157" class="memory-link">JP M,1157H</a></div><div>JUMP forward to 1157H if the value in REG 1 had to be scaled up (multiplied by 10) to get it in range.</div></div>
									<div class="assembly-row-combined model1"><div>113D</div><div>PUSH BC</div><div>Save the value in register pair BC (B was the number of <span class="code">#</span>'s before and C is the number of <span class="code">#</span>'s after) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>113E</div><div>LD E,A</div><div>Load register E with the number of times the current value in REG 1 was divided.</div></div>
									<div class="assembly-row-combined model1"><div>113F</div><div>LD A,B</div><div>Load register A with the number of digits before the decimal point requested.</div></div>
									<div class="assembly-row-combined model1"><div>1140</div><div>SUB A,D</div><div>Subtract
 the maximum length for the current number type in register D (which is 
6) from the number of digits requested in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1141</div><div>SUB A,E</div><div>Subtract the number of times the current value in REG 1 was divided in register E from the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1142-1144</div><div><a href="#1269" class="memory-link">CALL P,1269H</a></div><div>If the POSITIVE flag is set, gosub to 1269H to put leading zeros into the input buffer if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>1145-1147</div><div><a href="#127D" class="memory-link">CALL 127DH</a></div><div>GOSUB to 127DH to figure the comma count and the position of the decimal point.</div></div>
									<div class="assembly-row-combined model1"><div>1148-114A</div><div><a href="#12A4" class="memory-link">CALL 12A4H</a></div><div>GOSUB to 12A4H to convert the integer portion of the current value in REG 1 to an ASCII string.</div></div>
									<div class="assembly-row-combined model1"><div>114B</div><div>OR E</div><div>Check to see if there are any trailing zeros needed by testing the number of times the value was scaled.</div></div>
									<div class="assembly-row-combined model1"><div>114C-114E</div><div><a href="#1277" class="memory-link">CALL NZ,1277H</a></div><div>Go put trailing zeros into the input buffer if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>114F</div><div>OR E</div><div>Check to see if commas or the decimal point is needed.</div></div>
									<div class="assembly-row-combined model1"><div>1150-1152</div><div><a href="#1291" class="memory-link">CALL NZ,1291H</a></div><div>Go put commas and the decimal point into the input buffer if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>1153</div><div>POP DE</div><div>Get the edit counts value from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1154-1156</div><div><a href="#10B6" class="memory-link">JP 10B6H</a></div><div>Jump to 10B6H to convert the fractional portion fo the number to ASCII.</div></div>
								</div>
							</div>

							<h2 id="1157H">1157 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FFXXVS"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will print a SINGLE PRECISION or DOUBLE PREVISION number that has fractional digits</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1157</div><div>LD E,A</div><div>Load register E with the number of times the current value in REG 1 was scaled (multiplied by 10).</div></div>
									<div class="assembly-row-combined model1"><div>1158</div><div>LD A,C</div><div>Load register A with the number of digits requested to the right of the decimal point.</div></div>
									<div class="assembly-row-combined model1"><div>1159</div><div>OR A</div><div>Check to see if any digits to the right of the decimal point was requested.</div></div>
									<div class="assembly-row-combined model1"><div>115A-115C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0F16" class="memory-link">CALL NZ,0F16H</a></div><div>Go decrement the number of digits requested to the right of the decimal point if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>115D</div><div>ADD A,E</div><div>Add
 the number of times the current value was multiplied in register E to 
the number of digits to the right of the decimal point requested in 
register A.</div></div>
									<div class="assembly-row-combined model1"><div>115E-1160</div><div><a href="#1162" class="memory-link">JP M,1162H</a></div><div>Jump if the value in REG 1 must be scaled down.</div></div>
									<div class="assembly-row-combined model1"><div>1161</div><div>XOR A</div><div>Zero register A and indicate that there is on scaling down needed.</div></div>
									<div class="assembly-row-combined model1"><div>1162</div><div>PUSH BC</div><div>Save the value in register pair BC (B was the number of <span class="code">#</span>'s before and C is the number of <span class="code">#</span>'s after) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1163</div><div>PUSH AF</div><div>Save the value in register pair AF (the scale count) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1164-1166</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0F18" class="memory-link">CALL M,0F18H</a></div><div>GOSUB to 0F18H to divide the value in REG 1 by ten, A times, if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>1167-1169</div><div><a href="#1164" class="memory-link">JP M,1164H</a></div><div>Loop until the value in REG 1 is properly adjusted. When this is done, A will hold the number of times it was divided by 10.</div></div>
									<div class="assembly-row-combined model1"><div>116A</div><div>POP BC</div><div>Get the original scale count from the stack and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>116B</div><div>LD A,E</div><div>Load register A with the number of times the value in REG 1 was multiplied in register E.</div></div>
									<div class="assembly-row-combined model1"><div>116C</div><div>SUB A,B</div><div>Subtract the value in register B from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>116D</div><div>POP BC</div><div>Get the before/after value from the stack and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>116E</div><div>LD E,A</div><div>Load register E with the adjusted scale factor value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>116F</div><div>ADD A,D</div><div>Add
 the length of the maximum size for the current value in register D to 
the adjusted scale factor value in register A.  This will set the sign 
flag.</div></div>
									<div class="assembly-row-combined model1"><div>1170</div><div>LD A,B</div><div>Load register A with the number of <span class="code">#</span>'s before (stored in B).</div></div>
									<div class="assembly-row-combined model1"><div>1171-1173</div><div><a href="#117F" class="memory-link">JP M,117FH</a></div><div>Jump to 117FH if there are no digits to the left of the decimal point.</div></div>
									<div class="assembly-row-combined model1"><div>1174</div><div>SUB A,D</div><div>We
 now know there are leading digits so, subtract the maximum length for 
the current value in register D (6 for SINGLE precision and 10 for 
DOUBLE precision) from the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1175</div><div>SUB A,E</div><div>Then, subtract the adjusted scale value in register E from the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1176-1178</div><div><a href="#1269" class="memory-link">CALL P,1269H</a></div><div>If that subtraction leads to a positive number, go put leading zeros into the input buffer.</div></div>
									<div class="assembly-row-combined model1"><div>1179</div><div>PUSH BC</div><div>Save the value in register pair BC (B was the number of <span class="code">#</span>'s before and C is the number of <span class="code">#</span>'s after) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>117A-117C</div><div><a href="#127D" class="memory-link">CALL 127DH</a></div><div>GOSUB to set up BC for decimal point and comma counters.</div></div>
									<div class="assembly-row-combined model1"><div>117D-117E</div><div><a href="#1190" class="memory-link">JR 1190H</a></div><div>Jump to 1190H to edit the numbers before the decimal point.</div></div>
								</div>
							</div>

							<h2 id="117FH">117F - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FFXXV3"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will print a number without integer digits.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>117F-1181</div><div><a href="#1269" class="memory-link">CALL 1269H</a></div><div>Go put leading zeros into the input buffer if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>1182</div><div>LD A,C</div><div>Load
 Register A with the number of bytes requested to the right of the 
decimal point (in register C) because C is about to get wiped.</div></div>
									<div class="assembly-row-combined model1"><div>1183-1185</div><div><a href="#1294" class="memory-link">CALL 1294H</a></div><div>GOSUB to 1294H to put a decimal point into the input buffer.</div></div>
									<div class="assembly-row-combined model1"><div>1186</div><div>LD C,A</div><div>Reload register C with the number of digits requested to the right of the decimal point in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1187</div><div>XOR A</div><div>Zero Register A.</div></div>
									<div class="assembly-row-combined model1"><div>1188</div><div>SUB A,D</div><div>Subtract the maximum length for the current value in register D from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1189</div><div>SUB A,E</div><div>Subtract the value in register E from the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>118A-118C</div><div><a href="#1269" class="memory-link">CALL 1269H</a></div><div>GOSUB to 1269H to put that many zeroes into the input buffer (if necessary).</div></div>
									<div class="assembly-row-combined model1"><div>118D</div><div>PUSH BC</div><div>Save the value in register pair BC (B was the number of <span class="code">#</span>'s before and C is the number of <span class="code">#</span>'s after) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>118E</div><div>LD B,A</div><div>Load register B with the value in register A (which is 0).</div></div>
									<div class="assembly-row-combined model1"><div>118F</div><div>LD C,A</div><div>Load register C with the value in register A (which is 0).</div></div>
								</div>
							</div>

							<h2 id="119AH">119A - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FFXXV7"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will print trailing zeroes.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1190-1192</div><div><a href="#12A4" class="memory-link">CALL 12A4H</a></div><div>GOSUB to 12A4H to convert the integer portion of the SINGLE precision value in REG 1 to an ASCII string.</div></div>
									<div class="assembly-row-combined model1"><div>1193</div><div>POP BC</div><div>Get the number of <span class="code">#</span>'s before and number of <span class="code">#</span>'s after and put it back in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>1194</div><div>OR C</div><div>Check to see if there are any digits to the right of the decimal point requested and set the status accordingly.</div></div>
									<div class="assembly-row-combined model1"><div>1195-1196</div><div><a href="#119A" class="memory-link">JR NZ,119AH</a></div><div>Jump to 119AH if there are digits to the right of the decimal point requested.</div></div>
									<div class="assembly-row-combined model1"><div>1197-1199</div><div>LD HL,(40F3H)</div><div>Now
 we know that there are no digits to the right of the decimal point.  
Load register pair HL with the position of the decimal point (which is 
stored in 40F3H).<br><b>NOTE:</b> 40F3H-40F4H holds the temporary storage location.</div></div>
									<div class="assembly-row-combined model1"><div>119A</div><div>ADD A,E</div><div>Add the value in register E to the value in register A to get the number of digits before the decimal point.</div></div>
									<div class="assembly-row-combined model1"><div>119B</div><div>DEC A</div><div>Decrement the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>119C-119E</div><div><a href="#1269" class="memory-link">CALL P,1269H</a></div><div>If dropping A by 1 still results in a positive number, GOSUB 1269H to put that number of zeros into the input buffer.</div></div>
									<div class="assembly-row-combined model1"><div>119F</div><div>LD D,B</div><div>Load register D with the number of digits to the left of the decimal point requested (from Register B).</div></div>
									<div class="assembly-row-combined model1"><div>11A0-11A2</div><div><a href="#10BF" class="memory-link">JP 10BFH</a></div><div>Jump to 10BFH to edit the ASCII value.</div></div>
								</div>
							</div>

							<h2 id="11A3H">11A3 - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FFXIFL"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will print an integer in fixed format/floating point notation.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>11A3</div><div>PUSH HL</div><div>Save the current position of the input buffer (in register pair HL) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>11A4</div><div>PUSH DE</div><div>Save the edit flags (in register pair BC) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>11A5-11A7</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0ACC" class="memory-link">CALL 0ACCH</a></div><div>GOSUB 0ACCH to convert the integer value in REG 1 to a SINGLE precision value.</div></div>
									<div class="assembly-row-combined model1"><div>11A8</div><div>POP DE</div><div>Get the edit flags from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>11A9</div><div>XOR A</div><div>Zero register A, clear the status flags.</div></div>
								</div>
							</div>

							<h2 id="11AAH">11AA - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FFXFLV"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will print a SINGLE or DOUBLE PRECISION number in fixed format/floating point notation.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>11AA-11AC</div><div><a href="#11B0" class="memory-link">JP Z,11B0H</a></div><div>Slip
 the next 2 instructions to 11B0H (using a Z-80 trick) to skip the next 
instruction if the current value in REG 1 is SINGLE precision.</div></div>
									<div class="assembly-row-combined model1"><div>11AD-11AE</div><div>LD E,10H</div><div>Load register E with the maximum length of a double precision value (which is 16).</div></div>
									<div class="assembly-row-combined model1"><div>11AFH</div><div>01 + LD E,06H<br>or<br>LD BC, 1E06H</div><div>Z-80 Trick!  By putting a 01 here, the opcode becomes a 3 byte opcode, turning 01 1E 06 into <span class="code">LD BC, 1E06H</span>.  This would corrupt BC, but otherwise would then make the next instruction 11B2H, skipping the next instruction of <span class="code">LD E,06H</span> because, well, it doesn't exist!</div></div>
									<p class="debug-note" id="11B0">11B0H - Continuation Routine (From 11AAH) if the current value in REG 1 is SINGLE precision.</p>
									<div class="assembly-row-combined model1"><div>11B0-11B1</div><div>LD E,06H</div><div>Load register E with the maximum length of a single precision value (which is 6).</div></div>
									<div class="assembly-row-combined model1"><div>11B2-11B4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0955" class="memory-link">CALL 0955H</a></div><div>GOSUB 0955H to check the sign for the current value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>11B5</div><div>SCF</div><div>Set the CARRY FLAG (to force a jump at 11F3 on the first pass).</div></div>
									<div class="assembly-row-combined model1"><div>11B6-11B8</div><div><a href="#1201" class="memory-link">CALL NZ,1201H</a></div><div>GOSUB to 1201H to scale the current value in REG 1 if its nonzero.</div></div>
									<div class="assembly-row-combined model1"><div>11B9</div><div>POP HL</div><div>Get the input buffer position from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>11BA</div><div>POP BC</div><div>Get the number of <span class="code">#</span>'s before and the number of <span class="code">#</span>'s after from the stack and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>11BB</div><div>PUSH AF</div><div>Save the decimal point and the flag for test at 11F3H in register pair AF to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>11BC</div><div>LD A,C</div><div>Load register A with the number of digits to the right of the decimal point requested (stored in register C).</div></div>
									<div class="assembly-row-combined model1"><div>11BD</div><div>OR A</div><div>Set the status so we can see if there are any digits to the right of the decimal point requested through a zero register.</div></div>
									<div class="assembly-row-combined model1"><div>11BE</div><div>PUSH AF</div><div>Save the original trailing digit count (in register pair AF) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>11BF-11C1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0F16" class="memory-link">CALL NZ,0F16H</a></div><div>If
 the trail count is not zero, then GOSUB to 0F16H to decrement the 
number of digits requested to the right of the decimal point in register
 A.</div></div>
									<div class="assembly-row-combined model1"><div>11C2</div><div>ADD A,B</div><div>Add
 the number of digits requested for the left of the decimal point in 
register B to the number of digits requested to the right of the decimal
 point in register A.</div></div>
									<div class="assembly-row-combined model1"><div>11C3</div><div>LD C,A</div><div>Load register C with the total digit count (held in register A).</div></div>
									<div class="assembly-row-combined model1"><div>11C4</div><div>LD A,D</div><div>Load register A with the value of the edit flag in register D.</div></div>
									<div class="assembly-row-combined model1"><div>11C5-11C6</div><div>AND 04H</div><div>Check to see if the sign follows the ASCII string.</div></div>
									<div class="assembly-row-combined model1"><div>11C7-11C8</div><div>CP 01H</div><div>Set the CARRY FLAG according to the sign following the ASCII string test (it will be No Carry if a sign follows).</div></div>
									<div class="assembly-row-combined model1"><div>11C9</div><div>SBC A,A</div><div>Adjust
 register A so that it will reflect the sign following the ASCII string 
test (A will be 0 if there is no sign, and FEH otherwise).</div></div>
									<div class="assembly-row-combined model1"><div>11CA</div><div>LD D,A</div><div>Load register D with the edit flag (from register A).</div></div>
									<div class="assembly-row-combined model1"><div>11CB</div><div>ADD A,C</div><div>Add the value in register C to the value in register A so as to adjust the count of the digits to print if a sign follows.</div></div>
									<div class="assembly-row-combined model1"><div>11CC</div><div>LD C,A</div><div>Load register C with the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>11CD</div><div>SUB A,E</div><div>Subtract
 the value in register E from the adjusted value in register A so that A
 will now contain the number of times to divide by 10.</div></div>
									<div class="assembly-row-combined model1"><div>11CE</div><div>PUSH AF</div><div>Save the divisor count (from register pair AF) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>11CF</div><div>PUSH BC</div><div>Save the character count (from register pair BC) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>11D0-11D2</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0F18" class="memory-link">CALL M,0F18H</a></div><div>GOSUB to 0F18H to divide the current value in REG 1 by ten, Register A number of times.</div></div>
									<div class="assembly-row-combined model1"><div>11D3-11D5</div><div><a href="#11D0" class="memory-link">JP M,11D0H</a></div><div>Loop back 1 instruction (divide by 10) until the division has been completed.</div></div>
									<div class="assembly-row-combined model1"><div>11D6</div><div>POP BC</div><div>Get the counter of the <span class="code">#</span>'s from the stack and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>11D7</div><div>POP AF</div><div>Get the division count from the stack and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>11D8</div><div>PUSH BC</div><div>Save the value in Register Pair BC to the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>11D9</div><div>PUSH AF</div><div>Save the value in register pair AF to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>11DA-11DC</div><div><a href="#11DE" class="memory-link">JP M,11DEH</a></div><div>Skip the next instruction (i.e., jump to 11DEH) if there are any trailing zeroes.</div></div>
									<div class="assembly-row-combined model1"><div>11DD</div><div>XOR A</div><div>Zero register A and all status flags.</div></div>
									<div class="assembly-row-combined model1" id="11DE"><div>11DE</div><div>CPL</div><div>Make the trailing zero count posivite by inverting the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>11DF</div><div>INC A</div><div>Bump the value in register A so that it will be positive.</div></div>
									<div class="assembly-row-combined model1"><div>11E0</div><div>ADD A,B</div><div>Add the number of digits requested to the left of the decimal point in register B to the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>11E1</div><div>INC A</div><div>Bump the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>11E2</div><div>ADD A,D</div><div>Add
 the value of the maximum length for the current number type in register
 D (6 for single precision, 16 fo double precision) to the adjusted 
value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>11E3</div><div>LD B,A</div><div>Copy Register A into Register B so that B holds the number of digits before the decimal point.</div></div>
									<div class="assembly-row-combined model1"><div>11E4-11E5</div><div>LD C,00H</div><div>Load register C with zero (so that there are no commas).</div></div>
									<div class="assembly-row-combined model1"><div>11E6-11E8</div><div><a href="#12A4" class="memory-link">CALL 12A4H</a></div><div>GOSUB to 12A4H to convert the current value in REG 1 to an ASCII string.</div></div>
									<div class="assembly-row-combined model1"><div>11E9</div><div>POP AF</div><div>Get the number of #'s before from the stack and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>11EA-11EC</div><div><a href="#1271" class="memory-link">CALL P,1271H</a></div><div>GOSUB 1271H to put zeros into the trailing input buffer.</div></div>
									<div class="assembly-row-combined model1"><div>11ED</div><div>POP BC</div><div>Get the number of #'s before and the number of <span class="code">#</span>'s after from the stack and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>11EE</div><div>POP AF</div><div>Get the count of numbers before the decimal point from the stack and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>11EF-11F1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#092F" class="memory-link">CALL Z,092FH</a></div><div>GOSUB to 092FH to decrement the input buffer pointer in register pair HL if there are none.</div></div>
									<div class="assembly-row-combined model1"><div>11F2</div><div>POP AF</div><div>Get the first time flag from the stack and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>11F3-11F4</div><div><a href="#11F8" class="memory-link">JR C,11F8H</a></div><div>Jump to 11F8H (to add the exponent) if the CARRY FLAG was set during the first pass.</div></div>
									<div class="assembly-row-combined model1"><div>11F5</div><div>ADD A,E</div><div>Add the value in register E to the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>11F6</div><div>SUB A,B</div><div>Subtract the number of digits to the left of the decimal point requested in register B from the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>11F7</div><div>SUB A,D</div><div>Subtract the value in register D from the value in register A to get the size of the exponent.</div></div>
									<div class="assembly-row-combined model1" id="11F8"><div>11F8</div><div>PUSH BC</div><div>Save the value in Register Pair BC to the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>11F9-11FB</div><div><a href="#1074" class="memory-link">CALL 1074H</a></div><div>GOSUB to 1074H to figure the value of the exponent for the current value in REG 1</div></div>
									<div class="assembly-row-combined model1"><div>11FC</div><div>EX DE,HL</div><div>Load register pair HL with the value of the input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>11FD</div><div>POP DE</div><div>Get the value from the stack and put it in register pair DE.  Clear the stack.</div></div>
									<div class="assembly-row-combined model1"><div>11FE-1200</div><div><a href="#10BF" class="memory-link">JP 10BFH</a></div><div>Jump to 10BFH to edit the ASCII value.</div></div>
								</div>
							</div>

							<h2 id="1201H">1201 - Test the magnitude of SP and DP numbers, and clear the times the value was scaled<span class="origrom"> - "FOUTNV"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will scale (normalize) the number in the 
accumulator so that all the digits are in the integer part (i.e., 
between 99,999 and 999,999).  The signed base 10 exponent is returned in
 Register A.  Registers D and E are unchanged.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1201</div><div>PUSH DE</div><div>Save the value in register pair DE to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1202</div><div>XOR A</div><div>Zero register A and all the flags.</div></div>
									<div class="assembly-row-combined model1"><div>1203</div><div>PUSH AF</div><div>Save the value in register pair AF to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1204</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>1205-1207</div><div><a href="#1222" class="memory-link">JP PO,1222H</a></div><div>If that test shows we have a SINGLE PRECISION number (through getting a Parity-Odd flag), jump to 1222H.</div></div>
									<div class="assembly-row-combined model1"><div>1208-120A</div><div>LD A,(4124H)</div><div>At
 this point we know we have a DOUBLE precision value.  Load register A 
with the value of the exponent for the double precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>120B-120C</div><div>CP 91H</div><div>Check
 to see if the double precision value in REG 1 uses more than 16 bits of
 precision for the integer portion of the double precision value.<br><b>NOTE:</b> Results from a CP:<ul><li>Z: A and * are the same</li><li>NZ: A and * are NOT the same</li><li>C: A &lt; *</li><li>NC: A =&gt; *</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>120D-120F</div><div><a href="#1222" class="memory-link">JP NC,1222H</a></div><div>Jump to 1222H if the double precision value in REG 1 uses more than 16 bits of precision for its integer portion.</div></div>
									<div class="assembly-row-combined model1"><div>1210-1212</div><div>LD DE,1364H</div><div>Load register pair DE with the starting address for the double precision constant equal to 5.5x10e2.</div></div>
									<div class="assembly-row-combined model1"><div>1213-1215</div><div>LD HL,4127H</div><div>Load register pair HL with the starting address for REG2.<br><b>NOTE:</b> 4127H-412EH holds REG 2.</div></div>
									<div class="assembly-row-combined model1"><div>1216-1218</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09D3" class="memory-link">CALL 09D3H</a></div><div>GOSUB to 09D3H to move the double precision constant of 5.5x10e2 into REG2.</div></div>
									<div class="assembly-row-combined model1"><div>1219-121B</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0DA1" class="memory-link">CALL 0DA1H</a></div><div>GOSUB
 to 0DA1H to call the DOUBLE PRECISION MULTIPLY routine at 0DA1H (which 
multiplies the double precision value in REG 1 by the value in REG 2. 
The product is left in REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>121C</div><div>POP AF</div><div>Get the number of times the DOUBLE precision value was multiplied to scale it up from the stack and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>121D-121E</div><div>SUB A,0AH</div><div>Subtract ten from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>121F</div><div>PUSH AF</div><div>Save the value in register pair AF to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1220-1221</div><div><a href="#1208" class="memory-link">JR 1208H</a></div><div>Jump to 1208H so as to loop until the integer portion exceeds 2e16.</div></div>
									<div class="assembly-row-combined model1"><div>1222-1224</div><div><a href="#124F" class="memory-link">CALL 124FH</a></div><div>GOSUB to 124FH to compare the current value in REG 1 to 999999.5.</div></div>
									<div class="assembly-row-combined model1"><div>1225</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>1226-1228</div><div><a href="#1233" class="memory-link">JR NC,1233H</a></div><div>In ROM 1.2 this is a big bug fix.  Now if the shows we do NOT have a STRING, jump to 1233H</div></div>
									<div class="assembly-row-combined model1"><div>1229-122B</div><div>LD BC,9143H</div><div>Load register pair BC with the exponent and the MSB of a single precision constant.</div></div>
									<div class="assembly-row-combined model1"><div>122C-122E</div><div>LD DE,4FF9H</div><div>Load
 register pair DE with the NMSB and the LSB of a single precision 
constant. Register pairs BC and DE are now equal to a single precision 
constant of 99,999.945.</div></div>
									<div class="assembly-row-combined model1"><div>122F-1231</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0A0C" class="memory-link">CALL 0A0CH</a></div><div>GOSUB to 0A0CH to call the SINGLE PRECISION COMPARISON routine at 0A0CH.<br><br><span class="nobottomborder bold">NOTE:</span>  The routine at 0A0CH algebraically compares the single precision value in BC/DE to the single precision value REG 1.<br>The results are stored in A as follows:<ul><li>A=00H if REG 1 = BCDE</li><li>A=01H if REG 1&gt;BCDE; and </li><li>A=FFH if REG 1&lt;BCDE.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1232-1233</div><div><a href="#123A" class="memory-link">JR 123AH</a></div><div>Jump down two instructions to 123AH to test the results of the comparison.</div></div>
									<div class="assembly-row-combined model1"><div>1233-1235</div><div>LD DE,136CH</div><div>Load register pair DE with the starting address of a double precision constant equal to 9.9921El4.</div></div>
									<div class="assembly-row-combined model1"><div>1236-1238</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0A49" class="memory-link">CALL 0A49H</a></div><div>Go compare the double precision constant pointed to by register pair DE to the double precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>1239-123B</div><div><a href="#124C" class="memory-link">JP P,124CH</a></div><div>Jump
 to 124CH if the current value in REG 1 is greater than the constant 
compared to it (more than 5 digits in integer or less than 17 digits in 
DOUBLE precision).</div></div>
									<div class="assembly-row-combined model1"><div>123C</div><div>POP AF</div><div>Get the value of the scaled counter from the stack and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>123D-123F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0F0B" class="memory-link">CALL 0F0BH</a></div><div>GOSUB to 0F0BH to multiply the current value in REG 1 by ten.</div></div>
									<div class="assembly-row-combined model1"><div>1240</div><div>PUSH AF</div><div>Save the value in register pair AF to the stack.  A is the negative of the number of times the value was multiplied.</div></div>
									<div class="assembly-row-combined model1"><div>1241-1242</div><div><a href="#1225" class="memory-link">JR 1225H</a></div><div>Jump to 1225H to loop until it is between 999,999 and 99,999.</div></div>
									<div class="assembly-row-combined model1"><div>1243</div><div>POP AF</div><div>Get the scaled count from the stack and put it in Register A.</div></div>
									<div class="assembly-row-combined model1"><div>1244-1246</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0F18" class="memory-link">CALL 0F18H</a></div><div>GOSUB to 0F18H to divide the current value in REG 1 by ten.</div></div>
									<div class="assembly-row-combined model1"><div>1247</div><div>PUSH AF</div><div>Save the value in register pair AF to the stack.  A is the count of the number of times it was divided.</div></div>
									<div class="assembly-row-combined model1"><div>1248-124A</div><div><a href="#124F" class="memory-link">CALL 124FH</a></div><div>GOSUB to 124FH to loop until the value in REG 1 is &lt; 999,999.</div></div>
									<div class="assembly-row-combined model1"><div>124B</div><div>POP AF</div><div>Get the value from the stack and put it in register pair AF.  A = + times divided or - times multiplied.<br>Difference
 between M1 and M3 ROMs: This change first appeared in the "new" ROMs 
for the Model I. The order of two instructions (OR A and POP DE) have 
been reversed for no apparent reason.</div></div>
									<div class="assembly-row-combined model1"><div>124C</div><div>POP DE</div><div>Get the value from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>124D</div><div>OR A</div><div>In ROM v1.2 sets the status flags.  This also realigns the memory addresses from changes to v1.2 ROM.</div></div>
									<div class="assembly-row-combined model1"><div>124E</div><div>RET</div><div>Return.</div></div>
									<div class="assembly-row-combined model1"><div>124F</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>1250-1252</div><div><a href="#125E" class="memory-link">JP PE,125EH</a></div><div>If that test shows we have a DOUBLE PRECISION number, jump to 125EH.</div></div>
									<div class="assembly-row-combined model1"><div>1253-1255</div><div>LD BC,9474H</div><div>Now
 that we know we have a single precision number, load register pair BC 
with the exponent and the MSB of a single precision constant.</div></div>
									<div class="assembly-row-combined model1"><div>1256-1258</div><div>LD DE,23F8H</div><div>Load
 register pair DE with the NMSB and the LSB of a single precision 
constant. Register pairs BC and DE are now equal to a single precision 
constant of 999,999.5.</div></div>
									<div class="assembly-row-combined model1"><div>1259-125B</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0A0C" class="memory-link">CALL 0A0CH</a></div><div>Call the SINGLE PRECISION COMPARISON routine at 0A0CH.<br><br><span class="nobottomborder bold">NOTE:</span>  The routine at 0A0CH algebraically compares the single precision value in BC/DE to the single precision value REG 1.<br>The results are stored in A as follows:<ul><li>A=00H if REG 1 = BCDE</li><li>A=01H if REG 1&gt;BCDE; and </li><li>A=FFH if REG 1&lt;BCDE.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>125C-125D</div><div><a href="#1264" class="memory-link">JR 1264H</a></div><div>Jump to 1264H to test the result of the comparison.</div></div>
									<div class="assembly-row-combined model1"><div>125E-1260</div><div>LD DE,1374H</div><div>Load register pair DE with the starting address of a double precision constant equal to 1El6H.</div></div>
									<div class="assembly-row-combined model1"><div>1261-1263</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0A49" class="memory-link">CALL 0A49H</a></div><div>GOSUB to 0A49H to compare the double precision constant pointed to by register pair DE to the double precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>1264</div><div><a href="#1244" class="memory-link">POP HL</a></div><div>Get the return address from the stack and put it in register pair HL so we can go to 1244H.</div></div>
									<div class="assembly-row-combined model1"><div>1265-1267</div><div><a href="#1243" class="memory-link">JP P,1243H</a></div><div>In ROM v1.2 the ROM addresses had moved 1 byte.</div></div>
									<div class="assembly-row-combined model1"><div>1268</div><div>JP (HL)</div><div>Jump to the caller (which was POPed from the stack).</div></div>
								</div>
							</div>

							<br><h2 id="1269">1269H - This routine puts leading zeroes into the input buffer<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1269</div><div>OR A</div><div>Check to see if the value in register A is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>126A</div><div>RET Z</div><div>Return if the value in register A is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>126B</div><div>DEC A</div><div>Decrement the value in register A to show that an ASCII zero was moved to the print buffer.</div></div>
									<div class="assembly-row-combined model1"><div>126C-126D</div><div>LD (HL),"0"</div><div>Save a <span class="code">0</span> at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>126E</div><div>INC HL</div><div>Bump the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>126F-1270</div><div><a href="#126A" class="memory-link">JR 126AH</a></div><div>Jump back to 126AH until the number in Register A of ASCII zeroes were moved.</div></div>
									<div class="assembly-row-combined model1"><div>1271-1272</div><div><a href="#1277" class="memory-link">JR NZ,1277H</a></div><div>Jump to 1277H if not done adding trailing zeroes.</div></div>
									<div class="assembly-row-combined model1" id="1273"><div>1273</div><div>RET Z</div><div>Return if done adding trailing zeroes.</div></div>
									<div class="assembly-row-combined model1"><div>1274-1276</div><div><a href="#1291" class="memory-link">CALL 1291H</a></div><div>GOSUB to 1291H to put decimal point and commas into the input buffer.</div></div>
									<div class="assembly-row-combined model1"><div>1277-1278</div><div>LD (HL),"0"</div><div>Save a zero character at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1279</div><div>INC HL</div><div>Bump the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>127A</div><div>DEC A</div><div>Decrement the counter of trailing zeroes to add in register A.</div></div>
									<div class="assembly-row-combined model1"><div>127B-127C</div><div><a href="#1273" class="memory-link">JR 1273H</a></div><div>Jump back up to 1273H to RET.</div></div>
								</div>
							</div>

							<br><h2 id="127D">127DH - Subroutine to set up BC for decimal 
point and comma counters.  On entry: Register D holds the number of 
digits to print, Register E holds the count of the times the value was 
scaled up or down.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>127D</div><div>LD A,E</div><div>Load register A with the value in register E so that A holds the count of the times the value was scaled up or down.</div></div>
									<div class="assembly-row-combined model1"><div>127E</div><div>ADD A,D</div><div>Add the number of digits to print (from Register D) to the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>127F</div><div>INC A</div><div>Bump the adjusted value in register A so now A holds the number of digits before the decimal point.</div></div>
									<div class="assembly-row-combined model1"><div>1280</div><div>LD B,A</div><div>Load register B with the leading digit count (from register A).</div></div>
									<div class="assembly-row-combined model1"><div>1281</div><div>INC A</div><div>Bump the value in register A so not A holds the leading digits + 2.</div></div>
									<div class="assembly-row-combined model1"><div>1282-1283</div><div>SUB A,03H</div><div>Subtract three from the adjusted value in register A which, when combined with the next instruction as a loop, divides modulo 3.</div></div>
									<div class="assembly-row-combined model1"><div>1284-1285</div><div><a href="#1282" class="memory-link">JR NC,1282H</a></div><div>Loop back 1 instruction until the value in register A is -1, -2, or -3.</div></div>
									<div class="assembly-row-combined model1"><div>1286-1287</div><div>ADD A,05H</div><div>Add 5 to A to get a positive remainder.  This will give 4, 3, or 2 as the comma count.</div></div>
									<div class="assembly-row-combined model1"><div>1288</div><div>LD C,A</div><div>Load register C with the comma count in register A.</div></div>
									<div class="assembly-row-combined model1" id="1289"><div>1289-128B</div><div>LD A,(40D8H)</div><div>Load register A with the value of the edit flag (stored at 40D8H).<br><b>NOTE:</b> 40D8H-40D9H holds the temporary storage location.</div></div>
									<div class="assembly-row-combined model1"><div>128C-128D</div><div>AND 40H</div><div>Mask
 the EDIT FLAG against 40H (Binary: 0100 0000) to isolate bit 6 (the 
comma bit) in the edit flag word to see if commas are requested.</div></div>
									<div class="assembly-row-combined model1"><div>128E</div><div>RET NZ</div><div>Return with Register C = Comma count if commas are requested.</div></div>
									<div class="assembly-row-combined model1" id="128F"><div>128F</div><div>LD C,A</div><div>Zero the comma counter in register C.</div></div>
									<div class="assembly-row-combined model1" id="1290"><div>1290</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="1291">1291H - Subroutine to count the leading digits before the decimal point.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1291</div><div>DEC B</div><div>Decrement the decimal point counter in register B to see if the zero flag sets or not.</div></div>
									<div class="assembly-row-combined model1"><div>1292-1293</div><div><a href="#129C" class="memory-link">JR NZ,129CH</a></div><div>Jump to 129CH if the decimal point position hasn't been reached.</div></div>
									<div class="assembly-row-combined model1"><div>1294-1295</div><div>LD (HL),"."</div><div>Save a <span class="code">.</span> at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1296-1298</div><div>LD (40F3H),HL</div><div>Save the address of the decimal point position (which is held in 40F3H) in register pair HL.<br><b>NOTE:</b> 40F3H-40F4H holds the temporary storage location.</div></div>
									<div class="assembly-row-combined model1"><div>1299</div><div>INC HL</div><div>Bump the input buffer pointer in register pair H to the first character of the fractional part of a numberL.</div></div>
									<div class="assembly-row-combined model1"><div>129A</div><div>LD C,B</div><div>Zero
 the comma/decimal counter in register C (because B is zero since the 
above jump didn't fire) to stop any more decimal points and commas.</div></div>
									<div class="assembly-row-combined model1"><div>129B</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="129C">129CH - Continuation Routine (from 1292H) if the decimal point position hasn't been reached.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>129C</div><div>DEC C</div><div>Decrement the decimal/comma counter in register C.</div></div>
									<div class="assembly-row-combined model1"><div>129D</div><div>RET NZ</div><div>Return if this location is not the end of a 3 character group (and so it doesn't need a comma).</div></div>
									<div class="assembly-row-combined model1"><div>129E-129F</div><div>LD (HL),","</div><div>If didn't jump out, then we need a comma here so put a comma at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>12A0</div><div>INC HL</div><div>Bump the input buffer pointer (to account for the new comma) in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>12A1-12A2</div><div>LD C,03H</div><div>Reset the comma counter by setting it to 3.</div></div>
									<div class="assembly-row-combined model1"><div>12A3</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="12A4">12A4 - Routine to Convert the INTEGER porton of a DOUBLE precision value to its ASCII equivalent.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>12A4</div><div>PUSH DE</div><div>Save the edit flags (stored in register pair DE) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>12A5</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>12A6-12A8</div><div><a href="#12EA" class="memory-link">JP PO,12EAH</a></div><div>If
 we have a single precision number (PO Flag Set), JUMP to 12EAH to 
convert a SINGLE precision number into its INTEGER equivalent.</div></div>
									<div class="assembly-row-combined model1"><div>12A9</div><div>PUSH BC</div><div>Now that we know we have a DOUBLE PRECISION number, save leading digit count/comma count (in register pair BC) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>12AA</div><div>PUSH HL</div><div>Save the input buffer address (in register pair HL) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>12AB-12AD</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09FC" class="memory-link">CALL 09FCH</a></div><div>GOSUB to 09FCH to mmove the double precision value in REG 1 to REG2.</div></div>
									<div class="assembly-row-combined model1"><div>12AE-12B0</div><div>LD HL,137CH</div><div>Load register pair HL with the starting address of a double precision constant equal to 0.5.</div></div>
									<div class="assembly-row-combined model1"><div>12B1-12B3</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09F7" class="memory-link">CALL 09F7H</a></div><div>GOSUB to 09F7H to move the double precision value pointed to by register pair HL to REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>12B4-12B6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0C77" class="memory-link">CALL 0C77H</a></div><div>GOSUB
 to 0C77H - DOUBLE PRECISION ADD function (which adds the double 
precision value in REG 2 to the value in REG 1 (which is the constant 
0.5).  Result is left in REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>12B7</div><div>XOR A</div><div>Zero register A and clear the status flags.</div></div>
									<div class="assembly-row-combined model1"><div>12B8-12BA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0B7B" class="memory-link">CALL 0B7BH</a></div><div>GOSUB to 0B7BH to adjust the double precision result in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>12BB</div><div>POP HL</div><div>Get the input buffer address from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>12BC</div><div>POP BC</div><div>Get the counters from the stack and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>12BD-12BF</div><div>LD DE,138CH</div><div>Load
 register pair DE with the starting address of a series of double 
precision constants (i.e., a table of powers of 10 from 1.0x10E15 - 
1.0x10E6) for the binary to ASCII conversion.</div></div>
									<div class="assembly-row-combined model1"><div>12C0-12C1</div><div>LD A,0AH</div><div>Load register A with the number of times to divide the double precision value in REG 1 by a power of 10.</div></div>
									<div class="assembly-row-combined model1"><div>12C2-12C4</div><div><a href="#1291" class="memory-link">CALL 1291H</a></div><div>GOSUB to 1291H to add a decimal point or comma (as applicable) into the input buffer if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>12C5</div><div>PUSH BC</div><div>Save
 the count of digits before the decimal point and the count of digts 
after the decimal point (stored in register pair BC) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>12C6</div><div>PUSH AF</div><div>Save the division count (stored in register pair AF) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>12C7</div><div>PUSH HL</div><div>Save the current input buffer address (stored in register pair HL) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>12C8</div><div>PUSH DE</div><div>Save the address of the power table (stored in register pair DE) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>12C9-12CA</div><div>LD B,2FH</div><div>Load register B (which will be the quotient in ASCII for each division) with the ASCII value for a zero character minus one.</div></div>
									<div class="assembly-row-combined model1" id="12CB"><div>12CB</div><div>INC B</div><div>Bump the ASCII value for the digit in register B so as to start with ASCII "0".</div></div>
									<div class="assembly-row-combined model1"><div>12CC</div><div>POP HL</div><div>Get the address of the power table (i.e., the divisor) from the stack and put it in register pair HL and ...</div></div>
									<div class="assembly-row-combined model1"><div>12CD</div><div>PUSH HL</div><div>... put it right back into the stack so that it can be restored during the loop.</div></div>
									<div class="assembly-row-combined model1"><div>12CE-12D0</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0D48" class="memory-link">CALL 0D48H</a></div><div>GOSUB
 to 0D48H to subtract the double precision value pointed to by register 
pair HL from the double precision value in REG l.  This is to divide the
 current integer value by of a power of 10 starting at 10e15 working its
 way down to 10e6 in a loop until the remainder is less than the current
 power).</div></div>
									<div class="assembly-row-combined model1"><div>12D1-12D2</div><div><a href="#12CB" class="memory-link">JR NC,12CBH</a></div><div>Jump
 back to do another subtraction and keep looping until the CARRY FLAG 
gets set by the subtraction (meaning that the remainder is now less than
 the current power).</div></div>
									<div class="assembly-row-combined model1"><div>12D3</div><div>POP HL</div><div>Get the address of the power table from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>12D4-12D6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0D36" class="memory-link">CALL 0D36H</a></div><div>GOSUB
 to 0D36H to add the double precision value pointed to by register pair 
HL (which is the table of powers of 10) to the double precision 
remainder in REG 1 to make it a positive value. Return with the correct 
remainder in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>12D7</div><div>EX DE,HL</div><div>Load register pair DE with the starting address for the current power of 10 (stored in register pair HL).</div></div>
									<div class="assembly-row-combined model1"><div>12D8</div><div>POP HL</div><div>Get the current input buffer address from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>12D9</div><div>LD (HL),B</div><div>Save the ASCII value for the digit in register B at the location of the input buffer pointer (stored in register pair HL).</div></div>
									<div class="assembly-row-combined model1"><div>12DA</div><div>INC HL</div><div>Bump the input buffer pointer in register pair HL since we have just put a digit there.</div></div>
									<div class="assembly-row-combined model1"><div>12DB</div><div>POP AF</div><div>Get the status flags from the stack and put it in register pair AF so that we can test for 10 times.</div></div>
									<div class="assembly-row-combined model1"><div>12DC</div><div>POP BC</div><div>Get the counts of digits before/after the decimal point value from the stack and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>12DD</div><div>DEC A</div><div>Decrement the counter value in register A (we are going to loop 10 times).</div></div>
									<div class="assembly-row-combined model1"><div>12DE-12DF</div><div><a href="#12C2" class="memory-link">JR NZ,12C2H</a></div><div>Loop 10 times until the ASCII string has been figured.</div></div>
									<div class="assembly-row-combined model1"><div>12E0</div><div>PUSH BC</div><div>Save the the counts of digits before/after the decimal point value (stored in register pair BC) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>12E1</div><div>PUSH HL</div><div>Save the current input buffer pointer (stored in register pair HL) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>12E2-12E4</div><div>LD HL,411DH</div><div>Load register pair HL with the starting address for REG 1 (which holds the last half of the DOUBLE prevision value)<br>Note: 411DH-4124H holds REG l.</div></div>
									<div class="assembly-row-combined model1"><div>12E5-12E7</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09B1" class="memory-link">CALL 09B1H</a></div><div>Call 09B1H (which moves a SINGLE PRECISION number pointed to by HL to REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>12E8-12E9</div><div><a href="#12F6" class="memory-link">JR 12F6H</a></div><div>Jump to 12F6H to convert that last half to ASCII.</div></div>
								</div>
							</div>

							<h2 id="12EAH">12EA - LEVEL II BASIC MATH ROUTINE<span class="origrom"> - "FOUTCS"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine is to convert a SINGLE precision value to an 
INTEGER which will be the decimal digits.  Divide the integer equivalent
 by 100,000 and 10,000.  Use the code at 1335H to convert the last 1000 
to ASCII.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>12EA</div><div>PUSH BC</div><div>Save the leading digit count/comma count (in register pair BC) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>12EB</div><div>PUSH HL</div><div>Save the current input buffer pointer (stored in register pair HL) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>12EC-12EE</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0708" class="memory-link">CALL 0708H</a></div><div>GOSUB to 0708H to add a single precision value of 0.5 to the single precision value in REG 1.  The result is stored in BC/DE.</div></div>
									<div class="assembly-row-combined model1"><div>12EF</div><div>INC A</div><div>Bump the MSB.</div></div>
									<div class="assembly-row-combined model1"><div>12F0-12F2</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0AFB" class="memory-link">CALL 0AFBH</a></div><div>GOSUB to 0AFBH to convert the positive single precision value in REG 1 to an integer.  The result is stored in BC/DE.</div></div>
									<div class="assembly-row-combined model1"><div>12F3-12F5</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09B4" class="memory-link">CALL 09B4H</a></div><div>GOSUB
 to 09B4H (which moves the SINGLE PRECISION value in DC/DE [which is the
 integer portion of the original single precision value] into REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>12F6</div><div>POP HL</div><div>Get the current input buffer pointer value from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>12F7</div><div>POP BC</div><div>Get the leading digit count/comma count value from the stack and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>12F8</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>12F9-12FB</div><div>LD DE,13D2H</div><div>Load register pair DE with the starting address for a series of integer values (in this case, 100,000).</div></div>
									<div class="assembly-row-combined model1" id="12FC"><div>12FC</div><div>CCF</div><div>Complement the CARRY FLAG.  This is the first time switch for the division loop of 12FC-1327H.</div></div>
									<div class="assembly-row-combined model1"><div>12FD-12FF</div><div><a href="#1291" class="memory-link">CALL 1291H</a></div><div>GOSUB to 1291H to put a decimal point or a comma into the input buffer if necessary .</div></div>
									<div class="assembly-row-combined model1"><div>1300</div><div>PUSH BC</div><div>Save the counts of digits before/after the decimal point value (stored in register pair BC) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1301</div><div>PUSH AF</div><div>Save the CARRY FLAG for the count of the number of times through this loop (stored in register pair AF) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1302</div><div>PUSH HL</div><div>Save the current input buffer pointer value (stored in register pair HL) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1303</div><div>PUSH DE</div><div>Save the division table address (stored in register pair DE) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1304-1306</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09BF" class="memory-link">CALL 09BFH</a></div><div>GOSUB to 09BFH (which loads the SINGLE PRECISION value in REG 1 into register pair BC/DE).</div></div>
									<div class="assembly-row-combined model1"><div>1307</div><div>POP HL</div><div>Get the division table address (the integer value for 100,000) from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1308-1309</div><div>LD B,2FH</div><div>Load register B with the ASCII value for a zero character minus one.</div></div>
									<p class="debug-note" id="130A">130AH - This routine divides 
the integer portion of the current value by 100,000 using compound 
subtraction.  The quotient is kept in Register B as an ASCII value.</p>
									<div class="assembly-row-combined model1"><div>130A</div><div>INC B</div><div>Bump the ASCII value from the digit in register B to increase the ASCII value from 0 and upward.</div></div>
									<div class="assembly-row-combined model1"><div>130B</div><div>LD A,E</div><div>Load register A with the LSB of the single precision value in register E.</div></div>
									<div class="assembly-row-combined model1"><div>130C</div><div>SUB (HL)</div><div>Subtract
 the value at the location of the memory pointer in register pair HL 
(the LSB of 100,000) from the value of the LSB of the single precision 
value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>130D</div><div>LD E,A</div><div>Load register E with the adjusted LSB of the single precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>130E</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL to the next digit of 100,000.</div></div>
									<div class="assembly-row-combined model1"><div>130F</div><div>LD A,D</div><div>Load register A with the NMSB of the single precision value in register D.</div></div>
									<div class="assembly-row-combined model1"><div>1310</div><div>SBC A,(HL)</div><div>Subtract
 the value at the location of the memory pointer in register pair HL 
(the middle byte of 100,000) from the value of the NMSB of the single 
precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1311</div><div>LD D,A</div><div>Load register D with the adjusted NMSB of the single precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1312</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL to the MSB of 100,000.</div></div>
									<div class="assembly-row-combined model1"><div>1313</div><div>LD A,C</div><div>Load register A with the MSB of the single precision value in register C.</div></div>
									<div class="assembly-row-combined model1"><div>1314</div><div>SBC A,(HL)</div><div>Subtract
 the value at the location of the memory pointer in register pair HL 
from the value of the MSB of 100,000 (a single precision value in 
register A).</div></div>
									<div class="assembly-row-combined model1"><div>1315</div><div>LD C,A</div><div>Load register C with the adjusted MSB of the single precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1316</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL to the NMSB of 100,000.</div></div>
									<div class="assembly-row-combined model1"><div>1317</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL again, now to the LSB of 100,000.</div></div>
									<div class="assembly-row-combined model1"><div>1318-1319</div><div><a href="#130A" class="memory-link">JR NC,130AH</a></div><div>Loop until the ASCII value for the digit under 100,000 has been figured.</div></div>
									<div class="assembly-row-combined model1"><div>131A-131C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#07B7" class="memory-link">CALL 07B7H</a></div><div>We
 need to add 100,000 to C/DE and make it positive so we GOSUB to 07B7H 
to add the value at the location of the memory pointer in register pair 
HL to the value in register pairs BC and DE.</div></div>
									<div class="assembly-row-combined model1"><div>131D</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL to now point to the 10,000 constant.</div></div>
									<div class="assembly-row-combined model1"><div>131E-1320</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09B4" class="memory-link">CALL 09B4H</a></div><div>Save the remainder as a current value by GOSUB to 09B4H (which moves the SINGLE PRECISION value in DC/DE into REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>1321</div><div>EX DE,HL</div><div>Load
 register pair DE with the address of the next value to divide the 
current value in REG 1 by (which is the constant of 10,000).</div></div>
									<div class="assembly-row-combined model1"><div>1322</div><div>POP HL</div><div>Get the value of the memory pointer from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1323</div><div>LD (HL),B</div><div>Save the ASCII value for the digit in register B at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1324</div><div>INC HL</div><div>Bump the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1325</div><div>POP AF</div><div>Get the CARRY FLAG from the stack and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>1326</div><div>POP BC</div><div>Get the value from the stack and put it in register pair BC so it can be saved later.</div></div>
									<div class="assembly-row-combined model1"><div>1327-1328</div><div><a href="#12FC" class="memory-link">JR C,12FCH</a></div><div>If the CARRY FLAG is set, then reset it and loop the dividing by 10,000 until the integer portion is found.</div></div>
									<div class="assembly-row-combined model1"><div>1329</div><div>INC DE</div><div>If
 we fall through to here, we have divided the integer part of the single
 precision variable by 100,000 and then by 10,000 with the remainder 
being positive and saved as the current value.  With this we bump the 
value of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>132A</div><div>INC DE</div><div>and again bump the value of the memory pointer in register pair DE, so now DE points to the constant 1,000.</div></div>
									<div class="assembly-row-combined model1"><div>132B-132C</div><div>LD A,04H</div><div>Load register A with the number of digits for the ASCII string to be figured.</div></div>
									<div class="assembly-row-combined model1"><div>132D-132E</div><div><a href="#1335" class="memory-link">JR 1335H</a></div><div>Jump down to 1335H to convert the remainder to 4 ASCII digits.</div></div>
								</div>
							</div>

							<br><h2 id="132F">132FH - This routine will convert an INTEGER to ASCII.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>132F</div><div>PUSH DE</div><div>Save the edit flags (stored in register pair DE) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1330-1332</div><div>LD DE,13D8H</div><div>Load register pair DE with the starting address of the descending powers of 10 starting at 10,000.</div></div>
									<div class="assembly-row-combined model1"><div>1333-1334</div><div>LD A,05H</div><div>Load register A with the number of digits for the ASCII string to be built (i.e., 5).</div></div>
									<p class="debug-note" id="1335">1335H - This routine will convert the last x (based on A) digits of an INTEGER to ASCII.</p>
									<div class="assembly-row-combined model1"><div>1335-1337</div><div><a href="#1291" class="memory-link">CALL 1291H</a></div><div>Go put a decimal point or a comma into the input buffer if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>1338</div><div>PUSH BC</div><div>Save the counts of digits before/after the decimal point value (stored in register pair BC) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1339</div><div>PUSH AF</div><div>Save the number of digits counter (stored in register A) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>133A</div><div>PUSH HL</div><div>Save the address of the power table (stored in register pair HL) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>133B</div><div>EX DE,HL</div><div>Load register pair HL with the starting address of the descending powers of 10 starting at 10,000 (stored in register pair DE).</div></div>
									<div class="assembly-row-combined model1"><div>133C</div><div>LD C,(HL)</div><div>Load register C with the LSB for the power of 10 stored in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>133D</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL to be the MDB of the power of 10.</div></div>
									<div class="assembly-row-combined model1"><div>133E</div><div>LD B,(HL)</div><div>Load register B with the MSB for the integer value at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>133F</div><div>PUSH BC</div><div>Save the integer value of the power of 10 in register pair BC to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1340</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL to the next value in the power of 10 table.</div></div>
									<div class="assembly-row-combined model1"><div>1341</div><div>EX (SP),HL</div><div>Exchange the memory pointer of the next power of 10 (stored in register pair HL) with the value in the stack, and vice versa.</div></div>
									<div class="assembly-row-combined model1"><div>1342</div><div>EX DE,HL</div><div>Load register pair DE with the current value from the stack (stored in register pair HL).</div></div>
									<div class="assembly-row-combined model1"><div>1343-1345</div><div>LD HL,(4121H)</div><div>Load register pair HL with the integer value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>1346-1347</div><div>LD B,2FH</div><div>Since
 we are about to start a loop which starts with an INC, compensate by 
loading register B with the ASCII value for a zero character minus one.</div></div>
									<p class="debug-note" id="1348">1348 - This loop divides the 
current value by a power of 10 starting at 10,000 and working down to 
10.  The remainder frome ach division is added to the division and the 
sum becomes the dividend for the next division until done.  The quotient
 is +2FH (which is the ASCII equivalent of a quotient).</p>
									<div class="assembly-row-combined model1"><div>1348</div><div>INC B</div><div>Bump the ASCII value for the digit in register B (so it starts at 0 and moves up each loop).</div></div>
									<div class="assembly-row-combined model1"><div>1349</div><div>LD A,L</div><div>Load register A with the LSB of the integer value in register L.</div></div>
									<div class="assembly-row-combined model1"><div>134A</div><div>SUB E</div><div>Subtract the value of the LSB of the integer value in register E from the value of the LSB of the integer value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>134B</div><div>LD L,A</div><div>Load register L with the adjusted value of the LSB of the integer value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>134C</div><div>LD A,H</div><div>Load register A with the value of the MSB of the integer value in register H.</div></div>
									<div class="assembly-row-combined model1"><div>134D</div><div>SBC A,D</div><div>Subtract the MSB of the integer value in register D from the value of the MSB of the integer value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>134E</div><div>LD H,A</div><div>Load register H with the adjusted value of the MSB of the integer value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>134F-1350</div><div><a href="#1348" class="memory-link">JR NC,1348H</a></div><div>Loop back to 1348H until the CARRY FLAG is triggered because the quotient (stored in HL) is less than the current power of 10.</div></div>
									<div class="assembly-row-combined model1"><div>1351</div><div>ADD HL,DE</div><div>Add the remainder (stored as an integer in register pair DE) to the quotient (stored in register pair HL as an integer).</div></div>
									<div class="assembly-row-combined model1"><div>1352-1354</div><div>LD (4121H),HL</div><div>Save the integer remainder (stored in register pair HL) in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>1355</div><div>POP DE</div><div>Get the address of the next power of 10 from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1356</div><div>POP HL</div><div>Get the memory pointer for the output buffer from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1357</div><div>LD (HL),B</div><div>Save
 the ASCII value for the digit (from register B that tracked the number 
of divisions) to the location of the output buffer pointer (stored in 
register pair HL).</div></div>
									<div class="assembly-row-combined model1"><div>1358</div><div>INC HL</div><div>Bump the value of the input buffer pointer in register pair HL since we just filled that spot with an ASCII value.</div></div>
									<div class="assembly-row-combined model1"><div>1359</div><div>POP AF</div><div>Get the number of digits to convert from the stack and put it in A.</div></div>
									<div class="assembly-row-combined model1"><div>135A</div><div>POP BC</div><div>Get the counts of digits before/after the decimal point value from the stack and put it into register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>135B</div><div>DEC A</div><div>Decrement the value of the counter in register A (which is a countdown from 5).</div></div>
									<div class="assembly-row-combined model1"><div>135C-135D</div><div><a href="#1335" class="memory-link">JR NZ,1335H</a></div><div>If the counter of the number of digits (from 5) is still not zero, jump back to 1335H until all of the digits have been figured.</div></div>
									<div class="assembly-row-combined model1"><div>135E-1360</div><div><a href="#1291" class="memory-link">CALL 1291H</a></div><div>So
 now all the digits have been calculated in ASCII, so GOSUB 1291H to put
 a decimal point or comma into the input buffer if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>1361</div><div>LD (HL),A</div><div>Save
 a zero (the value in register A which hit zero when the loop from 5 
finished) to the input buffer, pointed to by register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1362</div><div>POP DE</div><div>Get the value from the stack (which was whatever value was in DE when this routine started) and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1363</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="1364">1364-136B - DOUBLE PRECISION CONSTANT STORAGE LOCATION<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1364-136BH</div><div>00 00 00 00 F9 02 15 A2</div><div>A double precision constant equal to 1E10 (or 10 x 10E9)is stored here.</div></div>
								</div>
							</div>

							<br><h2 id="136C">136C-1373 - DOUBLE PRECISION CONSTANT STORAGE LOCATION<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>136C-1373H</div><div>FD FF 9F 31 A9 5F 63 B2</div><div>A double precision constant equal to 9.9921E14 (or 1 x 10e15) is stored here.</div></div>
								</div>
							</div>

							<br><h2 id="1374">1374-137B - DOUBLE PRECISION CONSTANT STORAGE LOCATION<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1374-137BH</div><div>FE FF 03 BF C9 1B 0E B6</div><div>A double precision constant equal to 1x10^16 is stored here.</div></div>
								</div>
							</div>

							<br><h2 id="137C">137C-1383 - DOUBLE PRECISION CONSTANT STORAGE LOCATION<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>137C-1383H</div><div>00 00 00 00 00 00 00 80</div><div>A double precision constant equal to 0.5 is stored here.<br>BYTE
 SAVING NOTE: Referencing 1380H, which is half-way through this double 
precision value of .5, results in a single precision value of 0.5.</div></div>
								</div>
							</div>

							<br><h2 id="1384">1384-138B - DOUBLE PRECISION CONSTANT STORAGE LOCATION<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1384-138BH</div><div>00 00 04 BF C9 1B 0E B6</div><div>A double precision constant equal to 1x10^16 is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>138A-138DH</div><div>0E B5 00 80</div><div>BYTE SAVING NOTE: A double precision constant equal to .502778.</div></div>
								</div>
							</div>

							<br><h2 id="138C">138C-13D1 - DOUBLE PRECISION INTEGER CONSTANT STORAGE LOCATION<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>138C-1392H</div><div>00 80 C6 A5 7E 8D 03</div><div>1 x 10e15.</div></div>
									<div class="assembly-row-combined model1"><div>1393-1399H</div><div>00 40 7A 10 F3 5A 00</div><div>1 x 10e14.</div></div>
									<div class="assembly-row-combined model1"><div>139A-13A0H</div><div>00 A0 72 4E 18 09 00</div><div>1 x 10e13.</div></div>
									<div class="assembly-row-combined model1"><div>13A1-13A7H</div><div>00 10 A5 D5 E8 00 00</div><div>1 x 10e12.</div></div>
									<div class="assembly-row-combined model1"><div>13A1-13A7H</div><div>00 10 A5 D5 E8 00 00</div><div>1 x 10e12.</div></div>
									<div class="assembly-row-combined model1"><div>13A8-13AEH</div><div>00 E8 76 48 17 00 00</div><div>1 x 10e11 (which is 100,000,000,000).</div></div>
									<div class="assembly-row-combined model1"><div>13AF-13B5H</div><div>00 E4 0B 54 02 00 00</div><div>1 x 10e10 (which is 10,000,000,000).</div></div>
									<div class="assembly-row-combined model1"><div>13B6-13BCH</div><div>00 CA 9A 3B 00 00 00</div><div>1 x 10e09 (which is 1,000,000,000).</div></div>
									<div class="assembly-row-combined model1"><div>13BD-13C3H</div><div>00 E1 F4 05 00 00 00</div><div>1 x 10e08 (which is 100,000,000).</div></div>
									<div class="assembly-row-combined model1"><div>13C4-13CAH</div><div>80 96 98 00 00 00 00</div><div>1 x 10e07 (which is 10,000,000).</div></div>
									<div class="assembly-row-combined model1"><div>13CB-13D1H</div><div>40 42 0F 00 00 00 00</div><div>1 x 10e06 (which is 1,000,000).</div></div>
								</div>
							</div>

							<br><h2 id="13D2">13D2H-13D9H - SINGLE PRECISION INTEGER CONSTANT STORAGE LOCATION<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>13D2-13D4H</div><div>A0 86 01</div><div>1 x 10e04 (which is 100,000).</div></div>
									<div class="assembly-row-combined model1"><div>13D5-13D7H</div><div>10 27 00</div><div>1 x 10e03 (which is 10,000).</div></div>
									<div class="assembly-row-combined model1"><div>13D8-13D9H</div><div>E8 03</div><div>1 x 10e02 (which is 1,000).</div></div>
									<div class="assembly-row-combined model1"><div>13DA-13DBH</div><div>E8 03</div><div>1 x 10e01 (which is 100).</div></div>
									<div class="assembly-row-combined model1"><div>13DEH</div><div>10</div><div>1 x 10e00 (which is 10).</div></div>
									<div class="assembly-row-combined model1"><div>13DF</div><div><a href="#1380" class="memory-link">NOP</a></div><div>Nothing.</div></div>
								</div>
							</div>

							<br><h2 id="13E0">13E1-13E6 - LEVEL II BASIC MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>13E1</div><div>NOP</div><div>Do nothing.</div></div>
									<div class="assembly-row-combined model1" id="13E2"><div>13E2-13E4</div><div>LD HL,0982H</div><div>Load register pair HL with 0982H.<br><b>NOTE:</b> 0982H is the address of the routine for conversion of floating point numbers from negative to positive.</div></div>
									<div class="assembly-row-combined model1"><div>13E5</div><div>EX (SP),HL</div><div>Exchange the value of that routines jump address to the stack with the value of the return address in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>13E6</div><div>JP (HL)</div><div>Jump to the address in register pair HL, which is basically a return to caller.</div></div>
								</div>
							</div>

							<h2 id="13E7H">13E7-13F1 - LEVEL II BASIC <span class="code">SQR(n)</span><span class="origrom"> - "SQR"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine computes the square root of any value in 
ACCumulator.  It processes it by raising n to the power of 0.5. The root
 is left in ACCumulator as a single precision value.  Single-precision 
values only should be used</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>13E7-13F1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09A4" class="memory-link">CALL 09A4H</a></div><div>GOSUB 09A4 which moves the SINGLE PRECISION value in REG 1 to the stack (stored in LSB/MSB/Exponent order).</div></div>
									<div class="assembly-row-combined model1"><div>13EA-13EC</div><div>LD HL,1380H</div><div>Load register pair HL with the starting address of a single precision constant equal to 0.5 (which will be the exponent).</div></div>
									<div class="assembly-row-combined model1"><div>13ED-13EF</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09B1" class="memory-link">CALL 09B1H</a></div><div>GOSUB 09B1H (which moves a SINGLE PRECISION number pointed to by HL to REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>13F0-13F1</div><div><a href="#13F5" class="memory-link">JR 13F5H</a></div><div>Jump to the <span class="code">EXP(n)</span>
 routine at 13F5H (which will be using a .5 exponent to do the square 
root) skipping 13F2H since the exponent is already single precision.</div></div>
								</div>
							</div>

							<h2 id="13F2H">13F2-1478H - LEVEL II BASIC X to the Y Power (X^Y) ROUTINE<span class="origrom"> - "FPWRQ"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>A call to 13F2H raises the single precision value which has 
been saved to the STACK to the power specified in ACCumulator. The 
result will be returned in ACCumulator. The method of computation is e 
** (y ln x).</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>13F2-13F4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0AB1" class="memory-link">CALL 0AB1H</a></div><div>Make
 sure that the exponent is single precision by GOSUB to 0AB1H which is 
the CONVERT TO SINGLE PRECISION routine at 0AB1H (which converts the 
contents of REG 1 from integer or double precision into single 
precision).</div></div>
									<div class="assembly-row-combined model1"><div>13F5</div><div>POP BC</div><div>Get the MSB of the single precision value from the stack and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>13F6</div><div>POP DE</div><div>Get the NMSB and the LSB of the single precision value from the stack and put it in register pair DE.</div></div>
									<p class="debug-note">NOTE: To use a ROM call to raise a single
 precision number (the base) to a single precision power (the exponent),
 store the base (single precision) in registers BCDE, and store the 
exponent (also single precision) in 4121H-4124H and then CALL 13F7H.  
The result (in single precision format) is in 4121H-4124H and in 
approximately 50 milliseconds.</p>
									<div class="assembly-row-combined model1"><div>13F7-13F9</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0955" class="memory-link">CALL 0955H</a></div><div>GOSUB 0955H to check the sign for the single precision value in REG 1 (the exponent).</div></div>
									<div class="assembly-row-combined model1"><div>13FA</div><div>LD A,B</div><div>Load register A with the MSB of the number to be raised (stored as a single precision value in register B).</div></div>
									<div class="assembly-row-combined model1"><div>13FB-13FC</div><div><a href="#1439" class="memory-link">JR Z,1439H</a></div><div>Jump to the <span class="code">EXP(n)</span> routine at 1439H if the exponent (the single precision value in REG 1) is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>13FD-13FF</div><div><a href="#1404" class="memory-link">JP P,1404H</a></div><div>Skip
 the next 2 opcodes (which check to see if zero is involved) if the 
exponent (the single precision value in REG 1) is positive.</div></div>
									<div class="assembly-row-combined model1"><div>1400</div><div>OR A</div><div>Check to see if the value to be raised (i.e., the single precision value in register pairs BC and DE) is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>1401-1403</div><div><a href="#199A" class="memory-link">JP Z,199AH</a></div><div>Display a <span class="code">?/0 ERROR</span>
 message if the single precision value in REG 1 is negative and the 
single precision value in register pairs BC and DE is equal to zero.<br>/0 ERROR entry point.</div></div>
									<div class="assembly-row-combined model1"><div>1404</div><div>OR A</div><div>ANOTHER check to see if the value to be raised (i.e., the single precision value in register pairs BC and DE) is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>1405-1407</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0779" class="memory-link">JP Z,0779H</a></div><div>Jump to 0779H if the value to be raised (i.e., the single precision value in register pairs BC and DE) is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>1408</div><div>PUSH DE</div><div>At
 this point we know that none of the values are zero, and we are raising
 the number to a positive power.  Save the value to be raised (the NMSB 
and the LSB of the single precision value in register pair DE) to the 
stack.</div></div>
									<div class="assembly-row-combined model1"><div>1409</div><div>PUSH BC</div><div>Save the exponent and the MSB of the single precision value in register pair BC to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>140A</div><div>LD A,C</div><div>Load register A with the value of the MSB of the single precision value to be raised (which is stored in register C).</div></div>
									<div class="assembly-row-combined model1"><div>140B-140C</div><div>OR 7FH</div><div>Test the sign of the based by turning on bits 0-6 of the MSB of the single precision value (0111 1111) in register A.</div></div>
									<div class="assembly-row-combined model1"><div>140D-140F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09BF" class="memory-link">CALL 09BFH</a></div><div>Load
 the exponent (the power) into BC/DE by GOSUB to 09BF which loads the 
SINGLE PRECISION value in REG 1 (the exponent) into register pair BC/DE.</div></div>
									<div class="assembly-row-combined model1"><div>1410-1412</div><div><a href="#1421" class="memory-link">JP P,1421H</a></div><div>Jump down to 1421H if the base (the single precision value to the stack) is positive.</div></div>
									<div class="assembly-row-combined model1"><div>1413</div><div>PUSH DE</div><div>Save the NMSB and the LSB of the exponent (the single precision value in register pair DE) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1414</div><div>PUSH BC</div><div>Save the exponent and the LSB of the single precision value in register pair BC to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1415-1417</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0B40" class="memory-link">CALL 0B40H</a></div><div>GOSUB
 to 0B40H to figure the integer portion of the exponent (i.e., the 
single precision value in REG 1) into A with the truncated floating 
point portion into REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>1418</div><div>POP BC</div><div>Restore the exponent and the MSB of the single precision value from the stack and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>1419</div><div>POP DE</div><div>Restore the NMSB and the LSB of the single precision value from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>141A</div><div>PUSH AF</div><div>Save the integer portion of the exponent (i.e., the value in register pair AF) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>141B-141D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0A0C" class="memory-link">CALL 0A0CH</a></div><div>Compare the original exponent to the truncated one by GOSUB to 0A0CH.<br><br><span class="nobottomborder bold">NOTE:</span>  The routine at 0A0CH algebraically compares the single precision value in BC/DE to the single precision value REG 1.<br>The results are stored in A as follows:<ul><li>A=00H if REG 1 = BCDE</li><li>A=01H if REG 1&gt;BCDE; and </li><li>A=FFH if REG 1&lt;BCDE.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>141E</div><div>POP HL</div><div>Get the exponent as an integer from the stack and put it in register H.</div></div>
									<div class="assembly-row-combined model1"><div>141F</div><div>LD A,H</div><div>Load register A with the exponent as an integer (as stored in register H).</div></div>
									<div class="assembly-row-combined model1"><div>1420</div><div>RRA</div><div>If the exponent (as an integer) is odd, set the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1" id="1421"><div>1421</div><div>POP HL</div><div>Get the original exponent from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1422-1424</div><div>LD (4123H),HL</div><div>Save the value of the original exponent and the MSB of the single precision value (stored in register pair HL)  in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>1425</div><div>POP HL</div><div>Get the rest of the exponent from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1426-1428</div><div>LD (4121H),HL</div><div>Save
 the rest of the exponent (i.e., as stored in register pair HL as the 
NMSB and the LSB of the single precision value) in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>1429-142B</div><div><a href="#13E2" class="memory-link">CALL C,13E2H</a></div><div>If the CARRY FLAG is set (i.e. the exponent is odd and the base is negative) GOSUB to 13E2H.</div></div>
									<div class="assembly-row-combined model1"><div>142C-142E</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0982" class="memory-link">CALL Z,0982H</a></div><div>If the exponent is an integer and the base is negative, GOSUB to 0983H to invert the value of the exponent.</div></div>
									<div class="assembly-row-combined model1"><div>142F</div><div>PUSH DE</div><div>Save the NMSB and the LSB of the exponent (i.e., the single precision value in register pair DE) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1430</div><div>PUSH BC</div><div>Save the MSB of the exponent (i.e., the single precision value in register pair BC) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1431-1433</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0809" class="memory-link">CALL 0809H</a></div><div>CALL
 the LOG(N) routine at 0809H (which computes the natural log (base E) of
 the single precision value in REG 1. The result is returned as a single
 precision value in REG 1.  Can give an ILLEGAL FUNCTION CALL erro if a 
negative base is raised to a power with a fraction).</div></div>
									<div class="assembly-row-combined model1"><div>1434</div><div>POP BC</div><div>Get the exponent and the MSB of the single precision value from the stack and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>1435</div><div>POP DE</div><div>Get the NMSB and the LSB of the single precision from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1436-1438</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0847" class="memory-link">CALL 0847H</a></div><div>We
 need to multiply the ln(value) * the exponent so we have to GOSUB to 
0847H to SINGLE PRECISION MULTIPLY routine (which multiplies the current
 value in REG 1 by the value in (BC/DE). The product is left in REG 1.</div></div>
								</div>
							</div>

							<br><h2 id="1439-span">1439 - <span class="code">EXP</span> routine. Single-precision only. (REG 1 = EXP(REG1)).<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>A call to 1439H raises E (natural base) to the value in REG 1
 which must be a single precision value. The result will be returned in 
REG 1 as a single precision number.<br><br>NOTE: To use a ROM call to 
find EXP(X), where X is a single precision variable, store the value of X
 in 4121H-4124H and then CALL 1439H.  The result (in single precision 
format) is in 4121H-4124Hin approximately 28 milliseconds.  NOTE: A 
fatal error occurs if the result is as large as 2 to the power of 127.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1439-143BH<span class="origrom2">EXP</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09A4" class="memory-link">CALL 09A4H</a></div><div>Call 09A4 to move the SINGLE PRECISION value in REG 1 (the exponent) to the stack (stored in LSB/MSB/Exponent order).</div></div>
									<div class="assembly-row-combined model1"><div>143C-143E</div><div>LD BC,8138H</div><div>Load register pair BC with the exponent and MSB of a single precision constant.</div></div>
									<div class="assembly-row-combined model1"><div>143F-1441</div><div>LD DE,AA3BH</div><div>Load
 register pair DE with the NMSB and the LSB of a single precision 
constant. Register pairs BC and DE are now equal to a single precision 
constant of 1.442695 (which is approximately 2 + ln 2).</div></div>
									<div class="assembly-row-combined model1"><div>1442-1444</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0847" class="memory-link">CALL 0847H</a></div><div>We
 need to multiply the exponent value by 2 ln 2 so we call the SINGLE 
PRECISION MULTIPLY routine at 0847H (which multiplies the current value 
in REG 1 by the value in (BC/DE). The product is left in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>1445-1447</div><div>LD A,(4124H)</div><div>Load
 register A with the result of the math just done (i.e., which was 
multiplying the exponent value by 2 ln 2) which was stored in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>1448-1449</div><div>CP 88H</div><div>Check
 to see if the integer portion of the single precision value in REG 1 
uses more than 7 bits of precision by comparing it against a mask of 
1000 1000.</div></div>
									<div class="assembly-row-combined model1"><div>144A-144C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0931" class="memory-link">JP NC,0931H</a></div><div>Jump to 0931H if the single precision value in REG 1 uses more than 7 bits of precision for its integer portion.</div></div>
									<div class="assembly-row-combined model1"><div>144D-144F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0B40" class="memory-link">CALL 0B40H</a></div><div>So
 now that we know the integer portion is less than 8 bits, we need to 
get the integer and put it into Register A by GOSUB to 0B40H to get the 
integer portion of the value in REG 1 and return with it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1450-1451</div><div>ADD A,80H</div><div>Adjust the value in register A by masking it against 80H (Binary: 1000 0000).</div></div>
									<div class="assembly-row-combined model1"><div>1452-1453</div><div>ADD A,02H</div><div>Adjust the value in register A by adding 2 more (Binary: 1000 0010).</div></div>
									<div class="assembly-row-combined model1"><div>1454-1456</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0931" class="memory-link">JP C,0931H</a></div><div>If (exponent * 2 ln 2) is =&gt; 126 (meaning when 2 was added it it, it overflowed with a 128), jump to 0931H.</div></div>
									<div class="assembly-row-combined model1"><div>1457</div><div>PUSH AF</div><div>Save the integer value (+82H) (as stored in register pair AF) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1458-145A</div><div>LD HL,07F8H</div><div>Load register pair HL with a single precision constant equal to 1.0 (as found at 1458H).</div></div>
									<div class="assembly-row-combined model1"><div>145B-145D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#070B" class="memory-link">CALL 070BH</a></div><div>Go
 add the single precision constant 1.0 (as pointed to by register pair 
HL) to the current value in REG 1 which is EXP * 2 ln 2.</div></div>
									<div class="assembly-row-combined model1"><div>145E-1460</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0841" class="memory-link">CALL 0841H</a></div><div>Need to multiply that by ln 2, so GOSUB to 0841H to multiply (1 + [EXP * 2 ln 2]) (as stored in REG 1) by 0.693147.</div></div>
									<div class="assembly-row-combined model1"><div>1461</div><div>POP AF</div><div>Get the integerized value of EXP * 2 ln 2 (as stored in the stack) and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>1462</div><div>POP BC</div><div>Get
 the original exponent into BC/DE in 2 steps fist get the exponent and 
the MSB of the single precision value from the stack and put it in 
register pair BC ...</div></div>
									<div class="assembly-row-combined model1"><div>1463</div><div>POP DE</div><div>and then get the NMSB and the LSB of the single precision value from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1464</div><div>PUSH AF</div><div>Save the integerized EXP * 2 ln 2 (stored in register pair AF) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1465-1467</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0713" class="memory-link">CALL 0713H</a></div><div>Now
 we need to subtract the original exponent from the integerized exponent
 so we GOSUB to 0713H which is the SINGLE PRECISION SUBTRACT routine 
(which subtracts the single precision value in BC/DE from the single 
precision value in REG 1.  The difference is left in REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>1468-146A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0982" class="memory-link">CALL 0982H</a></div><div>To
 force that difference to be a positive number we GOSUB to 0982H which 
makes the current single precision value in REG 1 positive.</div></div>
									<div class="assembly-row-combined model1"><div>146B-146D</div><div>LD HL,1479H</div><div>Load register pair HL with the starting address for a series of 8 coefficients.</div></div>
									<div class="assembly-row-combined model1"><div>146E-1470</div><div><a href="#14A9" class="memory-link">CALL 14A9H</a></div><div>GOSUB to 14A9H to do that series of computations.</div></div>
									<div class="assembly-row-combined model1"><div>1471-1473</div><div>LD DE,0000H</div><div>We need to load the integerized equivalent of EXP * 2 lnt 2 into BC/DE so first we load register pair DE with zero ...</div></div>
									<div class="assembly-row-combined model1"><div>1474</div><div>POP BC</div><div>... and then get the value from the stack and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>1475</div><div>LD C,D</div><div>Load register C with zero (since Register D was filled with a zero in 1471H).</div></div>
									<div class="assembly-row-combined model1"><div>1476-1478</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0847" class="memory-link">JP 0847H</a></div><div>We
 need to multiply by the sum from the series and return so we jump to 
0847H which is the the SINGLE PRECISION MULTIPLY routine at 0847H (which
 multiplies the current value in REG 1 by the value in (BC/DE). The 
product is left in REG 1.</div></div>
								</div>
							</div>

							<br><h2 id="1479">1479-1499 - SINGLE PRECISION CONSTANT STORAGE LOCATION<br>This represents 1/6, -1/5, 1/4, -1/3, 1/2, -1, and 1<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1479H</div><div>09</div><div>The number of single precision constants (9) which follow are stored here.</div></div>
									<div class="assembly-row-combined model1"><div>147A-147DH</div><div>40 2E 94 74</div><div>A single precision constant equal to -0.00014171607 (-1.413165 * 10e-4) is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>147E-1481H</div><div>70 4F 2E 77</div><div>A single precision constant equal to 0.00132988204 (1.32988 * 10e-3, roughly -1/6) is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>1482-1485H</div><div>6E 02 88 7A</div><div>A single precision constant equal to -0.00830136052 (-8.30136 * 10e-3, roughly -1/5) is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>1486-1489H</div><div>E7 A0 2A 7C</div><div>A single precision constant equal to 0.04165735095 (roughly 1/4) is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>148A-148DH</div><div>50 AA AA 7E</div><div>A single precision constant equal to -0.16666531543 (roughly -1/3) is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>148E-1491H</div><div>FF FF 7F 7F</div><div>A single precision constant equal to 0.49999996981 (roughly 1/2) is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>1492-1495H</div><div>00 00 80 81</div><div>A single precision constant equal to -1.0 is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>1496-1499H</div><div>00 00 00 81</div><div>A single precision constant equal to 1.0 is stored here.</div></div>
								</div>
							</div>

							<br><h2 id="149A">149A-14C8 - LEVEL II BASIC MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is a general purpose summation routine which computes 
the series SUM ((((x^2 * c0+c1)x^2 +c2)x^2 + ... cN)x for I=0 to N when 
entered at 149AH  If entered at 14A9H the series changes to SUM 
((((x*c0+c1)x*c2)x+c3)x+...cN.  On entry, the x is held in BC/DE and HL 
points to a list containing the number of terms followed by the 
coefficients.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>149A-149C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09A4" class="memory-link">CALL 09A4H</a></div><div>GOSUB to 09A4 to which move the SINGLE PRECISION value in REG 1 to the stack (stored in LSB/MSB/Exponent order).</div></div>
									<div class="assembly-row-combined model1"><div>149D-149F</div><div>LD DE,0C32H</div><div>Load register pair DE with the return address of 0C32H.<br><b>NOTE:</b> 0C32H pops BC and DE and then JUMPs to JP 0847H.</div></div>
									<div class="assembly-row-combined model1"><div>14A0</div><div>PUSH DE</div><div>Save DE to the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>14A1</div><div>PUSH HL</div><div>Save
 the memory pointer of list containing the number of terms followed by 
the coefficients (as stored in register pair HL) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>14A2-14A4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09BF" class="memory-link">CALL 09BFH</a></div><div>GOSUB to 09BFH which loads the SINGLE PRECISION value in REG 1 into register pair BC/DE.</div></div>
									<div class="assembly-row-combined model1"><div>14A5-14A7</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0847" class="memory-link">CALL 0847H</a></div><div>Since
 REG 1 and BC/DE now hold the same number, you can square that by a 
GOSUB to 0847H which is the SINGLE PRECISION MULTIPLY routine (which 
multiplies the current value in REG 1 by the value in (BC/DE). The 
product is left in REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>14A8</div><div>POP HL</div><div>Restore the address of the coefficient from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>14A9-14AB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09A4" class="memory-link">CALL 09A4H</a></div><div>We
 need to move either x or x**2 (depending on the routine entry point) to
 the stack so we GOSUB to 09A4 which moves the SINGLE PRECISION value in
 REG 1 to the stack (stored in LSB/MSB/Exponent order).</div></div>
									<div class="assembly-row-combined model1"><div>14AC</div><div>LD A,(HL)</div><div>Load register A with the number of values to be figured at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>14AD</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL so that it points to the next coefficient.</div></div>
									<div class="assembly-row-combined model1"><div>14AE-14B0</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09B1" class="memory-link">CALL 09B1H</a></div><div>Now
 load the coefficient (stored in HL) and move it to REG 1 by GOSUB to 
09B1H (which moves a SINGLE PRECISION number pointed to by HL to REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>14B1H</div><div>06 F1</div><div>Z-80 Trick!  See the general explanation at 10F8H.</div></div>
									<div class="assembly-row-combined model1"><div>14B2</div><div><a href="#10F8" class="memory-link">POP AF</a></div><div>Get the count of coefficients left (from the stack) and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>14B3-14B4</div><div>POP BC<br>POP DE</div><div>Get the value of x from the stack and put it in register pair BC/DE.</div></div>
									<div class="assembly-row-combined model1"><div>14B5</div><div>DEC A</div><div>Count 1 of the terms as computed by decrementing the counter in register A.</div></div>
									<div class="assembly-row-combined model1"><div>14B6</div><div>RET Z</div><div>If that decrement results in a zero (meaning the series of computations has been completed) return out of the subroutine.</div></div>
									<div class="assembly-row-combined model1"><div>14B7-14B8</div><div>PUSH DE<br>PUSH BC</div><div>Save the NMSB and the LSB of x from DE to the stack and save the MSB of x from BC to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>14B9</div><div>PUSH AF</div><div>Save counter of remaining terms to compute (stored in register A) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>14BA</div><div>PUSH HL</div><div>Save the value of the memory pointer to the next coefficient (stored in register pair HL) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>14BB-14BD</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0847" class="memory-link">CALL 0847H</a></div><div>Compute
 C(I)*x by GOSUB to 0847H which is the SINGLE PRECISION MULTIPLY routine
 (which multiplies the current value in REG 1 by the value in (BC/DE). 
The product is left in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>14BE</div><div>POP HL</div><div>Restore the coefficient table address (from the stack) to register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>14BF-14C1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09C2" class="memory-link">CALL 09C2H</a></div><div>Get
 the next coefficient from HL into BC/DE by GOSUB to 09C2H (which loads a
 SINGLE PRECISION value pointed to by register pair HL into register 
pairs BC and DE).</div></div>
									<div class="assembly-row-combined model1"><div>14C2</div><div>PUSH HL</div><div>Save the next coefficient (stored in register pair HL) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>14C3-14C5</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0716" class="memory-link">CALL 0716H</a></div><div>Compute
 C(I)*x+C(I+1) by GOSUB to 0716H which is the SINGLE PRECISION ADD 
routine (which adds the single precision value in (BC/DE) to the single 
precision value in REG 1. The sum is left in REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>14C6</div><div>POP HL</div><div>Restore the coefficient table address (from the stack) to register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>14C7-14C8</div><div><a href="#14B2" class="memory-link">JR 14B2H</a></div><div>Jump back to 14B2H to continue the series.  REG 1 contains the current term.</div></div>
								</div>
							</div>

							<br><h2 id="14C9">14C9-1540 - LEVEL II BASIC <span class="code">RND(n)</span>.
  Generates a single-precisions random number between 0 and 1, or 1 and n
 depending on the parameter passed in REG 1, The random value is 
returned in REG 1 as an integer with the mode flag set. The parameter 
passed will determine the range of the random number returned. A 
parameter of 0 will return an interger between 0 and 1. A parameter 
greater than 0 will have any fraction portion truncated and will cause a
 value between 1 and the integer portion of the parameter to be 
returned. <button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
								<p>NOTE: To run a RND(J) function via a ROM call just The RND(J)
 function (with J a nonzero integer) load the value of J into the HL 
register pair.  Then CALL 14CCH and then  CALL 0A7FH.  The result (in 
integer format) is in 4121H-4122H and in HL in approximately 5.7 
milliseconds.  The input variable J must have a value between 1 and 
32767, inclusive, or an FC error will occur.</p>
									<div class="assembly-row-combined model1"><div>14C9-14CBH<span class="origrom2">RNDM</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0A7F" class="memory-link">CALL 0A7FH</a></div><div>Call
 the CONVERT TO INTEGER routine at 0A7FH (where the contents of REG 1 
are converted from single or double precision to integer and deposited 
into HL).</div></div>
									<div class="assembly-row-combined model1"><div>14CC</div><div>LD A,H</div><div>Load register A with the value of the MSB for the integer value in register H.</div></div>
									<div class="assembly-row-combined model1"><div>14CD</div><div>OR A</div><div>Check to see if the integer value in register pair HL is negative.</div></div>
									<div class="assembly-row-combined model1"><div>14CE-14D0</div><div><a href="#1E4A" class="memory-link">JP M,1E4AH</a></div><div>Display a <span class="code">?FC ERROR</span> message if the integer value in register pair HL is negative.</div></div>
									<div class="assembly-row-combined model1"><div>14D1</div><div>OR L</div><div>To test for HL=0, the opcode pair of LD A,H / OR L is a simplest way.  Only if both H and L are zero, will A be zero.</div></div>
									<div class="assembly-row-combined model1"><div>14D2-14D4</div><div><a href="#14F0" class="memory-link">JP Z,14F0H</a></div><div>If it is zero, we don't need the rest of the below which functions to generate <span class="code">RND(n)</span>
 so we just jump to 14F0H (which generates RND(0)) if the integer value 
in register pair HL is equal to zero (meaning the call was for RND(0)).</div></div>
									<div class="assembly-row-combined model1"><div>14D5</div><div>PUSH HL</div><div>Since it wasn't zero, we need to save the n of <span class="code">RND(n)</span> (as stored in register pair HL) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>14D6-14D8</div><div><a href="#14F0" class="memory-link">CALL 14F0H</a></div><div>GOSUB to 14F0H (which generates <span class="code">RND(0)</span>) and return with the single precision result in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>14D9-14DB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09BF" class="memory-link">CALL 09BFH</a></div><div>Load the random number into BC/DE by a GOSUB to 09BFH which loads the SINGLE PRECISION value in REG 1 into register pair BC/DE.</div></div>
									<div class="assembly-row-combined model1"><div>14DC</div><div>EX DE,HL</div><div>Load register pair HL with the NMSB and the LSB of the single precision value in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>14DD</div><div>EX (SP),HL</div><div>Exchange
 the integer value to the stack with NMSB and the LSB of the single 
precision value in register pair HL.  At this point, the random number 
is in the stack and the n (of <span class="code">RND(n)</span>) is stored in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>14DE</div><div>PUSH BC</div><div>Save the RND(0) value to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>14DF-14E1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0ACF" class="memory-link">CALL 0ACFH</a></div><div>Convert
 the original x of RND(x) to single precision by GOSUB to 0ACFH which 
converts the integer value in register pair HL to single precision and 
return with the result in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>14E2-14E3</div><div>POP BC<br>POP DE</div><div>Restore the RND(0) value from the stack and put it into register pair BC/DE.</div></div>
									<div class="assembly-row-combined model1"><div>14E4-14E6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0847" class="memory-link">CALL 0847H</a></div><div>Multiply the RND(0) value (currently in BC/DE) by the n of <span class="code">RND(n)</span>
 (currently in REG 1) by GOSUB to 0847H which is the SINGLE PRECISION 
MULTIPLY routine (which multiplies the current value in REG 1 by the 
value in (BC/DE). The product is left in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>14E7-14E9</div><div>LD HL,07F8H</div><div>Load register pair HL with the starting address of a single precision constant equal to 1.0.</div></div>
									<div class="assembly-row-combined model1"><div>14EA-14EC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#070B" class="memory-link">CALL 070BH</a></div><div>Increase
 the random number by one by GOSUB to 070BH which adds the single 
precision constant pointed to by register pair HL (which is 1.0) to the 
single precision value in REG 1 (which is the random number). Return 
with the single precision result in REG 1</div></div>
									<div class="assembly-row-combined model1"><div>14ED-14EF</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0B40" class="memory-link">JP 0B40H</a></div><div>With the random number now in REG 1, jump to 0B40H (which will convert it to an integer and RETurn to the subroutine caller).</div></div>
								</div>
							</div>

							<br><h2 id="14F0">14F0H - This routine calculates <span class="code">RND(0)</span>.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>NOTE: To run a RND(0) function via a ROM call just CALL 
14F0H. No input variable is necessary. The result (in single precision 
format) is in 4121H-4124H in approximately 2.4 milliseconds.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>14F0-14F2</div><div>LD HL,4090H</div><div>Load register pair HL with the starting address for a table used for figuring random numbers.<br><b>NOTE:</b> 4090H holds the random number seed 2</div></div>
									<div class="assembly-row-combined model1"><div>14F3</div><div>PUSH HL</div><div>Save the starting address for a table used for figuring random numbers (stored in HL) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>14F4-14F6</div><div>LD DE,0000H</div><div>Load register pair DE with zero (which will be the NMLSB and LSB of the starting value).</div></div>
									<div class="assembly-row-combined model1"><div>14F7</div><div>LD C,E</div><div>Load register C with zero (C will be the MSB of the starting value).</div></div>
									<div class="assembly-row-combined model1"><div>14F8-14F9</div><div>LD H,03H</div><div>Load register H with the counter value for the loop (which will be 3).</div></div>
									<div class="assembly-row-combined model1" id="14FA"><div>14FA-14FB</div><div>LD L,08H</div><div>Load register L with a counter value of 8.</div></div>
									<div class="assembly-row-combined model1" id="14FC"><div>14FC</div><div>EX DE,HL</div><div>Exchange the counters in register pair HL with the NMSB and the LSB of the random number in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>14FD</div><div>ADD HL,HL</div><div>Multiply the NMSB and the LSB of the random number in register pair HL by two.</div></div>
									<div class="assembly-row-combined model1"><div>14FE</div><div>EX DE,HL</div><div>Exchange the NMSB and the LSB of the random number in register pair HL with the counters in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>14FF</div><div>LD A,C</div><div>Load register A with the MSB of the random number in register C.</div></div>
									<div class="assembly-row-combined model1"><div>1500</div><div>RLA</div><div>Multiply the MSB of the random number in register A by two.</div></div>
									<div class="assembly-row-combined model1"><div>1501</div><div>LD C,A</div><div>Load register C with the adjusted MSB of the random number in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1502</div><div>EX (SP),HL</div><div>Exchange the counter values in register pair HL with the value of the memory pointer to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1503</div><div>LD A,(HL)</div><div>Load register A with the table value (held at the location of the memory pointer in register pair HL).</div></div>
									<div class="assembly-row-combined model1"><div>1504</div><div>RLCA</div><div>Multiply the value in register A by two.</div></div>
									<div class="assembly-row-combined model1"><div>1505</div><div>LD (HL),A</div><div>Save the doubled value (stored in register A) at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1506</div><div>EX (SP),HL</div><div>Exchange the memory pointer in register pair HL with the counter values to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1507-1509</div><div><a href="#1516" class="memory-link">JP NC,1516H</a></div><div>Jump forward to 1516H if the table value hasn't overflowed.</div></div>
									<div class="assembly-row-combined model1"><div>150A</div><div>PUSH HL</div><div>If we are here, the table value overflowed so we need to save the counter values in register pair HL to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>150B-150D</div><div>LD HL,(40AAH)</div><div>Load register pair HL with the NMSB and the LSB of the random number seed.<br><b>NOTE:</b> 40AAH-40ADH holds the random number seed.</div></div>
									<div class="assembly-row-combined model1"><div>150E</div><div>ADD HL,DE</div><div>Add
 the NMSB and the LSB of the random number in register pair DE to the 
NMSB and the LSB of the random number seed in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>150F</div><div>EX DE,HL</div><div>Load register pair DE with the adjusted NMSB and LSB of the random number in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1510-1512</div><div>LD A,(40ACH)</div><div>Load register A with the MSB of the random number seed.</div></div>
									<div class="assembly-row-combined model1"><div>1513</div><div>ADC A,C</div><div>Add the MSB of the random number in register C to the MSB of the random number seed in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1514</div><div>LD C,A</div><div>Load register C with the adjusted MSB of the random number in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1515</div><div>POP HL</div><div>Get the counter values from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1516</div><div>DEC L</div><div>Decrement the loop counter in register L.</div></div>
									<div class="assembly-row-combined model1"><div>1517-1519</div><div><a href="#14FC" class="memory-link">JP NZ,14FCH</a></div><div>Loop back to 14FCH until the above has been done eight times.</div></div>
									<div class="assembly-row-combined model1"><div>151A</div><div>EX (SP),HL</div><div>Exchange the counter values in register pair HL with the memory pointer of the table value to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>151B</div><div>INC HL</div><div>Bump to the next table value.</div></div>
									<div class="assembly-row-combined model1"><div>151C</div><div>EX (SP),HL</div><div>Exchange the value of the table value in register pair HL with the counter value to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>151D</div><div>DEC H</div><div>Decrement the counter value of the outer loop (in register H).</div></div>
									<div class="assembly-row-combined model1"><div>151E-1520</div><div><a href="#14FA" class="memory-link">JP NZ,14FAH</a></div><div>Loop back to 14FAH three times until the random number has been figured.</div></div>
									<div class="assembly-row-combined model1"><div>1521</div><div>POP HL</div><div>Clear the flag table address from the stack.  The fact that it is going into HL is not important.</div></div>
									<div class="assembly-row-combined model1"><div>1522-1524</div><div>LD HL,B065H</div><div>Load register pair HL with the value to reseed the random number seed.</div></div>
									<div class="assembly-row-combined model1"><div>1525</div><div>ADD HL,DE</div><div>Add the seed (from register pair HL) to the NMSB and the LSB of the random number in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1526-1528</div><div>LD (40AAH),HL</div><div>Save the adjusted value in register pair HL as the NMSB and the LSB of the random number seed.<br><b>NOTE:</b> 40AAH-40ADH holds the random number seed.</div></div>
									<div class="assembly-row-combined model1"><div>1529-152B</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0AEF" class="memory-link">CALL 0AEFH</a></div><div>Go set the current number type to single precision.</div></div>
									<div class="assembly-row-combined model1"><div>152C-152D</div><div>LD A,05H</div><div>Load register A with a 5.</div></div>
									<div class="assembly-row-combined model1"><div>152E</div><div>ADC A,C</div><div>Add 5 (the value held in A) and the MSB of the random number in register C.</div></div>
									<div class="assembly-row-combined model1"><div>152F-1531</div><div>LD (40ACH),A</div><div>Save the adjusted value in register A as the MSB of the random number seed.</div></div>
									<div class="assembly-row-combined model1"><div>1532</div><div>EX DE,HL</div><div>Swap DE and HL so as to move the NMSB and LSB to DE so that we will have a BC/DE pair for the random number.</div></div>
									<div class="assembly-row-combined model1"><div>1533-1534</div><div>LD B,80H</div><div>Load register B with a value for the sign flag and the exponent (Binary: 1000 0000).</div></div>
									<div class="assembly-row-combined model1"><div>1535-1537</div><div>LD HL,4125H</div><div>Load register pair HL with the address for the sign value storage location.<br><b>NOTE:</b> 4125H-4126H is used by floating point routines.</div></div>
									<div class="assembly-row-combined model1"><div>1538</div><div>LD (HL),B</div><div>Save the sign result (1000 0000) in register B at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1539</div><div>DEC HL</div><div>Decrement to exponent (held in register pair HL).</div></div>
									<div class="assembly-row-combined model1"><div>153A</div><div>LD (HL),B</div><div>Set the exponent to (1000 0000) so that the value will be &lt; 1.</div></div>
									<div class="assembly-row-combined model1"><div>153B</div><div>LD C,A</div><div>Load register C with the value of the MSB for the single precision random number in register A.</div></div>
									<div class="assembly-row-combined model1"><div>153C-153D</div><div>LD B,00H</div><div>Zero the value of the exponent in register B.</div></div>
									<div class="assembly-row-combined model1"><div>153E-1540</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0765" class="memory-link">JP 0765H</a></div><div>Jump to 0765H which will normalize the value and then jump to 14D9H unless <span class="code">RND(0)</span> was called in which case return to caller.</div></div>
								</div>
							</div>

							<br><h2 id="1541">1541-1546 - LEVEL II BASIC <span class="code">COS</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>COS routine. Single-precision only.(REG 1 = COS(REG 1)).<br>A
 call to 1541H computes the cosine for an angle given in radians. The 
angle must be a floating point value in REG 1; the cosine will be 
returned in REG 1 as a floating point value.</p>
								<p>NOTE: To use a ROM call to find COS(X), where X is a single 
precision variable (in radians), store the value of X in 4121H-4124H and
 then CALL 1541H.  The result (in single precision format) is in 
4121H-4124Hin approximately 25 milliseconds.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1541-1543H<span class="origrom2">COSN</span></div><div>LD HL,158BH</div><div>Load register pair HL with the starting address of a single precision constant equal to 1.57079637029 (which is pi / 2).</div></div>
									<div class="assembly-row-combined model1"><div>1544-1546</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#070B" class="memory-link">CALL 070BH</a></div><div>GOSUB
 to 070BH to add 1.57079637029 (stored in HL) to the single precision 
value in REG 1 and then pass through to the SIN() routine which is next.</div></div>
								</div>
							</div>

							<br><h2 id="1547">1547-158A - LEVEL II BASIC <span class="code">SIN</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p><span class="code">SIN(n)</span> routine.  Single-precision only.(REG 1 = SIN(REG 1)).</p>
								<p>A call to 1549H returns the sine as a single precision value in REG 1. The sine must be given in radians in REG 1.</p>
								<p>The actual calculation routine is:
								</p><p>Assume X &lt;= 360 degrees.</p>
								<p>Recompute x as x=x/360 so that x=&lt; 1.</p>
								<p>If x &lt;= 90 degrees go to step 7.</p>
								<p>If x &lt;= 180 degrees then x=0.5-x and then go to step 7.</p>
								<p>If x &lt;= 270 degrees then x=0.5-x.</p>
								<p>Recompute x as x=x-1.0.</p>
								<p>Compute SIN using the power series.</p>
								<p>NOTE: To use a ROM call to find SIN(X), where X is a single 
precision variable, store the value of X in 4121H-4124H and then CALL 
1547H.  The result (in single precision format) is in 4121H-4124Hin 
approximately 25 milliseconds. NOTE: The argument (X) must be in 
radians.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1547-1549H<span class="origrom2">SINE</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09A4" class="memory-link">CALL 09A4H</a></div><div>Call
 09A4 which moves the SINGLE PRECISION value in REG 1 (the x in a SIN(x)
 call) to the stack (stored in LSB/MSB/Exponent order).</div></div>
									<div class="assembly-row-combined model1"><div>154A-154C</div><div>LD BC,8349H</div><div>Load register pair BC with the exponent and the MSB of a single precision constant.</div></div>
									<div class="assembly-row-combined model1"><div>154D-154F</div><div>LD DE,0FDBH</div><div>Load
 register pair DE with the NMSB and the LSB of a single precision 
constant. Register pairs BC and DE now hold a single precision constant 
equal to 6.2831855 (which is pi * 2).</div></div>
									<div class="assembly-row-combined model1"><div>1550-1552</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09B4" class="memory-link">CALL 09B4H</a></div><div>Move 2 x pi value (held in DC/BE) into REG 1 by GOSUB to 09B4H (which moves the SINGLE PRECISION value in DC/DE into REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>1553-1554</div><div>POP BC<br>POP DE</div><div>Put the x from a SIN(x) call into BC/DE.</div></div>
									<div class="assembly-row-combined model1"><div>1555-1557</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#08A2" class="memory-link">CALL 08A2H</a></div><div>To
 divide the x from a SIN(x) call (held in BC/DE) by pi*2 (held in REG 1)
 we must GOSUB 80A2H to divide the single precision value in register 
pairs BC and DE by the single precision value in REG 1. Return with the 
single precision result in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>1558-155A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09A4" class="memory-link">CALL 09A4H</a></div><div>Move
 that value (x / 2*pi) from REG 1 to the stack by GOSUB to 09A4H which 
moves the SINGLE PRECISION value in REG 1 to the stack (stored in 
LSB/MSB/Exponent order).</div></div>
									<div class="assembly-row-combined model1"><div>155B-155D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0B40" class="memory-link">CALL 0B40H</a></div><div>Go
 figure the integer portion for the single precision value in REG 1 by 
calling 0B40H.  We need to do this so we can isolate the remainder.</div></div>
									<div class="assembly-row-combined model1"><div>155EH,155F</div><div>POP BC<br>POP DE</div><div>Put the quotient and remainder of x/2*pi into BC/DE.</div></div>
									<div class="assembly-row-combined model1"><div>1560-1562</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0713" class="memory-link">CALL 0713H</a></div><div>To
 get the remainder we need to subtract the integer portion from the full
 portion so we GOSUB 0713H (the SINGLE PRECISION SUBTRACT routine) to 
subtract the single precision value in BC/DE (the entire result) from 
the single precision value in REG 1 (the integer part of the result).  
The difference is left in REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>1563-1565</div><div>LD HL,158FH</div><div>Load register pair HL with the starting address of a single precision constant equal to 0.25.</div></div>
									<div class="assembly-row-combined model1"><div>1566-1568</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0710" class="memory-link">CALL 0710H</a></div><div>Next
 in calculating a SIN we would need to subtract .25 (held in HL) from 
the fractional part (held in REG 1) so as to see if it is &lt;= to 90 
degrees.  To do this we GOSUB 0710H to subtract the single precision 
value in REG 1 from the single precision constant pointed to by register
 pair HL. Return with the result in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>1569-156B</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0955" class="memory-link">CALL 0955H</a></div><div>Go check the sign of the result of that (.25 - fractional part) subtraction which is held in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>156C</div><div>SCF</div><div>Set the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>156D-156F</div><div><a href="#1577" class="memory-link">JP P,1577H</a></div><div>Jump to 1577H if the single precision value in REG 1 is positive (meaning it is &lt; than 90 degrees).</div></div>
									<div class="assembly-row-combined model1"><div>1570-1572</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0708" class="memory-link">CALL 0708H</a></div><div>If
 we are here, it is =&gt; 90 degrees, so we need to add .5 to the single
 precision value in REG 1. Return with the result in REG 1</div></div>
									<div class="assembly-row-combined model1"><div>1573-1575</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0955" class="memory-link">CALL 0955H</a></div><div>Go
 check the sign for the single precision value in REG 1 which basically 
checks to see if it is &gt; 0.75 (meaning &lt; 270 degrees).</div></div>
									<div class="assembly-row-combined model1"><div>1576</div><div>OR A</div><div>Test the value of the sign test in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1577</div><div>PUSH AF</div><div>Save the sign indicator (+ or -1) in register pair AF to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1578-157A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0982" class="memory-link">CALL P,0982H</a></div><div>If it is positive, make it negative by GOSUB to 0982H.</div></div>
									<div class="assembly-row-combined model1"><div>157B-157D</div><div>LD HL,158FH</div><div>Load register pair HL with the starting address of a single precision constant equal to 0.25.</div></div>
									<div class="assembly-row-combined model1"><div>157E-1580</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#070B" class="memory-link">CALL 070BH</a></div><div>Add .25 (stored in HL) to the current value in REG 1 by GOSUB to 070BH (result is saved in REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>1581</div><div>POP AF</div><div>Get the sign reversal flag from the stack and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>1582-1584</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0982" class="memory-link">CALL NC,0982H</a></div><div>Set the sign of the x term according to the quadrant by GOSUB to 0982H if if the CARRY FLAG wasn't set from above.</div></div>
									<div class="assembly-row-combined model1"><div>1585-1587</div><div>LD HL,1593H</div><div>Load
 register pair HL with 1593H (which is the starting address for a series
 of single precision values for a set of computations).</div></div>
									<div class="assembly-row-combined model1"><div>1588-158A</div><div><a href="#149A" class="memory-link">JP 149AH</a></div><div>JUMP to 149AH to compute the series and then RETURN.</div></div>
								</div>
							</div>

							<br><h2 id="158B">158BH-15A7H - SINGLE PRECISION CONSTANT STORAGE LOCATION<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>158B-158EH</div><div>DB 0F 49 81</div><div>A single precision constant equal to 1.57079637029 is stored here.</div></div>
									<div class="assembly-row-combined model1" id="158F"><div>158F-1592H</div><div>00 00 00 7F</div><div>A single precision constant equal to 0.25 is stored here.</div></div>
									<div class="assembly-row-combined model1" id="1593"><div>1593H</div><div>05H</div><div>The
 number of single precision constants (05) which follows is stored here.
  These are the coefficients used in the power series to compute SIN(x).</div></div>
									<div class="assembly-row-combined model1" id="1594"><div>1594-1597H</div><div>BAH D7H 1EH 86H</div><div>A single precision constant equal to 39.7106704708 is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>1598-159BH</div><div>64H 26H 99H 87H</div><div>A single precision constant equal to -76.5749816893 is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>159C-159FH</div><div>58H 34H 23H 87H</div><div>A single precision constant equal to 81.6022338865 is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>15A0-15A3H</div><div>E0H 6DH A5H 86H</div><div>A single precision constant equal to -41.3416748045 is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>15A4-15A7H</div><div>DAH 0FH 49H 83H</div><div>A single precision constant equal to 6.28318500497 is stored here.</div></div>
								</div>
							</div>

							<br><h2 id="15A8">15A8-15BC - LEVEL II BASIC TAN ROUTINE <span class="code">TAN(n)</span> - "TAN"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Single-precision only.(REG 1 = TAN(REG 1)).<br>A call to 
15A8H computes the tangent of an angle in radians. The angle must be 
specified as a single precision value in REG 1. The tangent will be left
 in REG 1.<br>Uses the fact that TAN(x) = SIN(x) / COS(x)</p>
								<p>NOTE: To use a ROM call to find TAN(X), where X is a single 
precision variable (in radians), store the value of X in 4121H-4124H and
 then CALL 15A8H. The result (in single precision format) is in 
4121H-4124Hin approximately 54 milliseconds. NOTE: A fatal error occurs 
if the result is as large as 2 to the power of 127, which will be the 
case if the value of X is sufficiently close to any odd multiple of pi/2
 radians.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>15A8-15AA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09A4" class="memory-link">CALL 09A4H</a></div><div>Call 09A4 which moves the SINGLE PRECISION value in REG 1 to the stack (stored in LSB/MSB/Exponent order).</div></div>
									<div class="assembly-row-combined model1"><div>15AB-15AD</div><div><a href="#1547" class="memory-link">CALL 1547H</a></div><div>Call the <span class="code">SIN(n)</span> routine at 1547H (which returns the sine as a single precision value in REG 1. The sine must be given in radians in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>15AEH,15AF</div><div>POP BC<br>POP HL</div><div>Get the original exponent and value from the stack and put it in register pair BC/HL.</div></div>
									<div class="assembly-row-combined model1"><div>15B0-15B2</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09A4" class="memory-link">CALL 09A4H</a></div><div>Call 09A4 which moves the SIN(x) single precision value (stored in REG) 1 to the stack (stored in LSB/MSB/Exponent order).</div></div>
									<div class="assembly-row-combined model1"><div>15B3</div><div>EX DE,HL</div><div>Load register pair DE with the NMSB and the LSB of the single precision value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>15B4-15B6H&nbsp;</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09B4" class="memory-link">CALL 09B4H</a></div><div>Call 09B4H (which moves the original value in BC/DE into REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>15B7-15B9</div><div><a href="#1541" class="memory-link">CALL 1541H</a></div><div>Call
 the COSINE routine at 1541H (which computes the cosine for an angle 
given in radians. The angle must be a floating point value; the cosine 
will be returned in REG 1 as a floating point value.</div></div>
									<div class="assembly-row-combined model1"><div>15BA-15BC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#08A0" class="memory-link">JP 08A0H</a></div><div>Jump to 08A0H to compute <span class="code">SIN(n)</span> / <span class="code">COS(n)</span> and return the value as <span class="code">TAN(n)</span>.</div></div>
								</div>
							</div>

							<br><h2 id="15BD">15BD-15E2 - LEVEL II BASIC ATN ROUTINE <span class="code">ATN(n)</span> routine - "ATAN".<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Single-precision only.(REG 1 = ATN(REG 1)).<br>A call to 15BD
 returns the angle in radians, for the floating point tangent value in 
REG 1. The angle will be left as a single precision value in REG 1.<br>The method of computation used in this routine is:
								</p><p>Test the sign of the tangent to see if a negative angle 
is in the 2nd or 4th quadrant.  Set the flag to force the result to 
positive on exit.  If the value is negative, invert the sign.</p>
								<p>Test magnitude of tangent.  If it is &lt; 1 go to step 3.  
Otherwise, compute its reciprocal and put the return address on the 
stack that will calculate pi/2 - series value.</p>
								<p>Evaluate the series:  (((x^2*c0+c1) x^2+c2) ... c8)x</p>
								<p>If the flag from step 1 is not set, then invert the sign of the series result.</p>
								<p>If the original value is &lt; 1 then return to the caller.  Otherwise, compute pi/2-value from step 4 and then return.</p>
								<p>NOTE: To use a ROM call to find ATN(X), where X is a single 
precision variable, store the value of X in 4121H-4124H and then CALL 
15BDH. The result (in single precision format, in radians) is in 
4121H-4124Hin approximately 27 milliseconds.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>15BD-15BF</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0955" class="memory-link">CALL 0955H</a></div><div>Go check the sign of the single precision value in REG 1</div></div>
									<div class="assembly-row-combined model1"><div>15C0-15C2</div><div><a href="#13E2" class="memory-link">CALL M,13E2H</a></div><div>If the single precision value in REG 1 is negative then GOSUB to 13E2H to return address of 0982H to the stack pointer.</div></div>
									<div class="assembly-row-combined model1"><div>15C3-15C5</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0982" class="memory-link">CALL M,0982H</a></div><div>Go convert the negative number in REG 1 to positive if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>15C6-15C8</div><div>LD A,(4124H)</div><div>Load register A with the exponent of the tangent (which is a single precision value in REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>15C9-15CA</div><div>CP 81H</div><div>Check
 to see if the the exponent of the tangent (which is a single precision 
value in REG 1) is less than one by comparing it against 81H (Binary: 
1000 0001).  Results:<ul><li>If A="1" it sets the ZERO FLAG.</li><li>If A&lt;"1" then the CARRY FLAG will be set</li><li>If A&gt;="1" then the NO CARRY FLAG will be set.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>15CB-15CC</div><div><a href="#15D9" class="memory-link">JR C,15D9H</a></div><div>Jump to forward to 15D9H if A&lt;"1".</div></div>
									<div class="assembly-row-combined model1"><div>15CD-15CF</div><div>LD BC,8100H</div><div>Load register pair BC with an exponent and a MSB for a single precision value.  This also sets C to 00H.</div></div>
									<div class="assembly-row-combined model1"><div>15D0</div><div>LD D,C</div><div>Zero the NMSB of the single precision value in register D.</div></div>
									<div class="assembly-row-combined model1"><div>15D1</div><div>LD E,C</div><div>Zero the LSB of the single precision value in register E.</div></div>
									<div class="assembly-row-combined model1"><div>15D2-15D4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#08A2" class="memory-link">CALL 08A2H</a></div><div>GOSUB
 082AH to get the reciprocal of the tangent.  This routine divides the 
single precision value in REG 1 into the single precision constant in 
register pairs BC and DE.</div></div>
									<div class="assembly-row-combined model1"><div>15D5-15D7</div><div>LD HL,0710H</div><div>Load register pair HL with a return address of 0710H (which is the subtract routine to be called once the series is calculated).</div></div>
									<div class="assembly-row-combined model1"><div>15D8</div><div>PUSH HL</div><div>Save the value of the return address in register pair HL to the stack.</div></div>
									<div class="assembly-row-combined model1" id="15D9"><div>15D9-15DB</div><div>LD HL,15E3H</div><div>Load register pair HL with the starting address for a series of single precision numbers for a set of computations.</div></div>
									<div class="assembly-row-combined model1"><div>15DC-15DE</div><div><a href="#149A" class="memory-link">CALL 149AH</a></div><div>GOSUB to 149AH to do the set of computations.</div></div>
									<div class="assembly-row-combined model1"><div>15DF-15E1</div><div>LD HL,158BH</div><div>Load register pair HL with the starting address of a single precision constant equal to 1.57079637029 (which is pi/2).</div></div>
									<div class="assembly-row-combined model1"><div>15E2</div><div>RET</div><div>Return.  The return address was set to 0710H above, which will then subtract the last term from pi/2 and then return.</div></div>
								</div>
							</div>

							<br><h2 id="15E3">15E3-1607 - SINGLE PRECISION CONSTANTS STORAGE LOCATION<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>15E3H</div><div>09H</div><div>The number of single precision constants (9) which follows is stored here</div></div>
									<div class="assembly-row-combined model1"><div>15E4-15E7H</div><div>4A D7 3B 78</div><div>A single precision constant equal to 0.00286622549 is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>15E8-15EBH</div><div>02 6E 84 7B</div><div>A single precision constant equal to -0.01616573699 is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>15EC-15EFH</div><div>FE C1 2F 7C</div><div>A single precision constant equal to 0.04290961441 is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>15F0-15F3H</div><div>74 31 9A 3D</div><div>A single precision constant equal to 0.07528963666 is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>15F4-15F7H</div><div>84 3D 5A 7D</div><div>A single precision constant equal to 0.10656264407 is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>15F8-15FBH</div><div>C8 7F 91 7E</div><div>A single precision constant equal to -0.14208900905 is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>15FC-15FFH</div><div>E4 BB 4C 7E</div><div>A single precision constant equal to 0.19993549561 is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>1600-1603H</div><div>6C AA AA 7F</div><div>A single precision constant equal to -0.33333146561 is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>1604-1607H</div><div>00 00 00 01</div><div>A single precision constant equal to 1.0 is stored here.</div></div>
								</div>
							</div>

							<h2 id="1608H">1608-18C8 - LIST OF BASIC RESERVED WORDS, TOKENS, AND ENTRY LOCATIONS AS FOLLOWS:<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The original ROM source code makes an interesting note about 
the order of these reserved words. Some reserved words are contained in 
other reserved words, which will cause a problem. They given examples 
of:
									</p><ul>
										<li><span class="code">IF J=F OR T=5</span> will process a <span class="code">FOR</span></li>
										<li><span class="code">INP</span> is part of <span class="code">INPUT</span></li>
										<li><span class="code">IF T OR Q THEN</span> will process a <span class="code">TO</span></li>
									</ul>
									SO, the smaller word always has to appear later in the reserved word table.
								<p></p>

								<br><br><br><br><br><br><br><table class="data-table">
									<thead><tr><th>Word</th><th>Token</th><th>Address</th><th>Word</th><th>Token</th><th>Address</th></tr></thead>
									<tbody>
										<tr><td>ABS</td><td>D9</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0977H" class="memory-link">0977</a></td><td>AND</td><td>D2</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#25FDH" class="memory-link">25FD</a></td></tr>
										<tr><td>ASC</td><td>F6</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2A0FH" class="memory-link">2A0F</a></td><td>ATN</td><td>E4</td><td><a href="#15BDH" class="memory-link">15BD</a></td></tr>
										<tr><td>AUTO</td><td>B7</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2008H" class="memory-link">2008</a></td><td>CDBL</td><td>F1</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0ADBH" class="memory-link">0ADB</a></td></tr>
										<tr><td>CHR$(</td><td>F7</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2A1FH" class="memory-link">2A1F</a></td><td>CINT</td><td>EF</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0A7FH" class="memory-link">0A7F</a></td></tr>
										<tr><td>CLEAR</td><td>B8</td><td><a href="#1E7AH" class="memory-link">1E7A</a></td><td>CLOAD</td><td>B9</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2C1FH" class="memory-link">2C1F</a></td></tr>
										<tr><td>CLOSE</td><td>A6</td><td>4185</td><td>CLS</td><td>84</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#01C9H" class="memory-link">01C9</a></td></tr>
										<tr><td>CMD</td><td>85</td><td>4173</td><td>CONT</td><td>B3</td><td><a href="#1DE4H" class="memory-link">1DE4</a></td></tr>
										<tr><td>COS</td><td>El</td><td><a href="#1541H" class="memory-link">1541</a></td><td>CSAVE</td><td>BA</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2BF5H" class="memory-link">2BF5</a></td></tr>
										<tr><td>CSNG</td><td>F0</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0ABlH" class="memory-link">0ABl</a></td><td>CVD</td><td>E8</td><td>415E</td></tr>
										<tr><td>CVI</td><td>E6</td><td>4152</td><td>CVS</td><td>E7</td><td>4158</td></tr>
										<tr><td>DATA</td><td>88</td><td><a href="#1F05H" class="memory-link">1F05</a></td><td>DEF</td><td>DD</td><td>415B</td></tr>
										<tr><td>DEFDBL</td><td>9B</td><td><a href="#1E09H" class="memory-link">1E09</a></td><td>DEFINT</td><td>99</td><td><a href="#1E03H" class="memory-link">1E03</a></td></tr>
										<tr><td>DEFSNG</td><td>9A</td><td><a href="#1E06H" class="memory-link">1E06</a></td><td>DEFSTR</td><td>98</td><td><a href="#1E00H" class="memory-link">1E00</a></td></tr>
										<tr><td>DELETE</td><td>B6</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2BC6H" class="memory-link">2BC6</a></td><td>DIM</td><td>8A</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2608H" class="memory-link">2608</a></td></tr>
										<tr><td>EDIT</td><td>9D</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2E60H" class="memory-link">2E60</a></td><td>ELSE</td><td>95</td><td><a href="#1F07H" class="memory-link">1F07</a></td></tr>
										<tr><td>END</td><td>80</td><td><a href="#1DAEH" class="memory-link">1DAE</a></td><td>EOF</td><td>E9</td><td>4161</td></tr>
										<tr><td>ERL</td><td>C2</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#24DDH" class="memory-link">24DD</a></td><td>ERR</td><td>C3</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#24CFH" class="memory-link">24CF</a></td></tr>
										<tr><td>ERROR</td><td>9E</td><td><a href="#1FF4H" class="memory-link">1FF4</a></td><td>EXP</td><td>E0</td><td><a href="#1439H" class="memory-link">1439</a></td></tr>
										<tr><td>FIELD</td><td>A3</td><td>417C</td><td>FIX</td><td>F2</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0B26H" class="memory-link">0B26</a></td></tr>
										<tr><td>FN</td><td>BE</td><td>4155</td><td>FOR</td><td>81</td><td><a href="#1CA1H" class="memory-link">1CA1</a></td></tr>
										<tr><td>FRE</td><td>DA</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#27D4H" class="memory-link">27D4</a></td><td>GET</td><td>A4</td><td>4174</td></tr>
										<tr><td>GOSUB</td><td>91</td><td><a href="#1EB1H" class="memory-link">1EB1</a></td><td>GOTO</td><td>5D</td><td><a href="#1EC2H" class="memory-link">1EC2</a></td></tr>
										<tr><td>IF</td><td>8F</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2039H" class="memory-link">2039</a></td><td>INKEY$</td><td>C9</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#019DH" class="memory-link">019D</a></td></tr>
										<tr><td>INP</td><td>DB</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2AEFH" class="memory-link">2AEF</a></td><td>INPUT</td><td>89</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#219AH" class="memory-link">219A</a></td></tr>
										<tr><td>INSTR</td><td>C5</td><td>419D</td><td>INT</td><td>D8</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0B37H" class="memory-link">0B37</a></td></tr>
										<tr><td>KILL</td><td>AA</td><td>4191</td><td>LEFT$</td><td>F8</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2A61H" class="memory-link">2A61</a></td></tr>
										<tr><td>LEN</td><td>F3</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2A03H" class="memory-link">2A03</a></td><td>LET</td><td>8C</td><td><a href="#1F21H" class="memory-link">1F21</a></td></tr>
										<tr><td>LINE</td><td>9C</td><td>41A3</td><td>LIST</td><td>B4</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2B2EH" class="memory-link">2B2E</a></td></tr>
										<tr><td>LLIST</td><td>B5</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2B29H" class="memory-link">2B29</a></td><td>LOAD</td><td>A7</td><td>4188</td></tr>
										<tr><td>LOC</td><td>EA</td><td>4164</td><td>LOF</td><td>EB</td><td>4167</td></tr>
										<tr><td>LOG</td><td>DF</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0809H" class="memory-link">0809</a></td><td>LPRINT</td><td>AF</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2067H" class="memory-link">2067</a></td></tr>
										<tr><td>LSET</td><td>AB</td><td>4197</td><td>MEM</td><td>C8</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#27C9H" class="memory-link">27C9</a></td></tr>
										<tr><td>MERGE</td><td>A8</td><td>418B</td><td>MID$</td><td>FA</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2A9AH" class="memory-link">2A9A</a></td></tr>
										<tr><td>MKD$</td><td>EE</td><td>4170</td><td>NAME</td><td>A9</td><td>418E</td></tr>
										<tr><td>NEW</td><td>BB</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#1B49H" class="memory-link">1B49H</a></td><td>NEXT</td><td>87</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#22B6H" class="memory-link">22B6</a></td></tr>
										<tr><td>NOT</td><td>CB</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#25C4H" class="memory-link">25C4</a></td><td>ON</td><td>A1</td><td><a href="#1FC6H" class="memory-link">1FC6</a></td></tr>
										<tr><td>OPEN</td><td>A2</td><td>4179</td><td>OR</td><td>D3</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#25F7H" class="memory-link">25F7</a></td></tr>
										<tr><td>OUT</td><td>AO</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2AFBH" class="memory-link">2AFB</a></td><td>PEEK</td><td>E5</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2CAAH" class="memory-link">2CAA</a></td></tr>
										<tr><td>POINT</td><td>C6</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0132H" class="memory-link">0132</a></td><td>POKE</td><td>B1</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2CB1H" class="memory-link">2CB1</a></td></tr>
										<tr><td>POS</td><td>DC</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#27F5H" class="memory-link">27F5</a></td><td>PRINT</td><td>B2</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#206FH" class="memory-link">206F</a></td></tr>
										<tr><td>PUT</td><td>A5</td><td>4182</td><td>RANDOM</td><td>86</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#01D3H" class="memory-link">01D3</a></td></tr>
										<tr><td>READ</td><td>8B</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#21EFH" class="memory-link">21EF</a></td><td>REM</td><td>93</td><td><a href="#1F07H" class="memory-link">1F07</a></td></tr>
										<tr><td>RESET</td><td>82</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0138H" class="memory-link">0138</a></td><td>RESTORE</td><td>90</td><td><a href="#1D91H" class="memory-link">1D91</a></td></tr>
										<tr><td>RESUME</td><td>9F</td><td><a href="#1FAFH" class="memory-link">1FAFH</a></td><td>RETURN</td><td>92</td><td><a href="#1EDEH" class="memory-link">1EDEH</a></td></tr>
										<tr><td>RIGHT$</td><td>F9</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2A91H" class="memory-link">2A91</a></td><td>RND</td><td>DE</td><td><a href="#14C9H" class="memory-link">14C9</a></td></tr>
										<tr><td>RSET</td><td>AC</td><td>419A</td><td>RUN</td><td>8E</td><td><a href="#1EA3H" class="memory-link">1EA3</a></td></tr>
										<tr><td>SAVE</td><td>AD</td><td>41A0</td><td>SET</td><td>83</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0135H" class="memory-link">0135</a></td></tr>
										<tr><td>SGN</td><td>D7</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#098AH" class="memory-link">098A</a></td><td>SIN</td><td>E2</td><td><a href="#1547H" class="memory-link">1547</a></td></tr>
										<tr><td>SQR</td><td>CD</td><td><a href="#13E7H" class="memory-link">13E7</a></td><td>STEP</td><td>cc</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2B01H" class="memory-link">2B01</a></td></tr>
										<tr><td>STOP</td><td>94</td><td><a href="#1DA9H" class="memory-link">1DA9</a></td><td>STR$</td><td>F4</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2836H" class="memory-link">2836</a></td></tr>
										<tr><td>STRING$</td><td>C4</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2A2FH" class="memory-link">2A2F</a></td><td>SYSTEM</td><td>AE</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#02B2H" class="memory-link">02B2</a></td></tr>
										<tr><td>TAB(</td><td>BC</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2137H" class="memory-link">2137</a></td><td>TAN</td><td>E3</td><td><a href="#15A8H" class="memory-link">15A8</a></td></tr>
										<tr><td>THEN</td><td>CA</td><td></td><td>TIME$</td><td>C7</td><td>4176</td></tr>
										<tr><td>TO</td><td>BD</td><td></td><td>TROFF</td><td>97</td><td><a href="#1DF8H" class="memory-link">1DF8</a></td></tr>
										<tr><td>TRON</td><td>96</td><td><a href="#1DF8H" class="memory-link">1DF8</a></td><td>USING</td><td>BF</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2CBDH" class="memory-link">2CBD</a></td></tr>
										<tr><td>USR</td><td>C1</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#27FEH" class="memory-link">27FE</a></td><td>VAL</td><td>FF</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2AC5H" class="memory-link">2AC5</a></td></tr>
										<tr><td>VARPTR</td><td>C0</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#24EBH" class="memory-link">24EB</a></td><td>+</td><td>CD</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#249FH" class="memory-link">249F</a></td></tr>
										<tr><td>-</td><td>CE</td><td><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2532H" class="memory-link">2532</a></td><td>*</td><td>CF</td><td></td></tr>
										<tr><td>/</td><td>D0</td><td></td><td>?</td><td>D1</td><td></td></tr>
										<tr><td>&gt;</td><td>D4</td><td></td><td>=</td><td>D5</td><td></td></tr>
										<tr><td>&lt;</td><td>D6</td><td></td><td>&amp;</td><td>26</td><td></td></tr>
										<tr><td>'</td><td>FB</td><td>3A93</td><td></td><td></td><td></td></tr>
									</tbody>
								</table>

							</div>

							<h2 id="18C9H">18C9-18F6 - STORAGE LOCATION FOR LEVEL II BASIC ERROR MESSAGES<span class="origrom"> - "ERRTAB"</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined"><div>18C9</div><div>"NF"</div><div>NEXT without FOR Error Message (Error 00H)</div></div>
									<div class="assembly-row-combined"><div>18CB</div><div>"SN"</div><div>Syntax Error Error Message (Error 02H)</div></div>
									<div class="assembly-row-combined"><div>18CD</div><div>"RG"</div><div>RETURN without GOSUB Error Message (Error 04H)</div></div>
									<div class="assembly-row-combined"><div>18CF</div><div>"OD"</div><div>Out of DATA) Error Message (Error 06H)</div></div>
									<div class="assembly-row-combined"><div>18D1</div><div>"FC"</div><div>Illegal Function Call Error Message (Error 08H)</div></div>
									<div class="assembly-row-combined"><div>18D3</div><div>"OV"</div><div>Overflow Error Message (Error 0AH)</div></div>
									<div class="assembly-row-combined"><div>18D5</div><div>"OM"</div><div>Out of Memory Error Message (Error 0CH)</div></div>
									<div class="assembly-row-combined"><div>18D7</div><div>"UL"</div><div>Underfined Line Number Error Message (Error 0EH)</div></div>
									<div class="assembly-row-combined"><div>18D9</div><div>"BS"</div><div>Subscript out of Range Error Message (Error 10H)</div></div>
									<div class="assembly-row-combined"><div>18DB</div><div>"DD"</div><div>Redimensioned Array Error Message (Error 12H)</div></div>
									<div class="assembly-row-combined"><div>18DD</div><div>"/0"</div><div>Division by Zero Error Message (Error 14H)</div></div>
									<div class="assembly-row-combined"><div>18DF</div><div>"ID"&gt;</div><div>Illegal Direct Operation Error Message (Error 16H)</div></div>
									<div class="assembly-row-combined"><div>18E1</div><div>"TM"</div><div>Type Mismatch Error Message (Error 18H)</div></div>
									<div class="assembly-row-combined"><div>18E3</div><div>"OS"</div><div>Out of String Message (Error 1AH)</div></div>
									<div class="assembly-row-combined"><div>18E5</div><div>"LS"</div><div>Out of Memory Error Message (Error 1CH)</div></div>
									<div class="assembly-row-combined"><div>18E7</div><div>"ST"</div><div>String Too Long Error Message (Error 1EH)</div></div>
									<div class="assembly-row-combined"><div>18E9</div><div>"CN"</div><div>Can't Continue Error Message (Error 20H)</div></div>
									<div class="assembly-row-combined"><div>18EB</div><div>"NR"</div><div>No RESUME Error Message (Error 22H)</div></div>
									<div class="assembly-row-combined"><div>18ED</div><div>"RW"</div><div>RESUME Without Error Error Message (Error 24H)</div></div>
									<div class="assembly-row-combined"><div>18EF</div><div>"UE"</div><div>Unprintable Error Error Message (Error 26H)</div></div>
									<div class="assembly-row-combined"><div>18F1</div><div>"HO"</div><div>Missing Operand Error Message (Error 28H)</div></div>
									<div class="assembly-row-combined"><div>18F3</div><div>"FD"</div><div>Bad file Data Error Message (Error 2AH)</div></div>
									<div class="assembly-row-combined"><div>18F5</div><div>"L3"</div><div>Disk BASIC Command Error Message (Error 2CH)</div></div>
								</div>
							</div>

							<br><h2 id="18F7">18F7-1904 - STORAGE LOCATION FOR THE SINGLE PRECISION DIVISION ROUTINE<br>This code is moved from 18F7-191DH to 4080H-40A5H during non-disk initial setup.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>18F7</div><div>SUB 00H</div><div>Subtract the LSB</div></div>
									<div class="assembly-row-combined model1"><div>18F9</div><div>LD L,A</div><div>Restore the value to L</div></div>
									<div class="assembly-row-combined model1"><div>18FA</div><div>LD A,H</div><div>Get the middle byte</div></div>
									<div class="assembly-row-combined model1"><div>18FB</div><div>SBC A,00H</div><div>Subtract the middle byte</div></div>
									<div class="assembly-row-combined model1"><div>18FD</div><div>LD H,A</div><div>Move the difference to H</div></div>
									<div class="assembly-row-combined model1"><div>18FE</div><div>LD A,B</div><div>Get the MSB</div></div>
									<div class="assembly-row-combined model1"><div>18FF</div><div>SBC A,00H</div><div>Subtract the MSB</div></div>
									<div class="assembly-row-combined model1"><div>1901</div><div>LD B,A</div><div>Move it back to A</div></div>
									<div class="assembly-row-combined model1"><div>1902</div><div>LD A,00H</div><div>Clear A</div></div>
									<div class="assembly-row-combined model1"><div>1904</div><div>RET</div><div>RETurn.</div></div>
								</div>
							</div>

							<br><h2 id="1905">1905-191C - STORAGE LOCATION FOR VALUES PLACED IN RAM UPON INITIALIZATION.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This code is moved to 408E during non-disk initial setup.</p>
								<div class="assembly-table">

									<div class="assembly-row-combined model1"><div>1918H</div><div>X</div><div>Difference
 between M1 and M3 ROMs: 1917H - 1918H contains 434CH in the Model I, 
444CH in the Model III. This value is loaded to 40A0H (the start of 
string space pointer) during power-up.</div></div>
									<div class="assembly-row-combined model1"><div>191CH</div><div>X</div><div>Difference
 between M1 and M3 ROMs: 191BH - 191CH contains 42E9H in the Model I, 
43E9H in the Model III. This value is loaded to 40A4H (the start of 
BASIC program pointer) during power-up.</div></div>

								</div>
							</div>

							<br><h2 id="191D">191DH-1935H - MESSAGE STORAGE LOCATION<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>191D-1923H</div><div>"Error"</div><div>The Level II BASIC ERROR message is stored here.</div></div>
									<div class="assembly-row-combined model1" id="1924"><div>1924-1928H</div><div>"in"</div><div>The Level II BASIC IN message is stored here.</div></div>
									<div class="assembly-row-combined model1" id="1929"><div>1929-192FH</div><div>"READY"</div><div>The Level II BASIC READY message is stored here.</div></div>
									<div class="assembly-row-combined model1" id="1930"><div>1930-1935H</div><div>"Break"</div><div>The Level II BASIC BREAK message is stored here.</div></div>
								</div>
							</div>

							<br><h2 id="1936">1936-1954 - SCAN STACK ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine is called with DE as the address of the NEXT index.  It scans the stack backwards looking for a <span class="code">FOR</span>
 push.  If one is found, it gets the address of the index and compares 
with the DE that was in place when this routine was called.  If it is 
equal, then it exits with A=0 and HL=Address of the variable.  If it is 
not equal it will keep scanning until no FOR push is found and then exit
 with A&lt;&gt;0.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1936-1938</div><div>LD HL,0004H</div><div>Load register pair HL with 4 so that we can backspace.</div></div>
									<div class="assembly-row-combined model1"><div>1939</div><div>ADD HL,SP</div><div>Add
 the 4 (held in HL) to the current value of the stack pointer.  HL will 
hold the current stack pointer, the stack point will bump forward 4.</div></div>
									<div class="assembly-row-combined model1"><div>193A</div><div>LD A,(HL)</div><div>Load register A with the value held at the current stack point MINUS 4.</div></div>
									<div class="assembly-row-combined model1"><div>193B</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL so as to backspace one more byte in case a <span class="code">FOR</span> token is located.</div></div>
									<div class="assembly-row-combined model1"><div>193C-193D</div><div>CP 81H</div><div>Check to see if the value in register A (which is the current stack pointer - 4) is a <span class="code">FOR</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>193E</div><div>RET NZ</div><div>Return if the value in register A isn't a <span class="code">FOR</span> token.  This returns with A being non-zero because there was no <span class="code">FOR</span> push.</div></div>
									<div class="assembly-row-combined model1"><div>193F</div><div>LD C,(HL)</div><div>Load register C with the LSB of the <span class="code">FOR</span>'s variable address.</div></div>
									<div class="assembly-row-combined model1"><div>1940</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL so as to backspace the current stack pointer by yet another byte.</div></div>
									<div class="assembly-row-combined model1"><div>1941</div><div>LD B,(HL)</div><div>Load register B with the MSB of the <span class="code">FOR</span>'s variable address.</div></div>
									<div class="assembly-row-combined model1"><div>1942</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL so now HL will be the address of the <span class="code">FOR</span> variable on the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1943</div><div>PUSH HL</div><div>Save the value in register pair HL (which is the address of the <span class="code">FOR</span> variable) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1944</div><div>LD L,C</div><div>Load register L with the LSB of the <span class="code">FOR</span> variable's address in register C.</div></div>
									<div class="assembly-row-combined model1"><div>1945</div><div>LD H,B</div><div>Load register H with the MSB of the <span class="code">FOR</span> variable's address in register B.</div></div>
									<div class="assembly-row-combined model1"><div>1946</div><div>LD A,D</div><div>Load register A with the MSB of the variable address in register D. This sets up fto test the user specified variable address.</div></div>
									<div class="assembly-row-combined model1"><div>1947</div><div>OR E</div><div>Check to see if the variable address in register pair DE is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>1948</div><div>EX DE,HL</div><div>Exchange
 the variable address in register pair HL with the variable address in 
register pair DE so that DE will now hold the address of the <span class="code">FOR</span> variable from the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1949-194A</div><div><a href="#194D" class="memory-link">JR Z,194DH</a></div><div>Skip the next 2 opcodes if the variable address in register pair DE was equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>194B</div><div>EX DE,HL</div><div>Exchange
 the variable address in register pair HL with the variable address in 
register pair DE so that HL will now have the address of the <span class="code">FOR</span> variable from the stack.</div></div>
									<div class="assembly-row-combined model1"><div>194C</div><div>RST 18H</div><div>This routine was entered with DE being the address of the <span class="code">NEXT</span>
 index, so we need to compare that against the index from the stack.  To
 do this, we RST 18 to see if the variable address in HL is the same as 
in DE, so we call the COMPARE DE:HL routine, which numerically compares 
DE and HL. Will not work for signed integers (except positive ones). 
Uses the A-register only. The result of the comparison is returned in 
the status register as:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1" id="194D"><div>194D-194F</div><div>LD BC,000EH</div><div>Load register pair BC with the value to backspace to next <span class="code">FOR</span> token (which is 10).</div></div>
									<div class="assembly-row-combined model1"><div>1950</div><div>POP HL</div><div>Get the memory pointer from the stack of the sign of the increment flag and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1951</div><div>RET Z</div><div>Return if the <span class="code">FOR</span> block matched the <span class="code">NEXT</span> index block.</div></div>
									<div class="assembly-row-combined model1"><div>1952</div><div>ADD HL,BC</div><div>If it didn't match, execute that 10 byte stepback in BC for the next possible <span class="code">FOR</span> push.</div></div>
									<div class="assembly-row-combined model1"><div>1953-1954</div><div><a href="#193A" class="memory-link">JR 193AH</a></div><div>Keep looking until the appropriate <span class="code">FOR</span> block has been located.</div></div>
								</div>
							</div>

							<br><h2 id="1955">1955-1962 - DATA MOVEMENT ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine moves a variable into another area specified by 
the caller.  On entry BC is set as the end address of the list to move 
(which is the upper limit); DE is set as the start address of the list 
to move; and HL is the end of the area to move it to.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1955-1957</div><div><a href="#196C" class="memory-link">CALL 196CH</a></div><div>GOSUB to 196CH to make sure there's enough room in memory for the string area.</div></div>
									<div class="assembly-row-combined model1"><div>1958</div><div>PUSH BC</div><div>Save the end address of the list to move (stored in BC) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1959</div><div>EX (SP),HL</div><div>Save the end address of the list to move (stored in the stack now) to register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>195A</div><div>POP BC</div><div>Get the end address of the move from the stack and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>195B</div><div>RST 18H</div><div>Now
 we need to check to see if the memory pointer in HL is the same as the 
memory pointer in DE (to see if the move is finished), so we call the 
COMPARE DE:HL routine, which numerically compares DE and HL. Will not 
work for signed integers (except positive ones). Uses the A-register 
only. The result of the comparison is returned in the status register 
as:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>195C</div><div>LD A,(HL)</div><div>Get a byte from the source list and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>195D</div><div>LD (BC),A</div><div>Save the byte into wherever BC is pointing.</div></div>
									<div class="assembly-row-combined model1" id="195E"><div>195E</div><div>RET Z</div><div>Return
 if finished with the move (i.e., the memory pointer in register pair HL
 is the same as the value of the memory pointer in register pair DE).</div></div>
									<div class="assembly-row-combined model1"><div>195F</div><div>DEC BC</div><div>Decrement the source address (in register pair BC).</div></div>
									<div class="assembly-row-combined model1"><div>1960</div><div>DEC HL</div><div>Decrement the destination address (in register pair HL).</div></div>
									<div class="assembly-row-combined model1"><div>1961-1962</div><div><a href="#195B" class="memory-link">JR 195BH</a></div><div>Loop until the list was moved.</div></div>
								</div>
							</div>

							<br><h2 id="1963">1963-197D - MEMORY CHECK ROUTINE - Computes the amount of space between HL and the end of memory at FFC6H.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1963</div><div>PUSH HL</div><div>Save the value in register pair HL to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1964-1966</div><div>LD HL,(40FDH)</div><div>Load register pair HL with the starting address of free memory (which is stored at 40FDH).<br><b>NOTE:</b> 40FDH-40FEH holds the pointer to the starting address of free memory.</div></div>
									<div class="assembly-row-combined model1"><div>1967-1968</div><div>LD B,00H</div><div>Load register B with zero.</div></div>
									<div class="assembly-row-combined model1"><div>1969</div><div>ADD HL,BC</div><div>Add 2 times the number of bytes required to start of free area (held in register pair BC) to the value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>196A</div><div>ADD HL,BC</div><div>Add the value in register pair BC to the value in register pair HL leaving HL to now contain the end of the free area.</div></div>
									<div class="assembly-row-combined model1"><div>196B-196C</div><div>3EH E5H</div><div>Z-80 Trick!  See the general explanation at 10F8H.</div></div>
									<div class="assembly-row-combined model1"><div>196C</div><div><a href="#10F8" class="memory-link">PUSH HL</a></div><div>Save the new free area pointer (which is the start) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>196D-196E</div><div>LD A,C6H</div><div>Load register A with C6H (which is the the LSB of FFC6H; the top of memory).</div></div>
									<div class="assembly-row-combined model1"><div>196F</div><div>SUB L</div><div>Subtract the LSB of the value of the new memory pointer in register L from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1970</div><div>LD L,A</div><div>Load
 register L with the adjusted value in register A (i.e., the free memory
 pointer resulting from subtracting the new starting address).</div></div>
									<div class="assembly-row-combined model1"><div>1971-1972</div><div>LD A,FFH</div><div>Load register A with the MSB of the top of memory.</div></div>
									<div class="assembly-row-combined model1"><div>1973</div><div>SBC A,H</div><div>Subtract
 the MSB of the new memory pointer in register H from the value in 
register A.  If the free space list exceeds FFC6 then the CARRY FLAG 
gets set, meaning memory overflowed.</div></div>
									<div class="assembly-row-combined model1"><div>1974-1975</div><div><a href="#197A" class="memory-link">JR C,197AH</a></div><div>If the CARRY FLAG is set, display a <span class="code">?OM ERROR</span> since we are out of memory.</div></div>
									<div class="assembly-row-combined model1"><div>1976</div><div>LD H,A</div><div>Next
 we need to determine if the free space list has overflowed the stack 
area so first we load register H with the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1977</div><div>ADD HL,SP</div><div>Add the value of the stack pointer to the adjusted value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1978</div><div>POP HL</div><div>Get the value from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1979</div><div>RET C</div><div>If the CARRY FLAG is set, then we have no overflow - so we better RETURN because the next step is an OM error processor.</div></div>
								</div>
							</div>

							<br><h2 id="197A">197A-197B - OM ERROR entry point.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>197A-197B</div><div>LD E,0CH</div><div>Load register E with the <span class="code">?OM ERROR</span>.</div></div>
									<div class="assembly-row-combined model1"><div>197C-197D</div><div><a href="#19A2" class="memory-link">JR 19A2H</a></div><div>Display an <span class="code">?OM ERROR</span> message.</div></div>
								</div>
							</div>

							<br><h2 id="197E">197E-1AF7 - LEVEL II BASIC COMMAND MODE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>197E-1980</div><div>LD HL,(40A2H)</div><div>Load register pair HL with the value of the current BASIC line number.<br><b>NOTE:</b> 40A2H-40A3H holds the current BASIC line number.</div></div>
									<div class="assembly-row-combined model1"><div>1981</div><div>LD A,H</div><div>Load register A with the MSB of the current BASIC line number in register H.</div></div>
									<div class="assembly-row-combined model1"><div>1982</div><div>AND L</div><div>Combine the LSB of the current BASIC line number in register L with the MSB of the current line number in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1983</div><div>INC A</div><div>Bump
 the value of the combined BASIC line number in register A.  If the 
current line is FFFFH then we have not started execution of a BASIC 
program yet (meaning we are still in the inputting phase).</div></div>
									<div class="assembly-row-combined model1"><div>1984-1985</div><div><a href="#198E" class="memory-link">JR Z,198EH</a></div><div>Jump to 198EH if Level II BASIC is still in the command mode (rather than being in execution mode).</div></div>
									<div class="assembly-row-combined model1"><div>1986-1988</div><div>LD A,(40F2H)</div><div>Load register A with contents of 40F2H.<br><b>NOTE:</b> 40F2H holds the error flag.</div></div>
									<div class="assembly-row-combined model1"><div>1989</div><div>OR A</div><div>Check to see if the error flag is set.</div></div>
									<div class="assembly-row-combined model1"><div>198A-198B</div><div>LD E,22H</div><div>Load register E with a <span class="code">?NR ERROR</span> code.</div></div>
									<div class="assembly-row-combined model1"><div>198C-198D</div><div><a href="#19A2" class="memory-link">JR NZ,19A2H</a></div><div>Jump to 19A2H if the error flag is set (meaning there was no <span class="code">RESUME</span> address).</div></div>
									<div class="assembly-row-combined model1"><div>198E-1990</div><div><a href="#1DC1" class="memory-link">JP 1DC1H</a></div><div>Otherwise, jump to 1DC1H (the READY routine) because there was an error in the input phase.</div></div>
									<div class="assembly-row-combined model1"><div>1991-1993</div><div>LD HL,(40DAH)</div><div>Load register pair HL with the <span class="code">DATA</span> line number (which is stored at 16602).<br><b>NOTE:</b> 40DAH-40DBH holds DATA line number.</div></div>
									<div class="assembly-row-combined model1"><div>1994-1996</div><div>LD (40A2H),HL</div><div>Save the DATA line number in register pair HL.<br><b>NOTE:</b> 40A2H-40A3H holds the current BASIC line number.</div></div>
									<div class="assembly-row-combined model1"><div>1997-1998</div><div>LD E,02H</div><div>Load register E with a <span class="code">?SN ERROR</span> code.<br>SN ERROR entry point.</div></div>
									<div class="assembly-row-combined model1" id="199A"><div>199A-199B</div><div>LD E,14H</div><div>Load register E with a 14H which is the <span class="code">?/0 ERROR</span> code.</div></div>
									<div class="assembly-row-combined model1"><div>199C-199E</div><div>LD BC,001EH</div><div>Load register BC with a <span class="code">?NF ERROR</span> code.<br><span class="code">?NF ERROR</span> entry point.</div></div>
									<div class="assembly-row-combined model1"><div>199F-19A1</div><div>LD BC,241EH</div><div>Load register BC with a <span class="code">?RW ERROR</span> code.<br><span class="code">?RW ERROR</span> entry point.</div></div>
									<div class="assembly-row-combined model1" id="19A2"><div>19A2-19A4</div><div>LD HL,(40A2H)</div><div>Load register pair HL with the value of the current BASIC line number which has the error.<br><b>NOTE:</b> 40A2H-40A3H holds the current BASIC line number.</div></div>
									<div class="assembly-row-combined model1"><div>19A5-19A7</div><div>LD (40EAH),HL</div><div>Save the value of the current BASIC line number with the error in register pair HL.<br><b>NOTE:</b> 40EAH-40EBH holds the line number  with error.</div></div>
									<div class="assembly-row-combined model1"><div>19A8-19AA</div><div>LD (40ECH),HL</div><div>Save the value of the current BASIC line number with the error in register pair HL.<br><b>NOTE:</b> 40ECH-40EDH holds EDIT line number.</div></div>
									<div class="assembly-row-combined model1" id="19AB"><div>19AB-19AD</div><div>LD BC,19B4H</div><div>Load register pair BC with the return address of 19B4H which is the continuation address after a reinitialization.</div></div>
									<div class="assembly-row-combined model1" id="19AE"><div>19AE-19B0</div><div>LD HL,(40E8H)</div><div>Load register pair HL with the value of the stack pointer (which is stored at 40E8H).<br><b>NOTE:</b> 40E8H-40E9H holds Stack pointer pointer.</div></div>
									<div class="assembly-row-combined model1"><div>19B1-19B3</div><div><a href="#1B9A" class="memory-link">JP 1B9AH</a></div><div>Jump to 1B9AH to reinitialize the system variables.</div></div>
									<div class="assembly-row-combined model1"><div>19B4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0000" class="memory-link">POP BC</a></div><div>Get the value from the stack and put it in register pair BC, which should be 0000H.</div></div>
									<div class="assembly-row-combined model1"><div>19B5</div><div>LD A,E</div><div>Load register A with the value of the error code in register E.</div></div>
									<div class="assembly-row-combined model1"><div>19B6</div><div>LD C,E</div><div>Load register C with the value of the error code in register E.</div></div>
									<div class="assembly-row-combined model1"><div>19B7-19B9</div><div>LD (409AH),A</div><div>Save the value of the error code (from in register A) into 409AH.<br><b>NOTE:</b> 409AH holds the RESUME flag.</div></div>
									<div class="assembly-row-combined model1"><div>19BA-19BC</div><div>LD HL,(40E6H)</div><div>Load
 register pair HL with the value of the current BASIC program pointer 
(which is stored in 40E6H) (i.e., the address  of the last byte executed
 in the current line).<br><b>NOTE:</b> 40E6H-40E7H holds the temporary storage location.</div></div>
									<div class="assembly-row-combined model1"><div>19BD-19BF</div><div>LD (40EEH),HL</div><div>Save the value of the current BASIC program pointer (which is stored in 40EEH) in register pair HL.<br><b>NOTE:</b> 40EEH-40EFH is used by RESUME.</div></div>
									<div class="assembly-row-combined model1"><div>19C0</div><div>EX DE,HL</div><div>Load register pair DE with the value of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>19C1-19C3</div><div>LD HL,(40EAH)</div><div>Load register pair HL with the value of the last number line executed (which is stored in 16618).<br><b>NOTE:</b> 40EAH-40EBH holds the line number  with error.</div></div>
									<div class="assembly-row-combined model1"><div>19C4-19C5</div><div>LD A,H<br>AND L</div><div>The
 easiest way to test a 2 Byte Register is to AND the MSB and LSB 
together, as the only way to get 1111 would be if both the LSB and MSB 
were 1111.  Here, HL las the last line number executed.</div></div>
									<div class="assembly-row-combined model1"><div>19C6</div><div>INC A</div><div>Bump
 the value of the combined current BASIC line number.  This will test to
 against FFFFH which would mean we are still in the input phase.</div></div>
									<div class="assembly-row-combined model1"><div>19C7-19C8</div><div><a href="#19D0" class="memory-link">JR Z,19D0H</a></div><div>Jump
 to 19D0H if Level II BASIC is in the command mode (meaning the line 
number was FFFFH, which then flipped to zero on the prior INC command).</div></div>
									<div class="assembly-row-combined model1"><div>19C9-19CB</div><div>LD (40F5H),HL</div><div>Save the value of the current BASIC line number in register pair HL to (40F5H).<br><b>NOTE:</b> 40F5H-40F6H holds the last line number executed.</div></div>
									<div class="assembly-row-combined model1"><div>19CC</div><div>EX DE,HL</div><div>Load register pair HL with the value of the current BASIC program pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>19CD-19CF</div><div>LD (40F7H),HL</div><div>Save the value of the current BASIC program pointer (which is stored in 16631) in register pair HL.<br><b>NOTE:</b> 40F7H-40F8H holds the last byte executed.</div></div>
									<div class="assembly-row-combined model1"><div>19D0-19D2</div><div>LD HL,(40F0H)</div><div>Load register pair HL with memory contents held at (40F0H).<br><b>NOTE:</b> 40F0H-40F1H holds the <span class="code">ON ERROR</span> adress.</div></div>
									<div class="assembly-row-combined model1"><div>19D3</div><div>LD A,H</div><div>Load register A with the MSB of the <span class="code">ON ERROR</span> address in register H.</div></div>
									<div class="assembly-row-combined model1"><div>19D4</div><div>OR L</div><div>Combine the LSB of the <span class="code">ON ERROR</span> address in register L with the MSB of the <span class="code">ON ERROR</span> address in register A.</div></div>
									<div class="assembly-row-combined model1"><div>19D5</div><div>EX DE,HL</div><div>Load register pair DE with the <span class="code">ON ERROR</span> address in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>19D6-19D8</div><div>LD HL,40F2H</div><div>Load register pair HL with the address of the error flag (which is 40F2H).<br><b>NOTE:</b> 40F2H holds the error flag.</div></div>
									<div class="assembly-row-combined model1"><div>19D9-19DA</div><div><a href="#19E3" class="memory-link">JR Z,19E3H</a></div><div>Jump to 19E3H (to error out) if there isn't an <span class="code">ON ERROR</span> address.</div></div>
									<div class="assembly-row-combined model1"><div>19DB</div><div>AND (HL)</div><div>Combine the value of the error flag at the location of the memory pointer in register pair HL with the combined value of the <span class="code">ON ERROR</span> address in register A.</div></div>
									<div class="assembly-row-combined model1"><div>19DC-19DD</div><div><a href="#19E3" class="memory-link">JR NZ,19E3H</a></div><div>Jump to 19E3H (to error out) if register A is non zero (meaning that there was no <span class="code">ON ERROR</span> address).</div></div>
									<div class="assembly-row-combined model1"><div>19DE</div><div>DEC (HL)</div><div>Decrement the value of the error flag at the location of the memory pointer in register pair HL so that RESUME will work.</div></div>
									<div class="assembly-row-combined model1"><div>19DF</div><div>EX DE,HL</div><div>Load register pair HL with the <span class="code">ON ERROR</span> address in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>19E0-19E2</div><div><a href="#1D36" class="memory-link">JP 1D36H</a></div><div>Jump to 1D36H to make that happen.</div></div>
									<div class="assembly-row-combined model1"><div>19E3</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>19E4</div><div>LD (HL),A</div><div>Clear
 the error override flag by save a zero (from register A) as the current
 error flag at the location of the memory pointer in register pair HL..</div></div>
									<div class="assembly-row-combined model1"><div>19E5</div><div>LD E,C</div><div>Load register E with the value of the error code in register C.</div></div>
									<div class="assembly-row-combined model1"><div>19E6-19E8</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#20F9" class="memory-link">CALL 20F9H</a></div><div>We need to position the video to the next line, so go display a carriage return on the video display if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>19E9-19EB</div><div>LD HL,18C9H</div><div>Load register pair HL with the starting address for the table of error messages.</div></div>
									<div class="assembly-row-combined model1"><div>19EC-19EE</div><div>CALL 41A6H</div><div>Go to the DOS link at 41A6H (whcih would load and execute BASIC error messages as supplied by DOS).<br><b>NOTE:</b> 41A6H-41E4H holds DOS links.<br>In NEWDOS 2.1, this would be a call to load a DISK BASIC error, with Register E holding the error number.</div></div>
									<div class="assembly-row-combined model1"><div>19EF</div><div>LD D,A</div><div>Since we are non-DOS, we continue by loading register D with zero.</div></div>
									<div class="assembly-row-combined model1"><div>19F0-19F1</div><div>LD A,3FH</div><div>Load register A with a "?" (which is ASCII code 3FH).</div></div>
									<div class="assembly-row-combined model1"><div>19F2-19F4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#032A" class="memory-link">CALL 032AH</a></div><div>GOSUB to 032AH to display the question mark in register A.</div></div>
									<div class="assembly-row-combined model1"><div>19F5</div><div>ADD HL,DE</div><div>Add the value of the error code in register pair DE to the starting address of the table of error messages in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>19F6</div><div>LD A,(HL)</div><div>Load register A with the first character of the error message at the location of the table pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>19F7-19F9</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#032A" class="memory-link">CALL 032AH</a></div><div>GOSUB to 032AH to display the first character of the error message in register A.</div></div>
									<div class="assembly-row-combined model1"><div>19FA</div><div>RST 10H</div><div>Error
 codes are 2 characters so we need to set the second character of the 
error in register A, call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>19FB-19FD</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#032A" class="memory-link">CALL 032AH</a></div><div>GOSUB to 032AH to display the second character of the error message in register A.</div></div>
									<div class="assembly-row-combined model1"><div>19FE-1A00</div><div>LD HL,191DH</div><div>Load register pair HL with 191DH which is the starting address of the READY message.</div></div>
									<div class="assembly-row-combined model1"><div>1A01</div><div>PUSH HL</div><div>Save the starting address of the READY message (held in HL) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1A02-1A04</div><div>LD HL,(40EAH)</div><div>Load register pair HL with the value of the current BASIC line number (i.e., the statement causing the error).<br><b>NOTE:</b> 40EAH-40EBH holds the line number  with error.</div></div>
									<div class="assembly-row-combined model1"><div>1A05</div><div>EX (SP),HL</div><div>Exchange
 the value of the current BASIC line number in register pair HL with the
 starting address of the Level II BASIC ERROR message to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1A06-1A08</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#28A7" class="memory-link">CALL 28A7H</a></div><div>We need to display the Level II BASIC ERROR message so we call the WRITE MESSAGE routine at 28A7H.<br><span class="bold">NOTE:</span><br><ul><li>The routine at 28A7 displays the message pointed to by HL on current system output device (usually video).</li><li>The string to be displayed must be terminated by a byte of machine zeros or a carriage return code 0D.</li><li>If terminated with a carriage return, control is returned to the caller after taking the DOS exit at 41D0H (JP 5B99H).</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1A09</div><div>POP HL</div><div>Get the value of the BASIC line number with the error from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1A0A-1A0C</div><div>LD DE,FFFEH</div><div>Load register pair DE with FFFEH.<br><br>This basically reserves the line number 65534 as a trigger for the next few steps.</div></div>
									<div class="assembly-row-combined model1"><div>1A0D</div><div>RST 18H</div><div>Now
 we need to compare the BASIC line number causing the error (held in HL)
 with FFFEH (held in DE) so as to see if we are in the initialization 
routine, so we call the COMPARE DE:HL routine, which numerically 
compares DE and HL. Will not work for signed integers (except positive 
ones). Uses the A-register only. The result of the comparison is 
returned in the status register as:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>1A0E-1A10</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0674" class="memory-link">JP Z,0674H</a></div><div>Jump to 0674H if we are in the initialization routine because the error line number was FFFEH.</div></div>
									<div class="assembly-row-combined model1"><div>1A11</div><div>LD A,H</div><div>We
 need to see if were in command mode, which is signalled by CURRENT LINE
 NUMBER of 0.  The first step is to load register A with the MSB of the 
current BASIC line number in register H.</div></div>
									<div class="assembly-row-combined model1"><div>1A12</div><div>AND L</div><div>Combine the LSB of the current BASIC line number in register L with the MSB of the current BASIC line number in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1A13</div><div>INC A</div><div>Bump
 the combined value of the current BASIC line number in register A to 
test to see if the line number is 00H (meaning command mode).</div></div>
									<div class="assembly-row-combined model1"><div>1A14-1A16</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0FA7" class="memory-link">CALL NZ,0FA7H</a></div><div>GOSUB to 0FA7H to display the current BASIC line number in register pair HL if Level II BASIC isn't in the command mode.</div></div>
									<div class="assembly-row-combined model1"><div>1A17H</div><div>3E C1</div><div>Z-80 Trick!  See the general explanation at 10F8H.</div></div>
									<div class="assembly-row-combined model1" id="1A18"><div>1A18</div><div><a href="#10F8" class="memory-link">POP BC</a></div><div>Get the value from the stack and put it in register pair BC.</div></div>
								</div>
							</div>

							<br><h2 id="1A19">1A19 - "$READY" - Jump to Model II BASIC "READY"<br>To exit from a machine-language program into BASIC's immediate mode, jump (not call) to $READY.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1A19-1A1BH<span class="origrom2">READY</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#038B" class="memory-link">CALL 038BH</a></div><div>Go set the current output device to the video display.<br>Re-entry into BASIC command mode entry point. (see 6CCH also).</div></div>
									<div class="assembly-row-combined model1"><div>1A1C-1A1E</div><div>CALL 41ACH</div><div>Go call the DOS link at 41ACH.<br>In NEWDOS 2.1, this is the start of BASIC just before BASIC shows the READY prompt.</div></div>
									<div class="assembly-row-combined model1"><div>1A1F-1A21</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#01F8" class="memory-link">CALL 01F8H</a></div><div>Go turn off the cassette recorder.</div></div>
									<div class="assembly-row-combined model1"><div>1A22-1A24</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#20F9" class="memory-link">CALL 20F9H</a></div><div>Go display a carriage return if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>1A25-1A27</div><div>LD HL,1929H</div><div>Load register pair HL with the starting address of the Level II BASIC READY message.</div></div>
									<div class="assembly-row-combined model1"><div>1A28-1A2A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#28A7" class="memory-link">CALL 28A7H</a></div><div>We need to display the Level II BASIC READY message, so we call the WRITE MESSAGE routine at 28A7H.<br><span class="bold">NOTE:</span><br><ul><li>The routine at 28A7 displays the message pointed to by HL on current system output device (usually video).</li><li>The string to be displayed must be terminated by a byte of machine zeros or a carriage return code 0D.</li><li>If terminated with a carriage return, control is returned to the caller after taking the DOS exit at 41D0H (JP 5B99H).</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1A2B-1A2D</div><div>LD A,(409AH)</div><div>Load register A with the value of the current error code.<br><b>NOTE:</b> 409AH holds the RESUME flag.</div></div>
									<div class="assembly-row-combined model1"><div>1A2E-1A2F</div><div>SUB 02H</div><div>Check to see if the current error code is a <span class="code">?SN ERROR</span> code by subtracting 2 from the error code, resulting in a zero if its a SN ERROR and any other number if it isn't..</div></div>
									<div class="assembly-row-combined model1"><div>1A30-1A32</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2E53" class="memory-link">CALL Z,2E53H</a></div><div>GOSUB to 2E53H to the EDIT mode if the current error code is a SN ERROR code.</div></div>
								</div>
							</div>

							<br><h2 id="1A33">1A33 - Many routines jump here as the start of the Level II BASIC interpreter.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>If the jump here was from an <span class="code">AUTO</span> call, (40E4H) will have the increment number, (40E1H) will be 0 if no <span class="code">AUTO</span> and non-zero if <span class="code">AUTO</span>, and (40E2H) will have the starting line number.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1A33-1A35</div><div>LD HL,FFFFH</div><div>Load register pair HL with the command mode line number of FFFFH.<br><b>NOTE:</b> FFFFH is the command mode line number.</div></div>
									<div class="assembly-row-combined model1"><div>1A36-1A38</div><div>LD (40A2H),HL</div><div>Save the line number in register pair HL as the current BASIC line number.<br><b>NOTE:</b> 40A2H-40A3H holds the current BASIC line number.</div></div>
									<div class="assembly-row-combined model1"><div>1A39-1A3B</div><div>LD A,(40E1H)</div><div>Load register A with the value of the <span class="code">AUTO</span> flag.  It will be zero if not in <span class="code">AUTO</span>, and anything else if in AUTO.</div></div>
									<div class="assembly-row-combined model1"><div>1A3C</div><div>OR A</div><div>Check to see if in the <span class="code">AUTO</span> mode.</div></div>
									<div class="assembly-row-combined model1"><div>1A3D-1A3E</div><div><a href="#1A76" class="memory-link">JR Z,1A76H</a></div><div>Jump to 1A76H if not in the <span class="code">AUTO</span> mode.</div></div>
									<div class="assembly-row-combined model1"><div>1A3F-1A41</div><div>LD HL,(40E2H)</div><div>We are in <span class="code">AUTO</span> mode so load register pair HL with the current <span class="code">AUTO</span> line number.<br><b>NOTE:</b> 40E2H-40E3H holds Current BASIC line number.</div></div>
									<div class="assembly-row-combined model1"><div>1A42</div><div>PUSH HL</div><div>Save the current <span class="code">AUTO</span> line number (stored in register pair HL) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1A43-1A45</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0FAF" class="memory-link">CALL 0FAFH</a></div><div>GOSUB
 to 0FAFH to call the HL TO ASCII routine at 0FAFH (which converts the 
value in the HL register pair (assumed to be an integer) to ASCII and 
display it at the current cursor position on the video screen) to 
display the AUTO line number.</div></div>
									<div class="assembly-row-combined model1"><div>1A46</div><div>POP DE</div><div>Get the current <span class="code">AUTO</span> line number from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1A47</div><div>PUSH DE</div><div>Save the current <span class="code">AUTO</span> line number in register pair DE to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1A48-1A4A</div><div><a href="#1B2C" class="memory-link">CALL 1B2CH</a></div><div>Call
 the SEARCH FOR LINE NUMBER routine at 1B2CH which looks for the line 
number specified in DE.  Returns C/Z with the line found in BC, NC/Z 
with line number is too large and HL/BC having the next available 
location, or NC/NZ with line number not found, and BC has the first 
available one after that.</div></div>
									<div class="assembly-row-combined model1"><div>1A4B-1A4C</div><div>LD A,"*"</div><div>Load register A with a <span class="code">*</span> (which will be code for a matching line number).</div></div>
									<div class="assembly-row-combined model1"><div>1A4D-1A4E</div><div><a href="#1A51" class="memory-link">JR C,1A51H</a></div><div>If
 the call to 1B2CH shows a matching line number was found in the BASIC 
program (by returning a C), skip the next instruction so that register A
 keeps the "*".</div></div>
									<div class="assembly-row-combined model1"><div>1A4F-1A50</div><div>LD A,20H</div><div>If
 we are here, then there was no matching line number so we need to 
change the next character from a "*" (which is loaded into register A 
which but is not applicable) to a space.</div></div>
									<div class="assembly-row-combined model1" id="1A51"><div>1A51-1A53</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#032A" class="memory-link">CALL 032AH</a></div><div>Go display the character in register A on the video display (which will be a "*" if a matching line number was found).</div></div>
									<div class="assembly-row-combined model1"><div>1A54-1A56</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0361" class="memory-link">CALL 0361H</a></div><div>GOSUB to 0361H to get input into the buffer.</div></div>
									<div class="assembly-row-combined model1"><div>1A57</div><div>POP DE</div><div>Get the current line number from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1A58-1A59</div><div><a href="#1A60" class="memory-link">JR NC,1A60H</a></div><div>Skip the next 3 opcodes if the <kbd>BREAK</kbd> key wasn't pressed.</div></div>
									<div class="assembly-row-combined model1"><div>1A5A</div><div>XOR A</div><div>The BREAK key was pressed so we need to zero register A to clear the AUTO increment flag.</div></div>
									<div class="assembly-row-combined model1"><div>1A5B-1A5D</div><div>LD (40E1H),A</div><div>Save the value in register A as the current AUTO flag (to turn off AUTO).<br><b>NOTE:</b> 40E1H will hold 0 if no <span class="code">AUTO</span> and non-zero if <span class="code">AUTO</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1A5E-1A5F</div><div><a href="#1A19" class="memory-link">JR 1A19H</a></div><div>Jump to the normal command mode "READY" routine at 1A19H.</div></div>
									<p class="debug-note" id="1A60">If we are here, then the <kbd>BREAK</kbd> key was not pressed.</p>
									<div class="assembly-row-combined model1"><div>1A60-1A62</div><div>LD HL,(40E4H)</div><div>Load register pair HL with the value of the <span class="code">AUTO</span> increment.<br><b>NOTE:</b> 40E4H-40E5H holds the AUTO increment number.</div></div>
									<div class="assembly-row-combined model1"><div>1A63</div><div>ADD HL,DE</div><div>Since we didn't BREAK out of the routine we need to keep processing the <span class="code">AUTO</span> so we add the value of the AUTO line number in register pair DE with the AUTO increment value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1A64-1A65</div><div><a href="#1A5A" class="memory-link">JR C,1A5AH</a></div><div>If that addition to the next <span class="code">AUTO</span> line number causes an overflow (by triggering the CARRY FLAG), jump to 1A5AH which is the same as if the <kbd>BREAK</kbd> key was hit.</div></div>
									<div class="assembly-row-combined model1"><div>1A66</div><div>PUSH DE</div><div>Save the current <span class="code">AUTO</span> line number in register pair DE to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1A67-1A69</div><div>LD DE,FFF9H</div><div>Load register pair DE with the maximum BASIC line number of FFF9H (=65529).<br><br>There is an explanation at 1E5AH as to why 65529 is the highest possible line number (vs 65535 which would make more sense).</div></div>
									<div class="assembly-row-combined model1"><div>1A6A</div><div>RST 18H</div><div>Now we need to compare the adjusted <span class="code">AUTO</span>
 line number (in HL) with the maximum BASIC line number (in DE), so we 
call the COMPARE DE:HL routine, which numerically compares DE and HL. 
Will not work for signed integers (except positive ones). Uses the 
A-register only. The result of the comparison is returned in the status 
register as:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>1A6B</div><div>POP DE</div><div>Get the current <span class="code">AUTO</span> line number from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1A6C-1A6D</div><div><a href="#1A5A" class="memory-link">JR NC,1A5AH</a></div><div>If the adjusted AUTO line number in register pair HL is too large, jump to 1A5AH which is the same as if the <kbd>BREAK</kbd> key was hit.</div></div>
									<div class="assembly-row-combined model1"><div>1A6E-1A70</div><div>LD (40E2H),HL</div><div>Save the adjusted <span class="code">AUTO</span> line number in register pair HL as the current <span class="code">AUTO</span> line number.<br><b>NOTE:</b> 40E2H-40E3H holds Current BASIC line number.</div></div>
									<div class="assembly-row-combined model1"><div>1A71-1A72</div><div>OR FFH</div><div>Load register A with the <span class="code">AUTO</span> flag value.</div></div>
									<div class="assembly-row-combined model1"><div>1A73-1A75</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2FEB" class="memory-link">JP 2FEBH</a></div><div>Jump to the <span class="code">EDIT</span> routine to save the current BASIC line.</div></div>
									<div class="assembly-row-combined model1"><div>1A76-1A77</div><div>LD A,3EH</div><div>Load register A with a &gt; (the prompt that follows READY)</div></div>
									<div class="assembly-row-combined model1"><div>1A78-1A7A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#032A" class="memory-link">CALL 032AH</a></div><div>Go display the Level II BASIC prompt in register A on the video display.</div></div>
									<div class="assembly-row-combined model1"><div>1A7B-1A7D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0361" class="memory-link">CALL 0361H</a></div><div>GOSUB to 0361H to accept input.  HL will hold the buffer address for that input.</div></div>
									<div class="assembly-row-combined model1"><div>1A7E-1A80</div><div><a href="#1A33" class="memory-link">JP C,1A33H</a></div><div>Jump to 1A33H if the <kbd>BREAK</kbd> key was pressed.</div></div>
									<div class="assembly-row-combined model1"><div>1A81</div><div>RST 10H</div><div>Since
 we need to bump the current input buffer pointer in register pair HL 
until it points to the first character, call the EXAMINE NEXT SYMBOL 
routine at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1A82</div><div>INC A</div><div>Bump the value of the character in register A.  This sets the status flags but saves the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>1A83</div><div>DEC A</div><div>Decrement the value of the character in register A so we can test for an end of statement.</div></div>
									<div class="assembly-row-combined model1"><div>1A84-1A86</div><div><a href="#1A33" class="memory-link">JP Z,1A33H</a></div><div>JUMP to 1A33H if we have an end of statement.</div></div>
									<div class="assembly-row-combined model1"><div>1A87</div><div>PUSH AF</div><div>Save the value in register pair AF to the stack (including the CARRY FLAG).</div></div>
									<div class="assembly-row-combined model1"><div>1A88-1A8A</div><div><a href="#1E5A" class="memory-link">CALL 1E5AH</a></div><div>Call the ASCII TO INTEGER routine at 1E5AH.<br><b>NOTE:</b>
 The routine at 1E5A converts the ASCII string pointed to by HL to an 
integer deposited into DE.  If the routine finds a non-numerica 
character, the conversion is stopped.</div></div>
									<p class="debug-note">1A8BH - This little looping routine is to clear any trailing blanks between the line number and the statement.</p>
									<div class="assembly-row-combined model1"><div>1A8B</div><div>DEC HL</div><div>Decrement the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1A8C</div><div>LD A,(HL)</div><div>Load register A with the value of the character at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1A8D-1A8E</div><div>CP 20H</div><div>Check to see if the character at the location of the input buffer pointer in register A is a space.</div></div>
									<div class="assembly-row-combined model1"><div>1A8F-1A90</div><div><a href="#1A8B" class="memory-link">JR Z,1A8BH</a></div><div>Loop back to 1A8BH if the character at the location of the input buffer pointer in register A is a space.</div></div>
									<div class="assembly-row-combined model1"><div>1A91</div><div>INC HL</div><div>Bump the value of the input buffer pointer in register pair HL so that it points to the first character following a line number.</div></div>
									<div class="assembly-row-combined model1"><div>1A92</div><div>LD A,(HL)</div><div>Load register A with that character.</div></div>
									<div class="assembly-row-combined model1"><div>1A93-1A94</div><div>CP 20H</div><div>Check to see if the character at the location of the input buffer pointer in register A is a space.</div></div>
									<div class="assembly-row-combined model1"><div>1A95-1A97</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09C9" class="memory-link">CALL Z,09C9H</a></div><div>If
 it is a space then skip it by a GOSUB to 09C9H which bumps the value of
 the input buffer pointer in register pair HL if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>1A98</div><div>PUSH DE</div><div>Save
 the BASIC line number in register pair DE (which was converted from 
ASCII to an integer in 1A88H through a call to 1E5AH) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1A99-1A9B</div><div><a href="#1BC0" class="memory-link">CALL 1BC0H</a></div><div>Tokenize the input via a GOSUB to 1BC0H.  BC will equal the length of the encoded statement when its done.</div></div>
									<div class="assembly-row-combined model1"><div>1A9C</div><div>POP DE</div><div>Get the value of the BASIC line number (which is an integer) from the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1A9D</div><div>POP AF</div><div>Get the CARRY FLAG (from the 1A81H character fetch) and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>1A9E-1AA0</div><div>LD (40E6H),HL</div><div>Save the input buffer pointer in register pair HL.<br><b>NOTE:</b> 40E6H-40E7H holds the temporary storage location.</div></div>
									<div class="assembly-row-combined model1"><div>1AA1-1AA3</div><div>CALL 41B2H</div><div>Go call the DOS line at 4182H.<br>In NEWDOS 2.1, this is the input scanner after tokenizing the current statement.</div></div>
									<div class="assembly-row-combined model1"><div>1AA4-1AA6</div><div><a href="#1D5A" class="memory-link">JP NC,1D5AH</a></div><div>Jump to 1D5AH if there wasn't a line number with the input (meaning it was a direct statement or a system command).</div></div>
									<div class="assembly-row-combined model1"><div>1AA7</div><div>PUSH DE</div><div>Save the BASIC line number (as an integer stored in register pair DE) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1AA8</div><div>PUSH BC</div><div>Save the length of the tokenized input (stored in register pair BC) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1AA9</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>1AAA-1AAC</div><div>LD (40DDH),A</div><div>Save the value in register A (which is a 00H) as the input flag.<br><b>NOTE:</b> 40DDH holds INPUT flag.</div></div>
									<div class="assembly-row-combined model1"><div>1AAD</div><div>RST 10H</div><div>Since
 we need find the first token, we have to bump the current input buffer 
pointer in register pair HL until it points to the next character by 
calling the EXAMINE NEXT SYMBOL routine at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1AAE</div><div>OR A</div><div>Set the flags.</div></div>
									<div class="assembly-row-combined model1"><div>1AAF</div><div>PUSH AF</div><div>Save the status flag to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1AB0</div><div>EX DE,HL</div><div>Load register pair HL with the integer value of the BASIC line number (held in register pair DE).</div></div>
									<div class="assembly-row-combined model1"><div>1AB1-1AB3</div><div>LD (40ECH),HL</div><div>Save the integer value of the line number (held in register pair HL) to 40ECH.<br><b>NOTE:</b> 40ECH-40EDH holds EDIT line number.</div></div>
									<div class="assembly-row-combined model1"><div>1AB4</div><div>EX DE,HL</div><div>Exchange
 the value of the input buffer pointer in register pair DE with the 
integer value of the BASIC line number in register pair HL.  This will 
fill DE with the line number for the search routine in the next 
instruction.</div></div>
									<div class="assembly-row-combined model1"><div>1AB5-1AB7</div><div><a href="#1B2C" class="memory-link">CALL 1B2CH</a></div><div>Call
 the SEARCH FOR LINE NUMBER routine at 1B2CH which looks for the line 
number specified in DE.  Returns C/Z with the line found in BC, NC/Z 
with line number is too large and HL/BC having the next available 
location, or NC/NZ with line number not found, and BC has the first 
available one after that.</div></div>
									<div class="assembly-row-combined model1"><div>1AB8</div><div>PUSH BC</div><div>Save the address of the line number in the BASIC program (if it exists) in register pair BC to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1AB9-1ABB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2BE4" class="memory-link">CALL C,2BE4H</a></div><div>If
 there wasn't a matching line number in the BASIC program, GOSUB to 
2BE4H to move the closest line number up in memory to make room for 
another line.</div></div>
									<div class="assembly-row-combined model1"><div>1ABC</div><div>POP DE</div><div>Get the integer address of the BASIC line number from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1ABD</div><div>POP AF</div><div>Restore the status from the 1AADH token scan into register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>1ABE</div><div>PUSH DE</div><div>Save the integer address of the BASIC line number to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1ABF-1AC0</div><div><a href="#1AE8" class="memory-link">JR Z,1AE8H</a></div><div>Jump
 to 1AE8H if there was a matching line number in the BASIC program; 
otherwise we move on and a new line has to be added as follows.</div></div>
									<div class="assembly-row-combined model1"><div>1AC1</div><div>POP DE</div><div>Get the address of the BASIC line number from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1AC2-1AC4</div><div>LD HL,(40F9H)</div><div>Load register pair HL with the end of the BASIC program pointer.<br><ul><li>Note: 40F9H-40FAH holds the starting address of the simple variable storage area.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1AC5</div><div>EX (SP),HL</div><div>Exchange the length of the tokenized input to the stack with the end of the BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1AC6</div><div>POP BC</div><div>Get the end of the BASIC program pointer from the stack and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>1AC7</div><div>ADD HL,BC</div><div>Add
 the end of the BASIC program pointer in register pair BC to the value 
of the length of the tokenized input in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1AC8</div><div>PUSH HL</div><div>Save the adjusted end of the BASIC program pointer in register pair HL to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1AC9-1ACB</div><div><a href="#1955" class="memory-link">CALL 1955H</a></div><div>Go check to see if there is enough room in memory for the new BASIC line by GOSUB to 1955H.</div></div>
									<div class="assembly-row-combined model1"><div>1ACC</div><div>POP HL</div><div>Get the new end of the BASIC program pointer from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1ACD-1ACF</div><div>LD (40F9H),HL</div><div>Save the new end of the BASIC program pointer in register pair HL.<br><ul><li>Note: 40F9H-40FAH holds the starting address of the simple variable storage area.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1AD0</div><div>EX DE,HL</div><div>Load register pair HL with the address of the BASIC line.</div></div>
									<div class="assembly-row-combined model1"><div>1AD1</div><div>LD (HL),H</div><div>Save the MSB of the address of the BASIC line in register H.</div></div>
									<div class="assembly-row-combined model1"><div>1AD2</div><div>POP DE</div><div>Get the value of the BASIC line number from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1AD3</div><div>PUSH HL</div><div>Save the value of the memory pointer in register pair HL to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1AD4</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL (which bumps it to the LSB of the line number entry).</div></div>
									<div class="assembly-row-combined model1"><div>1AD5</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL (which bumps it to the MSB of the line number entry).</div></div>
									<div class="assembly-row-combined model1"><div>1AD6</div><div>LD (HL),E</div><div>Save the LSB of the BASIC line number in register E at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1AD7</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1AD8</div><div>LD (HL),D</div><div>Save
 the MSB of the BASIC line number in register D at the location of the 
memory pointer in register pair HL.  At this point DE should have the 
binary value for the new line number.</div></div>
									<div class="assembly-row-combined model1"><div>1AD9</div><div>INC HL</div><div>Bump the value of the BASIC line number in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1ADA</div><div>EX DE,HL</div><div>Load register pair DE with first data byte address following the line number (held in register pair HL).</div></div>
									<div class="assembly-row-combined model1"><div>1ADB-1ADD</div><div>LD HL,(40A7H)</div><div>Load register pair HL with the value of the tokenized input pointer<br>Note: 40A7H-40A8H holds Input Buffer pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1ADE</div><div>EX DE,HL</div><div>Exchange the value of the memory pointer in register pair DE with the value of the tokenized input pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1ADF</div><div>DEC DE</div><div>Decrement the value of the tokenized input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1AE0</div><div>DEC DE</div><div>Decrement the value of the tokenized input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1AE1</div><div>LD A,(DE)</div><div>Load register A with the value at the location of the tokenized input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1AE2</div><div>LD (HL),A</div><div>Save the value in register A at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1AE3</div><div>INC HL</div><div>Bump the store address (held in register pair HL).</div></div>
									<div class="assembly-row-combined model1"><div>1AE4</div><div>INC DE</div><div>Bump the fetch address (held in register pair DE).</div></div>
									<div class="assembly-row-combined model1"><div>1AE5</div><div>OR A</div><div>Check to see if the character in register A is an end of the line character.</div></div>
									<div class="assembly-row-combined model1"><div>1AE6-1AE7</div><div><a href="#1AE1" class="memory-link">JR NZ,1AE1H</a></div><div>Loop until the whole of the new BASIC line has been stored in memory.</div></div>
									<div class="assembly-row-combined model1"><div>1AE8</div><div>POP DE</div><div>Get the address of the line in the program table from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1AE9-1AEB</div><div><a href="#1AFC" class="memory-link">CALL 1AFCH</a></div><div>Go update line pointers for all lines following the new line.</div></div>
									<div class="assembly-row-combined model1"><div>1AEC-1AEE</div><div>CALL 41B5H</div><div>Go call the DOS link at 41B5H.<br>In NEWDOS 2.1, this is the input scanner after updating the PST (Program Statement Table).</div></div>
									<div class="assembly-row-combined model1"><div>1AEF-1AF1</div><div><a href="#1B5D" class="memory-link">CALL 1B5DH</a></div><div>Update all the BASIC line pointers.</div></div>
									<div class="assembly-row-combined model1"><div>1AF2-1AF4</div><div>CALL 41B8H</div><div>Go call the DOS link at 41B8H.<br>In NEWDOS 2.1, this is the input scanner after reinitializing BASIC</div></div>
									<div class="assembly-row-combined model1"><div>1AF5-1AF7</div><div><a href="#1A33" class="memory-link">JP 1A33H</a></div><div>Go get the input again.</div></div>
								</div>
							</div>

							<br><h2 id="1AF8">1AF8-1B0F - LINE POINTERS ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine fixes the line pointers in a BASIC program. This
 is useful, for instance for a renumber program which has to move BASIC 
program lines from one location in memory to an other, which means that 
the line pointers would no longer be valid. This routine will fix them. 
Registers A, HL and DE are used.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1AF8</div><div>LD HL,(40A4H)</div><div>Load register pair HL with the start of the BASIC program pointer (called the PST).<br><b>NOTE:</b> 40A4H-40A5H holds the starting address of BASIC program text also known as the PROGRAM STATEMENT TABLE (PST).</div></div>
									<div class="assembly-row-combined model1"><div>1AFB</div><div>EX DE,HL</div><div>Move the PST address to DE.</div></div>
									<div class="assembly-row-combined model1"><div>1AFC</div><div>LD H,D</div><div>Load register H with the MSB of the memory pointer in register D.</div></div>
									<div class="assembly-row-combined model1"><div>1AFD</div><div>LD L,E</div><div>Load register L with the LSB of the memory pointer in register E.</div></div>
									<div class="assembly-row-combined model1"><div>1AFE</div><div>LD A,(HL)</div><div>Load register A with the value at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1AFF</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B00</div><div>OR (HL)</div><div>Since
 the first 2 bytes of each line contains the address of the next line, a
 0000H would signify the end byte.  With this, check to see if the 
character at the location of the memory pointer in register pair HL is 
an end of the BASIC program character.</div></div>
									<div class="assembly-row-combined model1"><div>1B01</div><div>RET Z</div><div>Return if done.</div></div>
									<div class="assembly-row-combined model1" id="1B02"><div>1B02</div><div>INC HL</div><div>Since
 HL is the 'beginning of statment pointer', we need to skip over the 3rd
 and 4th bytes, so bump the value of the memory pointer in register pair
 HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B03</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B04</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B05</div><div>XOR A</div><div>Zero register A and clear the flags.</div></div>
									<div class="assembly-row-combined model1"><div>1B06</div><div>CP (HL)</div><div>Check to see if the character at the location of the memory pointer in register HL is an end of the BASIC line character.</div></div>
									<div class="assembly-row-combined model1"><div>1B07</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B08</div><div><a href="#1B06" class="memory-link">JR NZ,1B06H</a></div><div>Loop until the end of the BASIC line character is found.</div></div>
									<div class="assembly-row-combined model1"><div>1B0A</div><div>EX DE,HL</div><div>Exchange
 the starting address of the current BASIC line in register pair DE with
 the starting address of the next BASIC line in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B0B</div><div>LD (HL),E</div><div>Save the LSB of the next BASIC line's starting address in register E at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B0C</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B0D</div><div>LD (HL),D</div><div>Save the MSB of the next BASIC line's starting address in register D at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B0E-1B0F</div><div><a href="#1AFC" class="memory-link">JR 1AFCH</a></div><div>Loop until the end of the program has been found.</div></div>
								</div>
							</div>

							<br><h2 id="1B10">1B10-1B48 - EVALUATE LINE NUMBERS<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is called by LIST and DELETE.  It converts the starting 
and ending linbers (X-Y) to binary and saves the ending line number on 
the stack.  Then the code locates the program table address for the 
starting line.  The routine leaves the address of the starting line in 
BC and the ending line number in the stack.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1B10-1B12</div><div>LD DE,0000H</div><div>Load register pair DE (which will be the line counter) with zero.</div></div>
									<div class="assembly-row-combined model1"><div>1B13</div><div>PUSH DE</div><div>Save the value in register pair DE to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1B14-1B15</div><div><a href="#1B1F" class="memory-link">JR Z,1B1FH</a></div><div>Jump to 1B1FH if there aren't any line numbers to be evaluated.</div></div>
									<div class="assembly-row-combined model1"><div>1B16</div><div>POP DE</div><div>Get the value from the stack and put it in register pair DE (which will be the line number).</div></div>
									<div class="assembly-row-combined model1"><div>1B17-1B19</div><div><a href="#1E4F" class="memory-link">CALL 1E4FH</a></div><div>Go
 evaluate the line number at the location of the current BASIC program 
pointer in register pair HL and return with the line number's binary 
value in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1B1A</div><div>PUSH DE</div><div>Save the first line number's value (stored in register pair DE) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1B1B-1B1C</div><div><a href="#1B28" class="memory-link">JR Z,1B28H</a></div><div>Jump if there isn't a second line number to be evaluated given (i.e, LIST 3000-).</div></div>
									<div class="assembly-row-combined model1"><div>1B1D-1B1E</div><div>RST 08H ‚áí  CEH</div><div>If we are here, there is a second line number.  That that would have to be preceded by a <span class="code">-</span>
 at the location of the current BASIC program pointer in register pair 
HL, call the COMPARE SYMBOL routine which comparess the symbol in the 
input string pointed to by HL register to the value in the location 
following the RST 08 call.  If there is a match, control is returned to 
address of the RST 08 instruction 2 with the next symbol in the 
Aregister and HL incremented by one. If the two characters do not match,
 a syntax error message is given and control returns to the Input 
Phase).</div></div>
									<div class="assembly-row-combined model1" id="1B1F"><div>1B1F-1B21</div><div>LD DE,FFFAH</div><div>Load register pair DE with the default second line number of FFAFH.</div></div>
									<div class="assembly-row-combined model1"><div>1B22-1B24</div><div><a href="#1E4F" class="memory-link">CALL NZ,1E4FH</a></div><div>Go
 evaluate the second line number at the location of the current BASIC 
program pointer in register pair HL and return with the line number's 
binary value in register pair DE.  Will return with Z flag set if it was
 a number.</div></div>
									<div class="assembly-row-combined model1"><div>1B25-1B27</div><div><a href="#1997" class="memory-link">JP NZ,1997H</a></div><div>Go to the Level II BASIC error routine and display a SN ERROR message if the data which followed the token wasn't a line number.</div></div>
									<div class="assembly-row-combined model1"><div>1B28</div><div>EX DE,HL</div><div>Load
 register pair HL with the value of the second line number in register 
pair DE and load register pair DE with the value of the current BASIC 
program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B29</div><div>POP DE</div><div>Get the value of the first line number from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1B2A</div><div>EX (SP),HL</div><div>Exchange the return address to the stack with the value of the second line number in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B2B</div><div>PUSH HL</div><div>Save the value of the return address in register pair HL to the stack so we can properly exit later.</div></div>
									<p class="debug-note" id="1B2C">
										1B2C - This routine searches a BASIC program for a BASIC line 
with a line number matching the value in the DE register pair.<br><br>
										To use this routine, the required line number must be placed 
in the DE register pair. When a match is found, this routine sets the 
CARRY FLAG; the BC register pair points to the start of the required 
line, and the HL register points to the start of the next line. HL, AF 
and BC are used.<br><br>
										This is the the SEARCH FOR LINE NUMBER routine at 1B2C, which 
searches the Program Statement Table (PST) for a BASIC statement with 
the line number specified in the DE register pair. All registers are 
used. The exit conditions are:<br><br>
										C/Z=Line Found and BC is the starting address of the line in the PST and HL is the address following;<br><br>
										NC/Z=Line not found or too large and HL/BC will have the address of the next available PST location; and<br><br>
										NC/NZ=Line not found and BC=Address of the first line number 
greater than the one specified and HL will be the address of the 
following line.
									</p>
									<div class="assembly-row-combined model1"><div>1B2C</div><div>LD HL,(40A4H)</div><div>Load register pair HL with the value of the start of the BASIC program pointer.<br><b>Note:</b> 40A4H-40A5H holds the starting address of BASIC program text also known as the PROGRAM STATEMENT TABLE (PST).</div></div>
									<div class="assembly-row-combined model1"><div>1B2F</div><div>LD B,H</div><div>Load register B with the value of the MSB of the memory pointer in register H.</div></div>
									<div class="assembly-row-combined model1"><div>1B30</div><div>LD C,L</div><div>Load register C with the LSB of the memory pointer in register L.  Now BC will hold the address of the current line in the PST.</div></div>
									<div class="assembly-row-combined model1"><div>1B31</div><div>LD A,(HL)</div><div>Load register A with the LSB of the address of the next line (held in register pair HL).</div></div>
									<div class="assembly-row-combined model1"><div>1B32</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL to the MSB of the address of the next line.</div></div>
									<div class="assembly-row-combined model1"><div>1B33</div><div>OR (HL)</div><div>Combine
 the value at the location of the memory pointer in register pair HL 
with the value in register A and set the status flags.</div></div>
									<div class="assembly-row-combined model1"><div>1B34</div><div>DEC HL</div><div>Restore HL to the start of the current line.</div></div>
									<div class="assembly-row-combined model1"><div>1B35</div><div>RET Z</div><div>Return if this is the end of PST (=the end of the BASIC program).</div></div>
									<div class="assembly-row-combined model1"><div>1B36</div><div>INC HL</div><div>It's
 not the end so we need HL to point the line number for the current line
 which means it must advance by 2.  Bump the value of the memory pointer
 in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B37</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B38</div><div>LD A,(HL)</div><div>Load register A with the LSB of the current BASIC line number at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B39</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL to point to the MSB of the current BASIC line number.</div></div>
									<div class="assembly-row-combined model1"><div>1B3A</div><div>LD H,(HL)</div><div>Load register H with the MSB of the current BASIC line number at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B3B</div><div>LD L,A</div><div>Load register L with the LSB of the current BASIC line number in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1B3C</div><div>RST 18H</div><div>Now
 we need to compare the value of the current BASIC line number in HL and
 the first line number (in DE), so we call the COMPARE DE:HL routine, 
which numerically compares DE and HL. Will not work for signed integers 
(except positive ones). Uses the A-register only. The result of the 
comparison is returned in the status register as:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>1B3D</div><div>LD H,B</div><div>Load register H with the MSB of the memory pointer in register B.</div></div>
									<div class="assembly-row-combined model1"><div>1B3E</div><div>LD L,C</div><div>Load register L with the LSB of the memory pointer in register C.</div></div>
									<div class="assembly-row-combined model1"><div>1B3F</div><div>LD A,(HL)</div><div>Load register A with the value at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B40</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B41</div><div>LD H,(HL)</div><div>Load register H with the MSB of the next BASIC line pointer at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B42</div><div>LD L,A</div><div>Load register L with the LSB of the next BASIC line pointer in register A to form the address of the next line in HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B43</div><div>CCF</div><div>Complement
 the value of the CARRY FLAG.  The carry will be set if the current line
 number is &lt; the value in DE.  This will clear the CARRY FLAG. </div></div>
									<div class="assembly-row-combined model1"><div>1B44</div><div>RET Z</div><div>Return
 if the first line number in register pair DE is the same as the current
 BASIC line number.  The line numbers match, so exit C, Z, BC=address of
 the current line, and HL=address of the next line.</div></div>
									<p class="debug-note" id="1B45">If we are here, then we have no match.</p>
									<div class="assembly-row-combined model1"><div>1B45</div><div>CCF</div><div>Complement (reverse) the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>1B46</div><div>RET NC</div><div>If
 the first line number in register pair DE is less than the current 
BASIC line number.  BC will be the address of the current line and HL 
will be the address of the next line.</div></div>
									<div class="assembly-row-combined model1"><div>1B47</div><div><a href="#1B2F" class="memory-link">JR 1B2FH</a></div><div>Loop until the location of the line number has been found in the BASIC program.</div></div>
								</div>
							</div>

							<br><h2 id="1B49">1B49-1B5C - LEVEL II BASIC <span class="code">NEW</span> ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1B49</div><div>RET NZ</div><div>Go to the Level II BASIC error routine and display a <span class="code">?SN ERROR</span> message if there is any input following the <span class="code">NEW</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1B4A-1B4C</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#01C9" class="memory-link">CALL 01C9H</a></div><div>Call the CLEAR SCREEN routine at 01C9 (which cleans the screen, changes to 64 characters, and homes the screen).</div></div>
									<div class="assembly-row-combined model1" id="1B4D"><div>1B4D</div><div>LD HL,(40A4H)</div><div>Load register pair HL with the start of the PST (the start of the BASIC program).<br><ul><li>Note: 40A4H-40A5H holds the starting address of BASIC program text also known as the PROGRAM STATEMENT TABLE (PST).</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1B50</div><div><a href="#1DF8" class="memory-link">CALL 1DF8H</a></div><div>GOSUB to the <span class="code">TROFF</span> routine at 1DF8H (which just loads A with a zero for <span class="code">TROFF</span>, and puts that 0 into 411BH).</div></div>
									<div class="assembly-row-combined model1"><div>1B53</div><div>LD (40E1H),A</div><div>Reset the <span class="code">AUTO</span> flag by putting a zero (which is in A due to the GOSUB to the <span class="code">TROFF</span> statement in the above instruction) into 40E1H.</div></div>
									<div class="assembly-row-combined model1"><div>1B56</div><div>LD (HL),A</div><div>We
 need to initialize the PST, and the way to do that is to zero the first
 two bytes so ... save a zero at the location of the memory pointer in 
register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B57</div><div>INC HL</div><div>... bump the value of the memory pointer in register pair HL ...</div></div>
									<div class="assembly-row-combined model1"><div>1B58</div><div>LD (HL),A</div><div>... and save a zero at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B59</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B5A</div><div>LD (40F9H),HL</div><div>Save the value in register pair HL at 40F9H to initialize the start of the variable list table as the end of the PST.<br><ul><li>Note: 40F9H-40FAH holds the starting address of the simple variable storage area.</li></ul></div></div>
								</div>
							</div>

							<br><h2 id="1B5D">1B5D-1BB2 - LEVEL II BASIC <span class="code">RUN</span> ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<p class="debug-note">
										Differences between M1 and M3 ROMs: The locations 1B5DH - 
1B5FH are part of the RUN, NEW, EDIT, etc. commands; in the Model I 
these three bytes contain a LD HL,(40A4H) instruction (resets HL to 
point to the start of the BASIC program). In the Model III, this has 
been replaced by a CALL 046BH instruction, which unprotects the video 
display in addition to resetting HL to the start of the BASIC program.</p>
										<ul>
										<li>This routine does a lot of variable resets and other things that are common to <span class="code">NEW</span> as well, so <span class="code">NEW</span> just does the special <span class="code">NEW</span> stuff and than passes right through to here to reset the rest.</li>
										<li>To use a ROM call to RUN a BASIC program, starting with its first line, execute the following instructions:<br>LD HL,1D1EH<br>PUSH HL<br>JP 1B5DH<br>The ability to RUN a BASIC program from an assembly language program is valuable for linking the two programs.</li>
										</ul>
									<p></p>
									<div class="assembly-row-combined model3"><div>*1B5D-1B5F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#046B" class="memory-link">CALL 046BH</a></div><div>GOSUB to 046BH to unprotect the screen and point HL to the start of data.</div></div>
									<div class="assembly-row-combined model1"><div>1B60</div><div>DEC HL</div><div>Decrement the value in register pair HL to backspace.</div></div>
									<div class="assembly-row-combined model1" id="1B61"><div>1B61-1B63</div><div>LD (40DFH),HL</div><div>Save the adjusted value in register pair HL into 40DFH.<br><b>NOTE:</b> 40DFH-40E0H is used by DOS.</div></div>
									<div class="assembly-row-combined model1"><div>1B64-1B65</div><div>LD B,1AH</div><div>Load register B with the number of variable names to be initialized (which is 26).</div></div>
									<div class="assembly-row-combined model1"><div>1B66-1B68</div><div>LD HL,4101H</div><div>Load register pair HL with the starting address of the variable declaration table (which is 4101H).<br><b>NOTE:</b> 4101H-411AH holds Variable Declaration Table.</div></div>
									<div class="assembly-row-combined model1"><div>1B69-1B6A</div><div>LD (HL),04H</div><div>Set the variable at the location of the memory pointer in register pair HL to a single precision variable.</div></div>
									<div class="assembly-row-combined model1"><div>1B6B</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL to the next variable.</div></div>
									<div class="assembly-row-combined model1"><div>1B6C-1B6D</div><div><a href="#1B69" class="memory-link">DJNZ 1B69H</a></div><div>Loop until all 26 variables have been set to single precision.</div></div>
									<div class="assembly-row-combined model1"><div>1B6E</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>1B6F-1B71</div><div>LD (40F2H),A</div><div>Save the value in register A (which is a zero) as the current value of the <span class="code">RESUME</span> flag to say that there is no error for <span class="code">RESUME</span> to handle.<br><b>NOTE:</b> 40F2H holds the error flag.</div></div>
									<div class="assembly-row-combined model1"><div>1B72</div><div>LD L,A</div><div>Zero register L.</div></div>
									<div class="assembly-row-combined model1"><div>1B73</div><div>LD H,A</div><div>Zero register H.</div></div>
									<div class="assembly-row-combined model1"><div>1B74-1B76</div><div>LD (40F0H),HL</div><div>Save a zero (held in register pair HL) as the current <span class="code">ON ERROR</span> address.<br><b>NOTE:</b> 40F0H-40F1H is used by <span class="code">ON ERROR</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1B77-1B79</div><div>LD (40F7H),HL</div><div>Save a zero (held in register pair HL) as the current <kbd>BREAK</kbd>, <span class="code">STOP</span>, or <span class="code">END</span> address.<br><b>NOTE:</b> 40F7H-40F8H holds the last byte executed.</div></div>
									<div class="assembly-row-combined model1"><div>1B7A-1B7C</div><div>LD HL,(40B1H)</div><div>Load register pair HL with the top of the memory pointer held in 40B1H.<br><b>NOTE:</b> 40B1H-40B2H holds MEMORY SIZE? pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1B7D-1B7F</div><div>LD (40D6H),HL</div><div>Save the top of memory pointer (held in register pair HL) as the next available address in the string space pointer.<br><b>NOTE:</b> 40D6H-40D7H holds Next available location in string space pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1B80-1B82</div><div><a href="#1D91" class="memory-link">CALL 1D91H</a></div><div>Go do a <span class="code">RESTORE</span> (which will mess with DE and HL).</div></div>
									<div class="assembly-row-combined model1"><div>1B83-1B85</div><div>LD HL,(40F9H)</div><div>Load register pair HL with the end of the BASIC program pointer.<br><ul><li>Note: 40F9H-40FAH holds the starting address of the simple variable storage area.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1B86-1B88</div><div>LD (40FBH),HL</div><div>Save the value in register pair HL as the new simple variables pointer.<br><ul><li>Note: 40FBH-40FCH holds the starting address of the BASIC array variable storage area.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1B89-1B8B</div><div>LD (40FDH),HL</div><div>Save the value in register pair HL as the new array variables pointer.<br><b>NOTE:</b> 40FDH-40FEH holds the pointer to the starting address of free memory.</div></div>
									<div class="assembly-row-combined model1"><div>1B8C-1B8E</div><div>CALL 41BBH</div><div>Go call the DOS line at 41BBH.<br>In NEWDOS 2.1 this initializes BASIC for a new routine.</div></div>
								</div>
							</div>

							<br><h2 id="1B8F">1B8FH - Inside the <span class="code">RUN</span> routine - Initialize the Level II BASIC variables and pointers<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1B8F</div><div>POP BC</div><div>Get the return address from the stack because we are about to change the stack pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1B90-1B92</div><div>LD HL,(40A0H)</div><div>Load register pair HL with the start of string space pointer.<br><b>Note:</b> 40A0H-40A1H holds the start of string space pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1B93</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B94</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL (so now HL has the sart of the string space pointer - 2).</div></div>
									<div class="assembly-row-combined model1"><div>1B95-1B97</div><div>LD (40E8H),HL</div><div>Save the string space pointer - 2 (in register pair HL) as the stack pointer<br>Note: 40E8H-40E9H holds Stack pointer pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1B98</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1B99</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL so it is back to being the start of the string space pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1B9A</div><div>LD SP,HL</div><div>Load the stack pointer with the start of the string space pointer (held in register pair HL).</div></div>
									<div class="assembly-row-combined model1"><div>1B9B-1B9D</div><div>LD HL,40B5H</div><div>Load register pair HL with the start of the string work area (which is 40B5H).<br><b>NOTE:</b> 40B5H-40D2H holds Temporary string work area.</div></div>
									<div class="assembly-row-combined model1"><div>1B9E-1BA0</div><div>LD (40B3H),HL</div><div>Save the value in register pair HL as the next available location in the string work area pointer.<br><b>NOTE:</b> 40B3H-40B4H holds Next available location in the temporary string work area pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1BA1-1BA3</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#038B" class="memory-link">CALL 038BH</a></div><div>GOSUB 038BH to set the current output device to the video display.</div></div>
									<div class="assembly-row-combined model1"><div>1BA4-1BA6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2169" class="memory-link">CALL 2169H</a></div><div>Go turn off the cassette recorder.</div></div>
									<div class="assembly-row-combined model1"><div>1BA7</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>1BA8</div><div>LD H,A</div><div>Zero register H.</div></div>
									<div class="assembly-row-combined model1"><div>1BA9</div><div>LD L,A</div><div>Zero register L.</div></div>
									<div class="assembly-row-combined model1"><div>1BAA-1BAC</div><div>LD (40DCH),A</div><div>Clear the <span class="code">FOR</span> statement flag.<br><b>NOTE:</b> 40DCH holds FOR flag.</div></div>
									<div class="assembly-row-combined model1"><div>1BAD</div><div>PUSH HL</div><div>Save the value in register pair HL (which is <span class="code">RUN</span>) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1BAE</div><div>PUSH BC</div><div>Save the value in register pair BC (which is the address to continue executing code) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1BAF-1BB1</div><div>LD HL,(40DFH)</div><div>Load register pair HL with the current value of the BASIC program pointer.<br><b>NOTE:</b> 40DFH-40E0H holds Used by DOS.</div></div>
									<div class="assembly-row-combined model1"><div>1BB2</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="1BB3">1BB3-1BBF - KEYBOARD INPUT ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
							<p>This is the last of the general purpose input routines. This 
routine functions identically to the 361H routine with the exception 
that it prints a "?" on the screen (like INPUT does with BASIC) before 
allowing input from the keyboard.</p>
							<p>To use a ROM call to display "?" on the video screen at the 
current cursor position (Non-DOS Systems Only), and then to input a 
string of up to 240 characters, execute CALL 1BB3H.  The input string 
will be in consecutive memory locations starting at the address 
contained in 40A7H-40A8H, with a zero byte at the end. The HL register 
pair will contain an address one less than the starting address of the 
stored input.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1BB3-1BB4H<span class="origrom2">INPUT</span></div><div>LD A,3FH</div><div>Load register A with a <span class="code">?</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1BB5-1BB7</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#032A" class="memory-link">CALL 032AH</a></div><div>Go display the <span class="code">?</span> (stored in register A) on the video display.</div></div>
									<div class="assembly-row-combined model1"><div>1BB8-1BB9</div><div>LD A,20H</div><div>Load register A with a space.</div></div>
									<div class="assembly-row-combined model1"><div>1BBA-1BBC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#032A" class="memory-link">CALL 032AH</a></div><div>Go display the space in register A on the video display.</div></div>
									<div class="assembly-row-combined model1"><div>1BBD-1BBF</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0361" class="memory-link">JP 0361H</a></div><div>Jump to the keyboard input routine at 0361H.</div></div>
								</div>
							</div>

							<br><h2 id="1BC0">1BC0-1C8F - TOKENIZE INPUT ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1BC0</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1 nodurda"><div>1BC1-1BC3</div><div>LD (40B0H),A</div><div>Save the value in register A as the current value of the tokenization flag.<br><b>NOTE:</b> 40B0H holds the temporary storage location.</div></div>
									<div class="assembly-row-combined model1 durda"><div>1BC1-1BC3</div><div>LD (409FH),A</div><div>Save the value in register A into the DATA FLAG held in 409FH.<br><b>NOTE:</b> Bit 0 HIGH means inside a quote.  Bit 1 HIGH means inside a DATA.  Bit 2 HIGH means inside a REM.<br><b>NOTE:</b> In the original Model III ROM, this byte was placed into 40B0H which was just a temporary storage location.</div></div>
									<div class="assembly-row-combined model1"><div>1BC4</div><div>LD C,A</div><div>Zero register C.</div></div>
									<div class="assembly-row-combined model1"><div>1BC5</div><div>EX DE,HL</div><div>Load register pair DE with the address of the first character after the line number (as stored in register pair HL).</div></div>
									<div class="assembly-row-combined model1"><div>1BC6-1BC8</div><div>LD HL,(40A7H)</div><div>Load register pair HL with the starting address of the input buffer.<br><b>NOTE:</b> 40A7H-40A8H holds Input Buffer pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1BC9</div><div>DEC HL</div><div>We need to backspace twice so ... decrement the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1BCA</div><div>DEC HL</div><div>... and again decrement the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1BCB</div><div>EX DE,HL</div><div>Exchange the string address - 2 from HL into DE, and the current input string address from DE into HL.</div></div>
									<div class="assembly-row-combined model1"><div>1BCC</div><div>LD A,(HL)</div><div>Load register A with the character at the current input string address (in register pair HL).</div></div>
									<div class="assembly-row-combined model1"><div>1BCD-1BCE</div><div>CP 20H</div><div>Check to see if the character in register A is a space.</div></div>
									<div class="assembly-row-combined model1"><div>1BCF-1BD1</div><div><a href="#1C5B" class="memory-link">JP Z,1C5BH</a></div><div>Jump to 1C5BH if the character in register A is a <span class="code"></span>.</div></div>
									<div class="assembly-row-combined model1"><div>1BD2</div><div>LD B,A</div><div>Load register B with the value of the character in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1BD3-1BD4</div><div>CP 22H</div><div>Check to see if the character in register A is a <span class="code">"</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1BD5-1BD7</div><div><a href="#1C77" class="memory-link">JP Z,1C77H</a></div><div>Jump to 1C77H if the character in register A is a <span class="code">"</span>.  1C77H will move the entire field between the quotes into the a code string.</div></div>
									<div class="assembly-row-combined model1"><div>1BD8</div><div>OR A</div><div>Check to see if the character in register A is an end of the input character and set the status flags.</div></div>
									<div class="assembly-row-combined model1"><div>1BD9-1BDB</div><div><a href="#1C7D" class="memory-link">JP Z,1C7DH</a></div><div>Jump to 1C7DH if the character in register A is an end of the input character.</div></div>
									<div class="assembly-row-combined model1 nodurda"><div>1BDC-1BDE</div><div>LD A,(40B0H)</div><div>Load register A with the value of the tokenization flag for <span class="code">DATA</span>.<br><b>NOTE:</b> 40B0H holds the temporary storage location.</div></div>
									<div class="assembly-row-combined model1 durda"><div>1BDC-1BDE</div><div>LD A,(409FH)</div><div>Load register A with the value of the DATA FLAG.<br><b>NOTE:</b> Bit 0 HIGH means inside a quote.  Bit 1 HIGH means inside a DATA.  Bit 2 HIGH means inside a REM.<br><b>NOTE:</b> In the original Model III ROM, this byte was read from 40B0H which was just a temporary storage location.</div></div>
									<div class="assembly-row-combined model1"><div>1BDF</div><div>OR A</div><div>Check to see if a DATA statement is being processed.</div></div>
									<div class="assembly-row-combined model1"><div>1BE0</div><div>LD A,(HL)</div><div>Load register A with the value of the next character.</div></div>
									<div class="assembly-row-combined model1"><div>1BE1-1BE3</div><div><a href="#1C5B" class="memory-link">JP NZ,1C5BH</a></div><div>Jump to 1C5BH if a <span class="code">DATA</span> statement is being processed.</div></div>
									<div class="assembly-row-combined model1"><div>1BE4-1BE5</div><div>CP 3FH</div><div>Check to see if the character in register A is a <span class="code">?</span> (meaning a <span class="code">PRINT</span> statement).</div></div>
									<div class="assembly-row-combined model1"><div>1BE6-1BE7</div><div>LD A,B2H</div><div>Load register A with a <span class="code">PRINT</span> token of B2H.</div></div>
									<div class="assembly-row-combined model1"><div>1BE8-1BEA</div><div><a href="#1C5B" class="memory-link">JP Z,1C5BH</a></div><div>Jump to 1C5BH if the character at the location of the input buffer pointer in register pair HL is a <span class="code">?</span>.  This will replace the <span class="code">?</span> with <span class="code">PRINT</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1BEB</div><div>LD A,(HL)</div><div>Re-
fetch the current character (from the memory location of the input 
buffer pointer in register pair HL) and put it into Register A.</div></div>
									<div class="assembly-row-combined model1"><div>1BEC-1BED</div><div>CP 30H</div><div>Check to see if the character in register A is less than a zero character (alpha numeric).<br><b>NOTE:</b> Results from a CP:<ul><li>Z: A and * are the same</li><li>NZ: A and * are NOT the same</li><li>C: A &lt; *</li><li>NC: A =&gt; *</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1BEE-1BEF</div><div><a href="#1BF5" class="memory-link">JR C,1BF5H</a></div><div>Jump to 1BF5H if the character in register A is less than a zero character, meaning it is not a digit or letter.</div></div>
									<div class="assembly-row-combined model1"><div>1BF0-1BF1</div><div>CP 3CH</div><div>Check
 to see if the character in register A is less than &lt; character 
(which is a test to see if it is 0-9, :, ;, &lt;, constant or special 
character.<br><b>NOTE:</b> Results from a CP:<ul><li>Z: A and * are the same</li><li>NZ: A and * are NOT the same</li><li>C: A &lt; *</li><li>NC: A =&gt; *</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1BF2-1BF4</div><div><a href="#1C5B" class="memory-link">JP C,1C5BH</a></div><div>Jump to 1C5BH if the character in register A is 0-9, :, ;, &lt;, constant or special character.</div></div>
									<div class="assembly-row-combined model1"><div>1BF5</div><div>PUSH DE</div><div>Save the value of the input buffer pointer in register pair DE to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1BF6-1BF8</div><div>LD DE,164FH</div><div>Load register pair DE with the starting address of the reserved words list.</div></div>
									<div class="assembly-row-combined model1"><div>1BF9</div><div>PUSH BC</div><div>Save the value in Register Pair BC to the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>1BFA-1BFC</div><div>LD BC,1C3DH</div><div>Load register pair BC with the return address after matching the reserved word list.</div></div>
									<div class="assembly-row-combined model1"><div>1BFD</div><div>PUSH BC</div><div>Save the return address in register pair BC to the stack .</div></div>
									<div class="assembly-row-combined model1"><div>1BFE-1BFF</div><div>LD B,7FH</div><div>Load register B with the initial reserved words counter.</div></div>
									<div class="assembly-row-combined model1"><div>1C00</div><div>LD A,(HL)</div><div>Load register A with the character at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1C01-1C02</div><div>CP 61H</div><div>Check to see if the character in register A is lower?case.<br><b>NOTE:</b> Results from a CP:<ul><li>Z: A and * are the same</li><li>NZ: A and * are NOT the same</li><li>C: A &lt; *</li><li>NC: A =&gt; *</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1C03-1C04</div><div><a href="#1C0C" class="memory-link">JR C,1C0CH</a></div><div>Jump to 1C0CH if the character in register A isn't lowercase.</div></div>
									<div class="assembly-row-combined model1"><div>1C05-1C06</div><div>CP 7BH</div><div>Check to see if the character in register A is lower?case.</div></div>
									<div class="assembly-row-combined model1"><div>1C07-1C08</div><div><a href="#1C0C" class="memory-link">JR NC,1C0CH</a></div><div>Jump down 2 instructions to 1C0CH if the character in register A isn't lowercase.</div></div>
									<div class="assembly-row-combined model1"><div>1C09-1C0A</div><div>AND 5FH</div><div>Make the lowercase character in register A upper?case.</div></div>
									<div class="assembly-row-combined model1"><div>1C0B</div><div>LD (HL),A</div><div>Save the adjusted character in register A at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1C0C</div><div>LD C,(HL)</div><div>Load register C with the character at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1C0D</div><div>EX DE,HL</div><div>Exchange the input buffer pointer in register pair HL with the reserved words list pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1C0E</div><div>INC HL</div><div>Bump the value of the reserved words list pointer to the next reserved word and put that in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1C0F</div><div>OR (HL)</div><div>Check to see if bit 7 of the character at the location of the reserved words list pointer in register pair HL is set.</div></div>
									<div class="assembly-row-combined model1"><div>1C10-1C12</div><div><a href="#1C0E" class="memory-link">JP P,1C0EH</a></div><div>Jump to 1C0EH if the character at the location of the reserved words list pointer in register pair HL doesn't have bit 7 set.</div></div>
									<div class="assembly-row-combined model1"><div>1C13</div><div>INC B</div><div>Bump the value of the reserved words counter in register B.</div></div>
									<div class="assembly-row-combined model1"><div>1C14</div><div>LD A,(HL)</div><div>Load register A with the character at the location of the reserved words list pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1C15-1C16</div><div>AND 7FH</div><div>Reset bit 7 (the sign bit) of the character in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1C17</div><div>RET Z</div><div>Return if this is the end of the reserved words list.</div></div>
									<div class="assembly-row-combined model1"><div>1C18</div><div>CP C</div><div>Check
 to see if the character in register C is the same as the character at 
the location of the reserved words list pointer in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1C19-1C1A</div><div><a href="#1C0E" class="memory-link">JR NZ,1C0EH</a></div><div>Jump to 1C0EH if the characters don't match.</div></div>
									<div class="assembly-row-combined model1"><div>1C1B</div><div>EX DE,HL</div><div>Exchange
 the value of the reserved words list pointer in register pair HL with 
the value of the input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1C1C</div><div>PUSH HL</div><div>Save the starting address of the current symbol (stored register pair HL) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1C1D</div><div>INC DE</div><div>Bump the value of the reserved words list pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1C1E</div><div>LD A,(DE)</div><div>Load register A with the character at the location of the reserved words list pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1C1F</div><div>OR A</div><div>Check to see if bit 7 of the character in register A is set.</div></div>
									<div class="assembly-row-combined model1"><div>1C20-1C22</div><div><a href="#1C39" class="memory-link">JP M,1C39H</a></div><div>Jump to 1C39H if we have the control element (i.e., bit 7 of the character in register A is set).</div></div>
									<div class="assembly-row-combined model1"><div>1C23</div><div>LD C,A</div><div>Load register C with the character in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1C24</div><div>LD A,B</div><div>Load register A with the value of the reserved words counter in register B.</div></div>
									<div class="assembly-row-combined model1"><div>1C25-1C26</div><div>CP 8DH</div><div>Check to see if the current reserved word being checked is <span class="code">GOTO</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1C27-1C28</div><div><a href="#1C2B" class="memory-link">JR NZ,1C2BH</a></div><div>Jump to 1C2BH if the current reserved word being checked isn't <span class="code">GOTO</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1C29</div><div>RST 10H</div><div>Since
 we need to skip spaces we need to bump the current input buffer pointer
 in register pair HL until it points to the next character, call the 
EXAMINE NEXT SYMBOL routine at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1C2A</div><div>DEC HL</div><div>Decrement the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1C2B</div><div>INC HL</div><div>Bump the value of the input buffer pointer in register pair HL to point to the next character.</div></div>
									<div class="assembly-row-combined model1"><div>1C2C</div><div>LD A,(HL)</div><div>Load
 register A with the next element from the string input (i.e., the 
character at the location of the input buffer pointer in register pair 
HL).</div></div>
									<div class="assembly-row-combined model1"><div>1C2D-1C2E</div><div>CP 61H</div><div>Check to see if the character in register A is lower-case.  Results:<ul><li>If A=61H it sets the ZERO FLAG</li><li>If A&lt;61H then the CARRY FLAG will be set</li><li>if A&gt;=61H then the NO CARRY FLAG will be set.</li></ul>If A is a not lower case then C will be set.</div></div>
									<div class="assembly-row-combined model1"><div>1C2F-1C30</div><div><a href="#1C33" class="memory-link">JR C,1C33H</a></div><div>Jump to 1C33H if the character in register A isn't lowercase.</div></div>
									<div class="assembly-row-combined model1"><div>1C31-1C32</div><div>AND 5FH</div><div>Mask A against 5FH (Binary: 0101 1111) to turn off bits 5 and 7 (which locks A to be between 00H and 7FH).</div></div>
									<div class="assembly-row-combined model1"><div>1C33</div><div>CP C</div><div>Check to see if the character in register A (the input element) matches the character in register C (the syntax element).</div></div>
									<div class="assembly-row-combined model1"><div>1C34-1C35</div><div><a href="#1C1D" class="memory-link">JR Z,1C1DH</a></div><div>Jump back to 1C1DH if the character in the input matches the reserved words character.</div></div>
									<div class="assembly-row-combined model1"><div>1C36</div><div>POP HL</div><div>If
 we didn't just jump away, we need to restart the scan from the last 
point in the syntax list (which is stored in the stack) and put it into 
HL.</div></div>
									<div class="assembly-row-combined model1"><div>1C37-1C38</div><div><a href="#1C0C" class="memory-link">JR 1C0CH</a></div><div>Jump back to 1C0CH.</div></div>
									<div class="assembly-row-combined model1"><div>1C39</div><div>LD C,B</div><div>Load register C with the value of the reserved words counter in register B.</div></div>
									<div class="assembly-row-combined model1"><div>1C3A</div><div><a href="#1C1C" class="memory-link">POP AF</a></div><div>Get the value from the stack and put it in register pair AF (which is just disposing of the HL push from 1C1CH).</div></div>
									<div class="assembly-row-combined model1"><div>1C3B</div><div>EX DE,HL</div><div>Exchange the current string with the syntax tree address for the string.</div></div>
									<div class="assembly-row-combined model1"><div>1C3C</div><div>RET</div><div>Return.</div></div>
									<div class="assembly-row-combined model1"><div>1C3D</div><div>EX DE,HL</div><div>Exchange the reserved words list pointer in register pair HL with the input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1C3E</div><div>LD A,C</div><div>Load register A with the value of the reserved words counter in register C.</div></div>
									<div class="assembly-row-combined model1"><div>1C3F</div><div>POP BC</div><div>Get the value from the stack and put it in register pair BC (basically to clear the return address from the stack).</div></div>
									<div class="assembly-row-combined model1"><div>1C40</div><div>POP DE</div><div>Get the input buffer pointer -2 from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1C41</div><div>EX DE,HL</div><div>Exchange
 the input buffer pointer in register pair HL with the input buffer 
pointer in register pair DE.  HL will be the buffer origin - 2 and DE 
will be the current string address.</div></div>
									<div class="assembly-row-combined model1"><div>1C42-1C43</div><div>CP 95H</div><div>Check to see if the token in register A is an <span class="code">ELSE</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1C44-1C45</div><div>LD (HL),3AH</div><div>Save a colon at the location of the input buffer pointer -2 in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1C46-1C47</div><div><a href="#1C4A" class="memory-link">JR NZ,1C4AH</a></div><div>Jump to 1C4AH if the token in register A isn't an <span class="code">ELSE</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1C48</div><div>INC C</div><div>Bump the value of the counter in register C (which is tracking the token buffer).</div></div>
									<div class="assembly-row-combined model1"><div>1C49</div><div>INC HL</div><div>Bump the value of the input buffer pointer in register pair HL (which is the token buffer).</div></div>
									<div class="assembly-row-combined model1"><div>1C4A-1C4B</div><div>CP 0FBH</div><div>Check to see if the token in register A is a <span class="code">REM</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1C4C-1C4D</div><div><a href="#1C5A" class="memory-link">JR NZ,1C5AH</a></div><div>Jump to 1C5AH if the token in register A isn't a <span class="code">REM</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1C4E-1C4F</div><div>LD (HL),3AH</div><div>Save a ":" at the memory location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1C50</div><div>INC HL</div><div>Bump the value of the input buffer pointer in register pair HL (because we just inserted a <span class="code">:</span>).</div></div>
									<div class="assembly-row-combined model1"><div>1C51-1C52</div><div>LD B,93H</div><div>Load register B with a <span class="code">REM</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1C53</div><div>LD (HL),B</div><div>Save the <span class="code">REM</span> token in register B at the memory location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1C54</div><div>INC HL</div><div>Bump the value of the input buffer pointer in register pair HL (because we just inserted a <span class="code">REM</span> token).</div></div>
									<div class="assembly-row-combined model1"><div>1C55</div><div>EX DE,HL</div><div>Exchange
 the value of the input buffer pointer in register pair HL with the 
value of the input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1C56</div><div>INC C</div><div>Bump the value of the counter in register C.</div></div>
									<div class="assembly-row-combined model1"><div>1C57</div><div>INC C</div><div>Bump the value of the counter in register C.</div></div>
									<div class="assembly-row-combined model1"><div>1C58-1C59</div><div><a href="#1C77" class="memory-link">JR 1C77H</a></div><div>Jump to 1C77H to move the comment to the token buffer.</div></div>
									<div class="assembly-row-combined model1"><div>1C5A</div><div>EX DE,HL</div><div>Exchange
 the value of the input buffer pointer in register pair HL with the 
value of the input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1" id="1C5B"><div>1C5B</div><div>INC HL</div><div>Bump the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1C5C</div><div>LD (DE),A</div><div>Save the value of the token in register A at the location of the input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1C5D</div><div>INC DE</div><div>Bump the value of the input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1C5E</div><div>INC C</div><div>Bump the value of the counter in register C (which is the index/counter for the next syntax element).</div></div>
									<div class="assembly-row-combined model1"><div>1C5F-1C60</div><div>SUB 3AH</div><div>Check to see if the character in register A is a <span class="code">:</span> to flag a multi-statement line.</div></div>
									<div class="assembly-row-combined model1"><div>1C61-1C62</div><div><a href="#1C67" class="memory-link">JR Z,1C67H</a></div><div>Jump to 1C67H if the character in register A is a colon and we have a multi-statement line.</div></div>
									<div class="assembly-row-combined model1"><div>1C63-1C64</div><div>CP 4EH</div><div>Check to see if the token in register A is a <span class="code">DATA</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1C65-1C66</div><div><a href="#1C6A" class="memory-link">JR NZ,1C6AH</a></div><div>Jump to 1C6AH if the token in register A is NOT a <span class="code">DATA</span> token.</div></div>
									<div class="assembly-row-combined model1 nodurda" id="1C67"><div>1C67-1C69</div><div>LD (40B0H),A</div><div>Save the value in register A as the tokenization flag for <span class="code">DATA</span>.<br><b>NOTE:</b> 40B0H holds the temporary storage location.</div></div>
									<div class="assembly-row-combined model1 durda" id="1C67"><div>1C67-1C69</div><div>LD (409FH),A</div><div>Save the value in register A into the DATA FLAG held in 409FH.<br><b>NOTE:</b> Bit 0 HIGH means inside a quote.  Bit 1 HIGH means inside a DATA.  Bit 2 HIGH means inside a REM.<br><b>NOTE:</b> In the original Model III ROM, this byte was placed into 40B0H which was just a temporary storage location.</div></div>
									<div class="assembly-row-combined model1" id="1C6A"><div>1C6A-1C6B</div><div>SUB 59H</div><div>Check to see if the token in register A is a <span class="code">REM</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1C6C-1C6E</div><div><a href="#1BCC" class="memory-link">JP NZ,1BCCH</a></div><div>Jump to 1BCCH if the token in register A isn't a <span class="code">REM</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1C6F</div><div>LD B,A</div><div>Load register B with a zero.</div></div>
									<div class="assembly-row-combined model1"><div>1C70</div><div>LD A,(HL)</div><div>Load register A with the character at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1C71</div><div>OR A</div><div>Check to see if the character in register A is an end of the input character.</div></div>
									<div class="assembly-row-combined model1"><div>1C72-1C73</div><div><a href="#1C7D" class="memory-link">JR Z,1C7DH</a></div><div>Jump out of this loop to 1C7DH if the character in register A is an end of the input character.</div></div>
									<div class="assembly-row-combined model1"><div>1C74</div><div>CP B</div><div>Check to see if the character in register B matches the character in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1C75-1C76</div><div><a href="#1C5B" class="memory-link">JR Z,1C5BH</a></div><div>Jump to 1C5BH if the character in register B matches the character in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1C77</div><div>INC HL</div><div>Bump the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1C78</div><div>LD (DE),A</div><div>Save the character in register A at the location of the input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1C79</div><div>INC C</div><div>Bump the value of the counter in register C.</div></div>
									<div class="assembly-row-combined model1"><div>1C7A</div><div>INC DE</div><div>Bump the value of the input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1C7B-1C7C</div><div><a href="#1C70" class="memory-link">JR 1C70H</a></div><div>Loop until a 'end of statement' or a ending quote is found.</div></div>

									<p class="debug-note" id="1C7D">Still Inside the TOKENIZE INPUT
 ROUTINE - This routine is called if the character in register A is an 
end of the input character.</p>
									<div class="assembly-row-combined model1"><div>1C7D-1C7F</div><div>LD HL,0005H</div><div>Load register pair HL with a five.</div></div>
									<div class="assembly-row-combined model1"><div>1C80</div><div>LD B,H</div><div>Load register B with zero.</div></div>
									<div class="assembly-row-combined model1"><div>1C81</div><div>ADD HL,BC</div><div>Add 5 to the length of the token buffer so far.</div></div>
									<div class="assembly-row-combined model1"><div>1C82</div><div>LD B,H</div><div>Load register B with the MSB of the value in register H.</div></div>
									<div class="assembly-row-combined model1"><div>1C83</div><div>LD C,L</div><div>Load register C with the LSB of the value in register L.</div></div>
									<div class="assembly-row-combined model1"><div>1C84-1C86</div><div>LD HL,(40A7H)</div><div>Load register pair HL with the start address of the input buffer.<br><b>NOTE:</b> 40A7H-40A8H holds the pointer to the start of the Input Buffer.</div></div>
									<div class="assembly-row-combined model1"><div>1C87</div><div>DEC HL</div><div>Decrement the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1C88</div><div>DEC HL</div><div>Decrement the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1C89</div><div>DEC HL</div><div>Decrement the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1C8A</div><div>LD (DE),A</div><div>Zero the location of the input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1C8B</div><div>INC DE</div><div>Bump the value of the input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1C8C</div><div>LD (DE),A</div><div>Zero the location of the input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1C8D</div><div>INC DE</div><div>Bump the value of the input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1C8E</div><div>LD (DE),A</div><div>Zero the location of the input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1C8F</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="1C90">1C90-1C95 - RST 0018H CODE<br>The RST 18H code is located here. (Unsigned compare (HL-DE)).<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the COMPARE DE:HL routine, which numerically compares
 DE and HL. Will not work for signed integers (except positive ones). 
Uses the A-register only. The result of the comparison is returned in 
the status register as:</p><table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table><p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1C90H<span class="origrom2">CHLDE</span></div><div>LD A,H</div><div>Load register A with the MSB of the value in register H.</div></div>
									<div class="assembly-row-combined model1"><div>1C91</div><div>SUB D</div><div>Subtract the value of the MSB of the value in register D from the MSB of the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1C92</div><div>RET NZ</div><div>Return if the MSB of the value in register D doesn't equal the MSB of the value in register H.</div></div>
									<div class="assembly-row-combined model1"><div>1C93</div><div>LD A,L</div><div>Load register A with the LSB of the value in register L.</div></div>
									<div class="assembly-row-combined model1"><div>1C94</div><div>SUB E</div><div>Subtract the LSB of the value in register E from the LSB of the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1C95</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="1C96">1C96-1CA0 - RST 0008H CODE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The RST 8H code is located here.<br>This is the COMPARE 
SYMBOL routine which comparess the symbol in the input string pointed to
 by HL register to the value in the location following the RST 08 call. 
 If there is a match, control is returned to address of the RST 08 
instruction 2 with the next symbol in the Aregister and HL incremented 
by one. If the two characters do not match, a syntax error message is 
given and control returns to the Input Phase).</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1C96</div><div>LD A,(HL)</div><div>Load register A with the character at the location of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1C97</div><div>EX (SP),HL</div><div>Save
 the return address of the routine by exchanging the value of the 
current BASIC program pointer in register pair HL with the value of the 
return address to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1C98</div><div>CP (HL)</div><div>Check
 to see if the character at the location following the RST 08H call 
(stored in register pair HL) is the same as the character in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1C99</div><div>INC HL</div><div>Bump the value of the return address in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1C9A</div><div>EX (SP),HL</div><div>Restore the return address (meaning the RST 08H plus 1 byte plus 1 byte) to the stack pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1C9B-1C9D</div><div><a href="#1D78" class="memory-link">JP Z,1D78H</a></div><div>Jump to the RST 0010H code if the characters match.</div></div>
									<div class="assembly-row-combined model1"><div>1C9E-1C90</div><div><a href="#1997" class="memory-link">JP 1997H</a></div><div>If they don't match, jump to the <span class="code">?SN ERROR</span> routine.</div></div>
								</div>
							</div>

							<br><h2 id="1CA1">1CA1-1D1D - Level II BASIC <span class="code">FOR</span> ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1CA1-1CA2</div><div>LD A,64H</div><div>Load register A with the value for the <span class="code">FOR</span> flag.</div></div>
									<div class="assembly-row-combined model1"><div>1CA3-1CA5</div><div>LD (40DCH),A</div><div>Save the value in register A as the current value of the FOR flag.<br><b>NOTE:</b> 40DCH holds <span class="code">FOR</span> flag.</div></div>
									<div class="assembly-row-combined model1"><div>1CA6-1CA8</div><div><a href="#1F21" class="memory-link">CALL 1F21H</a></div><div>Go evaluate the N=M portion of the expression.</div></div>
									<div class="assembly-row-combined model1"><div>1CA9</div><div>EX (SP),HL</div><div>Exchange the value of the current BASIC program pointer in register pair HL with the value to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1CAA-1CAC</div><div><a href="#1936" class="memory-link">CALL 1936H</a></div><div>GOSUB to 1936H to check to see if there is a <span class="code">FOR</span> statement to the stack already using the same variable name (called the index).</div></div>
									<div class="assembly-row-combined model1"><div>1CAD</div><div>POP DE</div><div>Get the current BASIC program pointer from the stack (which should be the <span class="code">TO</span> token and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1CAE-1CAF</div><div><a href="#1CB5" class="memory-link">JR NZ,1CB5H</a></div><div>If there isn't a matching <span class="code">FOR</span>
 statement to the stack, skip the next 4 instructions (which are 
preparing for a NEXT WITHOUT FOR error) and jump to 1CB5H.  If one is 
found, on exit HL will equal the starting address of the <span class="code">FOR</span> push.</div></div>
									<div class="assembly-row-combined model1"><div>1CB0</div><div>ADD HL,BC</div><div>Add
 the value in register pair BC (which is the offset to the end of the 
stack frame) to the value in register pair HL.  After this addition, we 
should be pointing to the end of the first <span class="code">FOR</span> frame push.</div></div>
									<div class="assembly-row-combined model1"><div>1CB1</div><div>LD SP,HL</div><div>Reset the stack pointer to end of the first <span class="code">FOR</span> frame push.  This also frees up the stack space and prepares for a NF error.</div></div>
									<div class="assembly-row-combined model1"><div>1CB2-1CB4</div><div>LD (40E8H),HL</div><div>Save the value in register pair HL as the stack pointer, get ready for a NF error.<br><b>NOTE:</b> 40E8H-40E9H holds Stack pointer pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1CB5</div><div>EX DE,HL</div><div>Exchange
 the value of the current BASIC program pointer in register pair DE with
 the value of the stack pointer address in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1CB6-1CB7</div><div>LD C,08H</div><div>Load register C with the 1/2 the amount of space needed.</div></div>
									<div class="assembly-row-combined model1"><div>1CB8-1CBA</div><div><a href="#1963" class="memory-link">CALL 1963H</a></div><div>Go check to see if there is enough memory (i.e., 16 bytes) left by calling 1963H (which is the MEMORY CHECK ROUTINE).</div></div>
									<div class="assembly-row-combined model1"><div>1CBB</div><div>PUSH HL</div><div>Save the value of the current BASIC program pointer (which is the code string address before the <span class="code">TO</span>) in register pair HL to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1CBC-1CBE</div><div><a href="#1F05" class="memory-link">CALL 1F05H</a></div><div>Keep scanning the current BASIC program (pointer is in register pair HL) until it points to the end of the BASIC statement.</div></div>
									<div class="assembly-row-combined model1"><div>1CBF</div><div>EX (SP),HL</div><div>Exchange
 the adjusted value of the current BASIC program pointer in register 
pair HL with the value of the current BASIC program pointer to the 
stack.</div></div>
									<div class="assembly-row-combined model1"><div>1CC0</div><div>PUSH HL</div><div>Save the value of the current BASIC program pointer in register pair HL to the stack.  This should be pointing to the <span class="code">TO</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1CC1-1CC3</div><div>LD HL,(40A2H)</div><div>Load register pair HL with the value (in binary) of the current BASIC line number.<br><b>NOTE:</b> 40A2H-40A3H holds the current BASIC line number.</div></div>
									<div class="assembly-row-combined model1"><div>1CC4</div><div>EX (SP),HL</div><div>Exchange
 the value of the current BASIC line number in register pair HL with the
 value of the current BASIC program pointer to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1CC5-1CC6</div><div>RST 08H ‚áí  BDH</div><div>Since
 the character at the location of the current BASIC program pointer in 
register pair HL must be TO token (BDH) so call the COMPARE SYMBOL 
routine which comparess the symbol in the input string pointed to by HL 
register to the value in the location following the RST 08 call.  If 
there is a match, control is returned to address of the RST 08 
instruction 2 with the next symbol in the Aregister and HL incremented 
by one. If the two characters do not match, a syntax error message is 
given and control returns to the Input Phase).</div></div>
									<div class="assembly-row-combined model1"><div>1CC7</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>1CC8-1CCA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0AF6" class="memory-link">JP Z,0AF6H</a></div><div>If that test shows we have a STRING, go to the Level II BASIC error routine and display a TM ERROR message.</div></div>
									<div class="assembly-row-combined model1"><div>1CCB-1CCD</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0AF6" class="memory-link">JP NC,0AF6H</a></div><div>If that test shows we have a DOUBLE PRECISION number, go display a <span class="code">?TM ERROR</span> message.</div></div>
									<div class="assembly-row-combined model1"><div>1CCE</div><div>PUSH AF</div><div>We have an integer, so let's keep going and save the value in register pair AF (the type flags) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>lCCFH-lCDl</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2337" class="memory-link">CALL 2337H</a></div><div>Go evaluate the expression at the location of the current BASIC program pointer in register pair HL (which should be the <span class="code">TO</span> side) and return with the result in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>1CD2</div><div>POP AF</div><div>Restore the index type flags from the from the stack and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>1CD3</div><div>PUSH HL</div><div>Save the value of the current BASIC program pointer (which is the code string after the <span class="code">TO</span> pointer) in register pair HL to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1CD4-1CD6</div><div><a href="#1CEC" class="memory-link">JP P,1CECH</a></div><div>Jump if the current number type is single precision.</div></div>
									<div class="assembly-row-combined model1"><div>1CD7-1CD9</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0A7F" class="memory-link">CALL 0A7FH</a></div><div>Call
 the CONVERT TO INTEGER routine at 0A7FH (where the contents of REG 1 
are converted from single or double precision to integer and deposited 
into HL).</div></div>
									<div class="assembly-row-combined model1"><div>1CDA</div><div>EX (SP),HL</div><div>Exchange the integer value in register pair HL (the current <span class="code">TO</span> value) with the value of the current BASIC program pointer to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1CDB-1CCD</div><div>LD DE,0001H</div><div>Load register pair DE with a default <span class="code">STEP</span> value of 1.</div></div>
									<div class="assembly-row-combined model1"><div>1CDE</div><div>LD A,(HL)</div><div>Load register A with the character at the location of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1CDF-1CE0</div><div>CP CCH</div><div>Check to see if the character in register A is CCH which is the <span class="code">STEP</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1CE1-1CE3</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2B01" class="memory-link">CALL Z,2B01H</a></div><div>So now we have a <span class="code">STEP</span>
 token so we have to get the step value into DE.  To do this, GOSUB to 
2B01H to evaluate the expression at the location of the current BASIC 
program pointer in register pair HL and return with the integer value in
 register pair DE if the character in register A is a STEP token.</div></div>
									<div class="assembly-row-combined model1"><div>1CE4</div><div>PUSH DE</div><div>Save the <span class="code">STEP</span> index value (in register pair DE) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1CE5</div><div>PUSH HL</div><div>Save the current BASIC program pointer (in register pair HL) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1CE6</div><div>EX DE,HL</div><div>Exchange the <span class="code">STEP</span>
 value (from DE) with the value of the current BASIC program pointer (in
 register pair HL).  Now HL will have the value so the next call can 
test its size.</div></div>
									<div class="assembly-row-combined model1"><div>1CE7-1CE9</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#099E" class="memory-link">CALL 099EH</a></div><div>GOSUB to 099EH to get the sign of the <span class="code">STEP</span> value into A.   It will be A=+1 if positive and A=-1 if negative.</div></div>
									<div class="assembly-row-combined model1"><div>1CEA-1CEB</div><div><a href="#1D0E" class="memory-link">JR 1D0EH</a></div><div>Jump down to 1D0EH to skip the convert to single precision code which follows.</div></div>
									<div class="assembly-row-combined model1" id="1CEC"><div>1CEC-1CEE</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0AB1" class="memory-link">CALL 0AB1H</a></div><div>Need the <span class="code">TO</span>
 value to be integer so GOSUB to the CONVERT TO SINGLE PRECISION routine
 at 0AB1H (which converts the contents of REG 1 from integer or double 
precision into single precision).</div></div>
									<div class="assembly-row-combined model1"><div>1CEF-1CF1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09BF" class="memory-link">CALL 09BFH</a></div><div>Call 09BF which loads the SINGLE PRECISION value in REG 1 (the <span class="code">TO</span> value in integer) into register pair BC/DE.</div></div>
									<div class="assembly-row-combined model1"><div>1CF2</div><div>POP HL</div><div>Get the value of the current BASIC program pointer from the stack (which should be the end of the <span class="code">TO</span> expression) and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1CF3H,1CF4</div><div>PUSH BC<br>PUSH DE</div><div>Save all 4 bytes of the <span class="code">TO</span> value to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1CF5-1CF7</div><div>LD BC,8100H</div><div>Load register pair BC with the exponent and the MSB for a single precision constant.</div></div>
									<div class="assembly-row-combined model1"><div>1CF8</div><div>LD D,C</div><div>Zero the NMSB for the single precision constant in register D.</div></div>
									<div class="assembly-row-combined model1"><div>1CF9</div><div>LD E,D</div><div>Zero
 the LSB for the single precision constant in register E. Register pairs
 BC and DE now hold a single precision constant equal to one.</div></div>
									<div class="assembly-row-combined model1"><div>1CFA</div><div>LD A,(HL)</div><div>Load register A with the character at the location of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1CFB-1CFC</div><div>CP CCH</div><div>Check to see if the character in register A is a <span class="code">STEP</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1CFD-1CFE</div><div>LD A,01H</div><div>Load register A with the default <span class="code">STEP</span> value (in this case, 1).</div></div>
									<div class="assembly-row-combined model1"><div>1CFF-1D00</div><div><a href="#1D0F" class="memory-link">JR NZ,1D0FH</a></div><div>Skip
 over the next unstructions by jumping down to 1D0FH if the character at
 the location of the current BASIC program pointer in register A isn't a
 <span class="code">STEP</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1D01-1D03</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2338" class="memory-link">CALL 2338H</a></div><div>Go evaluate the expression at the location of the current BASIC program pointer (which is the <span class="code">STEP</span> instruction and return with the result in REG 1</div></div>
									<div class="assembly-row-combined model1"><div>1D04</div><div>PUSH HL</div><div>Save the value of the current BASIC program pointer in register pair HL to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1D05-1D07</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0AB1" class="memory-link">CALL 0AB1H</a></div><div>Convert the <span class="code">STEP</span>
 value to single precision by calling the CONVERT TO SINGLE PRECISION 
routine at 0AB1H (which converts the contents of REG 1 from integer or 
double precision into single precision).</div></div>
									<div class="assembly-row-combined model1"><div>1D08-1D0A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09BF" class="memory-link">CALL 09BFH</a></div><div>Load the <span class="code">STEP</span> value into BC/DE by calling 09BF which loads the SINGLE PRECISION value in REG 1 into register pair BC/DE.</div></div>
									<div class="assembly-row-combined model1"><div>1D0B-1D0D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0955" class="memory-link">CALL 0955H</a></div><div>Go get the sign for the <span class="code">STEP</span> value (held in REG 1) into register A.  A will be +1 if positive, and -1 if negative.</div></div>
									<div class="assembly-row-combined model1"><div>1D0E</div><div>POP HL</div><div>Get the value of the current BASIC program pointer from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1D0F</div><div>PUSH BC</div><div>Save the exponent and the NMSB for the single precision value in register pair BC to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1D10</div><div>PUSH DE</div><div>Save the NMSB and the LSB for the single precision value in register pair DE to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1D11</div><div>LD C,A</div><div>Load register C with the sign value for the <span class="code">STEP</span> value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1D12</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>1D13</div><div>LD B,A</div><div>Load register B with type-adjusted and sign value of the number type flag test in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1D14</div><div>PUSH BC</div><div>Save the type-adjusted and sign value in register pair BC to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1D15</div><div>PUSH HL</div><div>Save the value of the current BASIC program pointer in register pair HL to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1D16-1D18</div><div>LD HL,(40DFH)</div><div>Load register B with a <span class="code">FOR x=y</span> token.<br><b>NOTE:</b> 40DFH-40E0H holds Used by DOS.</div></div>
									<div class="assembly-row-combined model1"><div>1D19</div><div>EX (SP),HL</div><div>Put the code address string into HL and put the address of the <span class="code">x</span> variable into the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1D1A-1D1B</div><div>LD B,81H</div><div>Load register B with the <span class="code">FOR</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1D1C</div><div>PUSH BC</div><div>Save the <span class="code">FOR</span> and token and the sign of the <span class="code">STEP</span> increment BC to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1D1D</div><div>INC SP</div><div>Bump
 the value of the stack pointer to leave a one byte gap.  By continuing 
onward, we will wind up continuing the execution of the code string.</div></div>
								</div>
							</div>

							<br><h2 id="1D1E">1D1E-1D77 - LEVEL II BASIC INTERPRETER<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1D1E-1D20</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0358" class="memory-link">CALL 0358H</a></div><div>GOSUB to 0358H to check to see if a key has been pressed.</div></div>
									<div class="assembly-row-combined model1"><div>1D21</div><div>OR A</div><div>Set the flags to test for what key was pressed.</div></div>
									<div class="assembly-row-combined model1"><div>1D22-1D24</div><div><a href="#1DA0" class="memory-link">CALL NZ,1DA0H</a></div><div>GOSUB to 1DA0H if the key pressed was a <span class="code">SHIFT-@</span>.  This will save the address of the last byte executed in the current line.</div></div>
									<div class="assembly-row-combined model1"><div>1D25-1D27</div><div>LD (40E6H),HL</div><div>Save the value of the current BASIC program pointer.<br><b>NOTE:</b> 40E6H-40E7H holds the temporary storage location.</div></div>
									<div class="assembly-row-combined model1"><div>1D28-1D2B</div><div>LD (40E8H),SP</div><div>Save the value of the stack pointer.<br><b>NOTE:</b> 40E8H-40E9H holds Stack pointer pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1D2C</div><div>LD A,(HL)</div><div>Load register A with the value at the location of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1D2D-1D2E</div><div>CP 3AH</div><div>Check to see if the character in register A is a <span class="code">:</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1D2F-1D30</div><div><a href="#1D5A" class="memory-link">JR Z,1D5AH</a></div><div>If the character is a <span class="code">:</span>, jump to 1D5AH since that means this is a brand new statement on this line.</div></div>
									<div class="assembly-row-combined model1"><div>1D31</div><div>OR A</div><div>There
 wasn't a colon, so the only valid thing we can find now is an END OF 
LINE character.  This will check to see if the character in register A 
is an end of the BASIC line character.</div></div>
									<div class="assembly-row-combined model1"><div>1D32-1D34</div><div><a href="#1997" class="memory-link">JP NZ,1997H</a></div><div>Go to the Level II BASIC error routine and display a <span class="code">?SN ERROR</span> message if the character in register A isn't an end of the BASIC line character.</div></div>
									<div class="assembly-row-combined model1"><div>1D35</div><div>INC HL</div><div>So
 now we know that we have another line number to check, so bump the 
value of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1D36</div><div>LD A,(HL)</div><div>Load
 register A with the LSB of the next BASIC line pointer at the location 
of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1D37</div><div>INC HL</div><div>Bump the value of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1D38</div><div>OR (HL)</div><div>Check to see if the next BASIC line pointer is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>1D39-1D3B</div><div><a href="#197E" class="memory-link">JP Z,197EH</a></div><div>Jump to 197EH if this is the end of the BASIC program.</div></div>
									<div class="assembly-row-combined model1"><div>1D3C</div><div>INC HL</div><div>If
 we are here, it was not the end of the BASIC program so we need to bump
 the value of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1D3D</div><div>LD E,(HL)</div><div>Load register E with the LSB of the BASIC line number at the location of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1D3E</div><div>INC HL</div><div>Bump the value of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1D3F</div><div>LD D,(HL)</div><div>Load register D with the MSB of the BASIC line number at the location of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1D40</div><div>EX DE,HL</div><div>Exchange
 the value of the BASIC line number in register pair DE with the value 
of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1D41-1D43</div><div>LD (40A2H),HL</div><div>Save the value of the BASIC line number in register pair HL.<br><b>NOTE:</b> 40A2H-40A3H holds the current BASIC line number.</div></div>
									<p class="debug-note">Honor a <span class="code">TRON</span> by showing the line number if it is in effect.</p>
									<div class="assembly-row-combined model1"><div>1D44-1D46</div><div>LD A,(411BH)</div><div>Before we move on, we need to honor a <span class="code">TRON</span>, if its in effect so first we load register A with the value of the <span class="code">TRON</span> flag.<br><b>NOTE:</b> 411BH holds the TRON/TROFF flag.</div></div>
									<div class="assembly-row-combined model1"><div>1D47</div><div>OR A</div><div>Check for <span class="code">TRON</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1D48-1D49</div><div><a href="#1D59" class="memory-link">JR Z,1D59H</a></div><div>Jump out of this routine to 1D59H if <span class="code">TROFF</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1D4A</div><div>PUSH DE</div><div>If we are here, we have to process the code to show the "&lt;nnnn&gt;" of a <span class="code">TRON</span>.  First, save the value of the current BASIC program pointer in register pair DE to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1D4B-1D4C</div><div>LD A,3CH</div><div>Load register A with a &lt;.</div></div>
									<div class="assembly-row-combined model1"><div>1D4D-1D4F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#032A" class="memory-link">CALL 032AH</a></div><div>Go display the &lt; that preceeds the line number in <span class="code">TRON</span> output</div></div>
									<div class="assembly-row-combined model1"><div>1D50-1D52</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0FAF" class="memory-link">CALL 0FAFH</a></div><div>Call
 the HL TO ASCII routine at 0FAFH (which converts the value in the HL 
register pair (assumed to be an integer) to ASCII and display it at the 
current cursor position on the video screen) to display the current 
BASIC line number.</div></div>
									<div class="assembly-row-combined model1"><div>1D53-1D54</div><div>LD A,3EH</div><div>Load register A with a &gt;</div></div>
									<div class="assembly-row-combined model1"><div>1D55-1D57</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#032A" class="memory-link">CALL 032AH</a></div><div>Go display the &gt; that follows the line number in <span class="code">TRON</span> output</div></div>
									<div class="assembly-row-combined model1"><div>1D58</div><div>POP DE</div><div>Get the value of the current BASIC program pointer from the stack and put it in register pair DE.</div></div>
									<p class="debug-note">Done with the <span class="code">TRON</span>, so let us continue</p>
									<div class="assembly-row-combined model1"><div>1D59</div><div>EX DE,HL</div><div>Load register pair HL with the value of the current BASIC program pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1" id="1D5A"><div>1D5A</div><div>RST 10H</div><div>We
 need to get the next token.  We bump the current input buffer pointer 
in register pair HL until it points to the next character, call the 
EXAMINE NEXT SYMBOL routine at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1D5B-1D5D</div><div>LD DE,1D1EH</div><div>Load register pair DE with the return address to go to after executing one verb.</div></div>
									<div class="assembly-row-combined model1"><div>1D5E</div><div>PUSH DE</div><div>Save that return address in register pair DE to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1D5F</div><div><a href="#1D1E" class="memory-link">RET Z</a></div><div>Return
 (back to 1D1EH) if the character at the location of the current BASIC 
program pointer (in register pair HL) is an end of the BASIC line 
character.</div></div>
									<div class="assembly-row-combined model1"><div>1D60-1D61</div><div>SUB 80H</div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in register A is a token.  This is accomplished because tokens 
range from 80H-FBH so this would give an index of the current token.</div></div>
									<div class="assembly-row-combined model1"><div>1D62-1D64</div><div><a href="#1F21" class="memory-link">JP C,1F21H</a></div><div>Jump to 1F21H if the character in register A isn't a BASIC token.</div></div>
									<div class="assembly-row-combined model1"><div>1D65-1D66</div><div>CP 3CH</div><div>Check to see if the token in register A is below the <span class="code">TAB(</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1D67-1D69</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2AE7" class="memory-link">JP NC,2AE7H</a></div><div>Jump out of here to 2AE7H if the token in register A is greater than or equal to a <span class="code">TAB(</span> token, meaning <span class="code">TAB(</span> to <span class="code">MID$(</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1D6A</div><div>RLCA</div><div>Multiply the token value in register A by two.  This doubles the remainder of the routine address offset.</div></div>
									<div class="assembly-row-combined model1"><div>1D6B</div><div>LD C,A</div><div>Load the adjusted token value in register C from register A.</div></div>
									<div class="assembly-row-combined model1"><div>1D6C-1D6D</div><div>LD B,00H</div><div>Load register B with zero so that BC now holds "00" and (2 x the token).</div></div>
									<div class="assembly-row-combined model1"><div>1D6E</div><div>EX DE,HL</div><div>Load register pair DE with the value of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1D6F-1D71</div><div>LD HL,1822H</div><div>Load register pair HL with the list of BASIC execution addresses.</div></div>
									<div class="assembly-row-combined model1"><div>1D72</div><div>ADD HL,BC</div><div>Add
 the value of the token offset in register pair BC to the starting 
address of the list of BASIC execution addresses in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1D73</div><div>LD C,(HL)</div><div>Load register C with the LSB of the execution address at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1D74</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1D75</div><div>LD B,(HL)</div><div>Load register B with the MSB of the execution address at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1D76</div><div>PUSH BC</div><div>Save the value of the execution address in register pair BC to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1D77</div><div>EX DE,HL</div><div>Load
 register pair HL with the value of the current BASIC program pointer in
 register pair DE (i.e., restore the code string address).</div></div>
								</div>
							</div>

							<br><h2 id="1D78">1D78-1D90 - RST 0010H CODE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>The RST 10H code is located here.  This is the EXAMINE NEXT 
SYMBOL routine which loads the next character from the string pointed to
 by the HL register set into the A-register and clears the CARRY FLAG if
 it is alphabetic, or sets it if is alphanumeric. Blanks and control 
codes 09 and OB are ignored causing the following character to be loaded
 and tested. The HL register will be incremented before loading any 
character therfore on the first call the HL register should contain the 
string address minus one. The string must be terminated by a byte of 
zeros).</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1D78H<span class="origrom2">FETCH</span></div><div>INC HL</div><div>Bump the value of the current BASIC program pointer in register pair HL to the next character.</div></div>
									<div class="assembly-row-combined model1"><div>1D79</div><div>LD A,(HL)</div><div>Load register A with the value of the character at the location of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1D7A-1D7B</div><div>CP 3AH</div><div>Check to see if the character at the location of the current BASIC program pointer in register A is greater than or equal to a <span class="code">:</span>.  Results:<ul><li>If A=<span class="code">:</span> it sets the ZERO FLAG</li><li>If A&lt;<span class="code">:</span> then the CARRY FLAG will be set</li><li>if A&gt;=<span class="code">:</span> then the NO CARRY FLAG will be set.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1D7C</div><div>RET NC</div><div>Return if the character at the location of the current BASIC program pointer in register A is greater than or equal to a <span class="code">:</span> (meaning <span class="code">:</span>, <span class="code">;</span>, <span class="code">&lt;</span> ... <span class="code">Y</span>, <span class="code">Z</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1D7D-1D7E</div><div>CP 20H</div><div>Check to see if the character at the location of the current BASIC program pointer in register A is a space.</div></div>
									<div class="assembly-row-combined model1"><div>1D7F-1D81</div><div><a href="#1D78" class="memory-link">JP Z,1D78H</a></div><div>Loop if the character at the location of the current BASIC program pointer in register A is a space.</div></div>
									<div class="assembly-row-combined model1"><div>1D82-1D83</div><div>CP 0BH</div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in register A is greater than or equal to 0BH (meaning it is not
 a control code).  Results:<ul><li>If A=0BH it sets the ZERO FLAG</li><li>If A&lt;0BH then the CARRY FLAG will be set</li><li>if A&gt;=0BH then the NO CARRY FLAG will be set.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1D84-1D85</div><div><a href="#1D8B" class="memory-link">JR NC,1D8BH</a></div><div>Jump if the character at the location of the current BASIC program pointer in register A if greater than or equal to 0BH.</div></div>
									<div class="assembly-row-combined model1"><div>1D86-1D87</div><div>CP 09H</div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in register A is greater than or equal to 09H (meaning a 
horizontal tab).  Results:<ul><li>If A=09H it sets the ZERO FLAG</li><li>If A&lt;09H then the CARRY FLAG will be set</li><li>if A&gt;=09H then the NO CARRY FLAG will be set.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1D88-1D8A</div><div><a href="#1D78" class="memory-link">JP NC,1D78H</a></div><div>Loop
 back up to get the next character if if the character at the location 
of the current BASIC program pointer in register A is greater than or 
equal to 09H.</div></div>
									<div class="assembly-row-combined model1"><div>1D8B-1D8C</div><div>CP 30H</div><div>Check to see if the character at the location of the current BASIC program pointer in register A is greater than or equal to a <span class="code">0</span>.  Results:<ul><li>If A=<span class="code">0</span> it sets the ZERO FLAG</li><li>If A&lt;<span class="code">0</span> then the CARRY FLAG will be set</li><li>if A&gt;=<span class="code">0</span> then the NO CARRY FLAG will be set.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1D8D</div><div>CCF</div><div>Complement
 (invert) the CARRY FLAG so that it will set the CARRY FLAG if that 
ascii character is numeric (i..e, greater than or equal to 30H).</div></div>
									<div class="assembly-row-combined model1"><div>1D8E</div><div>INC A</div><div>Clear the CARRY FLAG if it is not numeric (i.e., it is less than 30).</div></div>
									<div class="assembly-row-combined model1"><div>1D8F</div><div>DEC A</div><div>Set the status flags (except for the CARRY FLAG) according to the character at hand.</div></div>
									<div class="assembly-row-combined model1"><div>1D90</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="1D91">1D91-1D9A - LEVEL II BASIC <span class="code">RESTORE</span> ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1D91</div><div>EX DE,HL</div><div>Save the contents of HL by loading its contents into DE.</div></div>
									<div class="assembly-row-combined model1"><div>1D92-1D94</div><div>LD HL,(40A4H)</div><div>Load register pair HL with the start of the BASIC program pointer.<br><ul><li>Note: 40A4H-40A5H holds the starting address of BASIC program text also known as the PROGRAM STATEMENT TABLE (PST).</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1D95</div><div>DEC HL</div><div>Backspace from the start of the BASIC program pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1D96-1D98</div><div>LD (40FFH),HL</div><div>Save the start of the program pointer -1 into 40FFH.<br><b>NOTE:</b> 40FFH-4100H holds READ pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1D99</div><div>EX DE,HL</div><div>Restore the HL from being held in DE.</div></div>
									<div class="assembly-row-combined model1"><div>1D9A</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="1D9B">1D9B-1DAD - SCAN KEYBOARD ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1D9B-1D9D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0358" class="memory-link">CALL 0358H</a></div><div>GOSUB to 0358H to scan the keyboard.</div></div>
									<div class="assembly-row-combined model1"><div>1D9E</div><div>OR A</div><div>Set the flags (to see if a key was pressed).</div></div>
									<div class="assembly-row-combined model1"><div>1D9F</div><div>RET Z</div><div>Return if a key wasn't pressed.</div></div>
								</div>
							</div>

							<br><h2 id="1DA0">1DA0H - Inside the SCAN KEYBOARD ROUTINE - This will process a <kbd>SHIFT</kbd> + <kbd>@</kbd> (Pause) Keypress<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1DA0-1DA1</div><div>CP 60H</div><div>Check to see if the key pressed in register A is a <kbd>SHIFT</kbd> + <kbd>@</kbd>.</div></div>
									<div class="assembly-row-combined model1"><div>1DA2-1DA4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0384" class="memory-link">CALL Z,0384H</a></div><div>If you got a <kbd>SHIFT</kbd> + <kbd>@</kbd> we now need to honor that by waiting for yet another key to be pressed.</div></div>
									<div class="assembly-row-combined model1"><div>1DA5-1DA7</div><div>LD (4099H),A</div><div>Save the key pressed in register A as the value of the last key pressed.<br><b>NOTE:</b> 4099H holds the Last key pressed.</div></div>
									<div class="assembly-row-combined model1"><div>1DA8</div><div>DEC A</div><div>Check to see if the <kbd>BREAK</kbd> key was pressed.</div></div>
								</div>
							</div>

							<br><h2 id="1DA9">1DA9H-1DADH - Inside the SCAN KEYBOARD ROUTINE - This will process a <span class="code">STOP</span>.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1DA9</div><div>RET NZ</div><div>Return if the <kbd>BREAK</kbd> key wasn't pressed.<br>This is the <span class="code">STOP</span> entry point.</div></div>
									<div class="assembly-row-combined model1"><div>1DAA</div><div>INC A</div><div>Readjust the value of the key pressed in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1DAB-1DAD</div><div><a href="#1DB4" class="memory-link">JP 1DB4H</a></div><div>Jump into the applicable portion of the code that processes <span class="code">END</span>.</div></div>
								</div>
							</div>

							<br><h2 id="1DAE">1DAE-1DE3 - LEVEL II BASIC <span class="code">END</span> ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1DAE</div><div>RET NZ</div><div>Return and display a <span class="code">?SN ERROR</span> message if there is anything following the <span class="code">END</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1DAF</div><div>PUSH AF</div><div>Save the value in register pair AF to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1DB0-1DB2</div><div>CALL Z,41BBH</div><div>If this is a DOS system, then call the DOS link at 41BBH instead of continuing here.</div></div>
									<div class="assembly-row-combined model1"><div>1DB3</div><div>POP AF</div><div>Restore the <span class="code">END</span> status to the A register.</div></div>
									<div class="assembly-row-combined model1" id="1DB4"><div>1DB4-1DB6</div><div>LD (40E6H),HL</div><div>Save the value of the current BASIC program pointer in register pair HL.<br><b>NOTE:</b> 40E6H-40E7H holds the temporary storage location.</div></div>
									<div class="assembly-row-combined model1"><div>1DB7-1DB9</div><div>LD HL,40B5H</div><div>Load register pair HL with the starting address of the temporary string work area.<br><b>NOTE:</b> 40B5H-40D2H holds Temporary string work area.</div></div>
									<div class="assembly-row-combined model1"><div>1DBA-1DBC</div><div>LD (40B3H),HL</div><div>Save the value in register pair HL as the new temporary string work area pointer.<br><b>NOTE:</b> 40B3H-40B4H holds Next available location in the temporary string work area pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1DBD-1DBFH</div><div>21 F6 FF</div><div>Z-80 space saving trick</div></div>
									<div class="assembly-row-combined model1"><div>1DBE-1DBF</div><div>OR FFH</div><div>Set the flags.</div></div>
									<div class="assembly-row-combined model1"><div>1DC0</div><div>POP BC</div><div>Get the value from the stack and put it in register pair BC.  This clears out the stack.</div></div>
									<div class="assembly-row-combined model1" id="1DC1"><div>1DC1-1DC3</div><div>LD HL,(40A2H)</div><div>Load register pair HL with the value of the current BASIC line number in binary.<br><b>NOTE:</b> 40A2H-40A3H holds the current BASIC line number.</div></div>
									<div class="assembly-row-combined model1"><div>1DC4</div><div>PUSH HL</div><div>Save the value of the current BASIC line number (in binary) in register pair HL to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1DC5</div><div>PUSH AF</div><div>Save the value in register pair AF to the stack.  A will be 0 if it is an <span class="code">END</span> and A will be a 1 if it is a <span class="code">STOP</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1DC6</div><div>LD A,L</div><div>These
 3 instructions test to see if we are in command mode by testing for an 
uninitialized line (meaning a line number of FFFF).  First, load 
register A with the LSB of the current BASIC line number in register L.</div></div>
									<div class="assembly-row-combined model1"><div>1DC7</div><div>AND H</div><div>Combine the MSB of the current BASIC line number in register H with the LSB of the current BASIC line number in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1DC8</div><div>INC A</div><div>Bump the combined value of the current BASIC line number in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1DC9-1DCA</div><div><a href="#1DD4" class="memory-link">JR Z,1DD4H</a></div><div>Increasing
 FFFF by 1 would flip the Z flag on, meaning there was no line number.  
If there was no line number, skip the nex 3 instructions and go to 
1D44H.</div></div>
									<div class="assembly-row-combined model1"><div>1DCB-1DCD</div><div>LD (40F5H),HL</div><div>If we are here, we have a line number so save the line number we ended on in register pair HL.<br><b>NOTE:</b> 40F5H-40F6H holds the last line number executed.</div></div>
									<div class="assembly-row-combined model1"><div>1DCE-1DD0</div><div>LD HL,(40E6H)</div><div>Load register pair HL with the value of the current BASIC program pointer .<br><b>NOTE:</b> 40E6H-40E7H holds the temporary storage location.</div></div>
									<div class="assembly-row-combined model1"><div>1DD1-1DD3</div><div>LD (40F7H),HL</div><div>Save the value of the current BASIC program pointer in register pair HL.<br><b>NOTE:</b> 40F7H-40F8H holds the last byte executed.</div></div>
									<div class="assembly-row-combined model1"><div>1DD4-1DD6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#038B" class="memory-link">CALL 038BH</a></div><div>Go set the current output device to the video display.</div></div>
									<div class="assembly-row-combined model1"><div>1DD7-1DD9</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#20F9" class="memory-link">CALL 20F9H</a></div><div>Go display a carriage return if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>1DDA</div><div>POP AF</div><div>Restore A so we can see if this is an <span class="code">END</span> (where A=0) or a <span class="code">STOP</span> (where A=1).</div></div>
									<div class="assembly-row-combined model1"><div>1DDB-1DDD</div><div>LD HL,1930H</div><div>Load register pair HL with the starting address of the <kbd>BREAK</kbd> message.</div></div>
									<div class="assembly-row-combined model1"><div>1DDE-1DE0</div><div><a href="#1A06" class="memory-link">JP NZ,1A06H</a></div><div>Jump to 1A06H if it was a <kbd>BREAK</kbd> or a <span class="code">STOP</span> that halted program execution.</div></div>
									<div class="assembly-row-combined model1"><div>1DE1-1DE3</div><div><a href="#1A18" class="memory-link">JP 1A18H</a></div><div>At this point it was either due to an <span class="code">END</span>
 statement or an error while in command mode so jump to 1A18H  (note: 
This uses a Z-80 trick as 1A18H is in the middle of a 2 Opcode 
instruction starting at 1A17H).</div></div>
								</div>
							</div>

							<br><h2 id="1DE4">1DE4-1DF6 - LEVEL II BASIC <span class="code">CONT</span> ROUTINE.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1DE4-1DE6</div><div>LD HL,(40F7H)</div><div>Load register pair HL with the value of the continuation address.<br><b>NOTE:</b> 40F7H-40F8H holds the last byte executed.</div></div>
									<div class="assembly-row-combined model1"><div>1DE7-1DE8</div><div>LD A,H<br>OR L</div><div>Test
 HL for 0.  The easiest way to test a 2 byte register for zero is to 
load the MSB into A and then OR it with the LSB.  if the MSB was 0 and 
the LSB was 0, then A will be 0.</div></div>
									<div class="assembly-row-combined model1"><div>1DE9-1DEA</div><div>LD E,20H</div><div>Load register E with a <span class="code">?CN ERROR</span> code.</div></div>
									<div class="assembly-row-combined model1"><div>1DEB-1DED</div><div><a href="#19A2" class="memory-link">JP Z,19A2H</a></div><div>If HL was zero, then a CONT isn't possible, so JUMP to 19A2H to display a <span class="code">?CN ERROR</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1DEE</div><div>EX DE,HL</div><div>If
 we are here, there was a valid return line number, so load register 
pair DE with the value of the continuation line number in register pair 
HL.</div></div>
									<div class="assembly-row-combined model1"><div>1DEF-1DF1</div><div>LD HL,(40F5H)</div><div>Load HL with the value of the last BASIC line number executed.<br><b>NOTE:</b> 40F5H-40F6H holds the last line number executed.</div></div>
									<div class="assembly-row-combined model1"><div>1DF2-1DF4</div><div>LD (40A2H),HL</div><div>Save the last line number executed in register pair HL (which had the error) as the current BASIC line number.<br><b>NOTE:</b> 40A2H-40A3H holds the current BASIC line number.</div></div>
									<div class="assembly-row-combined model1"><div>1DF5</div><div>EX DE,HL</div><div>Swap so that HL will be the address of the continuation line.</div></div>
									<div class="assembly-row-combined model1"><div>1DF6</div><div>RET</div><div>Return (continue running but from the <span class="code">CONT</span> line number).</div></div>
								</div>
							</div>

							<br><h2 id="1DF7">1DF7H-1DFCH - <span class="code">TRON</span> and <span class="code">TROFF</span> Routine<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<p class="debug-note">1DF7H - <span class="code">TRON</span> Entry Point (Set A with AFH)</p>
									<div class="assembly-row-combined model1"><div>1DF7-1DF8</div><div>LD A,AFH</div><div>Load register A with AFH (Decimal: 175), which is the value for TRON when placed into 411BH.</div></div>
									<p class="debug-note" id="1DF8">1DF8H - <span class="code">TROFF</span> Entry Point (Set A with 00H)</p>
									<div class="assembly-row-combined model1"><div>1DF8</div><div>XOR A</div><div>Z-80 trick.  This command is only visible if jumped to.  This zeros register A.</div></div>
									<p class="debug-note" id="1DF9">1DF9-1DFC - COMMON CODE SHARED BY TRON AND TROFF - Put A into (411BH)</p>
									<div class="assembly-row-combined model1"><div>1DF9-1DFB</div><div>LD (411BH),A</div><div>Save the value in register A as the current value of the TRON/TROFF flag.<br><b>NOTE:</b> 411BH holds the TRON/TROFF flag.  0=off (TROFF), 175=on (TRON)</div></div>
									<div class="assembly-row-combined model1"><div>1DFC</div><div>RET</div><div>RETURN.</div></div>
								</div>
							</div>

							<br><h2 id="1DFD">1DFD-1DFF - DISK ROUTINE NOT USED BY LEVEL II BASIC.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1DFD</div><div>POP AF</div></div>
									<div class="assembly-row-combined model1"><div>1DFE</div><div>POP HL</div></div>
									<div class="assembly-row-combined model1"><div>1DFF</div><div>RET</div></div>
								</div>
							</div>

							<br><h2 id="1E00">1E00H-1E3CH - <span class="code">DEFxxx</span> Routine<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<p class="debug-note">1E00-1E02 - INSIDE THE DEFxxx ROUTINE - <span class="code">DEFSTR</span> Entry Point</p>
									<div class="assembly-row-combined model1"><div>1E00-1E01</div><div>LD E,03H</div><div>Load register E with the <span class="code">DEFSTR</span> string number type flag (03H).</div></div>
									<div class="assembly-row-combined model1"><div>1E02H</div><div>32 1B 41</div><div>Z-80 Trick!  See the general explanation at 10F8H.</div></div>
									<p class="debug-note" id="1E03">1E03H-1E05H - INSIDE THE DEFxxx ROUTINE - <span class="code">DEFINT</span> Entry Point</p>
									<div class="assembly-row-combined model1"><div>1E03-1E04</div><div>LD E,02H</div><div>Load register E with the <span class="code">DEFINT</span> integer number type flag (02H).</div></div>
									<div class="assembly-row-combined model1"><div>1E05H</div><div>011 1E 04</div><div>Z-80 Trick!  See the general explanation at 10F8H.</div></div>
									<p class="debug-note" id="1E06">1E06H-1E08H - INSIDE THE DEFxxx ROUTINE - <span class="code">DEFSNG</span> Entry Point</p>
									<div class="assembly-row-combined model1"><div>1E06-1E07</div><div>LD E,04H</div><div>Load register E with the <span class="code">DEFSNG</span> single precision number type flag (04H).</div></div>
									<div class="assembly-row-combined model1"><div>1E08H</div><div>011 E0 08</div><div>Z-80 Trick!  See the general explanation at 10F8H.</div></div>
									<p class="debug-note" id="1E09">1E09-1E0AH - INSIDE THE DEFxxx ROUTINE - <span class="code">DEFDBL</span> Entry Point</p>
									<div class="assembly-row-combined model1"><div>1E09-1E0A</div><div>LD E,08H</div><div>Load register E with the <span class="code">DEFDBL</span> double precision number type flag (08H).</div></div>
									<p class="debug-note" id="1E0B">1E0BH-1E3CH - INSIDE THE DEFxxx ROUTINE - Common code shared by all the above - All of those can either have a <span class="code">-</span> for a range of values or be separated by <span class="code">,</span>.  This code needs to figure out the variables that followed the <span class="code">DEF???</span> instruction and then set the variable type (which is currently sitting in Register E) in the variable table.</p>
									<div class="assembly-row-combined model1"><div>1E0B-1E0D</div><div><a href="#1E3D" class="memory-link">CALL 1E3DH</a></div><div>GOSUB
 to 1E3DH to check the value at memory location (HL), which would be the
 current BASIC program pointer, to see if it is a letter.  If its not, 
CARRY is set.  If it is, CARRY is clear.</div></div>
									<div class="assembly-row-combined model1"><div>1E0E-1E10</div><div>LD BC,1997H</div><div>Load register pair BC with a return address which will return to the <span class="code">?SN ERROR</span> routine.</div></div>
									<div class="assembly-row-combined model1"><div>1E11</div><div>PUSH BC</div><div>Save the ?SN ERROR address (in register pair BC) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1E12</div><div>RET C</div><div>Return if the character at the location of the current BASIC program pointer in register A isn't alphabetic (meaning that <span class="code">DEF???</span> wasn't followed by a letter).</div></div>
									<div class="assembly-row-combined model1"><div>1E13-1E14</div><div>SUB 41H</div><div>Subtract 41H from the letter's value in register A so that it will be in the range of 0-25.</div></div>
									<div class="assembly-row-combined model1"><div>1E15</div><div>LD C,A</div><div>Load register C with the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1E16</div><div>LD B,A</div><div>Load register B with the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1E17</div><div>RST 10H</div><div>Since
 we now need bump the value of the current BASIC program pointer until 
it points to the next character, call the EXAMINE NEXT SYMBOL routine at
 RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The 
RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1E18-1E19</div><div>CP CEH</div><div>Check to see if the character at the location of the current BASIC program pointer in register A is a <span class="code">-</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1E1A-1E1B</div><div><a href="#1E25" class="memory-link">JR NZ,1E25H</a></div><div>If it's not a <span class="code">-</span> we know this isn't a range, so jump to 1E25H because we don't need to get any more variables.</div></div>
									<div class="assembly-row-combined model1"><div>1E1C</div><div>RST 10H</div><div>If we are here, then we know the <span class="code">DEF???</span>
 has a range, so we need another character.  We bump the value of the 
current BASIC program pointer until it points to the next character, 
call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1E1D-1E1F</div><div><a href="#1E3D" class="memory-link">CALL 1E3DH</a></div><div>GOSUB
 to 1E3DH to check the value at memory location (HL), which would be the
 current BASIC program pointer, to see if it is a letter.  If its not, 
CARRY is set.  If it is, CARRY is clear.</div></div>
									<div class="assembly-row-combined model1"><div>1E20</div><div>RET C</div><div>Return if the character at the location of the current BASIC program pointer in register A isn't alphabetic.</div></div>
									<div class="assembly-row-combined model1"><div>1E21-1E22</div><div>SUB 41H</div><div>Subtract 41H from the letter's value in register A so that it will be in the range of 0-25.</div></div>
									<div class="assembly-row-combined model1"><div>1E23</div><div>LD B,A</div><div>Load register B with the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1E24</div><div>RST 10H</div><div>Since
 we now need bump the value of the current BASIC program pointer until 
it points to the next character, call the EXAMINE NEXT SYMBOL routine at
 RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The 
RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1E25</div><div>LD A,B</div><div>Load register A with the value of the second letter in register B.</div></div>
									<div class="assembly-row-combined model1"><div>1E26</div><div>SUB C</div><div>Subtract the value of the first letter in register C from the value of the second letter in Register  A.</div></div>
									<div class="assembly-row-combined model1"><div>1E27</div><div>RET C</div><div>If
 the CARRY FLAG is set (meaning that varible names are not in ascending 
order ... the one in Register C is earlier than the one in Register A), 
return (to a syntax error).</div></div>
									<div class="assembly-row-combined model1"><div>1E28</div><div>INC A</div><div>Bump the value in register A so that it holds the number of variable names to be changed.</div></div>
									<div class="assembly-row-combined model1"><div>1E29</div><div>EX (SP),HL</div><div>Clear the error address and save the current code string address.</div></div>
									<div class="assembly-row-combined model1"><div>1E2A-1E2C</div><div>LD HL,4101H</div><div>Load register pair HL with 4101H which is the starting address of the variable declaration table.<br><b>NOTE:</b> 4101H-411AH holds Variable Declaration Table.</div></div>
									<div class="assembly-row-combined model1"><div>1E2D-1E2E</div><div>LD B,00H</div><div>Load register B with zero.</div></div>
									<div class="assembly-row-combined model1"><div>1E2F</div><div>ADD HL,BC</div><div>Find
 the next entry in the type table by adding the value of the first 
letter in register pair BC to the value of the starting address of the 
variable declaration table in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1E30</div><div>LD (HL),E</div><div>E
 was set on entry to string, integer, single precision, or double 
precision as applicable.  Save the number type flag in register E at the
 location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1E31</div><div>INC HL</div><div>Bump the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1E32</div><div>DEC A</div><div>Decrement the count of the number of variables to be changed in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1E33-1E34</div><div><a href="#1E30" class="memory-link">JR NZ,1E30H</a></div><div>Loop until all of the variables in the <span class="code">DEFxxx</span> range have been changed.</div></div>
									<div class="assembly-row-combined model1"><div>1E35</div><div>POP HL</div><div>Restore the code string pointer into register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1E36</div><div>LD A,(HL)</div><div>Load A with the character at the location of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1E37-1E38</div><div>CP 2CH</div><div>Check to see if the character at the location of the current BASIC program pointer in register A is a <span class="code">,</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1E39</div><div>RET NZ</div><div>Return if the character at the location of the current BASIC program pointer in register A isn't a <span class="code">,</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1E3A</div><div>RST 10H</div><div>Since
 we now need bump the value of the current BASIC program pointer until 
it points to the next character, call the EXAMINE NEXT SYMBOL routine at
 RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The 
RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1E3B-1E3C</div><div><a href="#1E0B" class="memory-link">JR 1E0BH</a></div><div>Loop until done with all the variables.</div></div>
								</div>
							</div>

							<br><h2 id="1E3D">1E3D-1E44 - EXAMINE VARIABLE - See if the value
 pointed to at the memory location (HL) is an ASCII letter.  C Flag is 
set for yes, NC Flag for no.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1E3D</div><div>LD A,(HL)</div><div>Load register A with the character at the location of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1E3E-1E3F</div><div>CP 41H</div><div>Check to see if the character at the location of the current BASIC program pointer in register A is less than an <span class="code">A</span>.  Results:<ul><li>If A=<span class="code">A</span> it sets the ZERO FLAG</li><li>If A&lt;<span class="code">A</span> then the CARRY FLAG will be set</li><li>If A&gt;=<span class="code">A</span> then the NO CARRY FLAG will be set</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1E40</div><div>RET C</div><div>Return if the character at the location of the current BASIC program pointer in register A is less than an <span class="code">A</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1E41-1E42</div><div>CP 5BH</div><div>Check to see if the character at the location of the current BASIC program pointer in register A is greater than a <span class="code">Z</span>.  Results:<ul><li>If A=<span class="code">Z</span> it sets the ZERO FLAG</li><li>If A&lt;<span class="code">Z</span> then the CARRY FLAG will be set</li><li>If A&gt;=<span class="code">Z</span> then the NO CARRY FLAG will be set</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1E43</div><div>CCF</div><div>Complement
 the value of the CARRY FLAG. On exit this routine will have the CARRY 
FLAG set if the character at the location of the current BASIC program 
pointer in register A isn't alphabetic and will have the CARRY FLAG 
cleared if the character at the location of the current BASIC program 
pointer in register A is alphabetic.</div></div>
									<div class="assembly-row-combined model1"><div>1E44</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="1E45">1E45-1E4E - EXAMINE VARIABLE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is called when evaluating a subscript for a variable reference.  It will evaluate if the value is positive or negative.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1E45</div><div>RST 10H</div><div>Get
 the next symbol from the input.  Bump the value of the current BASIC 
program pointer until it points to the next character, call the EXAMINE 
NEXT SYMBOL routine at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1E46-1E48</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2B02" class="memory-link">CALL 2B02H</a></div><div>GOSUB
 to 2B02H to evaluate the expression at the current location of the 
BASIC program pointer in register pair HL and return with the integer 
result in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1E49</div><div>RET P</div><div>Return if the integer result in register pair DE is positive.  If it is negative, flow down to the <span class="code">?FC ERROR</span>.</div></div>
								</div>
							</div>

							<br><h2 id="1E4A">1E4A - FC ERROR entry point.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1E4A-1E4B</div><div>LD E,08H</div><div>Load register E with an <span class="code">?FC ERROR</span> code.</div></div>
									<div class="assembly-row-combined model1"><div>1E4C-1E4E</div><div><a href="#19A2" class="memory-link">JP 19A2H</a></div><div>Display a <span class="code">?FC ERROR</span> message.  If this is from a pass through, the error wll show if the integer result in register pair DE is negative.</div></div>
								</div>
							</div>

							<br><h2 id="1E4F">1E4F-1E79 - ASCII TO BINARY<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1E4F</div><div>LD A,(HL)</div><div>Load register A with the character at the location of the current BASIC program (which is pointed to by register pair HL).</div></div>
									<div class="assembly-row-combined model1"><div>1E50-1E51</div><div>CP 2EH</div><div>Check to see if the character at the location of the current BASIC program pointer in register A is a <span class="code">.</span>.  Results:<ul><li>If A=<span class="code">.</span> it sets the ZERO FLAG</li><li>If A&lt;<span class="code">.</span> then the CARRY FLAG will be set</li><li>If A&gt;=<span class="code">.</span> then the NO CARRY FLAG will be set</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1E52</div><div>EX DE,HL</div><div>Load register pair DE with the value of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1E53-1E55</div><div>LD HL,(40ECH)</div><div>Load register pair HL with the current BASIC line number.<br><b>NOTE:</b> 40ECH-40EDH holds EDIT line number.</div></div>
									<div class="assembly-row-combined model1"><div>1E56</div><div>EX DE,HL</div><div>Exchange
 the value of the current BASIC program pointer in register pair DE with
 the current BASIC line number in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1E57-1E59</div><div><a href="#1D78" class="memory-link">JP Z,1D78H</a></div><div>Jump
 to the RST 10H (EXAMINE NEXT SYMBOL) routine if the character at the 
location of the current BASIC program pointer in register A is a <span class="code">.</span>.</div></div>
								</div>
							</div>

							<br><h2 id="1E5A">1E5A - "DECBIN" - Converts numeric ASCII string
 pointed to by the HL register pair, to HEX and places the result in the
 DE register pair. After execution HL points to the delimiter and the A 
register contains the delimiter value. The Z flag is set if the 
delimiter equals 00 or 3A. Z is reset if any other delimiter is used. If
 there is no string at the location pointed to by HL the routine will 
return a MO ERROR (missing operand). If the result in the DE register 
pair exceeds FFFFH an OV ERROR (overflow) results.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1E5AH</div><div>DEC HL</div><div>Backspace HL (the current BASIC program pointer) to the current character.</div></div>
									<div class="assembly-row-combined model1"><div>1E5B-1E5D</div><div>LD DE,0000H</div><div>Load register pair DE with zero.</div></div>
									<div class="assembly-row-combined model1"><div>1E5E</div><div>RST 10H</div><div>Re-process that previous character through a RST 10H call.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1E5F</div><div>RET NC</div><div>Return if the character at the location of the current BASIC program pointer in register A isn't numeric.</div></div>
									<div class="assembly-row-combined model1"><div>1E60</div><div>PUSH HL</div><div>Save the value of the current BASIC program pointer in register pair HL to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1E61</div><div>PUSH AF</div><div>Save the value in register pair AF (which is the digit plus flags resulting from the RST 10H call) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1E62-1E64</div><div>LD HL,1998H</div><div>Load register pair HL with 6552.<br><br>Why
 6552?  Well, since the Z-80 has no multiply function, checking for any 
possible arbitrary number would require 4 branches for each step in the 
'add to itself until it hits * 10' plus another 4 when adding the last 
digit.  The TRS-80 ROM didn't have that kind of room, nor the time to do
 all that, so they needed a cheat and that cheat was to let it go as 
high 65529.  After all, 6552 + 1 more digit can NEVER exceed 65535, but 
6553 + 1 digit sure can!<br><br>So with this trick, the ROM just needs 
to first check the number against 6552, which, when multiplied by 10, 
and adding one more digit, will never exceed 65529 (because 9 is the 
highest one number can go).<br><br>By using this trick, only 1 
comparison is needed (is it greater or less than 6552) ... at the cost 
of 4 usable line numbers/memory size setting in the 6553x range.<br><br>Wait,
 you say.  65535-65529 is 6 numbers, so why do you say 4.  Well, another
 shortcut the ROM uses is that it assumes anything at line number 65535 
is being entered in direct mode (i.e., no line number; just a command), 
so 65535 couldn't be a line number.  Similarly, in 1A09, 65534 is 
reserved to trigger the BASIC interpreter to jump to the initial powerup
 routine in the ROM (i.e., a reboot) so you couldn't use that line 
number either.</div></div>
									<div class="assembly-row-combined model1"><div>1E65</div><div>RST 18H</div><div>Now
 we need to check to see if the integer value in DE is greater than 
6552, so we call the COMPARE DE:HL routine, which numerically compares 
DE and HL. Will not work for signed integers (except positive ones). 
Uses the A-register only. The result of the comparison is returned in 
the status register as:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>1E66-1E68</div><div><a href="#1997" class="memory-link">JP C,1997H</a></div><div>Go to the Level II BASIC error routine and display a SN ERROR message if the value in register pair DE is greater than 6552.</div></div>
									<div class="assembly-row-combined model1"><div>1E69</div><div>LD H,D</div><div>Load register H with the MSB of the integer total in register D.<br><br>This is so we can multiply HL (which should hold the number 6552) by 10.</div></div>
									<div class="assembly-row-combined model1"><div>1E6A</div><div>LD L,E</div><div>Load register L with the LSB of the integer total in register E.<br><br>This is so we can multiply HL (which should hold the number 6552) by 10.</div></div>
									<div class="assembly-row-combined model1"><div>1E6B</div><div>ADD HL,DE</div><div>Multiply the integer value in register pair HL by two.</div></div>
									<div class="assembly-row-combined model1"><div>1E6C</div><div>ADD HL,HL</div><div>Add
 HL to itself, which is the same as multiplying the integer value in 
register pair HL by two. The integer result in register pair HL is now 
equal to the integer value in register pair DE times four.</div></div>
									<div class="assembly-row-combined model1"><div>1E6D</div><div>ADD HL,DE</div><div>Add
 the integer value in register pair DE to the integer value in register 
pair HL. The integer result in register pair HL is now equal to the 
integer value in register pair DE times five.</div></div>
									<div class="assembly-row-combined model1"><div>1E6E</div><div>ADD HL,HL</div><div>Add
 HL to itself, which is the same as multiplying the integer value in 
register pair HL by two. The integer result in register pair HL is now 
equal to the integer value in register pair DE times ten.  Now HL is 
65520.</div></div>
									<div class="assembly-row-combined model1"><div>1E6F</div><div>POP AF</div><div>Put the last ASCII digit (from the stack) into AF.</div></div>
									<div class="assembly-row-combined model1"><div>1E70-1E71</div><div>SUB 30H</div><div>Convert the ASCII digit in register A to binary.</div></div>
									<div class="assembly-row-combined model1"><div>1E72</div><div>LD E,A</div><div>Load register E with the binary value of the character in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1E73-1E74</div><div>LD D,00H</div><div>Load register D with zero so that DE will be 0000 through 0009 (the binary equivalent of the digit).</div></div>
									<div class="assembly-row-combined model1"><div>1E75</div><div>ADD HL,DE</div><div>Add the binary value of the character in register pair DE to the integer value in register pair HL<br><br>As noted above, adding in any digit can only result in HL going to 65529.</div></div>
									<div class="assembly-row-combined model1"><div>1E76</div><div>EX DE,HL</div><div>Swap DE and HL.  This will have the effect of setting DE to be 10(base 10) * DE + A.</div></div>
									<div class="assembly-row-combined model1"><div>1E77</div><div>POP HL</div><div>Restore the pointer to the next digit (from the stack) into HL.</div></div>
									<div class="assembly-row-combined model1"><div>1E78-1E79</div><div><a href="#1E5E" class="memory-link">JR 1E5EH</a></div><div>Loop until the ASCII to binary conversion has been completed.</div></div>
								</div>
							</div>

							<br><h2 id="1E7A">1E7A-1EA0 - LEVEL II BASIC <span class="code">CLEAR</span> ROUTINE.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>  If Z FLAG is set, no number of bytes was provided (i.e., <span class="code">CLEAR</span> instead of <span class="code">CLEAR 20</span>).</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1E7A-1E7C</div><div><a href="#1B61" class="memory-link">JP Z,1B61H</a></div><div>Jump
 to 1B61H (which will set all 26 variables to single precision) if there
 isn't a number of bytes specified to clear for string space.</div></div>
									<div class="assembly-row-combined model1"><div>1E7D-1D7F</div><div><a href="#1E46" class="memory-link">CALL 1E46H</a></div><div>GOSUB
 to 1E46H to evaluate the number of bytes to be reserved for string 
space and return with the integer result in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1E80</div><div>DEC HL</div><div>Decrement the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1E81</div><div>RST 10H</div><div>Evaluate
 the next instruction through a RST 10H call.  This will bump the value 
of the current BASIC program pointer until it points to the next 
character, call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1E82</div><div>RET NZ</div><div>Return
 out of the routine if the character at the location of the current 
BASIC program pointer isn't an end of the BASIC statement character.</div></div>
									<div class="assembly-row-combined model1"><div>1E83</div><div>PUSH HL</div><div>Save the value of the current BASIC program pointer in register pair HL to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1E84-1E86</div><div>LD HL,(40B1H)</div><div>Load the top of memory pointer into register pair HL.<br><b>NOTE:</b> 40B1H-40B2H holds MEMORY SIZE? pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1E87</div><div>LD A,L</div><div>Load register A with the LSB of the top of memory pointer in register L.</div></div>
									<div class="assembly-row-combined model1"><div>1E88</div><div>SUB E</div><div>Subtract the LSB of the number of bytes for string space in register E from the LSB of the top of memory pointer in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1E89</div><div>LD E,A</div><div>Load register E with the LSB of the start of string space in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1E8A</div><div>LD A,H</div><div>Load register A with the MSB of the top of memory pointer in register H.</div></div>
									<div class="assembly-row-combined model1"><div>1E8B</div><div>SBC A,D</div><div>Subtract the MSB of the number of bytes for string space in register D from the MSB of the top of memory pointer in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1E8C</div><div>LD D,A</div><div>Load register D with the MSB of the start of string space pointer in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1E8D-1E8F</div><div><a href="#197A" class="memory-link">JP C,197AH</a></div><div>If
 the CARRY FLAG was triggered there isn't enough memory for the amount 
of string space specified, so go show a ?OM ERROR message.</div></div>
									<div class="assembly-row-combined model1"><div>1E90-1E92</div><div>LD HL,(40F9H)</div><div>Load register pair HL with the end of the BASIC program pointer.<br><ul><li>Note: 40F9H-40FAH holds the starting address of the simple variable storage area.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1E93-1E95</div><div>LD BC,0028H</div><div>Load register pair BC with the least amount of space needed for BASIC program variables.</div></div>
									<div class="assembly-row-combined model1"><div>1E96</div><div>ADD HL,BC</div><div>Add the value in register pair BC to the end of BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1E97</div><div>RST 18H</div><div>Now
 we need to check to the adjusted end of the BASIC program pointer (in 
HL) with the start of the string space pointer (in DE), so we call the 
COMPARE DE:HL routine, which numerically compares DE and HL. Will not 
work for signed integers (except positive ones). Uses the A-register 
only. The result of the comparison is returned in the status register 
as:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>1E98-1E9A</div><div><a href="#197A" class="memory-link">JP NC,197AH</a></div><div>Display an <span class="code">?OM ERROR</span>
 message if the start of string space pointer in register pair DE is 
less than the adjusted end of the BASIC program pointer in register pair
 HL.</div></div>
									<div class="assembly-row-combined model1"><div>1E9B</div><div>EX DE,HL</div><div>Put the new start of the string area address into HL.</div></div>
									<div class="assembly-row-combined model1"><div>1E9C-1E9E</div><div>LD (40A0H),HL</div><div>Load the start of string space pointer with HL.<br><b>Note:</b> 40A0H-40A1H holds the start of string space pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1E9F</div><div>POP HL</div><div>Restore the code string pointer back into HL.</div></div>
									<div class="assembly-row-combined model1"><div>1EA0-1EA2</div><div><a href="#1B61" class="memory-link">JP 1B61H</a></div><div>Jump to 1B61H.</div></div>
								</div>
							</div>

							<br><h2 id="1EA3">1EA3-1EB0 - LEVEL II BASIC <span class="code">RUN</span> ROUTINE.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>  If Z FLAG is set, no line number was provided (i.e., <span class="code">RUN</span> instead of <span class="code">RUN nnnn</span>).</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1EA3-1EA5</div><div><a href="#1B5D" class="memory-link">JP Z,1B5DH</a></div><div>JUMP to 1B5DH if there isn't a line number specified after the <span class="code">RUN</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1EA6-1EA8</div><div>CALL 41C7H</div><div>GOSUB to 41C7H which is where the <span class="code">RUN nnnn</span> code would be under DOS.</div></div>
									<p class="debug-note">If we are here, then the command was <span class="code">RUN nnnn</span> and we are in Cassette BASIC.</p>
									<div class="assembly-row-combined model1"><div>1EA9-1EAB</div><div><a href="#1B61" class="memory-link">CALL 1B61H</a></div><div>GOSUB to 1B61H to initialize the BASIC variables and pointers.</div></div>
									<div class="assembly-row-combined model1"><div>1EAC-1EAE</div><div>LD BC,1D1EH</div><div>Load register pair BC with the continuation addres in the execution driver.</div></div>
									<div class="assembly-row-combined model1"><div>1EAF-1EB0</div><div><a href="#1EC1" class="memory-link">JR 1EC1H</a></div><div>Jump to 1EC1H to use the <span class="code">GOTO</span> code to begin execution at the nnnn line.</div></div>
								</div>
							</div>

							<br><h2 id="1EB1">1EB1-1EC1 - LEVEL II BASIC <span class="code">GOSUB</span> ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p><br>Can be used to execute the equivalent of a <span class="code">GOSUB</span>
 statement from an assembly program. It allows a BASIC subroutine to be 
called from an assembly subroutine. After the BASIC subroutine executes,
 control returns to the next statement in the assembly program. All 
registers are used. On entry, the HL must contain an ASCII string with 
the starting line number of the subroutine.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1EB1-1EB2</div><div>LD C,03H</div><div>Load register B with the number of bytes needed for the <span class="code">GOSUB</span> push.</div></div>
									<div class="assembly-row-combined model1"><div>1EB3-1EB5</div><div><a href="#1963" class="memory-link">CALL 1963H</a></div><div>Go make sure that there's enough memory for the <span class="code">GOSUB</span> push.</div></div>
									<div class="assembly-row-combined model1"><div>1EB6</div><div>POP BC</div><div>Get the return address from the stack and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>1EB7</div><div>PUSH HL</div><div>Save the value of the current BASIC program pointer in register pair HL to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1EB8</div><div>PUSH HL</div><div>Create a hole to be filled in later by once again saving the value of the current BASIC program pointer to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1EB9-1EBB</div><div>LD HL,(40A2H)</div><div>Load register pair HL with the value of the current BASIC line number in binary.<br><b>NOTE:</b> 40A2H-40A3H holds the current BASIC line number.</div></div>
									<div class="assembly-row-combined model1"><div>1EBC</div><div>EX (SP),HL</div><div>Put the binary value for the current line number into the hole in the stack AND restore the code string pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1EBD-1EBE</div><div>LD A,91H</div><div>Load register A with a <span class="code">GOSUB</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1EBF</div><div>PUSH AF</div><div>Save the <span class="code">GOSUB</span> marker (in register pair AF) to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1EC0</div><div>INC SP</div><div>Bump the value of the stack pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1EC1</div><div>PUSH BC</div><div>Save the return address in register pair BC (which is to the <span class="code">GOTO</span> code) to the stack.</div></div>
								</div>
							</div>

							<br><h2 id="1EC2">1EC2-1EDD - LEVEL II BASIC <span class="code">GOTO</span> ROUTINE.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>  Register pair DE should hold the nnnn for the <span class="code">GOTO nnnn</span> command.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1EC2-1EC4</div><div><a href="#1E5A" class="memory-link">CALL 1E5AH</a></div><div>We need to put the line number to branch to into DE so we GOSUB to the ASCII TO INTEGER routine at 1E5A.<br><b>NOTE:</b>
 The routine at 1E5A converts the ASCII string pointed to by HL to an 
integer deposited into DE.  If the routine finds a non-numerica 
character, the conversion is stopped.</div></div>
									<div class="assembly-row-combined model1"><div>1EC5-1EC7</div><div><a href="#1F07" class="memory-link">CALL 1F07H</a></div><div>GOSUB
 to 1F07H to bump the current BASIC program pointer in register pair HL 
until it points to the end of the current BASIC line.</div></div>
									<div class="assembly-row-combined model1"><div>1EC8</div><div>PUSH HL</div><div>Save the value of the current BASIC program pointer in register pair HL to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1EC9-1ECB</div><div>LD HL,(40A2H)</div><div>Load register pair HL with the binary equivalent of the last line number.<br><b>NOTE:</b> 40A2H-40A3H holds the current BASIC line number.</div></div>
									<div class="assembly-row-combined model1"><div>1ECC</div><div>RST 18H</div><div>Now
 we need to compare the value of the current BASIC line number (in HL) 
with the value of the line number to branch to (in DE), so we call the 
COMPARE DE:HL routine, which numerically compares DE and HL. Will not 
work for signed integers (except positive ones). Uses the A-register 
only. The result of the comparison is returned in the status register 
as:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>1ECD</div><div>POP HL</div><div>Get the value of the current BASIC program pointer from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1ECE</div><div>INC HL</div><div>Bump
 the value of the current BASIC program pointer in register pair HL so 
as to restore the code string address.  DE holds the line number 
specified.</div></div>
									<div class="assembly-row-combined model1"><div>1ECF-1ED1</div><div><a href="#1B2F" class="memory-link">CALL C,1B2FH</a></div><div>If
 the line number to branch to (in register pair DE) is greater than the 
current BASIC line number then GOSUB to 1B2FH to find where the line 
number is located at a LATER location.</div></div>
									<div class="assembly-row-combined model1"><div>1ED2-1ED4</div><div><a href="#1B2C" class="memory-link">CALL NC,1B2CH</a></div><div>If
 the line number to branch to (in register pair DE) is less than the 
current BASIC line number, then go find where the line number is located
 by calling the SEARCH FOR LINE NUMBER routine at 1B2CH which looks for 
the line number specified in DE.  Returns C/Z with the line found in BC,
 NC/Z with line number is too large and HL/BC having the next available 
location, or NC/NZ with line number not found, and BC has the first 
available one after that.</div></div>
									<div class="assembly-row-combined model1"><div>1ED5</div><div>LD H,B</div><div>Load
 register H with the MSB of the new BASIC program pointer in register B.
  BC is still holding the address of the requested line number.</div></div>
									<div class="assembly-row-combined model1"><div>1ED6</div><div>LD L,C</div><div>Load register L with the LSB of the new BASIC program pointer in register C.</div></div>
									<div class="assembly-row-combined model1"><div>1ED7</div><div>DEC HL</div><div>Decrement the value of the current BASIC program pointer in register pair HL to get to the start of the line.</div></div>
									<div class="assembly-row-combined model1"><div>1ED8</div><div>RET C</div><div>If a line number was found, RETURN from this routine to the execution driver (to start execution at the new line number).</div></div>
									<p class="debug-note">Inside the <span class="code">GOTO</span> ROUTINE - If we are here, the line number nnnn was not found, so error out.</p>
									<div class="assembly-row-combined model1"><div>1ED9-1EDA</div><div>LD E,0EH</div><div>Load register E with an <span class="code">?UL ERROR</span> code.</div></div>
									<div class="assembly-row-combined model1"><div>1EDB-1EDD</div><div><a href="#19A2" class="memory-link">JP 19A2H</a></div><div>Since the line number wasn't found, display a <span class="code">?UL ERROR</span> message.</div></div>
								</div>
							</div>

							<br><h2 id="1EDE">1EDE-1E04 - LEVEL II BASIC <span class="code">RETURN</span> ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Returns control to the BASIC statement following the last <a href="#1EDF" class="memory-link">GOSUB</a>
 call. An assembly program called by a BASIC subroutine may wish to 
return directly to the orginal caller without returning through the 
subroutine entry point. This exit can be used for that return. The 
return address to the stack for the call to the assembly program must be
 cleared before returning via 1EDFH.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1EDE</div><div>RET NZ</div><div>Display a <span class="code">?SN ERROR</span> message if there is anything following the <span class="code">RETURN</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1EDF-1EE0</div><div>LD D,FFH</div><div>Load register D with FFH (a dummy address for the search routine).</div></div>
									<div class="assembly-row-combined model1"><div>1EE1-1EE3</div><div><a href="#1936" class="memory-link">CALL 1936H</a></div><div>GOSUB
 to 1936H to backspace the stack pointer by four and return with the 
value at the location of the stack pointer in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1EE4</div><div>LD SP,HL</div><div>Load the stack pointer with the new value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1EE5-1EE7HS</div><div>LD (40E8H),HL</div><div>Save the stack pointer position in register pair HL.<br><b>NOTE:</b> 40E8H-40E9H holds Stack pointer pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1EE8-1EE9</div><div>CP 91H</div><div>Check to see if the value in register A is a <span class="code">GOSUB</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1EEA-1EEB</div><div>LD E,04H</div><div>Load register E with a <span class="code">?RG ERROR</span> code.</div></div>
								</div>
							</div>

							<br><h2 id="1EEC">1EEC - <span class="code">?RG ERROR</span> entry point.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1EEC-1EEE</div><div><a href="#19A2" class="memory-link">JP NZ,19A2H</a></div><div>Display a <span class="code">?RG ERROR</span> message if there isn't a <span class="code">GOSUB</span> push to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1EEF</div><div>POP HL</div><div>Get the binary value of the <span class="code">GOSUB</span> line number from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1EF0-1EF2</div><div>LD (40A2H),HL</div><div>Save the <span class="code">GOSUB</span> line number in register pair HL as the current BASIC line number.<br><b>NOTE:</b> 40A2H-40A3H holds the current BASIC line number.</div></div>
									<div class="assembly-row-combined model1"><div>1EF3</div><div>INC HL</div><div>Bump the value of the current BASIC line number in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1EF4</div><div>LD A,H<br>OR L</div><div>The
 way to test HL for 0 is to LOAD A,H and OR L, so A will be 0 only if 
BOTH H and L were 0.  If HL=0 then HL was FFFFH and we have an overflow 
or a command mode.</div></div>
									<div class="assembly-row-combined model1"><div>1EF6-1EF7</div><div><a href="#1EFF" class="memory-link">JR NZ,1EFFH</a></div><div>Jump if Level II BASIC is in the command mode.</div></div>
									<div class="assembly-row-combined model1"><div>1EF8H-lEFA</div><div>LD A,(40DDH)</div><div>If we are here, we may have a one liner!  Load register A with the command mode flag.<br><b>NOTE:</b> 40DDH holds INPUT flag.</div></div>
									<div class="assembly-row-combined model1"><div>lEFB</div><div>OR A</div><div>Check for the command mode.</div></div>
									<div class="assembly-row-combined model1"><div>1EFC-1EFE</div><div><a href="#1A18" class="memory-link">JP NZ,1A18H</a></div><div>Jump to 1A18H if Level II BASIC is in the command mode.</div></div>
									<div class="assembly-row-combined model1"><div>1EFF-1F01</div><div>LD HL,1D1EH</div><div>Load register pair HL with the return address.</div></div>
									<div class="assembly-row-combined model1"><div>1F02</div><div>EX (SP),HL</div><div>Exchange the value of the current BASIC program pointer to the stack with the return address in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F03H</div><div>3E E1</div><div>Z-80 Trick!  See the general explanation at 10F8H.</div></div>
									<div class="assembly-row-combined model1" id="1F04"><div>1F04</div><div><a href="#10F8" class="memory-link">POP HL</a></div><div>Prepare to scan to the end of the GOSUB by restoring HL from the STACK.</div></div>
								</div>
							</div>

							<br><h2 id="1F05">1F05-1F20 - SCAN ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is also the DATA entry point.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1F05H</div><div>01</div><div>Z-80 Trick!  See the general explanation at 10F8H.</div></div>
									<div class="assembly-row-combined model1"><div>1F06H</div><div>3A</div><div>Z-80 Trick!  See the general explanation at 10F8H.</div></div>
									<div class="assembly-row-combined model1"><div>1F07-1F08</div><div>LD C,00H</div><div>Load register C with zero.</div></div>
									<div class="assembly-row-combined model1"><div>1F09-1F0A</div><div>LD B,00H</div><div>Load register B with zero.</div></div>
									<div class="assembly-row-combined model1" id="1F0B"><div>1F0B</div><div>LD A,C</div><div>Load register A with the stop scan character in register C.</div></div>
									<div class="assembly-row-combined model1"><div>1F0C</div><div>LD C,B</div><div>Load register C with the stop scan character in register B.</div></div>
									<div class="assembly-row-combined model1"><div>1F0D</div><div>LD B,A</div><div>Load register B with the stop scan character in register A.</div></div>
									<div class="assembly-row-combined model1" id="1F0E"><div>1F0E</div><div>LD A,(HL)</div><div>Load register A with the character at the location of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F0F</div><div>OR A</div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in register A is an end of the BASIC line character.</div></div>
									<div class="assembly-row-combined model1"><div>1F10</div><div>RET Z</div><div>Return
 if the character at the location of the current BASIC program pointer 
in register A is an end of the BASIC line character.</div></div>
									<div class="assembly-row-combined model1"><div>1F11</div><div>CP B</div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in register A is the same as the stop scan character in register
 B.</div></div>
									<div class="assembly-row-combined model1"><div>1F12</div><div>RET Z</div><div>Return
 if the character at the location of the current BASIC program pointer 
in register A is the same as the stop scan character in register B.</div></div>
									<div class="assembly-row-combined model1"><div>1F13</div><div>INC HL</div><div>Bump the value of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F14-1F15</div><div>CP 22H</div><div>Check to see if the character at the location of the current BASIC program pointer in register A is a <span class="code">"</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1F16-1F17</div><div><a href="#1F0B" class="memory-link">JR Z,1F0BH</a></div><div>Loop if the character at the location of the current BASIC program pointer in register A is a quote.</div></div>
									<div class="assembly-row-combined model1"><div>1F18-1F19</div><div>SUB 8FH</div><div>Check to see if the character at the location of the current BASIC program pointer in register A is a <span class="code">IF</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1F1A-1F1B</div><div><a href="#1F0E" class="memory-link">JR NZ,1F0EH</a></div><div>Loop back to 1F0EH if the character at the location of the current BASIC program pointer in register A isn't an <span class="code">IF</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1F1C</div><div>CP B</div><div>Check
 to see if the character at the location of the current BASIC program 
pointer in register A is the same as the character in register B.</div></div>
									<div class="assembly-row-combined model1"><div>1F1D</div><div>ADC A,D</div><div>Add the value in register D to the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1F1E</div><div>LD D,A</div><div>Load register D with the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1F1F-1F20</div><div><a href="#1F0E" class="memory-link">JR 1F0EH</a></div><div>Loop back to 1F0EH until scan is completed.</div></div>
								</div>
							</div>

							<br><h2 id="1F21">1F21-1F6B - LEVEL II BASIC <span class="code">LET</span> ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1F21-1F23</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#260D" class="memory-link">CALL 260DH</a></div><div>Call
 the FIND ADDRESS OF VARIABLE routine at 260DH which searches the 
Variable List Table for a variable name which matches the name in the 
string pointed to in HL, and return the address of that variable in DE 
(and if there is no variable, it creates it, zeroes it, and returns THAT
 location).</div></div>
									<div class="assembly-row-combined model1"><div>1F24-1F25</div><div>RST 08H ‚áí  D5H</div><div>Test if the variable name is followed by a <span class="code">=</span>.
  Since the character at the location of the current BASIC program 
pointer in register pair HL must be an EQUAL sign (D5) so call the 
COMPARE SYMBOL routine which comparess the symbol in the input string 
pointed to by HL register to the value in the location following the RST
 08 call.  If there is a match, control is returned to address of the 
RST 08 instruction 2 with the next symbol in the Aregister and HL 
incremented by one. If the two characters do not match, a syntax error 
message is given and control returns to the Input Phase).</div></div>
									<div class="assembly-row-combined model1"><div>1F26</div><div>EX DE,HL</div><div>Exchange
 the address of the variable in register pair DE with the value of the 
current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F27-1F29</div><div>LD (40DFH),HL</div><div>Save the addres of the variable in register pair HL.<br><b>NOTE:</b> 40DFH-40E0H holds Used by DOS.</div></div>
									<div class="assembly-row-combined model1"><div>1F2A</div><div>EX DE,HL</div><div>Exchange
 the value of the current BASIC program pointer in register pair DE with
 the address of the variable in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F2B</div><div>PUSH DE</div><div>Save the address of the variable in register pair DE to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1F2C</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>1F2D</div><div>PUSH AF</div><div>Save
 the value in register pair AF to the stack.  A will be -1 for an 
integer, 0 for a string, 1 for single precision, and 5 for double 
precision.</div></div>
									<div class="assembly-row-combined model1"><div>1F2E-1F30</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2337" class="memory-link">CALL 2337H</a></div><div>Go
 evaluate the expression at the location of the current BASIC program 
pointer in register pair HL and return with the result in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>1F31</div><div>POP AF</div><div>Get the value from the stack and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>1F32</div><div>EX (SP),HL</div><div>Exchange the address of the variable to the stack with the value of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F33-1F34</div><div>ADD A,03H</div><div>Adjust
 the value in register A so that it will hold the correct number type 
flag (i.e., A will be 2 for integer, 3 for string, 4 for single 
precision, and 8 for double precision).</div></div>
									<div class="assembly-row-combined model1"><div>1F35-1F37</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2819" class="memory-link">CALL 2819H</a></div><div>Go to 2819H to convert the result in REG 1 to the same number type for the variable .</div></div>
									<div class="assembly-row-combined model1"><div>1F38-1F3A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#0A03" class="memory-link">CALL 0A03H</a></div><div>Go save the result of the expression.</div></div>
									<div class="assembly-row-combined model1"><div>1F3B</div><div>PUSH HL</div><div>Save the address of the variable in register pair DE to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1F3C-1F3D</div><div><a href="#1F66" class="memory-link">JR NZ,1F66H</a></div><div>Jump if the result of the expression wasn't a string.</div></div>
									<div class="assembly-row-combined model1"><div>1F3E-1F40</div><div>LD HL,(4121H)</div><div>Load register pair HL with the starting address of the string's VARPTR in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>1F41</div><div>PUSH HL</div><div>Save the VARPTR for the string result in register pair HL to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1F42</div><div>INC HL</div><div>Bump the value of the VARPTR for the string result in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F43</div><div>LD E,(HL)</div><div>Load register E with the LSB of the address for the string at the location of the VARPTR for the string in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F44</div><div>INC HL</div><div>Bump the value of the VARPTR for the string result in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F45</div><div>LD D,(HL)</div><div>Load register D with the MSB of the address for the string at the location of the VARPTR for the string in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F46-1F48</div><div>LD HL,(40A4H)</div><div>Load register pair HL with the start of the BASIC program.<br><ul><li>Note: 40A4H-40A5H holds the starting address of BASIC program text also known as the PROGRAM STATEMENT TABLE (PST).</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1F49</div><div>RST 18H</div><div>Now
 we need to compare the start of the BASIC program area (in HL) with the
 address of the string result in DE, so we call the COMPARE DE:HL 
routine, which numerically compares DE and HL. Will not work for signed 
integers (except positive ones). Uses the A-register only. The result of
 the comparison is returned in the status register as:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>1F4A-1F4B</div><div><a href="#1F5A" class="memory-link">JR NC,1F5AH</a></div><div>Jump
 if the address of the string result in register pair DE is less than 
the start of the BASIC program area in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F4C-1F4E</div><div>LD HL,(40A0H)</div><div>Load register pair HL with the start of the string space pointer.<br><b>Note:</b> 40A0H-40A1H holds the start of string space pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1F4F</div><div>RST 18H</div><div>Now
 we need to compare the start of the string space pointer (in HL) with 
the address of the string result in DE, so we call the COMPARE DE:HL 
routine, which numerically compares DE and HL. Will not work for signed 
integers (except positive ones). Uses the A-register only. The result of
 the comparison is returned in the status register as:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>1F50</div><div>POP DE</div><div>Get the VARPTR for the string result from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1F51-1F52</div><div><a href="#1F62" class="memory-link">JR NC,1F62H</a></div><div>Jump
 if the address of the string result in register pair DE was less than 
the start of the string space pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F53-1F55</div><div>LD HL,(40F9H)</div><div>Load register pair HL with the simple variables pointer.<br><ul><li>Note: 40F9H-40FAH holds the starting address of the simple variable storage area.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1F56</div><div>RST 18H</div><div>Now
 we need to compare the address of the VARPTR for the string result in 
register pair DE with the simple variables pointer in register pair HL, 
so we call the COMPARE DE:HL routine, which numerically compares DE and 
HL. Will not work for signed integers (except positive ones). Uses the 
A-register only. The result of the comparison is returned in the status 
register as:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>1F57-1F58</div><div><a href="#1F62" class="memory-link">JR NC,1F62H</a></div><div>Jump
 if the address of the VARPTR for the string result in register pair DE 
is less than the simple variables pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F59-1F5AH</div><div>3E D1<br>LD A,D1H</div><div>Z-80 Trick</div></div>
									<div class="assembly-row-combined model1"><div>1F5A</div><div>POP DE</div><div>Get the VARPTR for the string result from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1F5B-1F5D</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#29F5" class="memory-link">CALL 29F5H</a></div><div>Go adjust the temporary string work area pointers.</div></div>
									<div class="assembly-row-combined model1"><div>1F5E</div><div>EX DE,HL</div><div>Exchange the VARPTR for the string in register pair DE with the string's address in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F5F-1F61</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2843" class="memory-link">CALL 2843H</a></div><div>Go move the string into string space.</div></div>
									<div class="assembly-row-combined model1"><div>1F62-1F64</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#29F5" class="memory-link">CALL 29F5H</a></div><div>Go adjust the temporary string work area pointers.</div></div>
									<div class="assembly-row-combined model1"><div>1F65</div><div>EX (SP),HL</div><div>Exchange the address of the variable in register pair BL with the address of the variable to the stack.</div></div>
									<div class="assembly-row-combined model1"><div>1F66-1F68</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#09D3" class="memory-link">CALL 09D3H</a></div><div>Go move the result to its proper location in memory.</div></div>
									<div class="assembly-row-combined model1"><div>1F69</div><div>POP DE</div><div>Get the address of the variable from the stack and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1F6A</div><div>POP HL</div><div>Get the value of the current BASIC program pointer from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F6B</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="1F6C">1F6C-1FAE - LEVEL II BASIC ERROR <span class="code">ON</span> ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1F6C-1F6D</div><div>CP 9EH</div><div>Check to see if the character at the location of the current BASIC program pointer in register A is an <span class="code">ERROR</span> token (since this is supposed to be <span class="code">ON ERROR</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1F6E-1F6F</div><div><a href="#1F95" class="memory-link">JR NZ,1F95H</a></div><div>Jump down to 1F95H if the character at the location of the current BASIC program pointer in register A isn't an <span class="code">ERROR</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1F70</div><div>RST 10H</div><div>If we are here, we have <span class="code">ON ERROR</span>
 but we do need to see what's next.  Since we now need bump the value of
 the current BASIC program pointer until it points to the next 
character, call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1F71-1F72</div><div>RST 08H ‚áí  8DH</div><div>The next valid character at the location of the current BASIC program pointer in register pair HL must be a <span class="code">GOTO</span>
 token (=8DH) so call the COMPARE SYMBOL routine which comparess the 
symbol in the input string pointed to by HL register to the value in the
 location following the RST 08 call.  If there is a match, control is 
returned to address of the RST 08 instruction 2 with the next symbol in 
the Aregister and HL incremented by one. If the two characters do not 
match, a syntax error message is given and control returns to the Input 
Phase).</div></div>
									<div class="assembly-row-combined model1"><div>1F73-1F75</div><div><a href="#1E5A" class="memory-link">CALL 1E5AH</a></div><div>Convert the next constant into binary (with the result in DE).  To do this, call the ASCII TO INTEGER routine at 1E5A.<br><b>NOTE:</b>
 The routine at 1E5A converts the ASCII string pointed to by HL to an 
integer deposited into DE.  If the routine finds a non-numerica 
character, the conversion is stopped.</div></div>
									<div class="assembly-row-combined model1"><div>1F76</div><div>LD A,D<br>OR E</div><div>To test DE for zero, LOAD A,D and then OR E.  A will be 0 only if BOTH D and E were 0</div></div>
									<div class="assembly-row-combined model1"><div>1F78-1F79</div><div><a href="#1F83" class="memory-link">JR Z,1F83H</a></div><div>Jump to 1F83H if the line number in register pair DE is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>1F7A-1F7C</div><div><a href="#1B2A" class="memory-link">CALL 1B2AH</a></div><div>Go find the location of the line number in register pair DE and return with the location of the line number in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>1F7DH,1F7E</div><div>LD D,B<br>LD E,C</div><div>Put the line number from BC into DE</div></div>
									<div class="assembly-row-combined model1"><div>1F7F</div><div>POP HL</div><div>Get the value of the current BASIC program pointer from the stack and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F80-1F82</div><div><a href="#1ED9" class="memory-link">JP NC,1ED9H</a></div><div>Display a ?UL ERROR message if the BASIC line doesn't exist.</div></div>
									<div class="assembly-row-combined model1"><div>1F83</div><div>EX DE,HL</div><div>Exchange
 the location of the BASIC line in register pair DE with the value of 
the current BASIC pro gram pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F84-1F86</div><div>LD (40F0H),HL</div><div>Save the location of the BASIC line in register pair HL.<br><b>NOTE:</b> 40F0H-40F1H is used by <span class="code">ON ERROR</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1F87</div><div>EX DE,HL</div><div>Exchange
 the value of the current BASIC program pointer in register pair DE with
 the location of the BASIC line in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F88</div><div>RET C</div><div>RETURN out of this routine to the execution driver if it was not <span class="code">ON ERROR GOTO 0000</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1F89-1F8B</div><div>LD A,(40F2H)</div><div>Load register A with the value of the error flag.<br><b>NOTE:</b> 40F2H holds the error flag.</div></div>
									<div class="assembly-row-combined model1"><div>1F8C</div><div>OR A</div><div>Check to see if the error flag is set.</div></div>
									<div class="assembly-row-combined model1"><div>1F8D</div><div>RET Z</div><div>RETURN out of this routine to the execution driver if the override flag is not set.</div></div>
									<div class="assembly-row-combined model1"><div>1F8E-1F90</div><div>LD A,(409AH)</div><div>Load register A with the error code.<br><b>NOTE:</b> 409AH holds the RESUME flag.</div></div>
									<div class="assembly-row-combined model1"><div>1F91</div><div>LD E,A</div><div>Load register E with the value of the error code in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1F92-1F94</div><div><a href="#19AB" class="memory-link">JP 19ABH</a></div><div>Go to the Level II error routine and display the error message for the error code in register E.</div></div>
									<p class="debug-note" id="1F95">1F95 - Still in the <span class="code">ON</span> routine, but we know it isn't <span class="code">ON ERROR</span>.  We now need to deal with the possibility that it was an <span class="code">ON n GOTO</span> or <span class="code">ON n GOSUB</span>.</p>
									<div class="assembly-row-combined model1"><div>1F95-1F97</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2B1C" class="memory-link">CALL 2B1CH</a></div><div>First we need to get the <span class="code">n</span>
 so go evaluate the expression at the location of the current BASIC 
program pointer and return with the result in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1F98</div><div>LD A,(HL)</div><div>Load
 register A with the next character (which should be a token) at the 
location of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1F99</div><div>LD B,A</div><div>Save that token into register B.</div></div>
									<div class="assembly-row-combined model1"><div>1F9A-1F9B</div><div>CP 91H</div><div>Check to see if the character at the location of the current BASIC program pointer in register A is a <span class="code">GOSUB</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1F9C-1F9D</div><div><a href="#1FA1" class="memory-link">JR Z,1FA1H</a></div><div>Skip the next 2 opcodes if the character at the location of current BASIC program pointer in register A is a <span class="code">GOSUB</span> token .</div></div>
									<div class="assembly-row-combined model1"><div>1F9E-1F9F</div><div>RST 08H ‚áí  8DH</div><div>Now let's test to see if the next character is the token for a <span class="code">GOTO</span>,
 call the COMPARE SYMBOL routine which comparess the symbol in the input
 string pointed to by HL register to the value in the location following
 the RST 08 call.  If there is a match, control is returned to address 
of the RST 08 instruction 2 with the next symbol in the Aregister and HL
 incremented by one. If the two characters do not match, a syntax error 
message is given and control returns to the Input Phase).</div></div>
									<div class="assembly-row-combined model1"><div>1FA0</div><div>DEC HL</div><div>Decrement the value of the current BASIC program pointer in register pair HL to point to the <span class="code">GOTO</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1FA1</div><div>LD C,E</div><div>Load register C with the LSB of the expression after the <span class="code">ON</span> token in register E (i.e., the "n" from <span class="code">ON n GOTO</span>).</div></div>
									<div class="assembly-row-combined model1"><div>1FA2</div><div>DEC C</div><div>Decrement the line number counter in register C.</div></div>
									<div class="assembly-row-combined model1"><div>1FA3</div><div>LD A,B</div><div>Load register A with the token in register B (which is either a <span class="code">GOSUB</span> or <span class="code">GOTO</span> token).</div></div>
									<div class="assembly-row-combined model1"><div>1FA4-1FA6</div><div><a href="#1D60" class="memory-link">JP Z,1D60H</a></div><div>Jump to 1D60H if the line number has been found.</div></div>
									<div class="assembly-row-combined model1"><div>1FA7-1FA9</div><div><a href="#1E5B" class="memory-link">CALL 1E5BH</a></div><div>Evaluate the line number at the location of the current BASIC program pointer and return with the result in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1FAA-1FAB</div><div>CP 2CH</div><div>Check to see if the character at the location of the current BASIC program pointer in register A is a <span class="code">comma</span>.  If not, it is the ent of the statement.</div></div>
									<div class="assembly-row-combined model1"><div>1FAC</div><div>RET NZ</div><div>Return if the character at the location of the current BASIC program pointer in register A isn't a <span class="code">,</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1FAD-1FAE</div><div><a href="#1FA2" class="memory-link">JR 1FA2H</a></div><div>Loop until the line number has been located.</div></div>
								</div>
							</div>

							<br><h2 id="1FAF">1FAF-1FF3 - LEVEL II BASIC <span class="code">RESUME</span> ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1FAF-1FB1</div><div>LD DE,40F2H</div><div>Load register pair DE with the address of the Level II BASIC error flag.<br><b>NOTE:</b> 40F2H holds the error flag.</div></div>
									<div class="assembly-row-combined model1"><div>1FB2</div><div>LD A,(DE)</div><div>Load
 register A with the error flag at the location of the memory pointer in
 register pair DE.  It will be FF if there is an error, and a zero 
otherwise.</div></div>
									<div class="assembly-row-combined model1"><div>1FB3</div><div>OR A</div><div>Check for an error.</div></div>
									<div class="assembly-row-combined model1"><div>1FB4-1FB6</div><div><a href="#19A0" class="memory-link">JP Z,19A0H</a></div><div>If there was no error, then display an <span class="code">?RW ERROR</span> message.</div></div>
									<div class="assembly-row-combined model1"><div>1FB7</div><div>INC A</div><div>Clear the error flag in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1FB8-1FBA</div><div>LD (409AH),A</div><div>Save the new error flag in register A.<br><b>NOTE:</b> 409AH holds the <span class="code">RESUME</span> flag.</div></div>
									<div class="assembly-row-combined model1"><div>1FBB</div><div>LD (DE),A</div><div>Save the new error flag in register A at the location of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1FBC</div><div>LD A,(HL)</div><div>Load register A with the character at the location of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1FBD-1FBE</div><div>CP 87H</div><div>Check to see if the character at the location of the current BASIC program pointer in register A is a <span class="code">NEXT</span> token.</div></div>
									<div class="assembly-row-combined model1"><div>1FBF-1FC0</div><div><a href="#1FCD" class="memory-link">JR Z,1FCDH</a></div><div>Jump down to 1FCDH if the character at the location of the current BASIC program pointer in register A is a <span class="code">NEXT</span> token (as in <span class="code">RESUME NEXT</span>).</div></div>
									<div class="assembly-row-combined model1"><div>1FC1-1FC3</div><div><a href="#1E5A" class="memory-link">CALL 1E5AH</a></div><div>Get the binary equivalent of the line number into DE by calling the ASCII TO INTEGER routine at 1E5A.<br><b>NOTE:</b>
 The routine at 1E5A converts the ASCII string pointed to by HL to an 
integer deposited into DE.  If the routine finds a non-numerica 
character, the conversion is stopped.</div></div>
									<div class="assembly-row-combined model1"><div>1FC4</div><div>RET NZ</div><div>Return to the execution driver if there wasn't a line number at the location of the current BASIC program pointer.</div></div>
									<div class="assembly-row-combined model1"><div>1FC5</div><div>LD A,D<br>OR E</div><div>To test DE against zero, LOAD A, D and OR E, so A will be 0 only if BOTH D and E are zero</div></div>
									<div class="assembly-row-combined model1"><div>1FC7-1FC9</div><div><a href="#1EC5" class="memory-link">JP NZ,1EC5H</a></div><div>Jump to the <span class="code">GOTO</span> code at 1EC5H if the line number in register pair DE isn't equal to zero (i.e., it was <span class="code">RESUME nnnn</span>).</div></div>
									<div class="assembly-row-combined model1"><div>1FCA</div><div>INC A</div><div>Bump the value in register A so that it will indicate <span class="code">RESUME 0</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1FCB-1FCC</div><div><a href="#1FCF" class="memory-link">JR 1FCFH</a></div><div>Jump to the <span class="code">RESUME 0</span> at 1FCFH.</div></div>
									<div class="assembly-row-combined model1"><div>1FCD</div><div>RST 10H</div><div>Since
 we now need bump the value of the current BASIC program pointer until 
it points to the next character, call the EXAMINE NEXT SYMBOL routine at
 RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The 
RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>1FCE</div><div>RET NZ</div><div>Return if this is the end of the BASIC statement.</div></div>
								</div>
							</div>

							<br><h2 id="1FCF">1FCF - This is the <span class="code">RESUME 0</span> routine<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1FCF-1FD1</div><div>LD HL,(40EEH)</div><div>Get the value of the current BASIC program pointer and put it in register pair HL.<br><b>NOTE:</b> 40EEH-40EFH is used by <span class="code">RESUME</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1FD2</div><div>EX DE,HL</div><div>Load register pair DE with the value of the current BASIC program pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>1FD3-1FD5</div><div>LD HL,(40EAH)</div><div>Load register pair HL with the current BASIC line number.<br><b>NOTE:</b> 40EAH-40EBH holds the line number  with error.</div></div>
									<div class="assembly-row-combined model1"><div>1FD6-1FD8</div><div>LD (40A2H),HL</div><div>Save the value of the current BASIC line number in register pair HL.  This is where we will resume execution.<br><b>NOTE:</b> 40A2H-40A3H holds the current BASIC line number.</div></div>
									<div class="assembly-row-combined model1"><div>1FD9</div><div>EX DE,HL</div><div>Load register pair HL with the value of the current BASIC program pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>1FDA</div><div>RET NZ</div><div>Return to the execution driver if this is <span class="code">RESUME 0</span>.</div></div>
									<div class="assembly-row-combined model1"><div>1FDB</div><div>LD A,(HL)</div><div>Get the character at the location of the current BASIC program pointer in register pair HL and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1FDC</div><div>OR A</div><div>Check
 the character at the location of the current BASIC program pointer in 
register A to see if its an end of the BASIC line character.</div></div>
									<div class="assembly-row-combined model1"><div>1FDD-1FDE</div><div><a href="#1FE3" class="memory-link">JR NZ,1FE3H</a></div><div>Jump
 forward to 1FE3H if the character at the location of the current BASIC 
program pointer in register A isn't an end of the BASIC line character.</div></div>
									<div class="assembly-row-combined model1"><div>1FDF</div><div>INC HL</div><div>Bump the value of the current BASIC program pointer in register pair HL to skip over the zero byte terminator.</div></div>
									<div class="assembly-row-combined model1"><div>1FE0</div><div>INC HL</div><div>Bump
 the value of the current BASIC program pointer in register pair HL to 
skip over the LSB of the pointer to the next statement.</div></div>
									<div class="assembly-row-combined model1"><div>1FE1</div><div>INC HL</div><div>Bump
 the value of the current BASIC program pointer in register pair HL to 
skip over the MSB of the pointer to the next statement.</div></div>
									<div class="assembly-row-combined model1"><div>1FE2</div><div>INC HL</div><div>Bump
 the value of the current BASIC program pointer in register pair HL to 
skip over the LSB of the line number in binary for the line following 
the error.</div></div>
									<div class="assembly-row-combined model1"><div>1FE3</div><div>INC HL</div><div>Bump
 the value of the current BASIC program pointer in register pair HL to 
skip over the MSB of the line number in binary for the line following 
the error.</div></div>
									<div class="assembly-row-combined model1"><div>1FE4</div><div>LD A,D</div><div>Load register A with the MSB of the line number with the error in register D.</div></div>
									<div class="assembly-row-combined model1"><div>1FE5</div><div>AND E</div><div>Combine
 the LSB of the line number with the error in register E with the MSB of
 the line number with the error in register A.  This begins the test for
 the end of program marker.</div></div>
									<div class="assembly-row-combined model1"><div>1FE6</div><div>INC A</div><div>Bump
 the combined value of the line number with the error in register A.  
This will finish the test of DE by turning the FFFFH into 0000H.</div></div>
									<div class="assembly-row-combined model1"><div>1FE7-1FE9</div><div><a href="#1F05" class="memory-link">JP NZ,1F05H</a></div><div>Jump to 1F05H if Level II BASIC isn't in the command mode.</div></div>
									<div class="assembly-row-combined model1"><div>1FEA-1FEC</div><div>LD A,(40DDH)</div><div>Load register A with the command mode flag.<br><b>NOTE:</b> 40DDH holds INPUT flag.</div></div>
									<div class="assembly-row-combined model1"><div>1FED</div><div>DEC A</div><div>Check to see if the command mode flag in register A is set.</div></div>
									<div class="assembly-row-combined model1"><div>1FEE-1FF0</div><div><a href="#1DBE" class="memory-link">JP Z,1DBEH</a></div><div>Jump to 1DBEH if Level II BASIC is in the command mode.</div></div>
									<div class="assembly-row-combined model1"><div>1FF1-1FF3</div><div><a href="#1F05" class="memory-link">JP 1F05H</a></div><div>Exit the routine by jumping to 1F05H.</div></div>
								</div>
							</div>

							<br><h2 id="1FF4">1FF4H-2007 - LEVEL II BASIC ERROR ROUTINE - Evaluates n for <span class="code">ERROR n</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>1FF4-1FF6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2B1C" class="memory-link">CALL 2B1CH</a></div><div>Go
 evaluate the expression at the location of the current BASIC program 
pointer in register pair HL and return with the result in A.</div></div>
									<div class="assembly-row-combined model1"><div>1FF7</div><div>RET NZ</div><div>Return if this isn't the end of the BASIC statement.</div></div>
									<div class="assembly-row-combined model1"><div>1FF8</div><div>OR A</div><div>Set up to check to see if the error number in register A is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>1FF9-1FFB</div><div><a href="#1E4A" class="memory-link">JP Z,1E4AH</a></div><div>Display an <span class="code">?FC ERROR</span> message if the error code in register A is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>1FFC</div><div>DEC A</div><div>Subtract one from the error code in register A.</div></div>
									<div class="assembly-row-combined model1"><div>1FFD</div><div>ADD A,A</div><div>Multiply the error code in register A by two (so now A = 2(A-1)).</div></div>
									<div class="assembly-row-combined model1"><div>1FFE</div><div>LD E,A</div><div>Load register E with 2(A-1).</div></div>
									<div class="assembly-row-combined model1"><div>1FFF-2000</div><div>CP 2DH</div><div>Check to see if the error code in register A is less than 2DH.  Results:<ul><li>If A=2DH it sets the ZERO FLAG</li><li>If A&lt;2DH then the CARRY FLAG will be set</li><li>if A&gt;=2DH then the NO CARRY FLAG will be set.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>2001-2002</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2005" class="memory-link">JR C,2005H</a></div><div>Jump forward 1 instruction (i.e., skip the line that sets up for an error of <span class="code">?UE ERROR</span>) if the error code (in register A) is in range (i.e., less than 45).</div></div>
								</div>
							</div>
						</div>
					</div>
				</div>
			</main>
		</div>
	</div>
	<!-- Fancybox JavaScript -->
	<script src="Model%20III%20ROM%20Explained%20-%20Part%202_files/fancybox.umd.js"></script>
	<!-- Initialize Fancybox -->
	<script>
		Fancybox.bind("[data-fancybox]", {
			Toolbar: {
				display: {
					left: ["infobar"],
					middle: [],
					right: ["slideshow", "thumbs", "close"],
				},
			},
			Thumbs: {
				autoStart: false,
			},
		});
	</script>
	<!-- Last Modified Date -->
	<script>
		document.write("<p style='text-align:right; padding: 10px 20px; font-style: italic; font-size: 0.85em; color: #666;'>Last edited: " + document.lastModified + "</p>");
	</script><p style="text-align:right; padding: 10px 20px; font-style: italic; font-size: 0.85em; color: #666;">Last edited: 12/20/2025 22:17:41</p>

<div id="mobile-overlay" class="mobile-menu-overlay"></div></body></html>