<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="TRS-80 Revived Site by Ira Goldklang's is an archive of everything related to the Tandy Radio Shack TRS-80 microcomputer lines. Site contains emulators, programs, manuals, books, patches, games, hints, discussions, and tons more.">
	<meta name="author" content="Ira Goldklang">
	<meta name="robots" content="index, follow">
	<link rel="icon" href="https://www.trs-80.com/icon.ico" type="image/x-icon">
	<link rel="canonical" href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm">
	<meta property="og:title" content="TRS-80 Revived Site - Ira Goldklang's TRS-80 Archive">
	<meta property="og:description" content="Complete archive of TRS-80 emulators, programs, manuals, books, and games for Tandy Radio Shack TRS-80 computers.">
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm">
	<meta name="twitter:card" content="summary">
	<meta name="twitter:title" content="TRS-80 Revived Site">
	<meta name="twitter:description" content="Complete archive of TRS-80 emulators, programs, and resources.">
	<title>Model III ROM Explained - Part 1</title>
	<!-- Load your existing CSS file -->
	<link rel="stylesheet" href="Model%20III%20ROM%20Explained%20-%20Part%201_files/trs80-css.css">
	<link rel="stylesheet" href="Model%20III%20ROM%20Explained%20-%20Part%201_files/trs80-hamburger.css">
	<!-- Fancybox CSS -->
	<link rel="stylesheet" href="Model%20III%20ROM%20Explained%20-%20Part%201_files/fancybox.css">
	<!-- Load the component loader -->
	<script src="Model%20III%20ROM%20Explained%20-%20Part%201_files/trs80-loader.js"></script>
	<script src="Model%20III%20ROM%20Explained%20-%20Part%201_files/trs80-hamburger.js"></script>
</head>
<body class="trs80-loaded"><button id="hamburger-btn" class="hamburger-menu" aria-label="Toggle menu">
            <span></span>
            <span></span>
            <span></span>
        </button>
	<div class="site-container">
		<!-- Header will be loaded here -->
		<div id="header"><style>
    .trs80-header-grid {
        display: grid;
        /* 'auto' lets the images take only needed space, '1fr' gives the rest to the text */
        grid-template-columns: auto 1fr auto;
        grid-template-rows: 1fr;
        grid-column-gap: 20px;
        grid-row-gap: 0;
        background-color: #003399;
        margin-top: 10px;
        padding: 10px;
        /* This ensures all items in the grid (images and text) are aligned to the top */
        align-items: start;
    }

    .trs80-header-left { grid-area: 1 / 1 / 2 / 2; display: flex; align-items: start; }
    .trs80-header-center { grid-area: 1 / 2 / 2 / 3; text-align: center; }
    .trs80-header-right { grid-area: 1 / 3 / 2 / 4; display: flex; align-items: start; justify-content: flex-end; }

    .trs80-title { color: white !important; font-size: 170%; text-align: center; margin: 0 0 10px 0; font-weight: bold; }

    .trs80-description {
        color: white !important;
        font-size: 120%;
        text-align: center;
        margin: 0 auto 15px auto;
        padding: 0 10px;
        line-height: 1.4;
    }

    .trs80-header-grid img { border: 0 !important; margin: 0 2px; }
    .trs80-img-60 { width: 60px; }
    .trs80-img-80 { width: 80px; }
    .trs80-img-90 { width: 90px; }
    .trs80-img-100 { width: 100px; }

    /* Search Button Styling */
    .header-search-container {
        margin-bottom: 10px;
    }

    .header-search-link {
        display: inline-block;
        background: #ffcc00; /* Retro TRS-80 Amber */
        color: #003399 !important;
        padding: 6px 15px;
        border-radius: 4px;
        font-weight: bold;
        font-size: 0.9em;
        text-decoration: none;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        transition: transform 0.2s, background 0.2s;
    }

    .header-search-link:hover {
        background: #ffe066;
        transform: scale(1.05);
        text-decoration: none;
    }

    @media screen and (max-width: 768px) {
        .trs80-header-grid {
            grid-template-columns: 1fr;
            grid-template-rows: auto auto auto;
            text-align: center;
            justify-items: center;
        }
        .trs80-header-left { grid-area: 1 / 1 / 2 / 2; justify-content: center; }
        .trs80-header-center { grid-area: 2 / 1 / 3 / 2; }
        .trs80-header-right { grid-area: 3 / 1 / 4 / 2; justify-content: center; }
        .trs80-title { font-size: 130%; }
        .trs80-description { font-size: 100%; text-align: center; }
        .trs80-img-60 { width: 50px; }
        .trs80-img-80 { width: 65px; }
        .trs80-img-90 { width: 75px; }
        .trs80-img-100 { width: 80px; }
    }
</style>

<div class="trs80-header-grid">
    <div class="trs80-header-left">
        <img src="Model%20III%20ROM%20Explained%20-%20Part%201_files/computer-model1-keyboardandscreen-100.png" alt="[Model I]" class="trs80-img-60">
        <img src="Model%20III%20ROM%20Explained%20-%20Part%201_files/computer-model3-rsc05-blur-x100.png" alt="[Model III]" class="trs80-img-60">
        <img src="Model%20III%20ROM%20Explained%20-%20Part%201_files/computer-model4-rsc10-x100.png" alt="[Model 4]" class="trs80-img-90">
    </div>

    <div class="trs80-header-center">
        <p class="trs80-title">Welcome To Ira Goldklang's TRS-80 Revived Site</p>

        <p class="trs80-description">
            TRS-80 Revived Site is an archive of everything related to 
the Tandy Radio Shack TRS-80 home microcomputer lines. Site contains 
emulators, programs, manuals, books, patches, games, hints, discussions,
 and tons more.
        </p>

        <div class="header-search-container">
            <a href="https://www.trs-80.com/main-search-site.htm" class="header-search-link">
                <span class="search-icon">üîç</span> SEARCH THIS SITE
            </a>
        </div>
    </div>

    <div class="trs80-header-right">
        <img src="Model%20III%20ROM%20Explained%20-%20Part%201_files/computer-model-4p-sideways-view-x100.png" alt="[Model 4P]" class="trs80-img-90">
        <img src="Model%20III%20ROM%20Explained%20-%20Part%201_files/computer-model100-ccf836-x100.png" alt="[Model 100]" class="trs80-img-80">
        <img src="Model%20III%20ROM%20Explained%20-%20Part%201_files/computer-pc2-rsc07-x100.png" alt="[Pocket Computer]" class="trs80-img-100">
    </div>
</div>
</div>
		<!-- Content wrapper with sidebar and main content -->
		<div class="content-wrapper">
			<!-- Left Navigation will be loaded here -->
			<aside class="sidebar" id="navbar"><div class="navigationpanelv2">
	<div class="nav-entry-block">
		<h2>FIRST TIME VISITORS</h2>
		<p style="font-size:150%; margin-top:0; text-align:center; color:red;"><a href="https://www.trs-80.com/main-welcome.htm">Visit the WELCOME page</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>Services</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-faq-reading-disks.htm" style="color:red !important;">Do you have TRS-80 Disks?  Send them in for Preservation and Conversion for use in an Emulator</a></li>
			<li><a href="https://www.trs-80.com/main-disketterequest.htm">Request Real DOS Disks</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>General</h2>
		<ul>
			<li><a href="https://www.trs-80.com/index.html">Site News</a></li>
			<li><a href="https://www.trs-80.com/main-introduction-to-emulators.htm">Intro to Emulation</a></li>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-interviews.htm">Interviews</a></span>
				<ul>
					<li><a href="https://americanhistory.si.edu/comphist/gates.htm">Bill Gates</a></li>
					<li><a href="http://www.trs-80.org/interview-bill-hogue/">Bill Hogue</a></li>
					<li><a href="http://www.trs-80.org/interview-dan-gookin/">Dan Gookin</a></li>
					<li><a href="https://www.trs-80.com/sub-interview-don-french.htm">Don French</a></li>
					<li><a href="https://bluebilby.com/dubois-mcnamara/">Dubouis &amp; McNamara</a></li>
					<li><a href="http://www.trs-80.org/interview-j-weaver/">J. Weaver Jr.</a></li>
					<li><a href="http://www.trs-80.org/interview-jack-crenshaw/">Jack Crenshaw</a></li>
					<li><a href="http://www.trs-80.org/interview-jim-stutsman/">Jim Stutsman</a></li>
					<li><a href="http://www.48k.ca/JoshLavinsky.html">Josh Lavinsky</a></li>
					<li><a href="http://www.trs-80.org/interview-kevin-tschudi/">Kevin Tschudi</a></li>
					<li><a href="http://www.trs-80.org/interview-paul-andreasen/">Paul Andreasen</a></li>
					<li><a href="https://www.trs-80.com/sub-interview-steve-leininger.htm">Steven W. Leininger</a></li>
					<li><a href="https://www.trs-80.com/sub-interview-bill-demas.htm">William Demas</a></li>
				</ul>
			</li>
			<li><a href="https://www.trs-80.com/main-shipping.htm">Shipping a TRS-80</a></li>
			<li><a href="https://www.trs-80.com/main-lore.htm">Radio Shack Lore</a></li>
			<li><a href="https://www.trs-80.com/main-fun-stuff.htm">Fun Stuff</a></li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>Help The Site!</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-missing-software.htm">Missing Software</a></li>
			<li><a href="https://www.trs-80.com/main-missing-magazines.htm">Missing Magazines</a></li>
			<li><a href="https://www.trs-80.com/main-faq-reading-disks.htm">Send in Your Disks for Archiving</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Searches</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-search-site.htm">Site-Wide Search</a></li>
			<li><a href="https://www.trs-80.com/main-search-software.htm">Software Search</a></li>
			<li><a href="https://www.trs-80.com/main-search-magazines.htm">Magazine Search</a></li>
			<li><a href="https://www.trs-80.com/main-search-rs-catalogs.htm">Catalog Search</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Emulation and Virtual Media</h2>
		<span>Info and Downloads:</span>
		<ul>
			<li><a href="https://www.trs-80.com/main-emulators.htm">Emulators</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-tape-utilities.htm">Virtual Tape Utilities</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-disk-utilities.htm">Virtual Disk Utilities</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-misc-utilities.htm">Misc TRS-80 Utilities</a></li>
		</ul>
		<span>How To Convert:</span>
		<ul>
			<li><a href="https://www.trs-80.com/main-emulation-conversion-tapes.htm">Tapes to Virtual</a></li>
			<li><a href="https://www.trs-80.com/main-emulation-conversion-disks.htm">Disks to Virtual</a></li>
			<li><a href="https://www.classic-computers.org.nz/system-80/software_esf_archive-imaging.htm">Stringy Floppy to Virtual</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Advanced</h2>
		<span>Internal Operations</span>
		<ul>
			<li>
				<span class="submenu-toggle">ROM/Z-80 Info</span>
				<ul>
					<li><a href="https://www.trs-80.com/main-internal-rom-related.htm#compared">ROMs Compared</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-level-1.htm">Model I Level 1 ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm">Model I Level II ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm">Model III Level II ROM</a></li>
					<li><a href="https://github.com/kiwisincebirth/TRS-80">Model III Level II Compilable Source</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4.htm">Model 4 ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4-xdrom-main.htm">Model 4 XDROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4p.htm">Model 4P Boot ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-network-4.htm">Network 4 ROM</a></li>
					<li><a href="https://www.gatesnotes.com/microsoft-original-source-code">Orig Source Code</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-bugs.htm">Bugs</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-rom-addresses.htm">Memory map and address reference</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-entry-points.htm">Entry Points to routines</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-io-and-misc-routines.htm">I/O and Misc ROM routines</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-math-calls.htm">Math Routines</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-rst-vectors.htm">RST vectors and Disk BASIC entry points</a></li>
					<li><a href="https://www.trs-80.com/sub-rom-z80-info.htm">Reference for Z-80 opcodes and undocumented command</a></li>
				</ul>
			</li>
			<li><a href="https://www.trs-80.com/main-internal-ram-addresses-and-routines.htm">RAM Addresses/Routines</a></li>
			<li><a href="https://www.trs-80.com/main-internal-ports-and-i-o.htm">Ports and I/O Devices</a></li>
			<li><a href="https://www.trs-80.com/sub-rom-dcbs.htm">Device Control Blocks (DCB's)</a></li>
			<li><a href="https://www.trs-80.com/main-internal-keyboard-map.htm">Keyboard Map</a></li>
		</ul>

		<span>Disassemblies</span>
		<ul>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-disassemblies.htm">Disassemblies</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-level-1.htm">Level I ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m1-part-1.htm">Level II ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm">Model III ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-4-durda.htm">Frank Durda Modified C-ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4.htm">Model 4 ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4p.htm">Model 4P Bootstrap ROM</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-m4-xdrom-main.htm">XDROM - Frank Durda's Model 4 ROM C replacement</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-dos-nd80-m1-main.htm">NEWDOS/80 v2.0</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-dos-td13-main.htm">TRSDOS v1.3</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-dos-td23-main.htm">TRSDOS v2.3</a></li>
					<li><a href="https://www.trs-80.com/sub-disassem-rom-network-4.htm">Network 4 Transporter ROM code analysis</a></li>
				</ul>
			</li>
		</ul>

		<span>Zaps/Patches/Fixes</span>
		<ul>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-zaps-and-patches.htm">Zaps and Patches</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/main-zaps-and-patches.htm#dos">DOS</a></li>
					<li><a href="https://www.trs-80.com/sub-zaps-sw-electric-pencil.htm">Electric Pencil</a></li>
					<li><a href="https://www.trs-80.com/sub-zaps-sw-general.htm">Other Software</a></li>
					<li><a href="https://www.trs-80.com/main-zaps-and-patches.htm#software-zaps-and">ZIPs of Patches</a></li>
				</ul>
			</li>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-tips-and-tricks.htm">Tips and Tricks</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/sub-tips-hard-drive.htm">Hard Drive Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-packing.htm">String Packing and USR Routines</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-level2.htm">Level II Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-reference-dos-newdos80-main.htm#tips">NEWDOS/80 Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-dos.htm">Other DOS Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-graphics.htm">TRS-80 Graphics</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-file-formats.htm">Tape and File Formats/Structures</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-easter-eggs.htm">Bugs and Easter Eggs</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-misc.htm">Misc Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-model-3.htm">Model III Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-model-4.htm">Model 4 Tips and Tricks</a></li>
					<li><a href="https://www.trs-80.com/sub-tips-model-4p.htm">Model 4P Tips and Tricks</a></li>
				</ul>
			</li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>TRS-80 Models</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-models.htm">Timeline</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model1.htm">Model I</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model2.htm">Model II</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model3.htm">Model III</a></li>
			<li><a href="https://www.trs-80.com/sub-models-model4.htm">Model 4/4P/4D</a></li>
			<li><a href="https://www.trs-80.com/sub-models-coco.htm">Color (Coco 1-3, MC-10)</a></li>
			<li><a href="https://www.trs-80.com/sub-models-laptops.htm">Laptops (100/200/600)</a></li>
			<li><a href="https://www.trs-80.com/sub-models-pocket.htm">Pocket (PC-1 to PC-8)</a></li>
			<li><a href="https://www.trs-80.com/sub-models-clones.htm">Clones</a></li>
			<li><a href="https://www.trs-80.com/sub-models-printers.htm">Printers</a></li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>

	<div class="nav-entry-block">
		<h2>Reference</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-reference-dos-trsdos-main.htm">TRSDOS</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-dos-dosplus.htm">DOSPlus</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-dos-newdos80-main.htm">NEWDOS/80</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-multidos.htm">MULTIDOS</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-dos-cpm.htm">CP/M</a></li>
			<li><a href="https://www.trs-80.com/sub-reference-level-2-basic.htm">Level II BASIC Ref</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Detailed Products</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-details-orchestra.htm">ORCH-80/85/90</a></li>
			<li><a href="https://www.trs-80.com/sub-details-speed-up-boards.htm">Speed-Up Boards</a></li>
			<li><a href="https://www.trs-80.com/sub-details-scott-adams.htm">Scott Adams Adventures</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Tandy Publications</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-rs-csbs.htm">Customer Service Bulletins</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-memos.htm">Memos / Bulletins / Releases</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-cc-answers.htm">Comp Center Answers</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-catalogs.htm">Catalogs</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-comics.htm">Comic Books</a></li>
		</ul>
		<span>Microcomputer News</span>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-rs-micronewsletter-usa.htm">USA Edition</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-micronewsletter-aus.htm">Australian Edition</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-rs-micronewsletter-other.htm">Other Editions</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Publications</h2>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-books.htm">Books</a></li>
			<li>
				<span class="submenu-toggle"><a href="https://www.trs-80.com/main-magazine-main-menu.htm">Magazines (Non-Tandy)</a></span>
				<ul>
					<li><a href="https://www.trs-80.com/sub-mag-80micro-main.htm">80 Microcomputing</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-80-notebook.htm">80 Notebook</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-80us-detail.htm">80 U.S. Journal</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-alternatesource-detail.htm">The Alternate Source</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-baron.htm">Baron's Microcomputing</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-cie.htm">C.I.E.</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-cload.htm">CLOAD</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-codeworks.htm">CodeWorks</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-computernews80.htm">Computer News 80</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-computer-user.htm">Computer User</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-creative.htm">Creative Computing</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-hecomputronics-detail.htm">H&amp;E Computronics</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-lsi-journal.htm">LDOS / LSI</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-micro80.htm">Micro-80</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-misosys-notes.htm">Misosys Notes</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-misosys-quarterly.htm">Misosys Quarterly</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-softside-detail.htm">Softside</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-the8ighty.htm">The 8ighty</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-trace.htm">Trace</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-trs8bit.htm">TRS8Bit</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-trstimes.htm">TRSTimes</a></li>
					<li><a href="https://www.trs-80.com/sub-mag-other.htm">Other Magazines</a></li>
				</ul>
			</li>
			<li><a href="https://www.trs-80.com/sub-publications-manuals-software-1.htm">Software Manuals</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-user-groups-1.htm">User's Group Newsletters</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-catalogs.htm">Catalogs (Non-Tandy)</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-flyers.htm">Product Flyers</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-company-news.htm">Company Newsletters</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>This Section for TRS-80 Hardware Owners</h2>
		<span>TRS-80 Upgrades/Parts:</span>
		<ul>
			<li><a href="https://www.trs-80.com/main-upgrades.htm">Upgrades and Parts</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-parts-thingverse.htm">Schematics/3-D Printable Parts</a></li>
		</ul>
		<span>TRS-80 Repairs:</span>
		<ul>
			<li class="navbumpv2"><a href="https://www.trs-80.com/main-repairs.htm">Main Repair Page</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-repair-people.htm">Repair People</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-how-to-open.htm">Opening a TRS-80</a></li>
			<li><a href="https://www.trs-80.com/sub-repairs-eprom.htm">Using an EPROM</a></li>
		</ul>
		<span>Hardware Mods and Hacks:</span>
		<ul>
			<li><a href="https://www.trs-80.com/sub-tips-modifications-model-1.htm">Model I</a></li>
			<li><a href="https://www.trs-80.com/sub-tips-modifications-model-3.htm">Model III</a></li>
			<li><a href="https://www.trs-80.com/sub-tips-modifications-model-4.htm">Model 4</a></li>
		</ul>
		<span>Other Items ...</span>
		<ul>
			<li><a href="https://www.trs-80.com/sub-publications-manuals-hardware-1.htm">Hardware Manuals</a></li>
			<li><a href="https://www.trs-80.com/sub-publications-manuals-service.htm">Service Manuals</a></li>
			<li><a href="https://voidstar.blog/tandy-radio-shack-computer-cassette-recorder-trs-ccr-usage/">Using a Computer / Tablet / Smartphone for Cassette I/O</a></li>
		</ul>
	</div>

	<div class="nav-entry-block">
		<h2>Misc</h2>
		<ul>
			<li><a href="https://www.trs-80.com/main-emailme.htm">Send Me Email</a></li>
			<li><a href="https://www.trs-80.com/main-old-news.htm">Archived News and Guestbook</a></li>
			<li><a href="https://www.trs-80.com/main-personalstories.htm">Personal Stories Submitted</a></li>
			<li><a href="https://www.trs-80.com/main-emaillinks.htm">Email and other TRS-80 Sites</a></li>
			<li><a href="https://www.trs-80.com/main-copyrights.htm">Copyrights</a></li>
		</ul>
		<p class="donatev2"><a href="https://www.trs-80.com/main-donate.htm">Support the Site</a></p>
	</div>
</div></aside>
			<!-- Main Content -->
			<main class="main-content">
				<div class="main-page-container">
				<h1>Model III ROM Explained - Part 1</h1>

					<div class="section-wrapper">
						<h2 id="introduction">Introduction<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
						<div class="section-content">
							<h3 id="these-3-pages-are-a">These 3 pages are a breakdown of the Model III ROM, with comments to help you understand what is going on.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h3>
							<p>The two thing to keep in mind while reading this disassembly are:</p>
							<ul>
							<li>The ROM had to be one big long program starting from 0000H 
and ending at 37FFH and everything it does had to be wedged into that 
single long block of code.  This means that jumps to other locations are
 a necessity because once a particular portion of the ROM executes, if 
it was allowed to keep going, unintended portions would also execute.  
With this, there is a LOT of jumping away.</li>
							<li>There are only so many variables and only so many Z-80 instructions.  There is no Z-80 instruction, for example, <span class="code">LD BC,SP</span>.
  With this, there is a huge amount of variable swapping.  I would dare 
say that whatever part of the ROM isn't jumping, is just swapping 
variables around.  The ROM would be a fraction of the size if there were
 more variables and more Z-80 instructions.</li>
							</ul>
							<p>Addresses with a "*" in front of them, which are also in blue, differ from the Model I.</p>
							<p>There is no difference between the early Model III ROM and the
 later Model III ROM in this range.  The Model 4 ROM is also identical 
to the Model III ROM in this range.</p>
						</div>
					</div>

					<div class="section-wrapper">
						<h2 id="model-iii-rom">Model III ROM Disassembled<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
						<div class="section-content">
							<br><h2 class="skip-banner" id="0000-0004-power-up">0000-0004 - POWER UP ROUTINE - $RESET<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>A jump to this routine reinitializes the entire system 
starting at the "CASS?" prompt.  If a disk controller is present, the 
Computer will attempt to load DOS UNLESS <kbd>BREAK</kbd> was held down before this jump.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0000<span class="origrom2">RESET</span></div><div>DI</div><div>Disables the interrupts and turns off clock</div></div>
									<div class="assembly-row-combined model1"><div>0001</div><div>XOR A</div><div>Clears the A register and status</div></div>
									<div class="assembly-row-combined model3"><div>*0002-0004</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-4.htm#3015H" class="memory-link">JP 3015H</a></div><div>Go
 to the Boostrap/Initialization routine at 3015H (which just jumps to 
3455H which is the BOOTSTRAP (sets interrupts, clears ports, checks for a
 <kbd>BREAK</kbd> key and tries to work with the disk controller).<br>Difference
 between M1 and M3: The jump is to the power-up routine, located at 
0674H in the Model I but jump is to 3015H in the Model III (3015H is the
 location of a vector to the start of the actual routine).</div></div>
									<div class="assembly-row-combined model1"><div>0005-0007</div><div>JP 4000H</div><div>Go to RST 0008H code via 4000H.</div></div>
								</div>
							</div>

							<br><h2 id="0008H">0008 - RST 08H<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0008<span class="origrom2">SYNTAX</span><br>(RST 008H)</div><div>JP 4000H</div><div>JUMPs
 to 4000H. 4000H passes control to 1C96H. This routine is used for 
scanning strings. It compares the character pointed to by the HL 
register pair with the character pointed to by the return address on the
 top of the STACK (Note that a RST instruction is in effect a CALL and 
places a return address on the STACK) formula: (HL)=((SP))? If they are 
not equal an SN ERROR will result; if they are equal then the return 
address on the STACK will be incremented to bypass the test character 
and control will be passed to RST 10H logic. RST 8H is used to look for 
expected characters in a string and then return with (HL) pointing to 
the next non-blank character. (see RST l0H) (BC and DE registers 
unaffected.). This routine can be used by CALLing 1C96H or RST 8H.<br>This
 is the COMPARE SYMBOL routine which comparess the symbol in the input 
string pointed to by HL register to the value in the location following 
the RST 08 call.  If there is a match, control is returned to address of
 the RST 08 instruction 2 with the next symbol in the Aregister and HL 
incremented by one. If the two characters do not match, a syntax error 
message is given and control returns to the Input Phase).</div></div>
								</div>
							</div>

							<br><h2 id="000BH">000B-000F - DISK ROUTINE - "WHERE"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>000B</div><div>POP HL</div><div>Get the address from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>000C</div><div>JP (HL)</div><div>JUMP to the location of the address in register pair HL.</div></div>

									<div class="assembly-row-combined model3" id="000DH"><div>*000D-000F<span class="origrom2">DBOOT</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-4.htm#3012H" class="memory-link">JP 3012H</a></div><div>Go
 to the Boostrap/Initialization routine at 3015H (which just jumps to 
3455H which is the BOOTSTRAP (sets interrupts, clears ports, checks for a
 <kbd>BREAK</kbd> key and tries to work with the disk controller).<br>Difference
 between M1 and M3: The jump is to the power-up routine, located at 
0674H in the Model I but jump is to 3015H in the Model III (3015H is the
 location of a vector to the start of the actual routine).</div></div>
								</div>
							</div>

							<br><h2 id="0010H">0010 - RST 10H<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0010H</div><div>JP 4003H</div><div>JUMPs to <a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#1D78H" class="memory-link">1D78H</a> (RST 0010H vector) through 4003H.<br><br>This
 routine INCrements HL and tests the characters pointed to by the HL 
register pair. It will bypass any spaces and CHAR'S 9 and 10 (shifted 
left and down arrows respectively). Upon return from this routine HL 
will point to the next non-blank character; the CARRY FLAG will be SET 
if HL is pointing to a numeric ASCII character and the Z flag will be 
SET if the character pointed to happens to be zero (ASCII 30H) or 3AH 
(":"). (BC and DE registers are unaffected) This routine can be used by 
CALLing 1D78H or RST 10H.</div></div>
								</div>
							</div>

							<br><h2 id="0013H">0013-0017 - KEYBOARD ROUTINE.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is jumped to from 002E (to get a byte from the Keyboard) and 0053 (to get a byte from the RS-232).</p>
								<p>This routine inputs a byte from an input device.  When 
calling, DE = must contain the starting address of DCB of device. On 
exit, A = byte received from device, Z set if device ready. Uses AF.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0013<span class="origrom2">INBYT</span></div><div>PUSH BC</div><div>Save the value in Register Pair BC to the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0014-0015</div><div>LD B, 01H</div><div>Load register B with the device type entry code of 01H.</div></div>
									<div class="assembly-row-combined model1"><div>0016-0017</div><div><a href="#0046H" class="memory-link">JR 0046H</a></div><div>JUMP to the Level II BASIC driver entry routine at 0046H which in turn jumps to <a href="#0674H" class="memory-link">0674H</a>, which is the keyboard driver entry routine.</div></div>
								</div>
							</div>

							<br><h2 id="0018H">0018 - RST 18H<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0018<br>(RST 018H)</div><div>JP 4006H</div><div>JUMPs to <a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#lC90H" class="memory-link">lC90H</a>
 through 4006H. This routine can be called by using RST 18H or CALL 
lC90H. It compares two 16 bit values in HL and DE and sets the S and Z 
flags accordingly (they are set in the same way as for a normal 8 bit 
CP). All registers are unchanged except for A.<br>This is the COMPARE 
DE:HL routine, which numerically compares DE and HL. Will not work for 
signed integers (except positive ones). Uses the A-register only. The 
result of the comparison is returned in the status register as:  <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
								</div>
							</div>

							<br><h2 id="001BH">001B-001E - DRIVER ENTRY ROUTINE - Part 1 - "PUT" or "OUTBYT"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine outputs a byte to a device. When calling, A = 
output byte, DE = starting address of DCB of device. On exit, Z set if 
device ready. Uses AF.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>001B</div><div>PUSH BC</div><div>Save the value in register pair BC on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>001C-001D</div><div>LD B,02H</div><div>Load register B with the device type entry code of 02H.</div></div>
									<div class="assembly-row-combined model1"><div>001E-001F</div><div><a href="#0046H" class="memory-link">JR 0046H</a></div><div>JUMP to the Level II BASIC driver entry routine at 0046H which in turn jumps to <a href="#0674H" class="memory-link">0674H</a>, which is the keyboard driver entry routine.</div></div>
								</div>
							</div>

							<br><h2 id="0020H">0020 - RST 20H<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0020H</div><div>JP 4009H</div><div>This
 routine jumps to 25D9H through 4009H. If the NTF=8 then C=RESET or else
 C=SET, Z flag will be SET if NTF=3 (S flag is valid also.). After 
execution of RST 20H or CALL 25D9H, A will contain the value NTF-3, all 
other registers are unchanged.<br>Returns a combination of STATUS flags and unique numeric values in the A Register according to the data mode flag (40AFH).<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table>This
 CALL is usually made to determine the type of the current value in REG 1
 (i.e., 4121H). It should be used with caution, however since the mode 
flag and REG 1 (i.e., 4121H) can get out of phase particularly if some 
of the CALLS described here are used to load REG l.</div></div>
								</div>
							</div>

							<br><h2 id="0023H">0023-0027 - DISK ROUTINE - "CTLBYT"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0023</div><div>PUSH BC</div><div>Save the value in register pair BC on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0024-0025</div><div>LD B,04H</div><div>Load register B with the device type entry code of 04H.</div></div>
									<div class="assembly-row-combined model1"><div>0026-0027</div><div><a href="#0046H" class="memory-link">JR 0046H</a></div><div>JUMP to the Level II BASIC driver entry routine at 0046H which in turn jumps to <a href="#0674H" class="memory-link">0674H</a>, which is the keyboard driver entry routine.</div></div>

								</div>
							</div>

							<br><h2 id="0028H">*0028H - RST 28H Routine Vector<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0028<br>(RST 028H)</div><div>JP 400CH</div><div>JUMPs to 400CH which contains C9H (RET) under Level II BASIC. This vector is only used by Disk BASIC. It is called by the <kbd>BREAK</kbd> key routine, and can be used to intercept the <kbd>BREAK</kbd> key logic.<br>This
 is the DOS FUNCTION CALL routine at RST 28 (which passes request code 
in A-register to DOS for processing. Returns for non-disk system. For 
disk systems, the A register must contain a legitimate DOS function 
code. If the code is positive, the CALL is ignored and control returns 
to the caller. Note that the DOS routine discards the return address 
stored on the STACK by the RST instruction. After processing control 
will be returned to the previous address on the STACK).</div></div>
								</div>
							</div>

							<br><h2 id="002BH">002B-002F - KEYBOARD ROUTINE - "$KBCHAR"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Keyboard scanning routine. After CALLing 2BH, the A register 
will contain the ASCII value for the key that was pressed. The A 
register will contain 00H if no key was pressed at the time. Apart from 
the AF register pair the DE register pair is also used by the routine.<br><br>This
 Routine Performs an instantaneous scan of the keyboard. If no key is 
depressed control is returned to the caller with the Aregister and 
status register set to zero. If any key (except the <kbd>BREAK</kbd> key) is active the ASCII value for that character is returned in the A-register. If the <kbd>BREAK</kbd>
 key is active, a RST 28 with a system request code of 01 is executed. 
The RST instruction results in a JUMP to the DOS Exit 400C. On non-disk 
systems the Exit returns, on disk systems control is passed to SYSO 
where the request code will be inspected and ignored, because system 
request codes must have bit 8 on. After inspection of the code, control 
is returned to the caller of 002B. Characters detected at 002B are not 
displayed. Uses DE, status, and A register<br><br>This routine loads DE 
with address of keyboard DCB and scans keyboard. On exit, if no key 
pressed the A register will contain a zero byte, else the character 
input from the keyboard wi 11 be returned in A. Character is not echoed 
to video. Uses AF,DE (to save DE use routine at 03588).</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>002B-002D<span class="origrom2">KBCHAR</span></div><div>LD DE,4015H</div><div>Load register pair DE with the starting address of the keyboard device control block.<br><b>NOTE:</b> 4015H holds Keyboard DCB - Device type.</div></div>
									<div class="assembly-row-combined model1"><div>002E-002F</div><div><a href="#0013H" class="memory-link">JR 0013H</a></div><div>JUMP to the Level II BASIC driver entry routine.</div></div>
								</div>
							</div>

							<br><h2 id="0030H">0030 - RST 30H<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0030H</div><div>JP 400FH</div><div>This location passes control to 400FH which contains a RET (C9H) under Level II. This location is only used by a Disk system.<br>This
 is the LOAD DEBUG routine, and loads the DEBUG program and transfers 
control to it. When DEBUG processing is complete, control is returned to
 the orginal caller. For non-disk systems control is returned 
immediately.</div></div>
								</div>
							</div>

							<br><h2 id="0033H">0033-0037 - "$VDCHAR" - Display a character.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This subroutine displays a character at the current cursor location.  On entry, Register A contains the character to display.<br><br>Character
 print routine. A CALL 33H will print a character at the current cursor 
position. The A register must contain the ASCII code for the character 
or graphics figure that is to be printed before CALLing this routine. 
The DE register pair is used by the routine.<br>A call to 0033H displays the character in the A-register on the video.  Control codes are permitted. All registers are used.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1" id="0033H"><div>0033-0035<span class="origrom2">VDCHAR</span></div><div>LD DE,401DH</div><div>Load register pair DE with 401DH which is the starting address of the video display device control block.</div></div>
									<div class="assembly-row-combined model1"><div>0036-0037</div><div><a href="#001BH" class="memory-link">JR 001BH</a></div><div>JUMP to the Level II BASIC driver entry routine at 001BH.<br><b>NOTE:</b>
  001BH saves BC to the STACK, Loads B with a 02H device code, and then 
JUMPs to 0046H which JUMPs to the keyboard entry driver routine at 
0674H.</div></div>
								</div>
							</div>

							<br><h2 id="0038H">0030 - RST 38H<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0038H<span class="origrom2">RST38</span></div><div>JP 4012H</div><div>This location will pass control to 4012H. This location is only used by a Disk system.<br>This
 is the INTERRUPT ENTRY POINT routine at RST 38H which is the system 
entry point for all interrupts. It contains a jump to a section of code 
in the Communications Region designed to field interrupts. That section 
of code consists of a DI (disables further interrupts) followed by a RET
 (returns to the point of interrupt) for non-disk systems, or a jump to 
an interrupt processor in SYS0/SYS if it is a DOS system. For DOS 
systems the interrupt handler consists of a task scheduler, where the 
exact cause of the interrupt is determined (usually a clock interrupt) 
and the next task from the task control block is executed. After task 
completion, control returns to the point of interrupt.</div></div>
								</div>
							</div>

							<br><h2 id="003BH">003B-003F - PRINTER ROUTINE - "$PRCHAR"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine waits until the printer is available or until a <kbd>BREAK</kbd> key his pressed.  If <kbd>BREAK</kbd> is pressed, this routine returns to the caller.  On entry Register A holds the ASCII character to be output to the printer.</p>
								<p>Character LPRINT routine. Same as 33H but outputs to line printer. (Contents of A register will be printed).<br><br>A
 call to 003BH causes the character contained in the A-register to be 
sent to the printer. A line count is maintained by the driver in the 
DCB. When a full page has been printed (66 lines), the line count is 
reset and the status register returned to the caller is set to zero. 
Control codes recognized by the printer driver are:<br><br>00=Returns 
the printer status in the upper two bits of the A-register and sets the 
status as zero if not busy, and non-zero if busy.<br><br>OB=Unconditionally skips to the top of the next page.<br><br>OC=Resets
 the line count (DCB 4) and compares its previous value to the lines per
 page (DCB 3) value. If the line count was zero, no action is taken. If 
the line count was non-zero then a skip to the top form is performed.<br><br>OD=Line terminator. Causes line count to be incremented and tested for full page. Usually causes the printer to begin printing.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>003B-003D</div><div>LD DE,4025H</div><div>Load register pair DE with 4025H which is the starting address of the printer device control block.</div></div>
									<div class="assembly-row-combined model1"><div>003E-003F</div><div><a href="#001BH" class="memory-link">JR 001BH</a></div><div>JUMP to the Level II BASIC driver entry routine at 001BH.<br><b>NOTE:</b>
  001BH saves BC to the STACK, Loads B with a 02H device code, and then 
JUMPs to 0046H which JUMPs to the keyboard entry driver routine at 
0674H.</div></div>
								</div>
							</div>

							<br><h2 id="0040-0042-input">0040-0042 - INPUT ROUTINE - "$KBLINE"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine gets a full like from the keyboard.  The line is
 terminated by a carriage return or BREAK.  Characters typed are echoed 
to the display.  On entry, B must be the maximum length of line to be 
accepted and (HL) must be the storage buffer which should be set to B+1.
  On Exit, CARRY will be set if the <kbd>BREAK</kbd> key was hit, 
Register B will contain the number of characters entered, and (HL) will 
contain the line from the keyboard followed by the terminating 
character.  Register paid DE is altered in this routine.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0040-0042<span class="origrom2">KBLINE</span></div><div><a href="#05D9H" class="memory-link">JP 05D9H</a></div><div>JUMP
 to the "WAIT FOR NEXT LINE" keyboard input routine at 05D9H (which 
takes keyboard entry until a carriage return, a break, or buffer overrun
 occurs).</div></div>
									<div class="assembly-row-combined model1 nodurda"><div>0043</div><div>RET</div></div>
									<div class="assembly-row-combined model1 nodurda"><div>0044</div><div>NOP</div></div>
									<div class="assembly-row-combined model1 nodurda"><div>0045</div><div>NOP</div></div>
									<div class="assembly-row-combined model3 durda"><div>0043-0045</div><div><a href="#0434H" class="memory-link">JP 0434H</a></div><div>JUMP to 0434H to print the character held in C.</div></div>
								</div>
							</div>

							<br><h2 id="0046H">0046-0048 - DRIVER ENTRY ROUTINE - Part 2 - "DRIVRV"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0046-0048</div><div><a href="#0674H" class="memory-link">JP 0674H</a></div><div>JUMP to 0674H.<br><b>NOTE:</b> 0674H is the Level II BASIC keyboard driver entry routine.<br><br>Difference
 between M1 and M3: The jump is to the I/O driver entry routine, located
 at 03C2H in the Model I but relocated to 0674H in the Model III.</div></div>
								</div>
							</div>

							<br><h2 id="0049H">*0049-004F - KEYBOARD ROUTINE - "$KBWAIT" - Go scan the keyboard and return with the key pressed, if any, in register A.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>A CALL to this memory location returns as soon as any key on 
keyboard is pressed.  ASCII value for character entered is returned in A
 register.  Uses A, status, and DE registers.  If <kbd>BREAK</kbd> is 
hit, then it will be returned in Register A just like any other key (as 
an 01H).  The characters are not echoed to the display.</p>
								<p>A call to 0049H returns as soon as any key on keyboard is pressed.  ASCII value for character entered is returned in A register.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0049<span class="origrom2">KBWAIT</span></div><div><a href="#002BH" class="memory-link">CALL 002BH</a></div><div>Character
 input routine. This routine is the same as 2BH (=Scan the Keyboard 
routine) except that it will not return until a key is pressed.</div></div>
									<div class="assembly-row-combined model3"><div>*004C</div><div>OR A</div><div>Check the value in register A to see if a key was pressed.</div></div>
									<div class="assembly-row-combined model3"><div>*004D</div><div>RET NZ</div><div>Return if a key was pressed.</div></div>
									<div class="assembly-row-combined model3"><div>*004E-004F</div><div><a href="#0049H" class="memory-link">JR 0049H</a></div><div>Loop until a key is pressed.</div></div>
								</div>
							</div>

							<br><h2 id="0050H">*0050-0053 - "$RSRCV" - Receive a character from the RS-232-C Interface<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>If the RS-232-C wait is enabled, this routine will wait for a character to be received, unless a <kbd>BREAK</kbd>
 is pressed.  If the wait is NOT enabled, it returns whether a character
 is received or not.  The character is stored in 16872.  A 0 means no 
character received.</p>
								<div class="assembly-table">
									<p class="debug-note">Difference between M1 and M3: In the 
Model I, locations 0050H through 005FH are a lookup table for special 
characters associated with the keyboard scan routine. These same 
locations in the Model III contain the entry points for routines 
associated with the RS-232-C interface C Receive character at 00S0H, 
Transmit character at 00SSH, Initialize RS-232-C at 00SAH). In both 
models, 0060H is the start of a time-delay routine, but in the Model III
 the three bytes starting at 0060H have been changed to a JP 01FBH 
instruction. The actual time delay routine (same as in the Model I 
except that an extra instruction is added to compensate for the faster 
clock speed of the Model III) has been moved to 01FBH in the Model III. 
Note that entry at 0063H has the same effect in both models, that is, 
the time delay will occur only if the z flag is reset (NZ).</p>
									<div class="assembly-row-combined model3"><div>*0050<span class="origrom2">RSRCV</span></div><div>LD DE,41E5H</div><div>Load DE with the RS-232 Input DCB of 41E5H.</div></div>
									<div class="assembly-row-combined model3"><div>*0053</div><div><a href="#0013H" class="memory-link">JR 0013H</a></div><div>Input a Byte from the RS-232</div></div>
								</div>
							</div>

							<br><h2 id="0055H">*0055-0058 - "$RSTX" - Transmit a character to the RS-232-C Interface<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>If the RS-232-C wait is enabled, this routine will wait until the character is transmitted unless a <kbd>BREAK</kbd>
 is pressed.  If the wait is NOT enabled, it returns whether a character
 is transmitted or not.  The character is stored in Register A.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0055<span class="origrom2">RSTX</span></div><div>LD DE,41EDH</div><div>Load DE with the RS-232 Input DCB of 41E5H.</div></div>
									<div class="assembly-row-combined model3"><div>*0058</div><div><a href="#001BH" class="memory-link">JR 001BH</a></div><div>Input a Byte from the RS-232</div></div>

								</div>
							</div>

							<br><h2 id="005AH">*005A-005F - "$RSINIT" - Initialize the RS-232-C Interface<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Initialize the RS-232-C interface to the following:  
Baud=300, Word Length=8, Parity=None, Stop Bits=One, Wait for completion
 of character I/O.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*005A<span class="origrom2">RSINIT</span></div><div>LD DE,41F5H</div><div>Load DE with the RS-232 Input DCB of 41E5H.</div></div>
									<div class="assembly-row-combined model3"><div>*005D</div><div><a href="#001BH" class="memory-link">JR 001BH</a></div><div>Input a Byte from the RS-232</div></div>
									<div class="assembly-row-combined model3"><div>*005F</div><div>NOP</div><div>-</div></div>

								</div>
							</div>

							<br><h2 id="0060H">*0060-0065 - "$DELAY"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is a general purpose routine to be used whenever you want to pause before continuing with a program.</p>
								<p>On entry, BC must be loaded with the delay multiplier.  The 
actual delay will be 2.46 + (14.8 * BC) microseconds.  When BC is zero, 
the maximum delay is used (65,535) which is about 1 second.  Routine 
uses BC and A.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0060</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0063</div><div><a href="#0060H" class="memory-link">JR NZ,0060H</a></div><div>If the ZERO flag is not set, run that delay routine again.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0064<span class="origrom2">DELAY</span></div><div><a href="#01FBH" class="memory-link">JP 01FBH</a></div><div>JUMP
 to the delay routine at 01FBH, which uses BC as a loop counter.  It 
RETs when done, so the next instruction is NOT a pass-through!</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0065</div><div>RET</div><div>Return</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0063</div><div><a href="#0060H" class="memory-link">JP 041FH</a></div><div>JUMP
 to the delay routine at 01FBH, which uses BC as a loop counter.  It 
RETs when done, so the next instruction is NOT a pass-through!</div></div>
									<div class="assembly-row-combined model3"><div>*0066</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-4.htm#3039H" class="memory-link">JP 3039H</a></div><div>JUMP
 to the delay routine at 01FBH, which uses BC as a loop counter.  It 
RETs when done, so the next instruction is NOT a pass-through!</div></div>
								</div>
							</div>

							<br><h2 id="0069H">*0069 - "$INITIO" - A call to $INITIO restores
 all I/O drivers to their initial default conditions, including I/O 
routes.  No entry conditions.  All registers are altered.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0069<span class="origrom2">INITIO</span></div><div><a href="#0452H" class="memory-link">JP 0452H</a></div><div>JUMP
 to the delay routine at 01FBH, which uses BC as a loop counter.  It 
RETs when done, so the next instruction is NOT a pass-through!</div></div>
								</div>
							</div>

							<br><h2 id="006CH">*006C - "$ROUTE" - Change I/O Device Routing<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>On entry store the source device of KI, DO, RI, RO, or PR into 4222H and 4223H as the destination device in 4220H and 4221H.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model3 nodurda"><div>*006C<span class="origrom2">ROUTE</span></div><div>LD DE,421DH</div><div>Load DE with the $ Routine DCB at 421DH</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*006F</div><div><a href="#001BH" class="memory-link">JR 001BH</a></div><div>If the ZERO flag is not set, run that delay routine again.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0071</div><div>NOP</div><div>-</div></div>
									<p class="debug-note model3 nodurda">
										This is a bug.   Location 06CCH on the Model I contained the 
correct entry to BASIC from a machine language routine that moved the 
stack pointer. On the Model III, 0072H still has the instruction JP 
06CCH; however, that is in the middle of the Model III's modified list 
routine.
									</p>
									<div class="assembly-row-combined model3 nodurda"><div>*0072</div><div><a href="#06CCH" class="memory-link">JP 06CCH</a></div><div>JUMP to 06CCH which decrements BC, gets the character at (BC) and checks to see if it is an "R".</div></div>
									<div class="assembly-row-combined model3 durda"><div>*006C</div><div>RET</div><div>Return</div></div>
									<div class="assembly-row-combined model3 durda"><div>*006D-006F</div><div>LD BC,1A18H</div><div>Load DE with the $ Routine DCB at 421DH</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0070-0072</div><div><a href="#001BH" class="memory-link">JP 19AEH</a></div><div>JUMP to 06CCH which decrements BC, gets the character at (BC) and checks to see if it is an "R".</div></div>
								</div>
							</div>

							<br><h2 id="0075H">0075-0104 - INITIALIZATION ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is part of the Level II initialization procedure. It 
moves a block of memory from 18F7H to l9lEH up to 4080H to 40A7H. 
(reserved RAM. area).<br><b>NOTE:</b> 4080H-408DH is a division support routine.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0075-0077<span class="origrom2">CSTLII</span></div><div>LD DE,4080H</div><div>Load register pair DE with 4080H which is the start of the ROM storage location of the Level II BASIC division routine.</div></div>
									<div class="assembly-row-combined model1"><div>0078-007A</div><div>LD HL,18F7H</div><div>Load register pair HL with the RAM storage location of the Level II BASIC division routine.</div></div>
									<div class="assembly-row-combined model1"><div>007B-007D</div><div>LD BC,0027H</div><div>Load register pair BC with the length of the Level II BASIC division routine (39 bytes).</div></div>
									<div class="assembly-row-combined model1"><div>007E-007F</div><div>LDIR</div><div>Move the Level II BASIC division routine in ROM (18F7H-191DH) to RAM (4080H-40A6H).</div></div>
									<div class="assembly-row-combined model3"><div>*0080-0082</div><div>LD HL,42E5H</div><div>Continue with the communication region initialization by loading register pair HL with 42E5H.<br>Difference
 between M1 and M3: The instruction starting at 0080H loads HL with 
41E5H in the Model I, 42E5H in the Model III. Following this, three 
memory locations (starting with the one pointed to by HL) are loaded 
with the values 3AH, 00H, and 2CH respectively. HL is then incremented 
once more and the result (41E8H or 42E8H) points to the start of the 
input buffer (and is stored at 40A7H).</div></div>
									<div class="assembly-row-combined model1"><div>0083-0084</div><div>LD (HL),3AH</div><div>Save a 3AH at the location of the memory pointer in register pair HL.<br><b>NOTE:</b> 3AH is the Z-80 Instruction of LOAD A, (xxH)</div></div>
									<div class="assembly-row-combined model1"><div>0085</div><div>INC HL</div><div>Increment the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0086</div><div>LD (HL),B</div><div>Zero out the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0087</div><div>INC HL</div><div>Increment the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0088-0089</div><div>LD (HL),2CH</div><div>Save a 2CH at the location of the memory pointer in register pair HL.<br><b>NOTE:</b> 2CH is the Z-80 Instruction INC L.</div></div>
									<div class="assembly-row-combined model1"><div>008A</div><div>INC HL</div><div>Increment the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>008B-008D</div><div>LD (40A7H),HL</div><div>This
 loads the input buffer pointer (held at 40A7H) with the keyboard buffer
 location address of 42E8H. (40A7H is the I/O buffer pointer and can be 
changed to relocate the buffer.). Save the value in register pair HL as 
the starting address of the keyboard input buffer area.<br><b>NOTE:</b> 40A7H-40A8H holds the input Buffer pointer.</div></div>
									<div class="assembly-row-combined model1"><div>008E-0090</div><div>LD DE,012DH</div><div>In prepartaion for a jump, load register pair DE with the starting address of the <span class="code">?L3 ERROR</span> routine.</div></div>
									<p class="debug-note" id="0091H">0091-0104 - The rest of the 
initialization routine. Asks MEMORY SIZE ?, sets the memory pointers 
accordingly and prints RADIO SHACK LEVEL II BASIC , then it jumps to 
1A19H which is the entry point for the BASIC command mode.</p>
									<p class="debug-note">Top of a DJNZ loop of 28 iterations.</p>
									<div class="assembly-row-combined model1"><div>0091-0092</div><div>LD B,1CH</div><div>Load register B with the number of times disk commands (=28) to save the jump to the <span class="code">?L3 ERROR</span> routine.</div></div>
									<div class="assembly-row-combined model1"><div>0093-0095</div><div>LD HL,4152H</div><div>Load
 register pair HL with the starting address of the Disk Basic links 
(which is 4152H) in preparation for generating an error if disk basic 
commands are attempted.<br><b>NOTE:</b> 4152H-41A3H holds Disk Basic links.</div></div>
									<div class="assembly-row-combined model1"><div>0096-0097</div><div>LD (HL),C3H</div><div>Save a C3H to the location of the memory pointer in register pair HL.<br><b>NOTE:</b> C3H is the first byte of a 3 byte JUMP xxxxH command.</div></div>
									<div class="assembly-row-combined model1"><div>0098</div><div>INC HL</div><div>Increment the memory pointer in register pair HL to the 2nd instruction of a 3 byte JUMP xxxxH command.</div></div>
									<div class="assembly-row-combined model1"><div>0099</div><div>LD (HL),E</div><div>Save the LSB of the <span class="code">?L3 ERROR</span> routine's starting address in register E (i.e., a 2DH) to the location of the memory pointer in register pair HL.<br><b>NOTE:</b>  Now we have JUMP 2Dxx as the instruction.</div></div>
									<div class="assembly-row-combined model1"><div>009A</div><div>INC HL</div><div>Increment
 the memory pointer in register pair HL to the 3rd instruction of each 3
 byte instruction in the Disk Basic command list, so as to point to the 
associated JUMP xxxxH command.</div></div>
									<div class="assembly-row-combined model1"><div>009B</div><div>LD (HL),D</div><div>Save the MSB of the <span class="code">?L3 ERROR</span> routine's starting address in register D (i.e., a 01H) to the location of the memory pointer in register pair HL.<br><b>NOTE:</b>  Now we have JUMP 2D01H as the instruction.  012DH is the JUMP point for a <span class="code">?L3 ERROR</span>.</div></div>
									<div class="assembly-row-combined model1"><div>009C</div><div>INC HL</div><div>Increment the memory pointer in Register Pair HL to the 1st byte of the next Disk Basic command in the list</div></div>
									<div class="assembly-row-combined model1"><div>009D-009E</div><div><a href="#0096H" class="memory-link">DJNZ 0096H</a></div><div>Do this for all 28 disk basic commands until all of the Disk Basic links have been set to jump to the <span class="code">?L3 ERROR</span> routine.</div></div>
									<p class="debug-note">End of the DJNZ loop of 28 iterations.</p>
									<div class="assembly-row-combined model1"><div>009F-00A0</div><div>LD B,15H</div><div>Load register B with the number of DOS links (=21) to set to RETs.<br><b>NOTE:</b> A DJNZ loop uses Register B to count down, so to prep for that loop, Register B has to be filled with the number of iterations.</div></div>
									<div class="assembly-row-combined model1"><div>00A1-00A2</div><div>LD (HL),C9H</div><div>Save a C9H (i.e. RETurn) to the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>00A3</div><div>INC HL</div><div>Increment the memory pointer in register pair HL a total of 3 times, as a JUMP is 3 instructions, but RET is just 1 instruction.</div></div>
									<div class="assembly-row-combined model1"><div>00A4</div><div>INC HL</div><div>Increment the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>00A5</div><div>INC HL</div><div>Increment the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>00A6-00A7</div><div><a href="#00A1H" class="memory-link">DJNZ 00A1H</a></div><div>Loop back to 00A1 until all 28 of the DOS links have been set to RETs.</div></div>
								</div>
							</div>

							<br><h2 id="001BH">001B-001F - VIDEO AND PRINTER ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*00A8-00AA</div><div>LD HL,43E8H</div><div>Load register pair HL with the starting address of user RAM (which is 42E8H).<br>Difference
 between M1 and M3: The instruction starting at 00A8H loads HL with 
42E8H in the Model I, 43E8H in the Model II I. This memory location is 
then zeroed (BASIC programs begin at the FOLLOWING memory location in 
non-disk systems).</div></div>
									<div class="assembly-row-combined model1"><div>00AB</div><div>LD (HL),B</div><div>Zero 42E8H (i.e., the location of the memory pointer in register pair HL).</div></div>
									<div class="assembly-row-combined model3"><div>*00AC-00AE</div><div>LD SP,42F8H</div><div>Load register pair HL with the starting address of user RAM (which is 42E8H).<br>Difference
 between M1 and M3: The instruction starting at 00A8H loads HL with 
42E8H in the Model I, 43E8H in the Model II I. This memory location is 
then zeroed (BASIC programs begin at the FOLLOWING memory location in 
non-disk systems).</div></div>
									<div class="assembly-row-combined model1"><div>00AF-00B1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#1B8FH" class="memory-link">CALL 1B8FH</a></div><div>GOSUB to 1B8FH to initialize the Level II BASIC variables and pointers.</div></div>
									<div class="assembly-row-combined model3"><div>*00B2-00B4</div><div>NOP<br>NOP<br>NOP</div><div>Difference
 between M1 and M3: In the Model I, a CALL to 01C9H (the "clear screen" 
routine) in located here (just prior to printing the "MEMORY SIZE?" 
prompt on the video display). In the Model III this has been replaced by
 three zero bytes (NOPs).</div></div>
									<div class="assembly-row-combined model1" id="00B5H"><div>00B5-00B7</div><div>LD HL,0105H</div><div>Load register pair HL with the starting address of the MEMORY SIZE? message.</div></div>
									<div class="assembly-row-combined model1"><div>00B8-00BA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#28A7H" class="memory-link">CALL 28A7H</a></div><div>We need to display the MEMORY SIZE? prompt so we must call the WRITE MESSAGE routine at 28A7H.<br><span class="bold">NOTE:</span><ul><li>The routine at 28A7 displays the message pointed to by HL on current system output device (usually video).</li><li>The string to be displayed must be terminated by a byte of machine zeros or a carriage return code 0D.</li><li>If terminated with a carriage return, control is returned to the caller after taking the DOS exit at 41D0H (JP 5B99H).</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>00BB-00BD</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#1BB3H" class="memory-link">CALL 1BB3H</a></div><div>Print a <span class="code">?</span> and get input from the keyboard.</div></div>
									<div class="assembly-row-combined model1"><div>00BE-00BF</div><div><a href="#00B5H" class="memory-link">JR C,00B5H</a></div><div>If the <kbd>BREAK</kbd> key was pressed (because the CARRY FLAG was set), ask again.</div></div>
									<div class="assembly-row-combined model1"><div>00C0</div><div>RST 10H</div><div>Since
 we now need to increment the input buffer pointer until it points to 
the first character of the input, call the EXAMINE NEXT SYMBOL routine 
at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>00C1</div><div>OR A</div><div>Set
 the status flag based on if the character at the location of the input 
buffer pointer in register A is an end of the input character (00H).</div></div>
									<div class="assembly-row-combined model1"><div>00C2-00C3</div><div><a href="#00D6H" class="memory-link">JR NZ,00D6H</a></div><div>JUMP
 forward to 00D6H (to skip the next instructions which attempt to 
calculate the memory size) if there was a response to the MEMORY SIZE? 
question.</div></div>
									<div class="assembly-row-combined model3"><div>*00C4-00C6<span class="origrom2">MEMSIZ</span></div><div>LD HL,444CH</div><div>If we are here then just an <kbd>ENTER</kbd>
 was hit in response to the MEMORY SIZE? question, so we need to figure 
it out dynamically, so load register pair HL with the starting address 
for the memory size check.Difference between M1 and M3: The instruction 
starting at 00C4H loads HL with 434CH in the Model I, 444CH in the Model
 III. If only "ENTER" was pressed in response to the "MEMORY SIZE?" 
prompt, a memory test is initiated starting at the location pointed to 
by HL, and continuing upward until the end of memory (or a bad memory 
location) is reached.</div></div>
									<div class="assembly-row-combined model1"><div>00C7</div><div>INC HL</div><div>We are going to start testing RAM at 444DH (Decimal: 17485) toward 65535, so increment the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>00C8-00C9</div><div>LD A,H<br>OR L</div><div>The
 easiest way to test a 2 byte register for zero is to load the MSB into A
 and then OR it with the LSB.  if the MSB was 0 and the LSB was 0, then A
 will be 0.  So ... first, load register A with the MSB of the current 
memory pointer in register H.</div></div>
									<div class="assembly-row-combined model1"><div>00CA-00CB</div><div><a href="#00E7H" class="memory-link">JR Z,00E7H</a></div><div>If HL has gone all the way up to 0000H (which means the last test tested 65535), JUMP to out of this testing routine to 00E7H.</div></div>
									<div class="assembly-row-combined model1"><div>00CC</div><div>LD A,(HL)</div><div>Load register A with the value at the location of the current memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>00CD</div><div>LD B,A</div><div>Load register B with the value in register A to preserve it, as A is about to get used.</div></div>
									<div class="assembly-row-combined model1"><div>00CE</div><div>CPL</div><div>Complement the value in register A (which is basically a test pattern).</div></div>
									<div class="assembly-row-combined model1"><div>00CF</div><div>LD (HL),A</div><div>Save the test pattern in register A to the location of the current memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>00D0</div><div>CP (HL)</div><div>Check to see if the value at the location of the memory pointer in register pair HL is the same as the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>00D1</div><div>LD (HL),B</div><div>Put back the original memory value (which was saved in B) to the location of the memory pointed in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>00D2-00D3</div><div><a href="#00C7H" class="memory-link">JR Z,00C7H</a></div><div>If the address exists, loop back to 00C7H until the end of memory is found.</div></div>
									<div class="assembly-row-combined model1"><div>00D4-00D5</div><div><a href="#00E7H" class="memory-link">JR 00E7H</a></div><div>If the address didn't exist, jump to 00E7H (which goes to he next address and tries again).</div></div>
									<p class="debug-note" id="00D6H">00D6 - Interpret the MEMORY 
SIZE response (whether it was actual via a JUMP from 00C2H or determined
 via a pass through), and do a memory test.</p>
									<div class="assembly-row-combined model1"><div>00D6-00D8</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#1E5AH" class="memory-link">CALL 1E5AH</a></div><div>Here
 the MEMORY SIZE? answer is in HL so call the ASCII TO INTEGER routine 
at 1E5AH (which will put the answer into DE in integer format).<br><b>NOTE:</b>
 The routine at 1E5A converts the ASCII string pointed to by HL to an 
integer deposited into DE.  If the routine finds a non-numerica 
character, the conversion is stopped.</div></div>
									<div class="assembly-row-combined model1"><div>00D9</div><div>OR A</div><div>Set the FLAGS based on A.</div></div>
									<div class="assembly-row-combined model1"><div>00DA-00DC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#1997H" class="memory-link">JP NZ,1997H</a></div><div>Display a <span class="code">?SN ERROR</span> if register A is not equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>00DD</div><div>EX DE,HL</div><div>Swap
 DE (where the integer version of the MEMORY SIZE? answer is located) 
and HL, so that register pair HL now has with the MEMORY SIZE answer 
again, but in integer format.</div></div>
									<div class="assembly-row-combined model1"><div>00DE</div><div>DEC HL</div><div>Decrement the MEMORY SIZE? in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>00DF-00E0</div><div>LD A,8FH</div><div>Load register A with a memory test value of 8FH (Binary: 1000 1111).</div></div>
									<div class="assembly-row-combined model1"><div>00E1</div><div>LD B,(HL)</div><div>Load register B with the value at the location of the MEMORY SIZE? pointer in register pair HL (to save the data thats there).</div></div>
									<div class="assembly-row-combined model1"><div>00E2</div><div>LD (HL),A</div><div>Put the test pattern (in A which is 8FH) into that the location of the MEMORY SIZE? pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>00E3</div><div>CP (HL)</div><div>Check to see if the value in the memory location set in HL matches the test pattern in A.</div></div>
									<div class="assembly-row-combined model1"><div>00E4</div><div>LD (HL),B</div><div>Restore the old memory contents back.</div></div>
									<div class="assembly-row-combined model1"><div>00E5-00E6</div><div><a href="#00B5H" class="memory-link">JR NZ,00B5H</a></div><div>The test at MEMORY SIZE? -1 failed so we have to ask MEMORY SIZE again by jumping to 00B5H.</div></div>
									<div class="assembly-row-combined model1"><div>00E7</div><div>DEC HL</div><div>Decrement the memory size pointer in register pair HL, so it is the amount of memory - 2.</div></div>
									<div class="assembly-row-combined model3"><div>*00E8-00EA</div><div>LD DE,4514H</div><div>Load register pair DE with the minimum MEMORY SIZE? response (held at 4514H).<br>Difference
 between M1 and M3: The instruction starting at 00E8H loads DE with 
4414H in the Model I and 4514H in the Model III. This is the minimum 
"MEMORY SIZE" that can be specified by the user.</div></div>
									<div class="assembly-row-combined model1"><div>00EB</div><div>RST 18H</div><div>Now
 we need to check to see if the MEMORY SIZE? pointer (in HL) is less 
than the minimum MEMORY SIZE? response (in DE), so we call the COMPARE 
DE:HL routine, which numerically compares DE and HL. Will not work for 
signed integers (except positive ones). Uses the A-register only. The 
result of the comparison is returned in the status register as:  <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>00EC-00EE</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#197AH" class="memory-link">JP C,197AH</a></div><div>If
 C is set, then the amount of actual memory (in HL) is less than the 
minimum memory required (in DE), so we have to go to the Level II BASIC 
error routine and display an OM ERROR.</div></div>
									<div class="assembly-row-combined model1"><div>00EF-00F1</div><div>LD DE,FFCEH</div><div>Load register pair DE with the default size of the string area (i.e., negative fifty).</div></div>
									<div class="assembly-row-combined model1"><div>00F2-00F4</div><div>LD (40B1H),HL</div><div>Save the MEMORY SIZE? amount (which is in HL) to 40B1H (which holds the MEMORY SIZE? pointer).</div></div>
									<div class="assembly-row-combined model1"><div>00F5</div><div>ADD HL,DE</div><div>Subtract the size of the string data (which was -50) from the highest memory address (stored in HE).</div></div>
									<div class="assembly-row-combined model1"><div>00F6-00F8</div><div>LD (40A0H),HL</div><div>Save the start of string space pointer (which is now held register pair HL) to 40A0H.<br><b>NOTE:</b> 40A0H-40A1H holds the start of string space pointer.</div></div>
									<div class="assembly-row-combined model1"><div>00F9-00FB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#1B4DH" class="memory-link">CALL 1B4DH</a></div><div>Go initialize/reset the Level II BASIC variables and pointers.</div></div>
									<div class="assembly-row-combined model1"><div>00FC-00FE</div><div>LD HL,0111H</div><div>Load
 register pair HL with the starting address of the RADIO SHACK LEVEL II 
BASIC message. 00FF-0101H Go display the RADIO SHACK LEVEL II BASIC 
message.</div></div>

									<div class="assembly-row-combined model3 nodurda" id="00FFH"><div>*00FF</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-4.htm#37EBH" class="memory-link">JP 37EBH</a> or CALL 021BH</div><div>Different ROM Versions handle this differently.  Both will display the message pointed to by HL.<br>Difference
 between M1 and M3: The instruction previous to this loads HL with the 
starting address of the opening message ("RADIO SHACK..."). In the Model
 I, a CALL to 28A7H (the "display message" routine) is stored here, 
while in the Model III this has been changed to a jump to 37EBH.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0102</div><div><a href="#01E7H" class="memory-link">JP 01E7H</a></div><div>If
 the ROM used the JUMP command in the prior instruction, we won't get 
here.  Otherwise, jump to 01E7H (which seems odd since it is jumping 
right in the middle of the print screen routine).</div></div>

									<div class="assembly-row-combined model3 durda" id="00FFH"><div>*00FF</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#021BH" class="memory-link">CALL 021BH</a> or CALL 021BH</div><div>GOSUB to 021BH to display the message pointed to by HL.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0102</div><div><a href="#01E6H" class="memory-link">JP 01E6H</a></div><div>If
 the ROM used the JUMP command in the prior instruction, we won't get 
here.  Otherwise, jump to 01E7H (which seems odd since it is jumping 
right in the middle of the print screen routine).</div></div>
								</div>
							</div>

							<br><h2 id="0105H">0105 - "MEMORY SIZE" Storage Area<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0105</div><div>"MEMORY SIZE" + 00H</div><div>MEMORY SIZE message storage area.<br>Difference between M1 and M3: "EMORY" changed to "emory" and "IZE" changed to "ize".</div></div>
								</div>
							</div>

							<br><h2 id="0111H">0111 - "RADIO SHACK MODEL-III BASIC" Storage Area<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0111</div><div>"RADIO SHACK MODEL-III BASIC" + 0DH</div><div>RADIO SHACK MODEL-III BASIC message storage area.<br>Difference between M1 and M3: "ADIO" changed to "adio", "HACK" changed to "hack", "LEVEL" changed to "Model", etc.</div></div>
								</div>
							</div>

							<br><h2 id="012DH">012D-0131 - ?L3 ERROR ROUTINE - "L3ERR"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>012D-012E</div><div>LD E,2CH</div><div>Load register E with the <span class="code">?L3 ERROR</span> code of 2CH.</div></div>
									<div class="assembly-row-combined model1"><div>012F-0131</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#19A2H" class="memory-link">JP 19A2H</a></div><div>Go to the Level II BASIC error routine with 2CH loaded into Register E.</div></div>
								</div>
							</div>

							<br><h2 id="0132H">0132-0134 - LEVEL II BASIC "<span class="code">POINT</span>" COMMAND ENTRY POINT<br><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0132</div><div>RST 10H</div><div>Since
 we need to bump the current BASIC program pointer until it points to 
the next character, call the EXAMINE NEXT SYMBOL routine at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>0133</div><div>XOR A</div><div>A will wind up being 0 if the <span class="code">POINT</span> command was entered ... otherwise.</div></div>
									<div class="assembly-row-combined model1" id="0134H"><div>0134</div><div>013E80</div><div>Z-80
 Trick! The byte at this memory location, 01H, is there to turn the real
 instruction that follows (the operative action of the SET command) into
 a harmless LD BC,xxxx.  This way, they didn't have to jump over SET or 
RESET to get to the common graphics code.  If parsing straight down, 
this loads BC with 0380H and then moves to 0136H.  But if jump straight 
to 0136H, you skip that 01H opcode, and get a real instruciton of 3EH 
80H.</div></div>
								</div>
							</div>

							<br><h2 id="0135H">0135-0137 - LEVEL II BASIC <span class="code">SET</span> COMMAND ENTRY POINT<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0135-0136</div><div>LD A,80H</div><div>Load register A with 80H (Decimal:1 28) which is <span class="code">SET</span>.</div></div>
									<div class="assembly-row-combined model1"><div>0136</div><div>1A</div><div>Z-80 Trick - See the note at 0134H for an explanation.</div></div>
								</div>
							</div>

							<br><h2 id="0138H">0138-0139 - LEVEL II BASIC <span class="code">RESET</span> COMMAND ENTRY POINT - "RESET"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0138-0139</div><div>LD A,01H</div><div>Load register A with 01H which is <span class="code">RESET</span>.</div></div>
								</div>
							</div>

							<br><h2 id="013AH">013A-019CH GRAPHICS ROUTINE - "GRAPH"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Common code for <span class="code">SET</span>/<span class="code">RESET</span>/<span class="code">POINT</span> - A will be 0 if <span class="code">POINT</span>, 80H if <span class="code">SET</span> and 1 for <span class="code">RESET</span>.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>013A</div><div>PUSH AF</div><div>Save the graphics mode in register A on the STACK so we can use A for other things.</div></div>
									<div class="assembly-row-combined model1"><div>013B-013C</div><div>RST 08H ‚áí  28H</div><div>Since <span class="code">SET</span>/<span class="code">RESET</span>/<span class="code">POINT</span>
 all need a "(" to start with, call the COMPARE SYMBOL routine which 
comparess the symbol in the input string pointed to by HL register to 
the value in the location following the RST 08 call.  If there is a 
match, control is returned to address of the RST 08 instruction 2 with 
the next symbol in the Register A and HL incremented by one. If the two 
characters do not match, a syntax error message is given and control 
returns to the Input Phase).</div></div>
									<div class="assembly-row-combined model1"><div>013D-013F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2B1CH" class="memory-link">CALL 2B1CH</a></div><div>Go
 evaluate the expression at the location of the current BASIC program 
pointer in register pair HL (which is the X variable) and return with 
the 8-bit value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0140-0141</div><div>CP 80H</div><div>Check to see if the X value in register A is greater than 80H (Decimal: 128) by testing A-80H.  Results:<ul><li>If A=80H it sets the ZERO FLAG</li><li>If A&lt;80H then the CARRY FLAG will be set</li><li>If A&gt;=80H then the NO CARRY FLAG will be set</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>0142-0144</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#1E4AH" class="memory-link">JP NC,1E4AH</a></div><div>If A is greater than 128, go to 1E4AH to display a <span class="code">?FC ERROR</span>.</div></div>
									<div class="assembly-row-combined model1"><div>0145</div><div>PUSH AF</div><div>Save the X value in register A on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0146-0147</div><div>RST 08H ‚áí  ","</div><div>At this point we have <span class="code">SET</span>/<span class="code">RESET</span>/<span class="code">POINT</span>, an open parenthesis, and an X variable, so now we must find a <span class="code">,</span>.
  To do this call the COMPARE SYMBOL routine which comparess the symbol 
in the input string pointed to by HL register to the value in the 
location following the RST 08 call.  If there is a match, control is 
returned to address of the RST 08 instruction 2 with the next symbol in 
the Aregister and HL incremented by one. If the two characters do not 
match, a syntax error message is given and control returns to the Input 
Phase).</div></div>
									<div class="assembly-row-combined model1"><div>0148-014A</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2B1CH" class="memory-link">CALL 2B1CH</a></div><div>Go
 evaluate the expression at the location of the current BASIC program 
pointer in register pair HL (which is the Y variable) and return with 
the 8-bit value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>014B-014C</div><div>CP 30H</div><div>Check to see if the Y value in Register A is greater than 47</div></div>
									<div class="assembly-row-combined model1"><div>014D-014F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#1E4AH" class="memory-link">JP NC,1E4AH</a></div><div>If the Y value is greater than 48, display a <span class="code">?FC ERROR</span> by JUMPing to 1E4AH.</div></div>
									<p class="debug-note" id="0150H">At this point, we have valid cordinates of X &lt;= 128 and a Y &lt;= 47.</p>
									<div class="assembly-row-combined model1"><div>0150-0151<span class="origrom2">SETRES</span></div><div>LD D,FFH</div><div>Prepare
 to divide Y coordinate by 3 ... load register D with starting quotient 
of FFH (which will turn into 00 once it enters the loop).</div></div>
									<p class="debug-note" id="0152H">These next few instructions 
divide the "Y" coordinate by subtraction.  It will keep subtracting 3 
(and tracking the number of times it does that in D) until the CARRY 
FLAG gets set, and then will add 3 to get the remainder.</p>
									<div class="assembly-row-combined model1"><div>0152</div><div>INC D</div><div>Increment the quotient in register D.</div></div>
									<div class="assembly-row-combined model1"><div>0153-0154</div><div>SUB 03H</div><div>Divide by subtraction ... subtract 3 from register A.</div></div>
									<div class="assembly-row-combined model1"><div>0155-0156</div><div><a href="#0152H" class="memory-link">JR NC,0152H</a></div><div>Loop
 back to 0152H to subtract again until we get to a subtraction where the
 CARRY FLAG gets set.  At that point, register D equals the Y value 
divided by 3 and we know we can't divide by 3 anymore.</div></div>
									<div class="assembly-row-combined model1"><div>0157-0158</div><div>ADD 03H</div><div>Add 3 to Register A so then we have the remainder.</div></div>
									<div class="assembly-row-combined model1"><div>0159</div><div>LD C,A</div><div>Save the remainder (in Register A) to Register C.</div></div>
									<p class="debug-note" id="015AH">These next few instructions 
fetch the "X" coordinate and do fun math to it together with the "Y" 
results go get a video memory offset for the graphic.</p>
									<div class="assembly-row-combined model1"><div>015A</div><div>POP AF</div><div>Get the X value from the STACK and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>015B</div><div>ADD A,A</div><div>Multiply the X value in Register A by two, storing the result in Register A</div></div>
									<div class="assembly-row-combined model1"><div>015C</div><div>LD E,A</div><div>Load Register E with the newly doubled Register A</div></div>
									<div class="assembly-row-combined model1"><div>015D-015E</div><div>LD B,02H</div><div>Load register B with the number of times to shift register pair DE (which is 2).</div></div>
									<div class="assembly-row-combined model1"><div>015F</div><div>LD A,D</div><div>Load Register A with the adjusted Y value in Register D</div></div>
									<div class="assembly-row-combined model1"><div>0160</div><div>RRA</div><div>Divide the adjusted Y value in register A by two.</div></div>
									<div class="assembly-row-combined model1"><div>0161</div><div>LD D,A</div><div>Save the new Y value in register A in register D.</div></div>
									<div class="assembly-row-combined model1"><div>0162</div><div>LD A,E</div><div>Load register A with the adjusted X value in register E.</div></div>
									<div class="assembly-row-combined model1"><div>0163</div><div>RRA</div><div>Divide the adjusted X value in register A by two.</div></div>
									<div class="assembly-row-combined model1"><div>0164</div><div>LD E,A</div><div>Load register E with the new X value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0165-0166</div><div><a href="#015FH" class="memory-link">DJNZ 015FH</a></div><div>Loop until the memory offset in register pair DE has been figured.</div></div>
									<div class="assembly-row-combined model1"><div>0167</div><div>LD A,C</div><div>Now we need to compute the position of the point so load register A with the value in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0168</div><div>ADC A,A</div><div>Multiply the value in register A by two and add the value of the CARRY FLAG to register A.</div></div>
									<div class="assembly-row-combined model1"><div>0169</div><div>INC A</div><div>Increment the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>016A</div><div>LD B,A</div><div>Save the bit position in register A in register B.</div></div>
									<div class="assembly-row-combined model1"><div>016B</div><div>XOR A</div><div>Zero register A and reset the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>016C</div><div>SCF</div><div>Set the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>016D</div><div>ADC A,A</div><div>Multiply the value in register A by two and add the value of the CARRY FLAG to register A.</div></div>
									<div class="assembly-row-combined model1"><div>016E-016F</div><div><a href="#016DH" class="memory-link">DJNZ 016DH</a></div><div>Loop to the prior instruction until the graphic mask has been completed in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0170</div><div>LD C,A</div><div>Save the graphic mask in register A in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0171</div><div>LD A,D</div><div>Load register A with the MSB of the video memory offset in register D.</div></div>
									<div class="assembly-row-combined model1"><div>0172-0173</div><div>OR 3CH</div><div>Set
 the bits of the MSB of the video memory offset in register A to turn on
 Bits 2, 3, 4, and 5 (3H = Decimal: 0011 1100) so that it will point to 
the correct location in video memory.  The only possible resulting 
values are 3CH-3FH, 7CH-7FH, BCH-BFH, and FCH-FFH.</div></div>
									<div class="assembly-row-combined model1"><div>0174</div><div>LD D,A</div><div>Save the revised MSB of the video memory pointer in register A in register D.</div></div>
									<p class="debug-note" id="0175H">We now have the location in 
video memory for the graphic character.  Since SET/RESET/POINT use the 
graphic ASCII character rather than plotting dots, we first need to make
 sure there is at least a graphic character already at the location.</p>
									<div class="assembly-row-combined model1"><div>0175</div><div>LD A,(DE)</div><div>Load register A with the character at the location of the video memory pointer in register pair DE.</div></div>
									<p class="debug-note" id="0176H">The following code is bugged. 
 What it is supposed to do is see if the character on the screen in the 
location to be modified is already a graphic, to build upon, or not, to 
erase and then build.  It does this by checking to see if the character 
is ‚â•128, which is fine for the Model I.  But on the Model III, there are
 valid characters above 192, and if one of those is present, it thinks 
its a graphic character and just flips bits, changing the character but 
not actually putting up a graphic.</p>
									<div class="assembly-row-combined model1"><div>0176</div><div>OR A</div><div>Set
 the flags.  To help with the next instruction here are a few pointers. 
 The lowest graphic character on the TRS-80 is 80H (Decimal: 128; 
Binary: 1000 0000).  When dealing with bits, a high bit 7 is also 
utilized to check the sign of something </div></div>
									<div class="assembly-row-combined model1"><div>0177-0179</div><div><a href="#017CH" class="memory-link">JP M,017CH</a></div><div>If
 the character at (DE) has the sign bit HIGH, it is a graphic character,
 so skip the next opcode if the character in register A is a graphic 
character.</div></div>
									<div class="assembly-row-combined model1"><div>017A-017B</div><div>LD A,80H</div><div>Load register A with a blank graphic character which is CHR$(128).</div></div>
									<div class="assembly-row-combined model1"><div>017C</div><div>LD B,A</div><div>Save the graphic character (held in Register A) into Register B.</div></div>
									<div class="assembly-row-combined model1"><div>017D</div><div>POP AF</div><div>Get the graphic character from the STACK (Register B) and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>017E</div><div>OR A</div><div>Set the flags according to the graphic mode in register A.</div></div>
									<div class="assembly-row-combined model1"><div>017F</div><div>LD A,B</div><div>Get the graphic character from register B and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0180-0181</div><div><a href="#0192H" class="memory-link">JR Z,0192H</a></div><div>JUMP forward to 0192H if the graphic mode is <span class="code">POINT</span>.</div></div>
									<p class="debug-note" id="0182H">If we are here, then we are dealing with either <span class="code">SET</span> or <span class="code">RESET</span>, as we would have jumped away in the prior instruction if it was the only other possible alternative, <span class="code">POINT</span>.</p>
									<div class="assembly-row-combined model1"><div>0182</div><div>LD (DE),A</div><div>Save the graphic character in register A at the location of the video memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0183-0185</div><div><a href="#018FH" class="memory-link">JP M,018FH</a></div><div>JUMP forward to 018FH if the graphic mode is <span class="code">SET</span>.</div></div>
									<p class="debug-note" id="0182H">If we are here, then we are dealing with <span class="code">RESET</span>, as we would have jumped away otherwise.</p>
									<div class="assembly-row-combined model1"><div>0186</div><div>LD A,C</div><div>Load register A with the graphic mask in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0187</div><div>CPL</div><div>Reverse the graphic mask in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0188</div><div>LD C,A</div><div>Load register C with the adjusted graphic mask in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0189</div><div>LD A,(DE)</div><div>Load register A with the character at the location of the video memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>018A</div><div>AND C</div><div>RESET the graphic bit by combining the graphic mask in register C with the graphic character in register A.</div></div>
									<p class="debug-note" id="018BH">Inside the <span class="code">RESET</span>
 routine.  This is common code though.  It will just put the graphic 
character, representing the SET or RESET (held in A) onto the screen (at
 the location held in DE).</p>
									<div class="assembly-row-combined model1"><div>018B</div><div>LD (DE),A</div><div>Save the adjusted graphic character in register A at the location of the video memory pointer in register pair DE.</div></div>
									<p class="debug-note" id="0182H">Inside the <span class="code">RESET</span>
 routine.  The character has been displayed (if a character was to be 
displayed), but we still need to make sure that we had proper syntax, so
 next we check for the close parenthesis and RETURN if we have it or 
ERROR if we do not.</p>
									<div class="assembly-row-combined model1"><div>018C-018D</div><div>RST 08 ‚áí  ")"</div><div>We need to check HL against 29H (ASCII: <span class="code">)</span>)
 so we call the COMPARE SYMBOL routine which comparess the symbol in the
 input string pointed to by HL register to the value in the location 
following the RST 08 call.  If there is a match, control is returned to 
address of the RST 08 instruction 2 with the next symbol in the 
Aregister and HL incremented by one. If the two characters do not match,
 a syntax error message is given and control returns to the Input 
Phase).</div></div>
									<div class="assembly-row-combined model1"><div>018E</div><div>RET</div><div>Return.</div></div>

									<p class="debug-note" id="018FH">Inside the <span class="code">SET</span> routine.  All this does is change the character accordingly and then jump back up into <span class="code">RESET</span> where it displays the character, checks for the <span class="code">)</span> and RETurns.</p>
									<div class="assembly-row-combined model1"><div>018F</div><div>OR C</div><div>SET the graphic bit by combining the graphic mask in register C with the graphic character in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0190-0191</div><div><a href="#018BH" class="memory-link">JR 018BH</a></div><div>JUMP back a few bytes to 018BH.</div></div>

									<p class="debug-note" id="0192H">Next is the <span class="code">POINT</span> routine.</p>
									<div class="assembly-row-combined model1"><div>0192</div><div>AND C</div><div>POINT the graphic bit by combining the graphic mask in register C with the graphic character in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0193-0194</div><div>ADD FFH</div><div>Subtract one from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0195</div><div>SBC A,A</div><div>Adjust the value in register A so that A will equal zero if the bit was off in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0196</div><div>PUSH HL</div><div>Save the current BASIC program pointer in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0197-0199</div><div><a href="#098DH" class="memory-link">CALL 098DH</a></div><div>Save the value in register A as the current result in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>019A</div><div>POP HL</div><div>Get the current BASIC program pointer from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>019B-019C</div><div><a href="#018CH" class="memory-link">JR 018CH</a></div><div>JUMP to 018CH.</div></div>
								</div>
							</div>

							<br><h2 id="019DH">019D-01C8 - LEVEL II BASIC - "INKEY" - <span class="code">INKEY$</span> ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>019D</div><div>RST 10H</div><div>Since
 we need to bump the current BASIC program pointer in register pair HL 
until it points to the next character, call the EXAMINE NEXT SYMBOL 
routine at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>019E</div><div>PUSH HL</div><div>Save the current BASIC program pointer in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>019F-01A1</div><div>LD A,(4099H)</div><div>Put the last key pressed (stored at 4099H) into Register A.</div></div>
									<div class="assembly-row-combined model1"><div>01A2</div><div>OR A</div><div>Set the status flags.</div></div>
									<div class="assembly-row-combined model1"><div>01A3-01A4</div><div><a href="#01ABH" class="memory-link">JR NZ,01ABH</a></div><div>JUMP to 01ABH (to skip the next character scan) if a key has been pressed.</div></div>
									<div class="assembly-row-combined model1"><div>01A5-01A7</div><div><a href="#0358H" class="memory-link">CALL 0358H</a></div><div>GOSUB to 0358H to scan the keyboard.</div></div>
									<div class="assembly-row-combined model1"><div>01A8</div><div>OR A</div><div>Set the status flags.</div></div>
									<div class="assembly-row-combined model1"><div>01A9-01AA</div><div><a href="#01BCH" class="memory-link">JR Z,01BCH</a></div><div>JUMP down to 01BCH if a key wasn't pressed.</div></div>
									<p class="debug-note">If we are here, a key was pressed and it has been stored in Register A</p>
									<div class="assembly-row-combined model1"><div>01AB</div><div>PUSH AF</div><div>Save the key pressed in register A on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>01AC</div><div>XOR A</div><div>Zero register A and clear the status flags.</div></div>
									<div class="assembly-row-combined model1"><div>01AD-01AF</div><div>LD (4099H),A</div><div>Save the value in register A to (4099H).<br><b>NOTE:</b> 4099H holds the last key pressed.</div></div>
									<div class="assembly-row-combined model1"><div>01B0</div><div>INC A</div><div>Increment the value in register A (which is going to represet the size of the character string to be built).</div></div>
									<div class="assembly-row-combined model1"><div>01B1-01B3</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2857H" class="memory-link">CALL 2857H</a></div><div>Make sure there is room for this character string by calling 2857H to make an entry in string space.</div></div>
									<div class="assembly-row-combined model1"><div>01B4</div><div>POP AF</div><div>Get the last key pressed from the STACK and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>01B5-01B7</div><div>LD HL,(40D4H)</div><div>Load register pair HL with the string's starting address (which is kept in 40D4H).</div></div>
									<div class="assembly-row-combined model1"><div>01B8</div><div>LD (HL),A</div><div>Save the last key pressed in register A at the location of the string pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>01B9-01BB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2884H" class="memory-link">JP 2884H</a></div><div>Go save the string's VARPTR as the current result.</div></div>
									<div class="assembly-row-combined model1"><div>01BC-01BE</div><div>LD HL,1928H</div><div>Load register pair HL with the starting address of the "READY" message (which is stored at 1928H).</div></div>
									<div class="assembly-row-combined model1"><div>01BF-01C1</div><div>LD (4121H),HL</div><div>Save the address in register pair HL as the current result in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>01C2-01C3</div><div>LD A,03H</div><div>Load register A with a string number type flag.</div></div>
									<div class="assembly-row-combined model1"><div>01C4-01C6</div><div>LD (40AFH),A</div><div>Save the value in register A as the current number type.<br><b>Note:</b> 40AFH holds the current number's type flag as follows:<ul><li>2: Integer</li><li>3: String</li><li>4: Single precision</li><li>8: Double precision</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>01C7</div><div>POP HL</div><div>Get the current BASIC program pointer from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>01C8</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="01C9H">01C9-01D2 - "$VDCLS" - Clear the video display screen.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>A CALL lC9H will clear the screen, select 64 characters and home the cursor. All registers are used.</p>
								<p>To use a ROM call to clear the screen, CALL 01C9H. The cursor is reset to the home position, which is 3C00H.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>01C9-01CA<span class="origrom2">$VDCLS</span></div><div>LD A,1CH</div><div>Load register A with the ASCII character to home the cursor.</div></div>
									<div class="assembly-row-combined model1"><div>01CB-01CD</div><div><a href="#033AH" class="memory-link">CALL 033AH</a></div><div>GOSUB to 033AH to send the character in register A (i.e., the ASCII character to home the cursor) to the video display.</div></div>
									<div class="assembly-row-combined model1"><div>01CE-01CF</div><div>LD A,1FH</div><div>Load register A with the ASCII character to clear to the end of the screen.</div></div>
									<div class="assembly-row-combined model1"><div>01D0-01D2</div><div><a href="#033AH" class="memory-link">JP 033AH</a></div><div>JUMP
 to 033AH to send the character in register A (i.e., the ASCII character
 to clear to the end of the screen) to the video display.  By JUMPing 
intead of CALLing, the RET in that routine will act as the RET for this 
routine.</div></div>
								</div>
							</div>

							<br><h2 id="01D3H">01D3-01D8 - LEVEL II BASIC RANDOM ROUTINE - "<span class="code">RANDOM</span>"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is part of the <span class="code">RANDOM</span> routine which takes a value out of the REFRESH register, stores it in location 40ABH and then returns.<br>A call to 01D3H reseeds the random number seed (location 40AB) with the current contents of the refresh register.</p>
								<p>NOTE: To run a RANDOM (seed the random number generator) via a
 ROM call just call CALL 01D3H.  This causes the contents of R (memory 
refresh) to be stored in 40ABH.  The entire 24 bit seed is stored in 
40AAH-40ACH.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>01D3</div><div>LD A,R</div><div>Load register A with the current value of the refresh register.</div></div>
									<div class="assembly-row-combined model1"><div>01D5-01D7</div><div>LD (40ABH),A</div><div>Save the value of the refresh register, as a pseudi-random value, to memory location 40ABH (the random number seed).</div></div>
									<div class="assembly-row-combined model1"><div>01D8</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 class="assembly-section-title nodurda" id="01D9">*01D9-01F7H- Print Screen Routine - "$PRSCN"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<p>This routine copies all 1024 characters from the screen to the
 printer.  If the printer is unavailable, this routine waits until the 
printer becomes available.  If BREAK is pressed, this routine returns to
 the caller.</p>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3 nodurda"><div>*01D9<span class="origrom2">PRSCN</span></div><div>LD HL,3C00H</div><div>Load HL with the memory location for the beginning of the video RAM.<br>Difference
 between M1 and M3: The routine to print the contents of the screen on 
the line printer is located from 01D9H to 01F4H on the Model III. On the
 Model I, 01D9H - 01F7H contains the routine to output one bit to the 
cassette.</div></div>
									<div class="assembly-row-combined model3 nodurda" id="01DCH"><div>*01DC</div><div>LD A,(HL)</div><div>Load HL with the memory location for the beginning of the video RAM.<br>Difference
 between M1 and M3: The routine to print the contents of the screen on 
the line printer is located from 01D9H to 01F4H on the Model III. On the
 Model I, 01D9H - 01F7H contains the routine to output one bit to the 
cassette.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*01DD</div><div>CP 80H</div><div>Check
 A against 80H, which represets the lowest graphic character.  If A &lt;
 80H then the character is NOT graphic and the the CARRY will be set.  
Otherwise NC is set to show that the character is a graphic character.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*01DF</div><div><a href="#01E3H" class="memory-link">JR C,01E3H</a></div><div>If the CARRY FLAG is set, we have a non-graphic characters, so skip the next instruction.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*01E1</div><div>LD A,2EH</div><div>Overwrite the current character held in Register A with a <span class="code">.</span>, so that all graphic characters are printed as <span class="code">.</span>'s.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*01E3</div><div><a href="#003BH" class="memory-link">CALL 003BH</a></div><div>Call the PRINT CHARACTER routine at 003BH (which sends the character in the A register to the printer).</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*01E6</div><div>INC HL</div><div>Bump HL to the next character on the screen.</div></div>
									<div class="assembly-row-combined model3 nodurda" id="01E7H"><div>*01E7</div><div>BIT 6,H</div><div>Check
 the 6th Bit in H to see if we are at the end of the line (meaning that H
 is now 64; 1 character beyond the 63 maximum per lime).</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*01E9</div><div><a href="#0214H" class="memory-link">JR NZ,0214H</a></div><div>If we are at 64, then JUMP to 0214H for a new line.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*01EB</div><div>LD A,L</div><div>Overwrite the current character held in Register A with a <span class="code">.</span>, so that all graphic characters are printed as <span class="code">.</span>'s.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*01EC</div><div>AND 03FH</div><div>AND
 the contents of A with 3FH (Binary: 00111111) to turn off Bits 7 and 6,
 making the maximum number A can be 3FH (Decimal: 63).</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*01EE</div><div>JR NZ,01DCH</div><div>If we are at 64, then JUMP to 0214H for a new line.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*01F0</div><div><a href="#0214H" class="memory-link">CALL 0214H</a></div><div>GOSUB to 0214H for a new line.<br>Difference between M1 and M3: 01F0H contains CALL 0221H instruction on Model I, and CALL 0214H instruction on Model III.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*01F3</div><div>JR 01DCH</div><div>Loop back to 01DCH for the next character.<br>Difference between M1 and M3: Contains LD B,5CH instruction on Model I, JR 01DCH instruction on Model III.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*01F5</div><div><a href="#00FEH" class="memory-link">DJNZ 00FEH</a></div><div>UNUSED</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*01F7</div><div>RET</div><div>Return</div></div>
								</div>
							</div>

							<br><h2 class="assembly-section-title nodurda" id="01D9">*01D9-01E5H - Subroutine to wait for PRINTER READY, but Honor a <kbd>BREAK</kbd> Key.  This routine used to be at 0440-044A.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3 durda"><div>*01D9-01DB</div><div>JP 3027H</div><div>JUMP to 3027H which is the VECTOR JUMP to 3781H which is the Print Screen Routine that used to be here.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*01DC-01DE</div><div><a href="#044BH" class="memory-link">CALL 044BH</a></div><div>GOSUB to 044BH to check to see if PRINTER READY by polling port F8H.  Printer will be READY if Z is set.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*01DF</div><div>RET Z</div><div>If it is ready (because Z is set) then RETURN.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*01E0-01E2</div><div><a href="#028DH" class="memory-link">CALL 028DH</a></div><div>Call the PRINT CHARACTER routine at 003BH (which sends the character in the A register to the printer).</div></div>
									<div class="assembly-row-combined model3 durda"><div>*01E3-01E4</div><div><a href="#01DCH" class="memory-link">JR Z,01DCH</a></div><div>If we are at 64, then JUMP to 0214H for a new line.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*01E5</div><div>RET</div><div>RETURN.</div></div>
								</div>
							</div>

							<br><h2 class="assembly-section-title durda" id="01E6H">*01E6H-01EC - Display the Copyright Message.  This routine used to be at 37EBH-37F5H.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3 durda"><div>*01E6-01E8</div><div><a href="#0202H" class="memory-link">LD HL,0202H</a></div><div>Overwrite the current character held in Register A with a <span class="code">.</span>, so that all graphic characters are printed as <span class="code">.</span>'s.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*01E9</div><div>NOP</div><div>-</div></div>
									<div class="assembly-row-combined model3 durda"><div>*01EA-01EC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#021BH" class="memory-link">CALL 021BH</a></div><div>Call the PRINT CHARACTER routine at 003BH (which sends the character in the A register to the printer).</div></div>
								</div>
							</div>

							<br><h2 class="assembly-section-title durda" id="01EDH">*01EDH-01F7H -  - Enable the TIME$ Command - This routine used to be at 37DCH.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3 durda"><div>*01ED-01EF</div><div><a href="#3030H" class="memory-link">LD HL,3030H</a></div><div>Overwrite the current character held in Register A with a <span class="code">.</span>, so that all graphic characters are printed as <span class="code">.</span>'s.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*01F0-01F2</div><div>LD (4177H),HL</div><div>Load the memory location held at 4177H with HL.<br><b>NOTE:</b> 4176H is the TIME$ vector as is currently set to be JP <span class="code">?L3 ERROR</span>
 as the M1/M3 ROM considered that to be a DOS command.  It is not a DOS 
command for a Model III so that jump needs to be changed.  In this case,
 it is changed from JP <span class="code">?L3 ERROR</span> to JP 3030H.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*01F3-01F5</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-1.htm#022EH" class="memory-link">JP 022EH</a></div><div>JUMP to 022EH to continue.<br><b>NOTE:</b> 022EH will enable interrupts, show the READY prompt, and RETURN.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*01F6</div><div>NOP</div><div>-</div></div>
									<div class="assembly-row-combined model3 durda"><div>*01F7</div><div>NOP</div><div>-</div></div>
								</div>
							</div>

							<br><h2 id="01F8H">*01F8 - Turn Off The Cassette Motor - "$CSOFF"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>After writing data to the cassette, this routine should be 
called to turn off the cassette drive.  There are no entry conditions 
and no registers are modified.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*01F8<span class="origrom2">CSOFF</span></div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-4.htm#300CH" class="memory-link">JP 300CH</a></div><div>JUMP to 022EH to continue.<br><b>NOTE:</b> 022EH will enable interrupts, show the READY prompt, and RETURN.</div></div>
								</div>
							</div>

							<br><h2 id="01FBH">*01FB-0201 - DELAY ROUTINE - "$DELAY"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is a delay loop. The BC register pair is used as the 
loop counter. The duration of the delay, in microseconds, is the value 
of BC times 14.65. Register A is used.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*01FB</div><div>LD A,A</div><div>Load the memory location held at 4177H with HL.<br><b>NOTE:</b> 4176H is the TIME$ vector as is currently set to be JP <span class="code">?L3 ERROR</span>
 as the M1/M3 ROM considered that to be a DOS command.  It is not a DOS 
command for a Model III so that jump needs to be changed.  In this case,
 it is changed from JP <span class="code">?L3 ERROR</span> to JP 3030H.</div></div>
									<div class="assembly-row-combined model3"><div>*01FC</div><div>DEC BC</div><div>Decrement the counter in register pair BC</div></div>
									<div class="assembly-row-combined model3"><div>*01FD-01FE</div><div>LD A,B<br>OR C</div><div>Load the memory location held at 4177H with HL.<br><b>NOTE:</b> 4176H is the TIME$ vector as is currently set to be JP <span class="code">?L3 ERROR</span>
 as the M1/M3 ROM considered that to be a DOS command.  It is not a DOS 
command for a Model III so that jump needs to be changed.  In this case,
 it is changed from JP <span class="code">?L3 ERROR</span> to JP 3030H.</div></div>
									<div class="assembly-row-combined model3"><div>*01FF</div><div><a href="#01FBH" class="memory-link">JR NZ,01FBH</a></div><div>Loop back to 01DCH for the next character.<br>Difference between M1 and M3: Contains LD B,5CH instruction on Model I, JR 01DCH instruction on Model III.</div></div>
									<div class="assembly-row-combined model3"><div>*0201</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0202H">*202 - Message Storage Location<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0202</div><div>(C) "80 Tandy" + 0DH</div><div>Copyright message storage area.</div></div>
								</div>
							</div>

							<br><h2 id="0210H">0210 - These instructions are never called or used.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3 nodurda" id="0210H"><div>*0210-0211</div><div>LD E,3DH</div><div>I
 do not see that this command is ever executed as it is never called.  
However, it loads E with 3DH, most likely to toss off an error.</div></div>
									<div class="assembly-row-combined model3 durda" id="0210H"><div>*0210-0211</div><div>NOP<br>NOP</div><div>-</div></div>
									<p class="debug-note" id="0212H">0212H - This continues a subroutine and was JUMPed to from 022CH. It zeroes A and all flags everything and RETURNs.<br>Difference
 between M1 and M3: In the Model I, routines to define cassette drive 
(0212H - 021DH), reset the cassette input port FFH (021EH - 022BH), and 
to blink the asterisk while reading a cassette (022CH - 0234H). In the 
Model III, a routine to insure compatibility with programs that define 
the cassette drive (XOR A followed by RET, located at 0212H &amp; 
0213H), a subroutine used by the routine that begins at 01D9H (0214H 
0227H), a couple of cassette-related segments (0228H - 022DH), and an EI
 instruction followed by JP 1Al9H (enable interrupts and return to BASIC
 "READY", located at 022EH - 0231H).</p>
									<div class="assembly-row-combined model3"><div>*0212</div><div>XOR A</div><div>Set A to ZERO and clear all status flags.</div></div>
									<div class="assembly-row-combined model3"><div>*0213</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0214H">0216-021A - Display a Carriage Return<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0214</div><div>LD A,0DH</div><div>I
 do not see that this command is ever executed as it is never called.  
However, it loads E with 3DH, most likely to toss off an error.</div></div>
									<div class="assembly-row-combined model3"><div>*0216</div><div><a href="#003BH" class="memory-link">CALL 003BH</a></div><div>Call the PRINT CHARACTER routine at 003B (which sends the character in the A register to the printer).</div></div>
									<div class="assembly-row-combined model3"><div>*0219</div><div>XOR A</div><div>Set A to ZERO and clear all status flags.</div></div>
									<div class="assembly-row-combined model3"><div>*021A</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="021BH">021B-0227 - "$VDLINE" - Display a Line Until 03H or 0DH Reached.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This subroutine displays a line. The line must be terminated 
with an ASCII ETX (X'03') or carriage return (X'0D'). If the terminator 
is a carriage return, it will be printed; if it is an ETX, it will not 
be printed. This allows VDLINE to position the 	cursor to the beginning 
of the next line or leave it at the position after the last text 
character.  On entry (HL) shuold contain the output text, terminated by a
 03H or a 0DH.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*021B<span class="origrom2">VIDLINE</span></div><div>LD A,(HL)</div><div>I
 do not see that this command is ever executed as it is never called.  
However, it loads E with 3DH, most likely to toss off an error.</div></div>
									<div class="assembly-row-combined model3"><div>*021C</div><div>INC HL</div><div>Bump HL.</div></div>
									<div class="assembly-row-combined model3"><div>*021D</div><div>CP 03H</div><div>Check those memory contents against 03H to see if it is the end of message.</div></div>
									<div class="assembly-row-combined model3"><div>*021F</div><div>RET Z</div><div>Return.</div></div>
									<div class="assembly-row-combined model3"><div>*0220</div><div><a href="#0033H" class="memory-link">CALL 0033H</a></div><div>If
 it was NOT the end of message, call the PRINT CHARACTER routine at 003B
 (which sends the character in the A register to the printer).</div></div>
									<div class="assembly-row-combined model3"><div>*0223</div><div>CP 0DH</div><div>Check to see if it was a carriage return.</div></div>
									<div class="assembly-row-combined model3"><div>*0225</div><div><a href="#021BH" class="memory-link">JR NZ,021BH</a></div><div>If it was NOT a carriage return, loop back to load A with the next character.</div></div>
									<div class="assembly-row-combined model3"><div>*0227</div><div>RET</div><div>If it WAS a carriage return, RETURN.</div></div>
								</div>
							</div>

							<br><h2 id="0228H">0228H - This continues a subroutine and was 
JUMPed to from 023DH.  It puts 3000H into the memory location pointed to
 by the stack pointer, and JUMPs to 302AH.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0228</div><div>EX (SP),HL</div><div>Put HL (which presumably has a return address in it) into the memory location of the STACK pointer.</div></div>
									<div class="assembly-row-combined model3"><div>*0229</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-4.htm#302AH" class="memory-link">JP 302AH</a></div><div>JUMP to 302AH.<br><b>NOTE:</b> 302AH is an entry in a jump vector table that JUMPs to 31F7H.  31F7H checks to see if we have a <span class="code">PRINT #</span>.</div></div>
								</div>
							</div>

							<br><h2 id="022CH">022CH - BLINK ASTERISK routine - This routine 
is CALLED from 02E7 and alternatively displays and clears an asterisk in
 the upper right hand corner of the video display.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*022C</div><div><a href="#0212H" class="memory-link">JR 0212H</a></div><div>If it was NOT a carriage return, loop back to load A with the next character.</div></div>
									<div class="assembly-row-combined model3" id="022EH"><div>*022E</div><div>EI</div><div>Enable Interrupts.</div></div>
									<div class="assembly-row-combined model3"><div>*022F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#1A19H" class="memory-link">JP 1A19H</a></div><div>JUMP to 302AH.<br><b>NOTE:</b> 302AH is an entry in a jump vector table that JUMPs to 31F7H.  31F7H checks to see if we have a <span class="code">PRINT #</span>.</div></div>
								</div>
							</div>

							<br><h2 id="0232H">0232 - These instructions are never called or used.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3 nodurda"><div>*0232</div><div>CCF</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0233</div><div>INC A</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0234</div><div>RET</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0232</div><div>NOP</div><div>-</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0233</div><div>NOP</div><div>-</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0234</div><div>NOP</div><div>-</div></div>
								</div>
							</div>

							<br><h2 id="0235H">*0235-0240 - CASSETTE ROUTINE - Read a Byte from Cassette - "CSIN"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>After the completion of a $CSHIN call, this $CSIN routine 
begins inputting data, one byte at a time. This routine MUST be called 
often enough to keep up with the baud rate.  There are no entry 
conditions.   A is modified to hold the data byte.<br>Difference between
 M1 and M3: In the Model I, 0235H - 0240H contains the routine to read 
one byte from the cassette, and 0241H - 0260H contains the routine to 
get one bit from the cassette. In the Model III, 0235H - 023CH contain 
the start of the Model III routine to read one byte from cassette, 023DH
 - 0242H is part of the routine that begins at 0287H (writes cassette 
leader and sync byte), 0243H - 024CH is the actual start of the routine 
to search for the cassette leader and aync byte, 024DH - 0252H is the 
actual start of the routine to write a byte to tape, and 0253H - 025EH 
is a subroutine used by the system to select 500 or 1500 baud tape 
speed.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0235<span class="origrom2">CSIN</span></div><div>PUSH DE</div><div>Save the value in register pair DE on the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*0236</div><div>PUSH BC</div><div>Save the value in register pair DE on the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*0237</div><div>PUSH HL</div><div>Save the value in register pair DE on the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*0238</div><div>LD HL,(420EH)</div><div>Put the TAPE READ VECTOR (stored at 420EH) into HL.</div></div>
									<div class="assembly-row-combined model3"><div>*023B</div><div>EX (SP),HL</div><div>Replace
 the value at the top of the stack with the TAPE READ VECTOR (stored at 
420EH), and what used to HL at the top of this routine into Register 
Pair HL.</div></div>
									<div class="assembly-row-combined model3"><div>*023C</div><div>RET</div><div>Go to the TAPE READ VECTOR.<br><b>NOTE:</b> When a routine is CALLed, the RETurn address is put at the top of the stack; so RET jumps to the value at the top of the STACK.</div></div>
								</div>
							</div>

							<br><h2 id="023DH">023D - This continues a subroutine and was JUMPed to from <a href="#028BH" class="memory-link">028BH</a> to to set the cassette write vector.  It just PUSHes HL, puts 3000H into HL, and JUMPs out to <a href="#0228H" class="memory-link">0228H</a>.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*023D</div><div>PUSH HL</div><div>Save the value in register pair DE on the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*023E</div><div>LD HL,3000H</div><div>Put the TAPE READ VECTOR (stored at 420EH) into HL.</div></div>
									<div class="assembly-row-combined model3"><div>*0241</div><div><a href="#0228H" class="memory-link">JR 0228H</a></div><div>JUMP back to 0228H.</div></div>
								</div>
							</div>

							<br><h2 id="0243H">*0243-024B - CASSETTE ROUTINE - Read a Byte from Cassette<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0243</div><div>DI</div><div>Disable interrupts.</div></div>
									<div class="assembly-row-combined model3"><div>*0244</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-4.htm#300FH" class="memory-link">CALL 300FH</a></div><div>GOSUB to 300FH to start the cassette.</div></div>
									<div class="assembly-row-combined model3"><div>*0247</div><div>PUSH HL</div><div>Save the value in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*0248-024A</div><div>LD HL,3006H</div><div>HL = 3006H</div></div>
									<div class="assembly-row-combined model3"><div>*024B</div><div><a href="#0228H" class="memory-link">JR 0228H</a></div><div>JUMP back to 0228H.</div></div>
								</div>
							</div>

							<br><h2 id="024DH">*024D-0252 - CASSETTE ROUTINE - Write a Byte to Cassette<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*024D</div><div>PUSH HL</div><div>Save the value in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*024E</div><div>LD HL,(420CH)</div><div>HL = 3006H</div></div>
									<div class="assembly-row-combined model3"><div>*0251</div><div>EX (SP),HL</div><div>Put
 the TAPE WRITE VECTOR (stored at 420CH) into the memory location 
pointed to by the STACK, and the memory location pointed to the STACK 
into HL.</div></div>
									<div class="assembly-row-combined model3"><div>*0252</div><div>RET</div><div>RETURN to the memory address held in the TAPE WRITE VECTOR.<br><b>NOTE:</b> When a routine is CALLed, the RETurn address is put at the top of the stack; so RET jumps to the value at the top of the STACK.</div></div>
									<div class="assembly-row-combined model3" id="0253H"><div>*0253</div><div>EX (SP),HL</div><div>Put
 the TAPE WRITE VECTOR (stored at 420CH) into the memory location 
pointed to by the STACK, and the memory location pointed to the STACK 
into HL.</div></div>
									<div class="assembly-row-combined model3"><div>*0254</div><div>LD A,(4211H)</div><div>Load
 A with the contents of memory location 4211H.  Memory location 4211H is
 the Cassette Baud Rate Select.  It will be Z for 500 baud, and NZ for 
1500 baud.</div></div>
									<div class="assembly-row-combined model3"><div>*0257</div><div>OR A</div><div>Set flags for A.</div></div>
									<div class="assembly-row-combined model3"><div>*0258</div><div><a href="#025DH" class="memory-link">JR Z,025DH</a></div><div>If A was a zero, jump to 025DH to leave the routine with HL as is.</div></div>
									<div class="assembly-row-combined model3"><div>*025A</div><div>INC HL</div><div>If A was not zero, bump HL 3 times to move to the fast vector.</div></div>
									<div class="assembly-row-combined model3"><div>*025B</div><div>INC HL</div><div>If A was not zero, bump HL 3 times to move to the fast vector.</div></div>
									<div class="assembly-row-combined model3"><div>*025C</div><div>INC HL</div><div>If A was not zero, bump HL 3 times to move to the fast vector.</div></div>
									<div class="assembly-row-combined model3"><div>*025D</div><div>EX (SP),HL</div><div>Put
 the TAPE WRITE VECTOR (stored at 420CH) into the memory location 
pointed to by the STACK, and the memory location pointed to the STACK 
into HL.</div></div>
									<div class="assembly-row-combined model3"><div>*025E</div><div>RET</div><div>RETURN to the memory address held in the TAPE WRITE VECTOR.<br><b>NOTE:</b> When a routine is CALLed, the RETurn address is put at the top of the stack; so RET jumps to the value at the top of the STACK.</div></div>
									<div class="assembly-row-combined model3" id="025FH"><div>*025F</div><div>POP BC</div><div>Clean out the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*0260</div><div>RET</div><div>RETURN.</div></div>
								</div>
							</div>

							<br><h2 id="0264H">0264 - "$CSOUT" - Output a byte to cassette.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>After writing the header with $CSHWR, use this $CSOUT to 
write the data, one byte at a time.  You MUST call $CSOUT often enough 
to keep up with the baud rate.  Register A needs to hold the data byte 
on entry.<br>Difference between M1 and M3: In the Model I, 0264H - 0283H
 contains the routine to output one byte to the cassette. In the Model 
III, 0264H - 0266H contains a jump to 024DH (the start of the Model III 
routine to output one byte to cassette), followed by time data (60 
seconds, 60 minutes, 24 hours) at 0266H - 0268H, followed by twelve 
bytes which contain the length of each of the twelve months (0264H - 
0274H). This is followed by two NOPs, then starting at 0277H is a 1DH 
byte, a 1EH byte, the message "Diskette?", and finally a 03H byte (at 
0282H).</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model3" id="0261H"><div>*0261</div><div><a href="#0264H" class="memory-link">CALL 0264H</a></div><div>GOSUB to the very next instruction.</div></div>
									<div class="assembly-row-combined model3"><div>*0264</div><div><a href="#024DH" class="memory-link">JR 024DH</a></div><div>JUMP to 024DH to write a byte to cassette.</div></div>
								</div>
							</div>

							<br><h2 id="0266H">0266 - Storage location for the maximum number of seconds in a minute, minutes in an hour, hours in a day, and days in a month.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0266</div><div>3C 3C 18</div><div>Time Data (60, 60, 24).</div></div>
									<div class="assembly-row-combined model3"><div>*0269</div><div>1F 1C 1F 1E</div><div>Month Lengths.</div></div>
									<div class="assembly-row-combined model3"><div>*026D</div><div>1F 1E 1F 1F</div><div>Month Lengths.</div></div>
									<div class="assembly-row-combined model3"><div>*0271</div><div>1E 1F 1E 1F</div><div></div></div>
									<div class="assembly-row-combined model3"><div>*0275</div><div>00 00</div><div>Unused.</div></div>
									<div class="assembly-row-combined model3"><div>*0277</div><div>1D</div><div>Group Separator.</div></div>
									<div class="assembly-row-combined model3"><div>*0278</div><div>1E</div><div></div></div>
									<div class="assembly-row-combined model3"><div>*0279</div><div>"DISKETTE?" + 03H</div><div>Message Space.</div></div>
									<div class="assembly-row-combined model3"><div>*0283</div><div>F2</div><div>UNUSED.</div></div>
								</div>
							</div>

							<br><h2 id="0284H">0284 - This subroutine is called by 2076H to turn the tape on, no header - it jumps out to <a href="#023DH" class="memory-link">023DH</a>.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Difference between M1 and M3: In the Model I, this area 
contains several cassette I/O routines, including turn on cassette, 
write leader and sync byte (0284H); write leader and sync byte (0287H); 
turn on cassette, search for leader and sync byte (0293H); search for 
leader and sync byte (0296H), put 2 asterisks in upper right corner of 
video ( part of previous routines, begins at 029FH). In the Model III, 
0284H contains a JP 0287H instruction (faster than three NOPs), while 
0287H is the start of the routine to turn on the cassette, write leader 
and sync byte. 028DH - 0292H contains the fast routine to check if <kbd>BREAK</kbd>
 is depressed. 0293H contains a JP 0243H instruction, while 0296H 
contains a JR 0243H (0243H is the actual start of the routine to turn on
 the cassette, search for leader and sync byte). 0298H - 02A0H is the 
machine language routine to turn on the built-in clock display (in the 
upper right hand corner of the video display), while 02A1H - 02A8H is 
the location of the corresponding routine to turn the clock display back
 off. </p>
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0284</div><div><a href="#0287H" class="memory-link">JP 0287H</a></div><div>JUMP
 to 0287H (the very next instruction anyway!), which was the the 
"$CSHWR" routine in the Model I ROM.  That routine writes tape leader 
and the A5H sync byte. DE and HL are unchanged.<br><br>Load register B with the number of bytes to be written.</div></div>
								</div>
							</div>

							<br><h2 id="0287H">0287 - Write Leader and Sync Byte - "$CSHWR"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Each cassette record begins with a header consisting of a 
leader sequence and a synchronization byte.  This $CSHWR routine turns 
on the cassette and writes out this header.  There are no entry 
conditions.  A is altered by this routine.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0287<span class="origrom2">CSHWR</span></div><div>DI</div><div>Disable Interrupts.</div></div>
									<div class="assembly-row-combined model3" id="0228H"><div>*0288</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-4.htm#300FH" class="memory-link">CALL 300FH</a></div><div>GOSUB to 300FH to turn on the cassette.</div></div>
									<div class="assembly-row-combined model3"><div>*028B</div><div><a href="#023DH" class="memory-link">JR 023DH</a></div><div>JUMP to 023DH to set the CASSETTE WRITE VECTOR.</div></div>

									<p class="debug-note" id="028DH">028DH - "$KBBRK" -Check for a <kbd>BREAK</kbd> key only.   This is a fast key scan routine which looks solely for the <kbd>BREAK</kbd>
 key.  Use this routine if you want to minimize the keyboard scan time 
without totally locking out the keyboard.  On exit NZ will be set if <kbd>BREAK</kbd> was set.  This subroutine is called by 0444H (in the middle of the PRINTER ROUTINE) to check for a <kbd>BREAK</kbd> key.</p>
									<div class="assembly-row-combined model3"><div>*028D<span class="origrom2">KBBRK</span></div><div>LD A,(3840H)</div><div>Check for <kbd>BREAK</kbd>
 Key.  First, load A with the memory contents of 3840H (which is the 
keyboard scan of 14400, the 7th keyboard line), to check for a BREAK.  
14400 is ENTER (01) CLEAR (02) <kbd>BREAK</kbd> (04) RIGHT ARROW (08) LINE FEED (16) LEFT ARROW (32) SPACE (64)</div></div>
									<div class="assembly-row-combined model3"><div>*0290</div><div>AND 4</div><div>AND
 the memory contents of 3840H with 04H (Binary: 0000 0100) to isolate 
only Bit 3.  This a precursor to a future test to see if it was a <kbd>BREAK</kbd> key.</div></div>
									<div class="assembly-row-combined model3"><div>*0292</div><div>RET</div><div>RETURN.</div></div>
								</div>
							</div>

							<br><h2 id="0293H">0293 - CASSETTE ROUTINE - Read the Header and Sync Bytes<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0293</div><div><a href="#0243H" class="memory-link">JP 0243H</a></div><div>JUMP to 0243H to read the cassette header.</div></div>
								</div>
							</div>

							<br><h2 id="0296H">0296 - CASSETTE ROUTINE - "CSHIN" - Search for Cassette Header and Sync Byte<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Each cassette record begins with a header consisting of a 
leader sequence and synchronization byte.  $CSHIN turns on the cassette 
drive and begins searching for this header information.  The subroutine 
returns to the calling program after the sync-byte has been read.  There
 are no entry conditions.   Register A is altered by the routine.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0296</div><div><a href="#0243H" class="memory-link">JR 0243H</a></div><div>JUMP to 0243H to read the cassette header.</div></div>
								</div>
							</div>

							<br><h2 id="0298H">0298 - Enable the Clock Display - "CLKON"<br>No entry conditions.  A is altered by this routine.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0298<span class="origrom2">CLKON</span></div><div>LD A,(4210H)</div><div>Put the contents of memory location 4210H into A.<br><b>NOTE:</b> 4210H holds the bit mask for port ECH.  Port ECH stores miscellaneous controls.</div></div>
									<div class="assembly-row-combined model3"><div>*029B</div><div>SET 0,A</div><div>Set BIT 0 of A.</div></div>
									<div class="assembly-row-combined model3"><div>*029D</div><div>LD (4210H),A</div><div>Put the contents of memory location 4210H into A.<br><b>NOTE:</b> 4210H holds the bit mask for port ECH.  Port ECH stores miscellaneous controls.</div></div>
									<div class="assembly-row-combined model3"><div>*02A0</div><div>RET</div><div>RETURN.</div></div>
								</div>
							</div>

							<br><h2 id="02A1H">02A1 - Disable the Clock Display - "CLKOFF"<br>No entry conditions.  A is altered by this routine.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*02A1<span class="origrom2">CLKOFF</span></div><div>LD A,(4210H)</div><div>Put the clock bit stored in memory location 4210H into A.<br><b>NOTE:</b> 4210H holds the bit mask for port ECH.  Port ECH stores miscellaneous controls.</div></div>
									<div class="assembly-row-combined model3" id="02A4H"><div>*02A4</div><div>RES 0,A</div><div>Reset BIT 0 of A.</div></div>
									<div class="assembly-row-combined model3"><div>*02A6</div><div><a href="#029DH" class="memory-link">JR 029DH</a></div><div>JUMP to 029DH.</div></div>
								</div>
							</div>

							<br><h2 id="0232H">02A8 - These instructions are never called or used.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3 nodurda"><div>*02A8</div><div>RET</div></div>
									<div class="assembly-row-combined model3 durda"><div>*02A8</div><div>NOP</div></div>
								</div>
							</div>

							<br><h2 id="02A9H">02A9-02B1 - LEVEL II SYSTEM ROUTINE-ENTRY POINT- "GSYSTR"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>02A9-02AB</div><div><a href="#0314H" class="memory-link">CALL 0314H</a></div><div>Go read 2 bytes from the cassette, which should be the execution address, and return with it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>02AC-02AE</div><div>LD (40DFH),HL</div><div>Save the just read execution address from HL into 40DFH.<br><b>NOTE:</b> 40DFH-40E0H is used by DOS.</div></div>
									<div class="assembly-row-combined model1" id="02B1H"><div>02AF-02B1</div><div><a href="#01F8H" class="memory-link">CALL 01F8H</a></div><div>GOSUB to 01F8H to turn off the cassette motor.</div></div>
									<div class="assembly-row-combined model1" id="02B2H"><div>02B2-02B4<span class="origrom2">SYSTEM</span></div><div>CALL 41E2H</div><div>Go call the DOS link at 41E2H.<br>In NEWDOS 2.1, this is called during a SYSTEM operation.</div></div>
									<p class="debug-note">The following instruction is a bug.  4288H would be correct for a Model I but is incorrect for a Model III.  It should be 4388H.</p>
									<div class="assembly-row-combined model1 nodurda"><div>02B5-02B7</div><div>LD SP,4288H</div><div>Set
 the STACK pointer to 4288H (which is the assumed load address).  This 
location passes control to the routine used by the BASIC command SYSTEM.</div></div>
									<div class="assembly-row-combined model1 durda"><div>02B5-02B7</div><div>LD SP,42E8H</div><div>Set
 the STACK pointer to 4288H (which is the assumed load address).  This 
location passes control to the routine used by the BASIC command SYSTEM.</div></div>
									<div class="assembly-row-combined model1"><div>02B8-02BA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#20FEH" class="memory-link">CALL 20FEH</a></div><div>Go display a carriage return on the video display if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>02BB-02BC</div><div>LD A,2AH</div><div>Load register A with an <span class="code">*</span> character (which will form the next prompt).</div></div>
									<div class="assembly-row-combined model1"><div>02BD-02BF</div><div><a href="#032AH" class="memory-link">CALL 032AH</a></div><div>Go display the <span class="code">*</span> character in register A on the video display.</div></div>
									<div class="assembly-row-combined model1"><div>02C0-02C2</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#1BB3H" class="memory-link">CALL 1BB3H</a></div><div>We need a filename now with a "?: prompt so GOSUB to 1BB3H to get the input from the keyboard.</div></div>
									<div class="assembly-row-combined model1 nodurda"><div>02C3-02C5</div><div><a href="#06CCH" class="memory-link">JP C,06CCH</a></div><div>If a <kbd>BREAK</kbd>
 key was hit (because the CARRY FLAG is now on from the 1BB3H call), go 
to 06CCH which is in the middle of a token routine looking for REM.  
This is a BUG.  The jump this way will cause the system to reboot.</div></div>
									<div class="assembly-row-combined model1 durda"><div>02C3-02C5</div><div><a href="#006DH" class="memory-link">JP C,006D</a></div><div>If a <kbd>BREAK</kbd>
 key was hit (because the CARRY FLAG is now on from the 1BB3H call), go 
to 06CCH which is in the middle of a token routine looking for REM.  
This is a BUG.  The jump this way will cause the system to reboot.</div></div>
									<div class="assembly-row-combined model1"><div>02C6</div><div>RST 10H</div><div>Since
 we need to bump the input buffer pointer in register pair HL until it 
points to the first character input, call the EXAMINE NEXT SYMBOL 
routine at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>02C7-02C9</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#1997H" class="memory-link">JP Z,1997H</a></div><div>JUMP to 1997H to display a <span class="code">?SN ERROR</span> if there wasn't any input.</div></div>
									<div class="assembly-row-combined model1"><div>02CA-02CB</div><div>CP 2FH</div><div>Check to see if the character at the location of the input buffer pointer in register A is a <span class="code">/</span> character.  "/" is 2FH.</div></div>
									<div class="assembly-row-combined model1"><div>02CC-02CD</div><div><a href="#031DH" class="memory-link">JR Z,031DH</a></div><div>JUMP to 031DH if the character at the location of the input buffer pointer in register A is a <span class="code">/</span>.</div></div>
									<div class="assembly-row-combined model1"><div>02CE-02D0</div><div><a href="#0293H" class="memory-link">CALL 0293H</a></div><div>Go turn on the cassette motor.</div></div>
									<div class="assembly-row-combined model1"><div>02D1-02D3</div><div><a href="#0235H" class="memory-link">CALL 0235H</a></div><div>Calls
 the READ ONE BYTE FROM CASSETTE routine at 0235H (whichh reads one byte
 from the cassette drive specified in register A, and returns the byte 
in register A).</div></div>
									<div class="assembly-row-combined model1"><div>02D4-02D5</div><div>CP 55H</div><div>Check to see if the byte read from the cassette in register A is a header byte.</div></div>
									<div class="assembly-row-combined model1"><div>02D6-02D7</div><div><a href="#02D1H" class="memory-link">JR NZ,02D1H</a></div><div>Loop until the header byte is found.</div></div>
									<div class="assembly-row-combined model1"><div>02D8-02D9</div><div>LD B,06H</div><div>Load register B with the length of the filename to read from the cassette (which is 6 characters).</div></div>
									<p class="debug-note">Top of a DJNZ loop of 06 characters.</p>
									<div class="assembly-row-combined model1"><div>02DA</div><div>LD A,(HL)</div><div>Load register A with the character at the location of the current input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>02DB</div><div>OR A</div><div>Check to see if the character at the location of the current input buffer pointer in register A is an end of input character.</div></div>
									<div class="assembly-row-combined model1"><div>02DC-02DD</div><div><a href="#02E7H" class="memory-link">JR Z,02E7H</a></div><div>JUMP
 out of this 'read the filename from the cassette' routine if the 
character at the location of the current input buffer pointer in 
register A is an end of input character.</div></div>
									<div class="assembly-row-combined model1"><div>02DE-02E0</div><div><a href="#0235H" class="memory-link">CALL 0235H</a></div><div>Calls
 the READ ONE BYTE FROM CASSETTE routine at 0235H (which reads one byte 
from the cassette drive specified in register A, and returns the byte in
 register A).</div></div>
									<div class="assembly-row-combined model1"><div>02E1</div><div>CP (HL)</div><div>Check
 to see if the character at the location of the current input buffer 
pointer in register pair HL is the same as the character read from the 
cassette in register A.</div></div>
									<div class="assembly-row-combined model3"><div>*02E2</div><div>INC HL</div><div>Increment the input buffer pointer in register pair HL.<br>Difference
 between M1 and M3: This is part of the SYSTEM tape load routine. In the
 Model I, these locations contain a JR NZ,02D1H instruction followed by 
an INC HL instruction. In the Model III, these instructions have been in
 effect reversed C INC HL followed by JR NZ,02D1H).  Since this area is 
not referenced by any other part of the ROM, it is POSSIBLE that this 
change may have been implemented in order to correct some problem that 
occured while reading the filename on a SYSTEM tape.</div></div>
									<div class="assembly-row-combined model3"><div>*02E3-02E4</div><div><a href="#02D1H" class="memory-link">JR NZ,02D1H</a></div><div>JUMP
 to 02D1H (skip to the next program on cassette) if the character at the
 location of the current input buffer pointer in register pair HL isn't 
the same as the character read from the cassette in register A.</div></div>
									<div class="assembly-row-combined model1"><div>02E5-02E6</div><div><a href="#02DAH" class="memory-link">DJNZ 02DAH</a></div><div>Loop until the whole of the filename has been read from the cassette and checked against the user response.</div></div>
									<p class="debug-note">End of the DJNZ loop of 06 characters.</p>
									<div class="assembly-row-combined model1"><div>02E7-02E9</div><div><a href="#022CH" class="memory-link">CALL 022CH</a></div><div>GOSUB to 022CH which just zeroes A and all flags and jumps back here.</div></div>
									<div class="assembly-row-combined model1"><div>02EA-02EC</div><div><a href="#0235H" class="memory-link">CALL 0235H</a></div><div>GOSUB
 to READ ONE BYTE FROM CASSETTE routine at 0235H (whichh reads one byte 
from the cassette drive specified in register A, and returns the byte in
 register A).</div></div>
									<div class="assembly-row-combined model1"><div>02ED-02EE</div><div>CP 78H</div><div>Check to see if the byte read from the cassette in register A is an execution address header byte (which is 78H).</div></div>
									<div class="assembly-row-combined model1"><div>02EF-02F0</div><div><a href="#02A9H" class="memory-link">JR Z,02A9H</a></div><div>JUMP if the byte read from the cassette in register A is an execution address header byte.</div></div>
									<div class="assembly-row-combined model1"><div>02F1-02F2</div><div>CP 3CH</div><div>Check to see if the byte read from the cassette in register A is a file block header byte (which is 3CH).</div></div>
									<div class="assembly-row-combined model1"><div>02F3-02F4</div><div><a href="#02EAH" class="memory-link">JR NZ,02EAH</a></div><div>Loop until either an execution address header byte or a file block header byte is read from the cassette.</div></div>
									<div class="assembly-row-combined model1"><div>02F5-02F7</div><div><a href="#0235H" class="memory-link">CALL 0235H</a></div><div>Calls
 the READ ONE BYTE FROM CASSETTE routine at 0235H (which reads one byte 
from the cassette drive specified in register A, and returns the byte in
 register A).</div></div>
									<div class="assembly-row-combined model1"><div>02F8</div><div>LD B,A</div><div>In preparation for the next DJZ loop, load register B with the number of bytes to be loaded in register A.</div></div>
									<div class="assembly-row-combined model1"><div>02F9-02FB</div><div><a href="#0314H" class="memory-link">CALL 0314H</a></div><div>Go read the file block's starting address from the cassette and return with it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>02FC</div><div>ADD A,L</div><div>Add the LSB of the file block's starting address in register L to the MSB of the file block's starting address in register A.</div></div>
									<div class="assembly-row-combined model1"><div>02FD</div><div>LD C,A</div><div>Load register C with the file block's starting checksum in register A.</div></div>
									<div class="assembly-row-combined model1"><div>02FE-0300</div><div><a href="#0235H" class="memory-link">CALL 0235H</a></div><div>Calls
 the READ ONE BYTE FROM CASSETTE routine at 0235H (which reads one byte 
from the cassette drive specified in register A, and returns the byte in
 register A).</div></div>
									<div class="assembly-row-combined model1"><div>0301</div><div>LD (HL),A</div><div>Save the byte read from the cassette in register A at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0302</div><div>INC HL</div><div>Increment the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0303</div><div>ADD A,C</div><div>Add the value of the current checksum in register C to the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0304</div><div>LD C,A</div><div>Load register C with the updated checksum in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0305-0306</div><div><a href="#02FEH" class="memory-link">DJNZ 02FEH</a></div><div>Loop until the whole file block has been read.</div></div>
									<div class="assembly-row-combined model1"><div>0307-0309</div><div><a href="#0235H" class="memory-link">CALL 0235H</a></div><div>Calls
 the READ ONE BYTE FROM CASSETTE routine at 0235H (which reads one byte 
from the cassette drive specified in register A, and returns the byte in
 register A).</div></div>
									<div class="assembly-row-combined model1"><div>030A</div><div>CP C</div><div>Check to see if the computed checksum in register C is the same as the checksum read from the cassette in register A.</div></div>
									<div class="assembly-row-combined model1"><div>030B-030C</div><div><a href="#02E7H" class="memory-link">JR Z,02E7H</a></div><div>If its the same, jump to 02E7H because the next instructions are for bad checksums.</div></div>
									<div class="assembly-row-combined model1"><div>030D-030E</div><div>LD A,43H</div><div>Load register A with a <span class="code">C</span> character.</div></div>
									<div class="assembly-row-combined model1"><div>030F-0311</div><div>LD (3C3EH),A</div><div>Display a <span class="code">C</span> on the video display (at 15422).</div></div>
									<div class="assembly-row-combined model1"><div>0312-0313</div><div><a href="#02EAH" class="memory-link">JR 02EAH</a></div><div>JUMP to 02EAH and keep reading bytes.</div></div>
								</div>
							</div>

							<br><h2 id="0314H">0314-0316 - This subroutine reads two bytes 
from tape (providing that the tape is already running) and puts them in 
the HL register pair. It is used by the SYSTEM routine to read the last 
two bytes on tape which give the entry point. A JP (HL) can then be 
executed to jump to the location specified, when used for this purpose. 
Only HL is used by this routine.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0314<span class="origrom2">GETADR</span></div><div><a href="#0235H" class="memory-link">CALL 0235H</a></div><div>GOSUB
 to the READ ONE BYTE FROM CASSETTE routine at 0235H (whichh reads one 
byte from the cassette drive specified in register A, and returns the 
byte in register A).</div></div>
									<div class="assembly-row-combined model1"><div>0317</div><div>LD L,A</div><div>Load register L with the byte read from the cassette in register A (which is the LSB of the 16 bit value).</div></div>
									<div class="assembly-row-combined model1"><div>0318-031A</div><div><a href="#0235H" class="memory-link">CALL 0235H</a></div><div>GOSUB
 to the READ ONE BYTE FROM CASSETTE routine at 0235H (whichh reads one 
byte from the cassette drive specified in register A, and returns the 
byte in register A).</div></div>
									<div class="assembly-row-combined model1"><div>031B</div><div>LD H,A</div><div>Load register H with the byte read from the cassette in register A (which is the MSB of the 16 bit value).</div></div>
									<div class="assembly-row-combined model1"><div>031C</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="031DH">031D - "SYSGO" - This subroutine checks to see
 if we have a starting address from the "*?" prompt and if not, default 
to 40DFH, and then JUMP to whatever that address is.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>031D</div><div>EX DE,HL</div><div>Load register pair DE with the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>031E-0320</div><div>LD HL,(40DFH)</div><div>Load register pair HL with the current execution address (which is stored at 40DFH).<br><b>NOTE:</b> 40DFH-40E0H is used by DOS.</div></div>
									<div class="assembly-row-combined model1"><div>0321</div><div>EX DE,HL</div><div>So
 that we can run a RST 10H in the next instruction, we need to exchange 
the execution address in register pair HL with the input buffer pointer 
in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0322</div><div>RST 10H</div><div>Since
 we need to bump the current input buffer pointer in register pair HL 
until it points to the next character, call the EXAMINE NEXT SYMBOL 
routine at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>0323-0325</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#1E5AH" class="memory-link">CALL NZ,1E5AH</a></div><div>Call the ASCII TO INTEGER routine at 1E5AH.<br><b>NOTE:</b>
 The routine at 1E5A converts the ASCII string pointed to by HL to an 
integer deposited into DE.  If the routine finds a non-numerica 
character, the conversion is stopped.</div></div>
									<div class="assembly-row-combined model1"><div>0326-0327</div><div><a href="#02B2H" class="memory-link">JR NZ,02B2H</a></div><div>JUMP if it turns out there weren't any digits in the input.</div></div>
									<div class="assembly-row-combined model1"><div>0328</div><div>EX DE,HL</div><div>Since
 there were digits (or else we would have jumped in the prior 
instruction), exchange the input buffer pointer in register pair HL with
 the execution address in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0329</div><div>JP (HL)</div><div>JUMP to the execution address (i.e. "/xxxx") which is in register pair HL.</div></div>
								</div>
							</div>

							<br><h2 id="032AH">032A-0347 - OUTPUT ROUTINE - "OUTCHR" or "DSPCHR"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is a general purpose output routine which outputs a byte
 from the A register to video, tape or printer. In order to use it, the 
location 409CH must be loaded with -1 for tape, 0 for video or 1 for the
 line printer.<br><b>Note:</b> 409CH holds the current output device flag:</p><ul><li>-1:  Cassette</li><li>0: Video</li><li>1: Printer</li></ul><p></p>
								<p>This routine outputs a byte to device determined by byte 
stored at (409CH) - FFH=Tape, 0=Video, l=Printer. When calling, A = 
output byte. Uses AF. Warning: This routine CALLs a Disk BASIC link at 
address 41ClH which may have to be "plugged" with a RETurn (C9H) 
instruction.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>032A</div><div>PUSH BC</div><div>We are going to need to use Register C, so push register pair BC into the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>032B</div><div>LD C,A</div><div>Load register C with the character to be output in register A.</div></div>
									<div class="assembly-row-combined model1"><div>032C-032E</div><div>CALL 41C1H</div><div>Go call the DOS link at 41ClH.<br>In NEWDOS 2.1, this writes to the system output device.</div></div>
									<div class="assembly-row-combined model1"><div>032F-0331</div><div>LD A,(409CH)</div><div>Load register A with the current output device number stored in 409CH.<br><b>NOTE:</b> 409CH holds the current output device flag:<ul><li>-1:  Cassette</li><li>0: Video</li><li>1: Printer</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>0332</div><div>OR A</div><div>Set the flags.</div></div>
									<div class="assembly-row-combined model1"><div>0333</div><div>LD A,C</div><div>A = C (the character to be output).</div></div>
									<div class="assembly-row-combined model1"><div>0334</div><div>POP BC</div><div>Get the value from the STACK and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>0335-0337</div><div><a href="#0264H" class="memory-link">JP M,0264H</a></div><div>If
 the character in register A is to be sent to the cassette (because A 
was NEGATIVE) then JUMP to the the WRITE ONE BYTE TO CASSETTE routine at
 0264H (which writes the byte in the A register to the cassette drive 
selected in the A register).</div></div>
									<div class="assembly-row-combined model1"><div>0338-0339</div><div><a href="#039CH" class="memory-link">JR NZ,039CH</a></div><div>If the character in register A is to be sent to the printer (because A was NOT ZERO) then JUMP to 039CH.</div></div>
								</div>
							</div>

							<br><h2 id="032AH">033A-0347 - "CRTOUT" OUTPUT ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p></p><ul> <li>To use a ROM call to print a single character at
 the current cursor position, and to update the cursor position, load 
the ASCII value of the character into the A register and then CALL 
033AH.</li> <li>To display special functions using a ROM call, load the A
 register with the value given below for the special function and then 
CALL 033AH. <ol> <li>Backspace and erase previous character - 08H</li> <li>Carriage return and linefeed - 0DH</li> <li>Turn on cursor - 0EH</li> <li>Turn off cursor - 0FH</li> <li>Convert to 32 characters per line mode - 17H</li> <li>Backspace cursor - 18H</li> <li>Advance cursor one position - 19H</li> <li>Downward line feed - 1AH</li> <li>Upward line feed - 1BH</li> <li>Home (cursor to upper left corner) - 1CH</li> <li>Move cursor to beginning of current line - 1DH</li> <li>Erase from cursor position to end of line - 1EH</li> <li>Erase from cursor position to end of screen - 1FH</li> </ol></li> </ul><p></p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>033A</div><div>PUSH DE</div><div>If
 we're here, then that value in A wasn't going to the cassette or the 
printer, so it must be going to the video.  This routine performs the 
same function as 33H except that it doesn't destroy the contents of the 
DE register pair. This means that all the general purpose registers are 
saved, which is often desirable.<br><br>Save the value in register pair DE on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>033B-033D</div><div><a href="#0033H" class="memory-link">CALL 0033H</a></div><div>Call the DISPLAY A CHARACTER routine at 0033H (which puts the character in register A on the video screen).</div></div>
									<div class="assembly-row-combined model1"><div>033E</div><div>PUSH AF</div><div>Save the character in register A on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>033F-0341</div><div><a href="#0348H" class="memory-link">CALL 0348H</a></div><div>Go update the current cursor position and test to see if the display memory is full.</div></div>
									<div class="assembly-row-combined model1"><div>0342-0344</div><div>LD (40A6H),A</div><div>Save the current cursor line position stored in 40A6H to register A.<br><b>NOTE:</b> 40A6H holds the current cursor line position.</div></div>
									<div class="assembly-row-combined model1"><div>0345</div><div>POP AF</div><div>Get the character from the STACK and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0346</div><div>POP DE</div><div>Get the value from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0347</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0348H">0348-0357 - VIDEO ROUTINE - Get the cursor location (taking into account whether we are in 32 or 64 character mode)<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is a bug in the Model III code.  The code is a holdover 
from the Model I to test whether or not the video display is currently 
in the 32-character mode.  The next 2 instructions (LD A,403DH and AND 
08H) was supposed to test bit 3 of memory location 403DH to make that 
determination, but 403DH does not hold the 32 character flag on the 
Model III!  To fix this bug, the next 2 instructions should be LD 
A,(4210H) and AND 04H.  This bug results in the improper operation of 
the TAB function when the video display is in the 32 character mode.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0348-034A</div><div>LD A,(403DH)</div><div>Load register A with the 32/64 character per line flag (which is stored in 403DH).</div></div>
									<div class="assembly-row-combined model1"><div>034B-034C</div><div>AND 08H</div><div>MASK
 register A with a 08H (Binary: 0000 1000) to leave only BIT 3 live 
enabling a test for the 32/64 character per line flag in register A, and
 set the flags (so if Bit 3 was a 0 then Z FLAG is set).</div></div>
									<div class="assembly-row-combined model1"><div>034D-034F</div><div>LD A,(4020H)</div><div>Load register A with the LSB of the current cursor position.<br><b>NOTE:</b> 4020H-4021H holds Video DCB - Cursor location.</div></div>
									<div class="assembly-row-combined model1"><div>0350-0351</div><div><a href="#0355H" class="memory-link">JR Z,0355H</a></div><div>JUMP to 0355H if this is the 64 character per line mode.</div></div>
									<div class="assembly-row-combined model1"><div>0352</div><div>RRCA</div><div>Divide the LSB of the current cursor position in register A by two.</div></div>
									<div class="assembly-row-combined model1"><div>0353-0354</div><div>AND 1FH</div><div>Mask
 the cursor line position in register A for a 32 character per line (AND
 against 0001 1111) to force its position to be no less than 3C00H.</div></div>
									<div class="assembly-row-combined model1"><div>0355-0356</div><div>AND 3FH</div><div>Mask
 the cursor line position in register A for 64 characters per line (AND 
against 0011 1111) to force its position to be no more than 3FFFH.</div></div>
									<div class="assembly-row-combined model1"><div>0357</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0358H">0358-0360 - KEYBOARD ROUTINE - "KBD2"<br>Here 
is the routine to simulate the INKEY$ function. It performs exactly the 
same function as 2BH but it restores all registers, whereas 2BH destroys
 the contents of the DE register pair. This makes 35BH more useful than 
2BH.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0358-035A</div><div>CALL 41C4H</div><div>GOSUB to the DOS link at 41C4H.</div></div>
									<div class="assembly-row-combined model1"><div>035B</div><div>PUSH DE</div><div>Since the next routine uses DE, save the value in register pair DE on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>035C-035E</div><div><a href="#002BH" class="memory-link">CALL 002BH</a></div><div>GOSUB to the SCAN KEYBOARD routine at 002BH.</div></div>
									<div class="assembly-row-combined model1"><div>035F</div><div>POP DE</div><div>Restore Register Pair DE from the stack.</div></div>
									<div class="assembly-row-combined model1"><div>0360</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0361H">0361-0383 - INPUT ROUTINE - "LINP2"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is one of the general purpose input routines (see 05D9 
and 1BB3 also). This routine inputs a string from the keyboard, up to a 
maximum of 240 characters (F0H), and echoes them to the screen. It puts 
this data into a buffer located at the address pointed to by the buffer 
pointer at 40A7H. (e.g. If 40A7H contains 5000H the data will be stored 
from 5000H onwards). The string is terminated with a zero byte. The 
program returns from this routine as soon as the ENTER key has been 
pressed. When it does so, HL contains the start address of the input 
string and B contains the length of the string. (RST 10H can be used to 
make HL point to the first character of the string, if required.).<br><b>NOTE:</b> 40A7H-40A8H holds the input Buffer pointer.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0361</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>0362</div><div>LD (4099H),A</div><div>Save the value in register A as the last key pressed (which is stored in 4099H).<br><b>NOTE:</b> 4099H holds the last key pressed.</div></div>
									<div class="assembly-row-combined model1"><div>0365</div><div>LD (40A6H),A</div><div>Save the value in register A as the current cursor line position (which is stored in 40A6H).<br><b>NOTE:</b> 40A6H holds the current cursor line position.</div></div>
									<div class="assembly-row-combined model1"><div>0368</div><div>CALL 41AFH</div><div>GOSUB the DOS link at 41AFH.<br>In NEWDOS 2.1, this is the start of keyboard input.</div></div>
									<div class="assembly-row-combined model1"><div>036B</div><div>PUSH BC</div><div>Save the value in Register Pair BC to the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>036C</div><div>LD HL,(40A7H)</div><div>Load register pair HL with the starting address of the input buffer (which is stored in 40A7H).<br><b>NOTE:</b> 40A7H-40A8H holds the input Buffer pointer.</div></div>
									<div class="assembly-row-combined model1"><div>036F</div><div>LD B,F0H</div><div>Load register B with the length of the input buffer (which is 240).</div></div>
									<div class="assembly-row-combined model1"><div>0371</div><div><a href="#05D9H" class="memory-link">CALL 05D9H</a></div><div>GOSUB
 to the "WAIT FOR NEXT LINE" keyboard input routine at 05D9H (which 
takes keyboard entry until a carriage return, a break, or buffer overrun
 occurs).</div></div>
									<div class="assembly-row-combined model1"><div>0374</div><div>PUSH AF</div><div>Save the flags on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0375</div><div>LD C,B</div><div>Load register C with the length of the input in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0376</div><div>LD B,00H</div><div>Zero register B so that register pair BC will have the length of the input.</div></div>
									<div class="assembly-row-combined model1"><div>0378</div><div>ADD HL,BC</div><div>Add the length of the input in register pair BC to the starting address of the input buffer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0379</div><div>LD (HL),00H</div><div>Save an end of the input character at the location of the end of input pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>037B</div><div>LD HL,(40A7H)</div><div>Load register pair HL with the starting address of the input buffer (which is 40A7H).<br><b>NOTE:</b> 40A7H-40A8H holds the input Buffer pointer.</div></div>
									<div class="assembly-row-combined model1"><div>037E</div><div>POP AF</div><div>Get the flags from the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>037F</div><div>POP BC</div><div>Get the value from the STACK and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>0380</div><div>DEC HL</div><div>Decrement the input buffer pointer in register pair HL (so that HL is the input area pointer - 1).</div></div>
									<div class="assembly-row-combined model1"><div>0381</div><div>RET C</div><div>Return if the <kbd>BREAK</kbd> key was pressed.</div></div>
									<div class="assembly-row-combined model1"><div>0382</div><div>XOR A</div><div>Otherwise (i.e., the <kbd>BREAK</kbd> key was not pressed), zero all the status flags.</div></div>
									<div class="assembly-row-combined model1"><div>0383</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0384H">0384-038A - KEYBOARD ROUTINE - "KBWT2" - Waits for keypress<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0384</div><div><a href="#0358H" class="memory-link">CALL 0358H</a></div><div>Go scan the keyboard.</div></div>
									<div class="assembly-row-combined model1"><div>0387</div><div>OR A</div><div>Check to see if a key was pressed.</div></div>
									<div class="assembly-row-combined model1"><div>0388</div><div>RET NZ</div><div>Return if a key was pressed (meaning OR A was set to NZ).</div></div>
									<div class="assembly-row-combined model1"><div>0389</div><div><a href="#0384H" class="memory-link">JR 0384H</a></div><div>Loop until a key is pressed.</div></div>
								</div>
							</div>

							<br><h2 id="038BH">038B-039B - PRINTER ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine resets device type flag at 409CH to zero (output
 to video display), also outputs a carriage return to the line printer 
if printer is not at beginning of line (determined by checking the 
contents of the printer line position flag at 409B - if flag contains 
zero, printer is at start of line). Note that if printer line position 
flag does not contain zero and the printer is not on line, the computer 
will "hang up" waiting for a "printer ready" signal.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>038B</div><div>XOR A</div><div>Zero register A, which then means it contains the device code for VIDEO.</div></div>
									<div class="assembly-row-combined model1"><div>038C-038E</div><div>LD (409CH),A</div><div>Save the value in register A (the current output device code of video) to 409CH.<br><b>NOTE:</b> 409CH holds the current output device flag:<ul><li>-1:  Cassette</li><li>0: Video</li><li>1: Printer</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>038F-0391</div><div>LD A,(409BH)</div><div>Load register A with the current printer carriage position (which is stored at 409BH).<br><b>NOTE:</b> 409BH holds the printer carriage position.</div></div>
									<div class="assembly-row-combined model1"><div>0392</div><div>OR A</div><div>Check to see if the carriage position in register A is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0393</div><div>RET Z</div><div>Return if the carriage position in register A is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0394-0395</div><div>LD A,0DH</div><div>Load register A with a carriage return character (i.e., 0DH).</div></div>
									<div class="assembly-row-combined model1"><div>0396</div><div>PUSH DE</div><div>Save the value in register pair DE on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0397-0399</div><div><a href="#039CH" class="memory-link">CALL 039CH</a></div><div>Go send the carriage return character in register A to the printer.</div></div>
									<div class="assembly-row-combined model1"><div>039A</div><div>POP DE</div><div>Get the value from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>039B</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="039CH">039C-03C1 - PRINTER ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the LPRINT routine. All registers are saved. The byte to be printed should be in the A register.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>039C</div><div>PUSH AF</div><div>Save the value in register pair AF on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>039D</div><div>PUSH DE</div><div>Save the value in register pair DE on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>039E</div><div>PUSH BC</div><div>Save the value in register pair BC on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>039F</div><div>LD C,A</div><div>Load register C with the character to be sent to the printer in register A.</div></div>
									<div class="assembly-row-combined model1"><div>03A0</div><div>LD E,00H</div><div>Zero register E (which will ultimately hold the new character/line count of 0CH, 0DH, or 0AH).</div></div>
									<div class="assembly-row-combined model1"><div>03A2</div><div>CP 0CH</div><div>Check to see if the character to be sent to the printer in register A is equal to 0CH (which is 'skip to next line').</div></div>
									<div class="assembly-row-combined model1"><div>03A4</div><div><a href="#03B6H" class="memory-link">JR Z,03B6H</a></div><div>JUMP to 03B6H if the character to be sent to the printer in register A is equal to 0CH.</div></div>
									<div class="assembly-row-combined model1"><div>03A6</div><div>CP 0AH</div><div>Check to see if the character to be sent to the printer in register A is a line feed character (i.e., 0AH).</div></div>
									<div class="assembly-row-combined model1"><div>03A8</div><div><a href="#03ADH" class="memory-link">JR NZ,03ADH</a></div><div>JUMP to 03ADH if the character to be sent to the printer in register A isn't a line feed character.</div></div>
									<div class="assembly-row-combined model1"><div>03AA</div><div>LD A,0DH</div><div>Load register A with a carriage return character (i.e., 0DH).</div></div>
									<div class="assembly-row-combined model1"><div>03AC</div><div>LD C,A</div><div>Load register C with the character to be sent to printer in register A.</div></div>
									<div class="assembly-row-combined model1"><div>03AD</div><div>CP 0DH</div><div>Check to see if the character to be sent to the printer in register A is a carriage return character.</div></div>
									<div class="assembly-row-combined model1"><div>03AF</div><div><a href="#03B6H" class="memory-link">JR Z,03B6H</a></div><div>JUMP to 03B6H if the character to be sent to the printer in register A is a carriage return character.</div></div>
									<div class="assembly-row-combined model1"><div>03B1</div><div>LD A,(409BH)</div><div>Load register A with the current printer carriage position (stored in 409BH).<br><b>NOTE:</b> 409BH holds the printer carriage position.</div></div>
									<div class="assembly-row-combined model1"><div>03B4</div><div>INC A</div><div>Increment the current carriage position in register A.</div></div>
									<div class="assembly-row-combined model1"><div>03B5</div><div>LD E,A</div><div>Load register E with the current carriage position in register A.</div></div>
									<p class="debug-note" id="03B6H">03B6H - If we are here, the character sto be sent to the printer was a SKIP TO NEXT LINE (0CH) or a CARRIAGE RETURN (0DH).</p>
									<div class="assembly-row-combined model1"><div>03B6</div><div>LD A,E</div><div>Load
 register A with the current carriage position in register E.  Why do 
this since its obviously already done?  Because this is a jump point!</div></div>
									<div class="assembly-row-combined model1"><div>03B7</div><div>LD (409BH),A</div><div>Put Register A (the current carriage position) into 409BH.<br><b>NOTE:</b> 409BH holds the printer carriage position.</div></div>
									<div class="assembly-row-combined model1"><div>03BA</div><div>LD A,C</div><div>Load register A with the character to be sent to the printer in register C.</div></div>
									<div class="assembly-row-combined model1"><div>03BB</div><div><a href="#003BH" class="memory-link">CALL 003BH</a></div><div>Call the PRINT CHARACTER routine at 003B (which sends the character in the C register to the printer).</div></div>
									<div class="assembly-row-combined model1"><div>03BE</div><div>POP BC</div><div>Get the value from the STACK and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>03BF</div><div>POP DE</div><div>Get the value from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>03C0</div><div>POP AF</div><div>Get the value from the STACK and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>03C1</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 class="assembly-section-title nodurda" id="03C2H">*03C2H-0451H - PRINTER ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<p class="debug-note">Difference between M1 and M3: Start of 
I/O driver area which has been totally rearranged in the Model III. 
Specifically, in the Model I the area from 03C2H through 0SD0H was 
arranged as follows: 03C2H - 03E2H is the I/O driver entry routine, 
03E3H - 0457H is the keyboard driver routine, 0458H - 058CH is the video
 driver routine, and 058DH - 0SD0H is the line printer driver routine. 
In the Model III, 03C2H - 0451H is the line printer driver routine, 
0452H - 0468H is the actual location of the routine to initialize all 
I/O drivers, 046BH - 0472H is a routine used by the RUN/EDIT/NEW 
commands to unprotect the video display and to load HL with the start of
 BASIC program pointer at 40A4H-40A5H, and 0473H-05D0H is the video 
driver routine and the keyboard driver begins at 3024H in the Model 
III).</p>
									<div class="assembly-row-combined model3 nodurda"><div>*03C2</div><div>LD A,C</div><div>A = C (the current character).</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03C3</div><div>CP 20H</div><div>Check to see if the character is a control character by testing A - 20H.  Results:<ul><li>If A=20H it sets the ZERO FLAG</li><li>If A&lt;20H then the CARRY FLAG will be set</li><li>if A&gt;=20H then the NO CARRY FLAG will be set.</li></ul>If A is a CONTROL CHARACTER then C will be set.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03C5</div><div><a href="#03E5H" class="memory-link">JR NC,03E5H</a></div><div>If A was &gt;= a <span class="code">SPACE</span>, the NC would be set meaning A is a control character, jump to 03E5H to skip a bunch of needless tests.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03C7</div><div>CP 0DH</div><div>Check to see if the character is a control character by testing A - 20H.  Results:<ul><li>If A=20H it sets the ZERO FLAG</li><li>If A&lt;20H then the CARRY FLAG will be set</li><li>if A&gt;=20H then the NO CARRY FLAG will be set.</li></ul>If A is a CONTROL CHARACTER then C will be set.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03C9</div><div><a href="#03F5H" class="memory-link">JR Z,03F5H</a></div><div>If A was &gt;= a <span class="code">SPACE</span>, the NC would be set meaning A is a control character, jump to 03E5H to skip a bunch of needless tests.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03CB</div><div>CP 0CH</div><div>Check to see if the character is a control character by testing A - 20H.  Results:<ul><li>If A=20H it sets the ZERO FLAG</li><li>If A&lt;20H then the CARRY FLAG will be set</li><li>if A&gt;=20H then the NO CARRY FLAG will be set.</li></ul>If A is a CONTROL CHARACTER then C will be set.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03CD</div><div><a href="#03FFH" class="memory-link">JR NZ,03FFH</a></div><div>If A was &gt;= a <span class="code">SPACE</span>, the NC would be set meaning A is a control character, jump to 03E5H to skip a bunch of needless tests.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03CF</div><div>LD A,(IX+03H)</div><div>A = C (the current character).</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03D2</div><div>SUB (IX+04H)</div><div>Subtract the number of lines printed from A.<br><b>NOTE:</b> IX+4 is the number of lines printed.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03D5</div><div>LD B,A</div><div>LET B = A</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03D6</div><div><a href="#0440H" class="memory-link">CALL 0440H</a></div><div>GOSUB to 0440H to wait until the printer is ready (honoring BREAK, if hit).</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03D9</div><div>LD A,0AH</div><div>LET B = A</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03DB</div><div>OUT (0F8H),A</div><div>Output the LINE FEED character to port 0F8H.<br><b>NOTE:</b> 0F8H is the printer port.  If you put data to it, it prints it.  Otherwise, Bits 4-7 hold printer status.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03DD</div><div><a href="#03D6H" class="memory-link">DJNZ 03D6H</a></div><div>JUMP back to 03D6H until the number of lines left in the page is zero.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03DF</div><div>LD (IX+05H),00H</div><div>LET B = A</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03E3</div><div><a href="#0439H" class="memory-link">JR 0439H</a></div><div>JUMP to 0439H to set the number of lines printed to 01 and exit</div></div>
								</div>
							</div>

							<br><h2 class="assembly-section-title nodurda" id="03E5H">Inside 
the PRINTER ROUTINE - If we are here, the characters to be sent to the 
printer are NOT control characters, so test for graphics (and jump 
away), and if not, put the character from the PRINTER LOOKUP TABLE into 
C.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3 nodurda"><div>*03E5</div><div>CP 80H</div><div>Test for a graphics character by comparing A to 80H.  If it is a graphics character than NC will be set.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03E7</div><div><a href="#0419H" class="memory-link">JR NC,0419H</a></div><div>JUMP to 0439H to set the number of lines printed to 01 and exit</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03E9</div><div>LD B,00H</div><div>Load B with a 00 (to set a MSB = 0).</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03EB</div><div>SUB 20H</div><div>Subtract 20H from A to adjust the character to the table.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03ED</div><div>LD C,A</div><div>Load B with a 00 (to set a MSB = 0).</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03EE</div><div>LD HL,3145H</div><div>Load B with a 00 (to set a MSB = 0).</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03F1</div><div>ADD HL,BC</div><div>Add BC to HL so that HL will have the character location in the character table.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03F2</div><div>LD C,(HL)</div><div>Load C with the character at the position of HL in the character table.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03F3</div><div><a href="#0403H" class="memory-link">JR 0403H</a></div><div>JUMP to 0403H to continue.</div></div>
								</div>
							</div>

							<br><h2 class="assembly-section-title nodurda" id="03F5H">*03F5-0424 - Inside the PRINTER ROUTINE - Print A Character Honoring Page Height and Width<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3 nodurda"><div>*03F5</div><div>LD A,(IX+05H)</div><div>Load C with the character at the position of HL in the character table.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03F8</div><div>OR A</div><div>Set the flags for A, including a test for zero/none.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03F9</div><div>LD A,C</div><div>Load C with the character at the position of HL in the character table.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03FA</div><div><a href="#03FFH" class="memory-link">JR NZ,03FFH</a></div><div>JUMP to 0403H to continue.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03FC</div><div>LD A,0AH</div><div>Load C with the character at the position of HL in the character table.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03FE</div><div>LD C,A</div><div>Load C with the character at the position of HL in the character table.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*03FF</div><div>CP 20H</div><div>Check
 to see if the character is a control character by testing A - 20H.  If 
A=20H it sets the ZERO FLAG.  If A&lt;20H then the CARRY FLAG will be 
set and if A&gt;=20H then the NO CARRY FLAG will be set.  If A is a 
CONTROL CHARACTER then C will be set.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0401</div><div><a href="#0419H" class="memory-link">JR C,0419H</a></div><div>If it is a control character, jump to 0419H.</div></div>
									<p class="debug-note nodurda" id="0403H">*0403 - Inside the 
PRINTER ROUTINE - If we are here, then C holds the printable character 
to be printed as determined by the PRINTER CHARACTER TABLE.</p>
									<div class="assembly-row-combined model3 nodurda"><div>*0403</div><div>LD A,(IX+06H)</div><div>Load A with the MAXIMUM PRINT WIDTH.<br><b>NOTE:</b> IX+06H holds the MAXIMUM PRINT WIDTH.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0406</div><div>INC A</div><div>Bump A to one beyond that (i.e., unlimited).</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0407</div><div><a href="#0419H" class="memory-link">JR Z,0419H</a></div><div>If it is a control character, jump to 0419H.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0409</div><div>CP (IX+05H)</div><div>Check to see if the line is full by comparing A with IX+5.<br><b>NOTE:</b> IX+5 is the number of characters printed.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*040C</div><div><a href="#0419H" class="memory-link">JR NC,0419H</a></div><div>If it is a control character, jump to 0419H.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*040E</div><div><a href="#0440H" class="memory-link">CALL 0440H</a></div><div>GOSUB to 0440H to wait until the printer is ready (honoring BREAK, if hit).</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0411</div><div>LD A,0DH</div><div>Load A with a carriage return.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0413</div><div>OUT (0F8H),A</div><div>Send the carriage return to port 0F8H.<br><b>NOTE:</b> 0F8H is the printer port.  If you put data to it, it prints it.  Otherwise, Bits 4-7 hold printer status.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0415</div><div>LD (IX+05H),00H</div><div>Load A with a carriage return.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0419</div><div><a href="#0440H" class="memory-link">CALL 0440H</a></div><div>GOSUB to 0440H to wait until the printer is ready (honoring BREAK, if hit).</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*041C</div><div>LD A,C</div><div>Load A with a carriage return.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*041D</div><div>OUT (F8H),A</div><div>Send the carriage return to port 0F8H.<br><b>NOTE:</b> 0F8H is the printer port.  If you put data to it, it prints it.  Otherwise, Bits 4-7 hold printer status.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*041F</div><div>INC (IX+05H)</div><div>Bump the number of characters printed.<br><b>NOTE:</b> IX+5 is the number of characters printed.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0422</div><div>CP 0DH</div><div>Check A for a carriage return.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0424</div><div><a href="#042AH" class="memory-link">JR Z,042AH</a></div><div>If A was a carriage return, skip the next few instructions and jump to 042AH.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0426</div><div>CP 0AH</div><div>Check A for a carriage return.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0428</div><div><a href="#043DH" class="memory-link">JR NZ,043DH</a></div><div>If A was a carriage return, skip the next few instructions and jump to 042AH.</div></div>
									<p class="debug-note nodurda" id="042AH">042A - Inside the PRINTER ROUTINE - If we are here, then we have a LINE FEED or a CARRIAGE RETURN in A.</p>
									<div class="assembly-row-combined model3 nodurda"><div>*042A</div><div>LD (IX+05H),00H</div><div>Reset the number of characters printed.<br><b>NOTE:</b> IX+5 is the number of characters printed.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*042E</div><div>INC (IX+04H)</div><div>Bump IX+04.<br><b>NOTE:</b> IX+4 is the number of lines printed.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0431</div><div>LD A,(IX+04H)</div><div>Load A with the number of lines printed.</div></div>
									<div class="assembly-row-combined model3 nodurda" id="0434H"><div>*0434</div><div>CP (IX+03H)</div><div>Compare that to the maximum number of lines per page.<br><b>NOTE:</b> IX+3 is the maximum number of lines per page.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0437</div><div><a href="#043DH" class="memory-link">JR NZ,043DH</a></div><div>Skip the next instruction by JUMPing to 043DH if the number of lines printed is less than maximum number of lines per page.</div></div>
									<div class="assembly-row-combined model3 nodurda" id="0439H"><div>*0439</div><div>LD (IX+04H),01H</div><div>Load A with the number of lines printed.</div></div>
									<div class="assembly-row-combined model3 nodurda" id="043DH"><div>*043D</div><div>XOR A</div><div>Clear A and the status bits.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*043E</div><div>LD A,C</div><div>Load A with the number of lines printed.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*043F</div><div>RET</div><div>RETURN.</div></div>
								</div>
							</div>

							<br><h2 class="assembly-section-title nodurda" id="0440H">*0440-044A - Inside the PRINTER ROUTINE - Subroutine to wait for PRINTER READY, but honor a BREAK Key<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3 nodurda"><div>*0440</div><div><a href="#044BH" class="memory-link">CALL 044BH</a></div><div>GOSUB to 044BH to check the printer.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0443</div><div>RET Z</div><div>If it is ready (because Z is set) then RETURN.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0444</div><div><a href="#028DH" class="memory-link">CALL 028DH</a></div><div>GOSUB to 044BH to check the printer.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0447</div><div><a href="#0440H" class="memory-link">JR Z,0440H</a></div><div>Loop back to 0440H if <kbd>BREAK</kbd> wasn't pressed.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*0449</div><div>POP AF</div><div>Restore AF from the STACK.</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*044A</div><div>RET</div><div>If it is ready (because Z is set) then RETURN.</div></div>
								</div>
							</div>

							<br><h2 class="assembly-section-title durda" id="03C2H">*03C2H-0451H - PRINTER ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3 durda"><div>*03C2</div><div>LD A,C</div><div>A = C (the current character).</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03C3</div><div>CP ' '</div><div>Check to see if the character is a control character by testing A - 20H.  Results:<ul><li>If A=20H it sets the ZERO FLAG</li><li>If A&lt;20H then the CARRY FLAG will be set</li><li>if A&gt;=20H then the NO CARRY FLAG will be set.</li></ul>If A is a CONTROL CHARACTER then C will be set.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03C5</div><div>JR NC,03E9H</div><div>If A was &gt;= a <span class="code">SPACE</span>, the NC would be set meaning A is a control character, jump to 03E5H to skip a bunch of needless tests.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03C7</div><div>CP 0DH</div><div>Check to see if the character is a control character by testing A - 20H.  Results:<ul><li>If A=20H it sets the ZERO FLAG</li><li>If A&lt;20H then the CARRY FLAG will be set</li><li>if A&gt;=20H then the NO CARRY FLAG will be set.</li></ul>If A is a CONTROL CHARACTER then C will be set.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03C9</div><div>JR Z,0414H</div><div>If A was &gt;= a <span class="code">SPACE</span>, the NC would be set meaning A is a control character, jump to 03E5H to skip a bunch of needless tests.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03CB</div><div>CP 0CH</div><div>Check to see if the character is a control character by testing A - 20H.  Results:<ul><li>If A=20H it sets the ZERO FLAG</li><li>If A&lt;20H then the CARRY FLAG will be set</li><li>if A&gt;=20H then the NO CARRY FLAG will be set.</li></ul>If A is a CONTROL CHARACTER then C will be set.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03CD</div><div>JR NZ,041DH</div><div>If A was &gt;= a <span class="code">SPACE</span>, the NC would be set meaning A is a control character, jump to 03E5H to skip a bunch of needless tests.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03CF</div><div>LD A,(IX+03H)</div><div>A = C (the current character).</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03D2</div><div>SUB (IX+04H)</div><div>Subtract the number of lines printed from A.<br><b>NOTE:</b> IX+4 is the number of lines printed.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03D5</div><div>LD B,A</div><div>LET B = A</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03D6</div><div>CALL 01DCH</div><div>GOSUB to 0440H to wait until the printer is ready (honoring BREAK, if hit).</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03D9</div><div>LD A,0AH</div><div>LET B = A</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03DB</div><div>OUT (F8H),A</div><div>Output the LINE FEED character to port 0F8H.<br><b>NOTE:</b> 0F8H is the printer port.  If you put data to it, it prints it.  Otherwise, Bits 4-7 hold printer status.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03DD</div><div>DJNZ 03D6H</div><div>JUMP back to 03D6H until the number of lines left in the page is zero.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03DF</div><div>LD (IX+05H),00H</div><div>LET B = A</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03E3</div><div>LD (IX+04H),01H</div><div>Load B with a 00 (to set a MSB = 0).</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03E7</div><div>JR 0448H</div><div>JUMP to 0439H to set the number of lines printed to 01 and exit</div></div>
									<p class="debug-note nodurda" id="03E9H">*03E9-03F5 - Inside the PRINTER ROUTINE - Subroutine if the character is a CONTROL CHARACTER.</p>
									<div class="assembly-row-combined model3 durda"><div>*03E9</div><div>LD A,(41FBH)</div><div>Load B with a 00 (to set a MSB = 0).</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03EC</div><div>OR A</div><div>Set the flags</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03ED</div><div>JR Z,03F6H</div><div>JUMP to 0439H to set the number of lines printed to 01 and exit</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03EF</div><div>CP 01H</div><div>Test for a graphics character by comparing A to 80H.  If it is a graphics character than NC will be set.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03F1</div><div>JP Z,3045H</div><div>If
 A is 01H, JUMP to 3045H, which I guess is Frank's shot at Z-80 trick.  
This jumps in the middle of the OPCODE at 3044H, but in doing so, turns 
that into a JUMP to 376AH.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03F4</div><div>JR 041FH</div><div>JUMP to 0403H to continue.</div></div>
									<p class="debug-note nodurda" id="03F6H">*03F6-4000 - Inside the PRINTER ROUTINE - Subroutine if the memory contents of 41FBH are zero.</p>
									<div class="assembly-row-combined model3 durda"><div>*03F6</div><div>LD A,(41FCH)</div><div>Load C with the character at the position of HL in the character table.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03F9</div><div>OR A</div><div>Set the flags for A, including a test for zero/none.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03FA</div><div>JR NZ,040AH</div><div>JUMP to 0403H to continue.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03FC</div><div>LD A,C</div><div>Load C with the character at the position of HL in the character table.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03FD</div><div>CP A0H</div><div>Check
 to see if the character is a control character by testing A - 20H.  If 
A=20H it sets the ZERO FLAG.  If A&lt;20H then the CARRY FLAG will be 
set and if A&gt;=20H then the NO CARRY FLAG will be set.  If A is a 
CONTROL CHARACTER then C will be set.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*03FF</div><div>JR C,041FH</div><div>JUMP to 0403H to continue.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0401</div><div>CP C0H</div><div>Check to see if the line is full by comparing A with IX+5.<br><b>NOTE:</b> IX+5 is the number of characters printed.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0403</div><div>JR NC,040FH</div><div>If it is a control character, jump to 0419H.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0405</div><div>ADD A,40H</div><div>If
 we are here then A&gt;=A0H, but A&lt;C0H (i.e., betweem 160 and 191), 
so add 40H (Decimal: 64; or 1 character below "A") to Register A.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0407</div><div>LD C,A</div><div>Load A with the MAXIMUM PRINT WIDTH.<br><b>NOTE:</b> IX+06H holds the MAXIMUM PRINT WIDTH.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0408</div><div>JR 041FH</div><div>If it is a control character, jump to 0419H.</div></div>
									<p class="debug-note nodurda" id="040AH">*040AH-040EH - Inside the PRINTER ROUTINE - Subroutine if the memory contents of 41FCH are zero.</p>
									<div class="assembly-row-combined model3 durda"><div>*040A</div><div>LD A,C</div><div>Load A with the MAXIMUM PRINT WIDTH.<br><b>NOTE:</b> IX+06H holds the MAXIMUM PRINT WIDTH.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*040B</div><div>CP C0H</div><div>Check to see if the line is full by comparing A with IX+5.<br><b>NOTE:</b> IX+5 is the number of characters printed.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*040D</div><div>JR C,041FH</div><div>If it is a control character, jump to 0419H.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*040F</div><div>SUB 20H</div><div>Subtract 20H from A to adjust the character to the table.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0411</div><div>LD C,A</div><div>Load A with a carriage return.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0412</div><div>JR 041FH</div><div>JUMP to 041FH.</div></div>
								</div>
							</div>

							<br><h2 class="assembly-section-title nodurda" id="0414H">*0414H-040EH - Inside the PRINTER ROUTINE - We have a CARRIAGE RETURN to print.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3 durda"><div>*0414</div><div>LD A,(IX+05H)</div><div>Load A with a carriage return.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0417</div><div>OR A</div><div>Set the flags for A, including a test for zero/none.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0418</div><div>JR NZ,0434H</div><div>JUMP to 041FH.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*041A</div><div>LD A,0AH</div><div>Load A with a carriage return.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*041C</div><div>LD C,A</div><div>Load A with a carriage return.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*041D</div><div>JR 0434H</div><div>JUMP to 041FH.</div></div>
								</div>
							</div>

							<br><h2 class="assembly-section-title nodurda" id="041F">*041F - 
Inside the PRINTER ROUTINE - If we are here, then C holds the printable 
character to be printed as determined by the PRINTER CHARACTER TABLE.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3 durda"><div>*041F</div><div>LD A,(IX+06H)</div><div>Load A with a carriage return.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0422</div><div>INC A</div><div>Bump IX+04.<br><b>NOTE:</b> IX+4 is the number of lines printed.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0423</div><div>JR Z,0434H</div><div>If A was a carriage return, skip the next few instructions and jump to 042AH.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0425</div><div>CP (IX+05H)</div><div>Check A for a carriage return.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0428</div><div>JR NC,0434H</div><div>If A was a carriage return, skip the next few instructions and jump to 042AH.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*042A</div><div>CALL 01DCH</div><div>GOSUB to 01DCH to wait until the printer is ready (honoring BREAK, if hit).</div></div>
									<div class="assembly-row-combined model3 durda"><div>*042D</div><div>LD A,0DH</div><div>Reset the number of characters printed.<br><b>NOTE:</b> IX+5 is the number of characters printed.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*042F</div><div>OUT (F8H),A</div><div>Send the carriage return to port 0F8H.<br><b>NOTE:</b> 0F8H is the printer port.  If you put data to it, it prints it.  Otherwise, Bits 4-7 hold printer status.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0431</div><div>CALL 3048H</div><div>DURDA NOTE.</div></div>
									<p class="debug-note nodurda" id="0434H">*0434 - Inside the PRINTER ROUTINE - It seems that if something jumps here, we have a valid character in C to print.</p>
									<div class="assembly-row-combined model3 durda"><div>*0434</div><div>CALL 01DCH</div><div>DURDA NOTE.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0437</div><div>LD A,C</div><div>Load A with the number of lines printed.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0438</div><div>OUT (F8H),A</div><div>Send the character to port F8H.<br><b>NOTE:</b> F8H is the printer port.  If you put data to it, it prints it.  Otherwise, Bits 4-7 hold printer status.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*043A</div><div>INC (IX+05H)</div><div>Bump the number of characters printed.<br><b>NOTE:</b> IX+5 is the number of characters printed.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*043D</div><div>CP 0DH</div><div>Compare that to the maximum number of lines per page.<br><b>NOTE:</b> IX+3 is the maximum number of lines per page.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*043F</div><div>JR Z,0445H</div><div>Skip the next instruction by JUMPing to 043DH if the number of lines printed is less than maximum number of lines per page.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0441</div><div>CP 0AH</div><div>Check to see if the character in register A is 0AH (ASCII: LINE FEED character).</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0443</div><div>JR NZ,0448H</div><div>Loop back to 0440H if <kbd>BREAK</kbd> wasn't pressed.</div></div>
									<div class="assembly-row-combined model3 durda" id="0445H"><div>*0445</div><div>CALL 3048H</div><div>GOSUB to 044BH to check the printer.</div></div>
									<div class="assembly-row-combined model3 durda" id="0448H"><div>*0448</div><div>XOR A</div><div>Clear A and the status bits.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0449</div><div>LD A,C</div><div>Load the character into A.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*044A</div><div>RET</div><div>If it is ready (because Z is set) then RETURN.</div></div>

									<p class="debug-note" id="044BH">*044B-0451 - Inside the PRINTER ROUTINE - Subroutine to check to see if PRINTER READY by polling port F8H</p>
									<div class="assembly-row-combined model3"><div>*044B</div><div>IN A,(F8H)</div><div>Set A with the Printer Status Byte.<br><b>NOTE:</b>
 F8H is the printer port.  If Bit 7 is set, the printer is not busy.  If
 Bit 6 is set the printer is not out of paper.  If bit 5 is set, the 
device is selected.  If Bit 4 is set, no printer fault.</div></div>
									<div class="assembly-row-combined model3"><div>*044D</div><div>AND 0F0H</div><div>AND A against F0H (Binary: 11110000) to strip off BITS 3-0, leaving BITS 7-4 intact.</div></div>
									<div class="assembly-row-combined model3"><div>*044F</div><div>CP 30H</div><div>Check to see if the character in register A is 0AH (ASCII: LINE FEED character).</div></div>
									<div class="assembly-row-combined model3"><div>*0451</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="03F5H">*0452-0468 - Initialize KB, DI, PR, RI, RO and RN<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0452</div><div>LD HL,36BFH</div><div>Initialize to Keyboard, Display Drive, and Printer ...</div></div>
									<div class="assembly-row-combined model3"><div>*0455</div><div>LD DE,4015H</div><div>Initialize to Keyboard, Display Drive, and Printer ...</div></div>
									<div class="assembly-row-combined model3"><div>*0458</div><div>LD BC,0018H</div><div>Initialize to Keyboard, Display Drive, and Printer ...</div></div>
									<div class="assembly-row-combined model3"><div>*045B</div><div>LDIR</div></div>
									<div class="assembly-row-combined model3"><div>*045D</div><div>LD HL,36F9H</div><div>Initialize RI, RO, and RN ...</div></div>
									<div class="assembly-row-combined model3"><div>*0460</div><div>LD DE,41E5H</div><div>... by moving the 24 bytes starting at 36F9H ...</div></div>
									<div class="assembly-row-combined model3"><div>*0463</div><div>LD BC,0018H</div><div>... by moving the 24 bytes starting at 36F9H ...</div></div>
									<div class="assembly-row-combined model3"><div>*0466</div><div>LDIR</div></div>
									<div class="assembly-row-combined model3"><div>*0468</div><div>RET</div><div>RETURN.</div></div>
								</div>
							</div>

							<br><h2 id="0469H">0469-046A - These instructions are never called or used.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3 nodurda"><div>*0469-046A</div><div>JR NZ,00DAH</div><div>JUMP to 00DA to JUMP to display a <span class="code">?SN ERROR</span>.</div></div>
									<div class="assembly-row-combined model3 durda"><div>*0469-046A</div><div><a href="#00DAH" class="memory-link">NOP</a></div><div>-</div></div>
								</div>
							</div>

							<br><h2 id="046BH">*046B-0472 - This subroutine zeroes out the PROTECTED SCREEN LINES (if any) and point HL to the start of data<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*046B</div><div>XOR A</div><div>Clear A and all Status Bits.</div></div>
									<div class="assembly-row-combined model3"><div>*046C</div><div>LD (4214H),A</div><div>... by moving the 24 bytes starting at 36F9H ...</div></div>
									<div class="assembly-row-combined model3"><div>*046F</div><div>LD HL,(40A4H)</div><div>... by moving the 24 bytes starting at 36F9H ...</div></div>
									<div class="assembly-row-combined model3"><div>*0472</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0473H">*0473H-04B1H - Video Display DCB.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0473</div><div>DI</div><div>Disable Interrupts.</div></div>
									<div class="assembly-row-combined model3"><div>*0474-0479</div><div>LD L,(IX+03H)<br>LD H,(IX+04H)</div><div>Load HL with the MSB and LSB of the current cursor position (Held in IX+3 and IX+4).</div></div>
									<div class="assembly-row-combined model3"><div>*047A</div><div>LD A,(IX+05H)</div><div>Load HL with the MSB and LSB of the current cursor position (Held in IX+3 and IX+4).</div></div>
									<div class="assembly-row-combined model3"><div>*047D</div><div>OR A</div><div>Set flags.  It will be Z if the cursor is off.</div></div>
									<div class="assembly-row-combined model3"><div>*047E</div><div><a href="#0481H" class="memory-link">JR Z,0481H</a></div><div>Skip the next instruction (i.e., JUMP to 0481H) if the cursor is off.</div></div>
									<div class="assembly-row-combined model3"><div>*0480</div><div>LD (HL),A</div><div>If we are here, the cursor is on so display the character held in A at the current cursor position held in HL.</div></div>
									<div class="assembly-row-combined model3"><div>*0481</div><div>LD A,C</div><div>If we are here, the cursor is on so display the character held in A at the current cursor position held in HL.</div></div>
									<div class="assembly-row-combined model3"><div>*0482</div><div>CP 20H</div><div>Check to see if the character is a control character by comparing A to 20H.  Results:<ul><li>If A=20H it sets the ZERO FLAG.</li><li>If A&lt;20H then the CARRY FLAG will be set</li><li>If A&gt;=20H then the NO CARRY FLAG will be set.</li></ul>If A is a CONTROL CHARACTER then the CARRY FLAG will be set.</div></div>
									<div class="assembly-row-combined model3"><div>*0484</div><div><a href="#0521H" class="memory-link">JP C,0521H</a></div><div>If the CARRY FLAG is set (i.e., we have a control character), JUMP to 0521H.</div></div>
									<div class="assembly-row-combined model3"><div>*0487</div><div>CP C0H</div><div>Check to see if the character is a control character by comparing A to 20H.  Results:<ul><li>If A=20H it sets the ZERO FLAG.</li><li>If A&lt;20H then the CARRY FLAG will be set</li><li>If A&gt;=20H then the NO CARRY FLAG will be set.</li></ul>If A is a CONTROL CHARACTER then the CARRY FLAG will be set.</div></div>
									<div class="assembly-row-combined model3"><div>*0489</div><div><a href="#04B7H" class="memory-link">JR NC,04B7H</a></div><div>If the CARRY FLAG is NOT set (i.e., we have a TAB or SPECIAL CHARACTER), JUMP to 04B7H.</div></div>
									<p class="debug-note" id="048BH">*048B - Inside the CURSOR 
MANAGEMENT ROUTINE - If we are here, the character is not a control 
character, tab, or special characters.</p>
									<div class="assembly-row-combined model3"><div>*048B</div><div><a href="#0576H" class="memory-link">CALL 0576H</a></div><div>GOSUB to 0576H to display the character on the screen.</div></div>
									<div class="assembly-row-combined model3" id="048EH"><div>*048E</div><div>LD A,H</div><div>If we are here, the cursor is on so display the character held in A at the current cursor position held in HL.</div></div>
									<div class="assembly-row-combined model3"><div>*048F</div><div>AND 03H</div><div>Mask A against 03H (0000 0011), so that only the last 2 bits are live (so it can be only 0, 1, 2 or 3).</div></div>
									<div class="assembly-row-combined model3"><div>*0491</div><div>OR 3CH</div><div>OR it against 3CH (0011 1100), so that it is 0011 11xx where xx are those 2 bits (so it can be only 60, 61, 62, or 63).</div></div>
									<div class="assembly-row-combined model3"><div>*0493</div><div>LD H,A</div><div>Load H with the masked A.</div></div>
									<div class="assembly-row-combined model3"><div>*0494</div><div>LD D,(HL)</div><div>Load H with the masked A.</div></div>
									<div class="assembly-row-combined model3"><div>*0495</div><div>LD A,(IX+05H)</div><div>Load H with the masked A.</div></div>
									<div class="assembly-row-combined model3"><div>*0498</div><div>OR A</div><div>OR it against 3CH (0011 1100), so that it is 0011 11xx where xx are those 2 bits (so it can be only 60, 61, 62, or 63).</div></div>
									<div class="assembly-row-combined model3"><div>*0499</div><div><a href="#04A8H" class="memory-link">JR Z,04A8H</a></div><div>If the cursor is NOT on (A is Zero), then jump to 04A8H.</div></div>
									<div class="assembly-row-combined model3"><div>*049B</div><div>LD (IX+05H),D</div><div>Load H with the masked A.</div></div>
									<div class="assembly-row-combined model3"><div>*049E</div><div>LD A,(IX+06H)</div><div>Load H with the masked A.</div></div>
									<div class="assembly-row-combined model3"><div>*04A1</div><div>CP 20H</div><div>Check
 to see if the character is a control character by testing A - 20H.  If 
A=20H it sets the ZERO FLAG.  If A&lt;20H then the CARRY FLAG will be 
set and if A&gt;=20H then the NO CARRY FLAG will be set.  If A is a 
CONTROL CHARACTER then C will be set.</div></div>
									<div class="assembly-row-combined model3"><div>*04A3</div><div><a href="#04A7H" class="memory-link">JR NC,04A7H</a></div><div>If it is not a control character, us it by jumping to 04A7H.</div></div>
									<div class="assembly-row-combined model3"><div>*04A5</div><div>LD A,0B0H</div><div>If it is a control character, then load A with the default cursor of B0H.<br><b>NOTE:</b> B0H is a two pixel wide graphic character located below the letter line.</div></div>
									<div class="assembly-row-combined model3"><div>*04A7</div><div>LD (HL),A</div><div>If it is a control character, then load A with the default cursor of B0H.<br><b>NOTE:</b> B0H is a two pixel wide graphic character located below the letter line.</div></div>
									<div class="assembly-row-combined model3" id="04A8H"><div>*04A8</div><div>LD (IX+03H),L</div><div>If it is a control character, then load A with the default cursor of B0H.<br><b>NOTE:</b> B0H is a two pixel wide graphic character located below the letter line.</div></div>
									<div class="assembly-row-combined model3"><div>*04AB</div><div>LD (IX+04H),H</div><div>If it is a control character, then load A with the default cursor of B0H.<br><b>NOTE:</b> B0H is a two pixel wide graphic character located below the letter line.</div></div>
									<div class="assembly-row-combined model3"><div>*04AE</div><div>XOR A</div><div>Zero A and clear all status flags.</div></div>
									<div class="assembly-row-combined model3"><div>*04AF</div><div>LD A,C</div><div>If it is a control character, then load A with the default cursor of B0H.<br><b>NOTE:</b> B0H is a two pixel wide graphic character located below the letter line.</div></div>
									<div class="assembly-row-combined model3"><div>*04B0</div><div>EI</div><div>Enable Interrupts.</div></div>
									<div class="assembly-row-combined model3"><div>*04B1</div><div>RET</div><div>RETURN.</div></div>
								</div>
							</div>

							<br><h2 id="04B2H">*04B2 - Cursor Management - Move to the start of the line.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*04B2</div><div>LD A,L</div><div>Load register A with the LSB of the current position in register L.</div></div>
									<div class="assembly-row-combined model3"><div>*04B3-04A3</div><div>AND C0H</div><div>Point
 to the beginning of the line by ANDing it against 1100 0000 to keep 
only Bits 6 and 7 (so it will be XX00H, XX40H, XX80H, or XXC0H).</div></div>
									<div class="assembly-row-combined model3"><div>*04B5</div><div>LD L,A</div><div>Load register A with the LSB of the current position in register L.</div></div>
									<div class="assembly-row-combined model3"><div>*04B6</div><div>RET</div><div>RETURN.</div></div>
								</div>
							</div>

							<br><h2 id="04B7H">*04B7 - Cursor Management - We have EITHER a TAB or SPECIAL CHARACTER, so figure it out, and proceed accordingly.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*04B7</div><div>LD A,(IX+07H)</div><div>Load register A with the LSB of the current position in register L.</div></div>
									<div class="assembly-row-combined model3"><div>*04BA</div><div>OR A</div><div>Set the Flags for A.</div></div>
									<div class="assembly-row-combined model3"><div>*04BB</div><div>LD A,C</div><div>Load register A with the LSB of the current position in register L.</div></div>
									<div class="assembly-row-combined model3"><div>*04BC</div><div><a href="#048BH" class="memory-link">JR NZ,048BH</a></div><div>If A is Not Zero, jump to 048BH to display the special character set.</div></div>
									<div class="assembly-row-combined model3"><div>*04BE</div><div>SUB C0H</div><div>Subtract C0H (Binary: 1100 0000) to compute a TAB.</div></div>
									<div class="assembly-row-combined model3"><div>*04C0</div><div><a href="#048EH" class="memory-link">JR Z,048EH</a></div><div>If TAB(0) then jump to 048EH.</div></div>
									<div class="assembly-row-combined model3"><div>*04C2</div><div>LD B,A</div><div>Load B with the number of spaces needed.</div></div>
									<div class="assembly-row-combined model3"><div>*04C3</div><div>LD A,20H</div><div>Load B with the number of spaces needed.</div></div>
									<div class="assembly-row-combined model3"><div>*04C5</div><div><a href="#0576H" class="memory-link">CALL 0576H</a></div><div>GOSUB to 0576H to display the character on screen.</div></div>
									<div class="assembly-row-combined model3"><div>*04C8</div><div><a href="#04C3H" class="memory-link">DJNZ 04C3H</a></div><div>Loop back 2 Instructions until B is exhausted.</div></div>
									<div class="assembly-row-combined model3"><div>*04CA</div><div><a href="#048EH" class="memory-link">JR 048EH</a></div><div>If TAB(0) then jump to 048EH.</div></div>
								</div>
							</div>

							<br><h2 id="04CCH">*04CC - Cursor Management - CURSOR ON.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*04CC</div><div>LD A,(HL)</div><div>Load B with the number of spaces needed.</div></div>
									<div class="assembly-row-combined model3" id="04CDH"><div>*04CD</div><div>LD (IX+05H),A</div><div>Load B with the number of spaces needed.</div></div>
									<div class="assembly-row-combined model3"><div>*04D0</div><div>RET</div><div>RETURN.</div></div>
								</div>
							</div>

							<br><h2 id="04D1H">*04D1 - Cursor Management - CURSOR OFF (Jumped to from 0539H)<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*04D1</div><div>XOR A</div><div>Zero A and all Flags.</div></div>
									<div class="assembly-row-combined model3"><div>*04D2</div><div><a href="#04CDH" class="memory-link">JR 04CDH</a></div><div>JUMP to 04CDH to put the character held in A at the cursor position.</div></div>
								</div>
							</div>

							<br><h2 id="04D4H">*04D4 - Cursor Management - HOME CURSOR<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*04D4</div><div>LD HL,3C00H</div><div>Getting ready to HOME the cursor, so load HL with 3C00H.<br><b>NOTE:</b> 3C00H is the start of the video display RAM.</div></div>
									<div class="assembly-row-combined model3"><div>*04D7</div><div>LD A,(4210H)</div><div>Getting ready to HOME the cursor, so load HL with 3C00H.<br><b>NOTE:</b> 3C00H is the start of the video display RAM.</div></div>
									<div class="assembly-row-combined model3"><div>*04DA</div><div>AND FBH</div><div>Mask A with FBH (Binary: 1111 1011) to turn off Bit 2.</div></div>
									<div class="assembly-row-combined model3"><div>*04DC</div><div><a href="#0570H" class="memory-link">CALL 0570H</a></div><div>GOSUB to 0570H Put A into memory location 4210H (4210H holds the bit mask for port ECH) and then output A to Port ECH.</div></div>
									<div class="assembly-row-combined model3"><div>*04DF</div><div>LD A,(4214H)</div><div>Getting ready to HOME the cursor, so load HL with 3C00H.<br><b>NOTE:</b> 3C00H is the start of the video display RAM.</div></div>
									<div class="assembly-row-combined model3"><div>*04E2</div><div>AND 07H</div><div>AND A with 07H (Binary: 0000 0111) to keep only Bits 0, 1, and 2.  This means that the only possibilities for A are 0-7.</div></div>
									<div class="assembly-row-combined model3" id="04E4H"><div>*04E4</div><div>RET Z</div><div>If A is ZERO (no lines to protect) then RETURN.</div></div>
									<div class="assembly-row-combined model3"><div>*04E5</div><div><a href="#0504H" class="memory-link">CALL 0504H</a></div><div>Since A is not ZERO, we have to protect some lines.  First, GOSUB to 0504H to move the cursor down.</div></div>
									<div class="assembly-row-combined model3" id="04E8H"><div>*04E8</div><div>DEC A</div><div>Decrement A.</div></div>
									<div class="assembly-row-combined model3"><div>*04E9</div><div><a href="#04E4H" class="memory-link">JR 04E4H</a></div><div>Loop back to 04E4H to either RETURN if we are at zero, or move down another line and try again.</div></div>
								</div>
							</div>

							<br><h2 id="04EBH">*04EB - Cursor Management - BACKSPACE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*04EB</div><div>DEC HL</div><div>Decrement A.</div></div>
									<div class="assembly-row-combined model3"><div>*04EC</div><div>LD A,(4210H)</div><div>Load A with the memory contents of 4210H.<br><b>NOTE:</b>
 4210H holds the bit mask for port ECH.  Port ECH stores miscellaneous 
controls.  In this case, we are looking for the bit which holds whether 
we are in LARGE characters or SMALL characters.</div></div>
									<div class="assembly-row-combined model3"><div>*04EF</div><div>AND 04H</div><div>AND A with 07H (Binary: 0000 0111) to keep only Bits 0, 1, and 2.  This means that the only possibilities for A are 0-7.</div></div>
									<div class="assembly-row-combined model3"><div>*04F1</div><div><a href="#04F4H" class="memory-link">JR Z,04F4H</a></div><div>If it is Z is set, then we have small characters, so jump to skip the next instruction.</div></div>
									<div class="assembly-row-combined model3"><div>*04F3</div><div>DEC HL</div><div>Decrement HL to back up the cursor another space.</div></div>
									<div class="assembly-row-combined model3"><div>*04F4</div><div>LD (HL),20H</div><div>Put a space in the current cursor position.</div></div>
									<div class="assembly-row-combined model3"><div>*04F6</div><div>RET</div><div>RETURN.</div></div>
								</div>
							</div>

							<br><h2 id="04F7H">*04F7 - Cursor Management - CURSOR BACK<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*04F7</div><div>LD A,(4210H)</div><div>Put a space in the current cursor position.</div></div>
									<div class="assembly-row-combined model3"><div>*04FA</div><div>AND 04H</div><div>Mask A with 04H (0000 0100) to leave only bit 3 live, allowing Z to be set if Bit 3 is high, and NZ to be set if Bit 3 is low.</div></div>
									<div class="assembly-row-combined model3"><div>*04FC</div><div><a href="#04FFH" class="memory-link">CALL NZ,04FFH</a></div><div>If
 A is not zero (which means A is 4), then GOSUB to the next instruction,
 which is a clever way to run that routine twice since we are in LARGE 
type.</div></div>
									<div class="assembly-row-combined model3"><div>*04FF</div><div>LD A,L</div><div>Put a space in the current cursor position.</div></div>
									<div class="assembly-row-combined model3"><div>*0500</div><div>AND 3FH</div><div>Mask A with 3F (0011 1111) to strip off Bits 6 and 7.  A can now be no higher than 3F (Decimal: 63).</div></div>
									<div class="assembly-row-combined model3"><div>*0502</div><div>DEC HL</div><div>Decrement HL to back up the cursor.</div></div>
									<div class="assembly-row-combined model3"><div>*0503</div><div>RET NZ</div><div>RETURN if we are not at the start of the screen.</div></div>
								</div>
							</div>

							<br><h2 id="0504H">*0504 - Cursor Management - CURSOR DOWN<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0504</div><div>LD DE,0040H</div><div>(If we are at the start of the screen) we need to move down one line, so load DE with 40H (64).</div></div>
									<div class="assembly-row-combined model3"><div>*0507</div><div>ADD HL,DE</div><div>Add DE (64 characters) to HL (current cursor position).</div></div>
									<div class="assembly-row-combined model3"><div>*0508</div><div>RET</div><div>RETURN if we are not at the start of the screen.</div></div>
								</div>
							</div>

							<br><h2 id="0509H">*0509 - Cursor Management - CURSOR FORWARD.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0509</div><div>INC HL</div><div>HL should be holding the current cursor position.  Bump HL one forward.</div></div>
									<div class="assembly-row-combined model3"><div>*050A</div><div>LD A,L</div><div>(If we are at the start of the screen) we need to move down one line, so load DE with 40H (64).</div></div>
									<div class="assembly-row-combined model3"><div>*050B</div><div>AND 3FH</div><div>Mask A with 3F (0011 1111) to strip off Bits 6 and 7.  A can now be no higher than 3F (Decimal: 63).</div></div>
									<div class="assembly-row-combined model3"><div>*050D</div><div>RET NZ</div><div>RETURN if we are not at the start of the screen.</div></div>
								</div>
							</div>

							<br><h2 id="050EH">*050E - Cursor Management - CURSOR UP<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*050E</div><div>LD DE,FFC0H</div><div>(If we are at the start of the screen) we need to move down one line, so load DE with 40H (64).</div></div>
									<div class="assembly-row-combined model3"><div>*0511</div><div>ADD HL,DE</div><div>Subtract 64 (the length a line on screen) from HL to move it to the previous line.</div></div>
									<div class="assembly-row-combined model3"><div>*0512</div><div>RET</div><div>RETURN.</div></div>
								</div>
							</div>

							<br><h2 id="0513H">*0513-0520 - Cursor Management - Turn on DOUBLE SIZE and put the cursor on EVEN columns only.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0513</div><div>LD A,(4210H)</div><div>Load A with the memory contents of 4210H.<br><b>NOTE:</b>
 4210H holds the bit mask for port ECH.  Port ECH stores miscellaneous 
controls.  In this case, we are looking for the bit which holds whether 
we are in LARGE characters or SMALL characters.</div></div>
									<div class="assembly-row-combined model3"><div>*0516</div><div>OR 04H</div><div>OR A against 04 (0000 0100) to turn on the 3rd bit.  This will turn on DOUBLE SIZE characters.</div></div>
									<div class="assembly-row-combined model3"><div>*0518</div><div><a href="#0570H" class="memory-link">CALL 0570H</a></div><div>GOSUB to 0570H to put A into memory location 4210H (4210H holds the bit mask for port ECH) and then output A to Port ECH.</div></div>
									<div class="assembly-row-combined model3"><div>*051B</div><div>INC HL</div><div>Bump HL to move the cursor + 1.</div></div>
									<div class="assembly-row-combined model3"><div>*051C</div><div>LD A,L</div><div>Load A with the memory contents of 4210H.<br><b>NOTE:</b>
 4210H holds the bit mask for port ECH.  Port ECH stores miscellaneous 
controls.  In this case, we are looking for the bit which holds whether 
we are in LARGE characters or SMALL characters.</div></div>
									<div class="assembly-row-combined model3"><div>*051D</div><div>AND FEH</div><div>Mask A (the LSB of the cursor position) with FE (1111 1110) which turns off BIT 0.  This is to set to an even position.</div></div>
									<div class="assembly-row-combined model3"><div>*051F</div><div>LD L,A</div><div>Load A with the memory contents of 4210H.<br><b>NOTE:</b>
 4210H holds the bit mask for port ECH.  Port ECH stores miscellaneous 
controls.  In this case, we are looking for the bit which holds whether 
we are in LARGE characters or SMALL characters.</div></div>
									<div class="assembly-row-combined model3"><div>*0520</div><div>RET</div><div>RETURN.</div></div>
								</div>
							</div>

							<br><h2 id="0560H">*0521-055F - Cursor Management - Process Special Characters<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0521</div><div>LD DE,048EH</div><div>Put
 048EH into DE.  This will eventually act as the RETURN location and is 
the routine that makes sure the cursor is still on the screen.</div></div>
									<div class="assembly-row-combined model3"><div>*0524</div><div>PUSH DE</div><div>Put that RETurn address into the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*0525</div><div>CP 08H</div><div>Compare A with 08H.<br><b>NOTE:</b> 08H is a <span class="code">BACKSPACE</span>.</div></div>
									<div class="assembly-row-combined model3"><div>*0527</div><div><a href="#04EBH" class="memory-link">JR Z,04EBH</a></div><div>If A is <span class="code">BACKSPACE</span>, jump to 04EBH to deal with it.</div></div>
									<div class="assembly-row-combined model3"><div>*0529</div><div>CP 0AH</div><div>Compare A with 08H.<br><b>NOTE:</b> 08H is a <span class="code">BACKSPACE</span>.</div></div>
									<div class="assembly-row-combined model3"><div>*052B</div><div><a href="#05AFH" class="memory-link">JP Z,05AFH</a></div><div>If A is <span class="code">LINE FEED</span>, jump to 05AFH to deal with it.</div></div>
									<div class="assembly-row-combined model3"><div>*052E</div><div>CP 0DH</div><div>Compare A with 08H.<br><b>NOTE:</b> 08H is a <span class="code">BACKSPACE</span>.</div></div>
									<div class="assembly-row-combined model3"><div>*0530</div><div><a href="#05AFH" class="memory-link">JP Z,05AFH</a></div><div>If A is <span class="code">CARRIAGE RETURN</span>, jump to 05AFH to deal with it.</div></div>
									<div class="assembly-row-combined model3"><div>*0533</div><div>CP 0EH</div><div>Compare A with 0EH.<br><b>NOTE:</b> 0EH is a <span class="code">CURSOR ON</span>.</div></div>
									<div class="assembly-row-combined model3"><div>*0535</div><div><a href="#04CCH" class="memory-link">JR Z,04CCH</a></div><div>If A is <span class="code">CURSOR ON</span>, jump to 04CCH to deal with it.</div></div>
									<div class="assembly-row-combined model3"><div>*0537</div><div>CP 0FH</div><div>Compare A with 0EH.<br><b>NOTE:</b> 0EH is a <span class="code">CURSOR ON</span>.</div></div>
									<div class="assembly-row-combined model3"><div>*0539</div><div><a href="#04D1H" class="memory-link">JR Z,04D1H</a></div><div>If A is <span class="code">CURSOR ON</span>, jump to 04CCH to deal with it.</div></div>
									<div class="assembly-row-combined model3"><div>*053B</div><div>SUB 15H</div><div>Subtract 15H (Decimal: 21) from A to bring it down into the control character range.</div></div>
									<div class="assembly-row-combined model3"><div>*053D</div><div><a href="#0560H" class="memory-link">JR Z,0560H</a></div><div>If A is <span class="code">CURSOR ON</span>, jump to 04CCH to deal with it.</div></div>
									<div class="assembly-row-combined model3"><div>*053F</div><div>DEC A</div><div>Decrement A by 1.  This would test for special and alternative characters.</div></div>
									<div class="assembly-row-combined model3"><div>*0540</div><div><a href="#056BH" class="memory-link">JR Z,056BH</a></div><div>If A is 0, jump to 056BH to deal with it.</div></div>
									<div class="assembly-row-combined model3"><div>*0542</div><div>DEC A</div><div>Decrement A by 1.  This would test for <span class="code">DOUBLE SIZE</span>.</div></div>
									<div class="assembly-row-combined model3"><div>*0543</div><div><a href="#0513H" class="memory-link">JR Z,0513H</a></div><div>If A is 0, jump to 056BH to deal with it.</div></div>
									<div class="assembly-row-combined model3"><div>*0545</div><div>DEC A</div><div>Decrement A by 1.  This would test for <span class="code">DOUBLE SIZE</span>.</div></div>
									<div class="assembly-row-combined model3"><div>*0546</div><div><a href="#04F7H" class="memory-link">JR Z,04F7H</a></div><div>If A is 0, jump to 056BH to deal with it.</div></div>
									<div class="assembly-row-combined model3"><div>*0548</div><div>DEC A</div><div>Decrement A by 1.  This would test for <span class="code">DOUBLE SIZE</span>.</div></div>
									<div class="assembly-row-combined model3"><div>*0549</div><div><a href="#0509H" class="memory-link">JR Z,0509H</a></div><div>If A is 0, jump to 056BH to deal with it.</div></div>
									<div class="assembly-row-combined model3"><div>*054B</div><div>DEC A</div><div>Decrement A by 1.  This would test for <span class="code">DOUBLE SIZE</span>.</div></div>
									<div class="assembly-row-combined model3"><div>*054C</div><div><a href="#0504H" class="memory-link">JR Z,0504H</a></div><div>If A is 0, jump to 056BH to deal with it.</div></div>
									<div class="assembly-row-combined model3"><div>*054E</div><div>DEC A</div><div>Decrement A by 1.  This would test for <span class="code">DOUBLE SIZE</span>.</div></div>
									<div class="assembly-row-combined model3"><div>*054F</div><div><a href="#050EH" class="memory-link">JR Z,050EH</a></div><div>If A is 0, jump to 056BH to deal with it.</div></div>
									<div class="assembly-row-combined model3"><div>*0551</div><div>DEC A</div><div>Decrement A by 1.  This would test for <span class="code">HOME CURSOR</span>.</div></div>
									<div class="assembly-row-combined model3"><div>*0552</div><div><a href="#04D4H" class="memory-link">JP Z,04D4H</a></div><div>If A is <span class="code">HOME CURSOR</span>, jump to 04D4H to deal with it.</div></div>
									<div class="assembly-row-combined model3"><div>*0555</div><div>DEC A</div><div>Decrement A by 1.  This would test for <span class="code">HOME CURSOR</span>.</div></div>
									<div class="assembly-row-combined model3"><div>*0556</div><div><a href="#04B2H" class="memory-link">JP Z,04B2H</a></div><div>If A is <span class="code">HOME CURSOR</span>, jump to 04D4H to deal with it.</div></div>
									<div class="assembly-row-combined model3"><div>*0559</div><div>DEC A</div><div>Decrement A by 1.  This would test for <span class="code">HOME CURSOR</span>.</div></div>
									<div class="assembly-row-combined model3"><div>*055A</div><div><a href="#05BCH" class="memory-link">JR Z,05BCH</a></div><div>If A is <span class="code">CLEAR TO END OF LINE</span>, jump to 05BCH to deal with it.</div></div>
									<div class="assembly-row-combined model3"><div>*055C</div><div>DEC A</div><div>Decrement A by 1.  This would test for <span class="code">HOME CURSOR</span>.</div></div>
									<div class="assembly-row-combined model3"><div>*055D</div><div><a href="#05C5H" class="memory-link">JR Z,05C5H</a></div><div>If A is <span class="code">CLEAR TO END OF LINE</span>, jump to 05BCH to deal with it.</div></div>
									<div class="assembly-row-combined model3"><div>*055F</div><div>RET</div><div>RETURN (to 048EH to makes sure the cursor is still on the screen).</div></div>
								</div>
							</div>

							<br><h2 id="0560H">*0560 - Cursor Management - Control Characters.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0560</div><div>LD A,(IX+07H)</div><div>Load A with the contents of IX+07H, which toggles TAB and ALTERNATIVE.</div></div>
									<div class="assembly-row-combined model3"><div>*0563</div><div>AND 01H</div><div>MASK A with 0000 0001, to keep only the character flag bit.</div></div>
									<div class="assembly-row-combined model3"><div>*0565</div><div>XOR 01H</div><div>XOR A with 0000 0001 to toggle the character flag bit.</div></div>
									<div class="assembly-row-combined model3"><div>*0567</div><div>LD (IX+07H),A</div><div>Load A with the contents of IX+07H, which toggles TAB and ALTERNATIVE.</div></div>
									<div class="assembly-row-combined model3"><div>*056A</div><div>RET</div><div>RETURN.</div></div>
								</div>
							</div>

							<br><h2 id="056BH">*056B - Cursor Management - Special and Alternative Characters<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*056B</div><div>LD A,(4210H)</div><div>Load A with the contents of IX+07H, which toggles TAB and ALTERNATIVE.</div></div>
									<div class="assembly-row-combined model3"><div>*056E</div><div>XOR 08H</div><div>XOR A with 0000 0001 to toggle the character flag bit.</div></div>
									<div class="assembly-row-combined model3" id="0570H"><div>*0570</div><div>LD (4210H),A</div><div>Put the toggled A back into memory location 4210H.<br><b>NOTE:</b> 4210H holds the bit mask for port ECH.  Port ECH stores miscellaneous controls.</div></div>
									<div class="assembly-row-combined model3"><div>*0573</div><div>OUT (ECH),A</div><div>Output A to Port ECH.</div></div>
									<div class="assembly-row-combined model3"><div>*0575</div><div>RET</div><div>RETURN.</div></div>
								</div>
							</div>

							<br><h2 id="0576H">0576 - This routine displays a character, 
moves forward either 1 or 2 spaces depending on if we are double size or
 not, and advances the screen if that character pushed the cursor beyond
 the end of the screen.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*0576</div><div>LD (HL),A</div><div>Put the toggled A back into memory location 4210H.<br><b>NOTE:</b> 4210H holds the bit mask for port ECH.  Port ECH stores miscellaneous controls.</div></div>
									<div class="assembly-row-combined model3"><div>*0577</div><div>INC HL</div><div>Bump HL to advance the cursor.</div></div>
									<div class="assembly-row-combined model3"><div>*0578</div><div>LD A,(4210H)</div><div>Put the toggled A back into memory location 4210H.<br><b>NOTE:</b> 4210H holds the bit mask for port ECH.  Port ECH stores miscellaneous controls.</div></div>
									<div class="assembly-row-combined model3"><div>*057B</div><div>AND 04H</div><div>Mask A with 04H (0000 0100), so the only possibilties are 4 (0000 0100) or 0 (0000 0000).</div></div>
									<div class="assembly-row-combined model3"><div>*057D</div><div><a href="#0580H" class="memory-link">JR Z,0580H</a></div><div>If it is zero, then we are SMALL SIZE, and JUMP to 0580H.</div></div>
									<div class="assembly-row-combined model3"><div>*057F</div><div>INC HL</div><div>Bump HL to advance the cursor.</div></div>
									<div class="assembly-row-combined model3"><div>*0580</div><div>LD A,H</div><div>We need to test to see if we just fell off the screen, so load A with the MSB of the cursor location.</div></div>
									<div class="assembly-row-combined model3"><div>*0581</div><div>CP 40H</div><div>Compare the MSB of the cursor location held in A against 40H (Binary: 0100 0000, Decimal: 64).</div></div>
									<div class="assembly-row-combined model3"><div>*0583</div><div>RET NZ</div><div>If it is not zero then we did not fall off the screen, then RETURN.</div></div>
									<div class="assembly-row-combined model3"><div>*0584</div><div><a href="#050EH" class="memory-link">CALL 050EH</a></div><div>If we are here then we fell off the screen so first GOSUB to 050EH to move up a line.</div></div>
									<div class="assembly-row-combined model3"><div>*0587</div><div>PUSH HL</div><div>Save the cursor location held in HL to the STACK.</div></div>
									<p class="debug-note" id="0588H">*0588 - Cursor Management - Scroll the Screen</p>
									<div class="assembly-row-combined model3"><div>*0588</div><div>LD A,(4214H)</div><div>We need to test to see if we just fell off the screen, so load A with the MSB of the cursor location.</div></div>
									<div class="assembly-row-combined model3"><div>*058B</div><div>AND 07H</div><div>AND
 A with 07H (0000 0111) to turn off all bits except for Bits 0, 1, and 
2.  This means that the only possibilities for A are 0-7.</div></div>
									<div class="assembly-row-combined model3" id="058DH"><div>*058D</div><div>LD HL,3C00H</div><div>We need to test to see if we just fell off the screen, so load A with the MSB of the cursor location.</div></div>
									<div class="assembly-row-combined model3"><div>*0590</div><div>LD DE,0400H</div><div>Load DE with the size of the screen (1024 characters).</div></div>
									<div class="assembly-row-combined model3"><div>*0593</div><div>PUSH BC</div><div>Save the value in Register Pair BC to the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*0594</div><div>LD BC,0040H</div><div>Load DE with the size of the screen (1024 characters).</div></div>
									<div class="assembly-row-combined model3"><div>*0597</div><div>INC A</div><div>Increase A which is holding the number of lines to protect.</div></div>
									<div class="assembly-row-combined model3" id="0598H"><div>*0598</div><div>ADD HL,BC</div><div>Add BC (the number of characers per line) to HL (the current cursor position), which then moves us down one line.</div></div>
									<div class="assembly-row-combined model3"><div>*0599</div><div>EX DE,HL</div><div>Swap DE and HL which will then reduce the screen size by one line.</div></div>
									<div class="assembly-row-combined model3"><div>*059A</div><div>OR A</div><div>Set the flags for A.</div></div>
									<div class="assembly-row-combined model3"><div>*059B</div><div>SBC HL,BC</div><div>Subtract, with carry, BC from HL.</div></div>
									<div class="assembly-row-combined model3"><div>*059D</div><div>EX DE,HL</div><div>Swap DE and HL which will then reduce the screen size by one line.</div></div>
									<div class="assembly-row-combined model3"><div>*059E</div><div>DEC A</div><div>Reduce A by one, so that we have one less line to protect.</div></div>
									<div class="assembly-row-combined model3"><div>*059F</div><div><a href="#0598H" class="memory-link">JR NZ,0598H</a></div><div>Loop back to 0598H until we have finished this for all protectable lines.</div></div>
									<div class="assembly-row-combined model3"><div>*05A1</div><div>PUSH DE</div><div>Save DE to the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*05A2</div><div>PUSH HL</div><div>Save DE to the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*05A3</div><div>OR A</div><div>Set the flags for A, as we prepare to move the start back up.</div></div>
									<div class="assembly-row-combined model3"><div>*05A4</div><div>SBC HL,BC</div><div>Subtract, with carry, BC from HL to move up one line.</div></div>
									<div class="assembly-row-combined model3"><div>*05A6</div><div>EX DE,HL</div><div>Swap DE and HL so that the source is now the start of screen plus one line.</div></div>
									<div class="assembly-row-combined model3"><div>*05A7</div><div>POP HL</div><div>Restore HL from the STACK.  HL will be the START OF SCREEN.</div></div>
									<div class="assembly-row-combined model3"><div>*05A8</div><div>POP BC</div><div>Restore HL from the STACK.  HL will be the START OF SCREEN.</div></div>
									<div class="assembly-row-combined model3"><div>*05A9</div><div>LDIR</div><div>Scroll the unprotected portions of the screen.</div></div>
									<div class="assembly-row-combined model3"><div>*05AB</div><div>POP BC</div><div>Restore HL from the STACK.  HL will be the START OF SCREEN.</div></div>
									<div class="assembly-row-combined model3"><div>*05AC</div><div>EX DE,HL</div><div>Swap DE and HL so that the source is now the start of screen plus one line.</div></div>
									<div class="assembly-row-combined model3"><div>*05AD</div><div><a href="#05C6H" class="memory-link">JR 05C6H</a></div><div>JUMP to 05C6H to clear to the end of screen without changing HL.</div></div>
								</div>
							</div>

							<br><h2 id="05AFH">*05AF - Cursor Management - CARRIAGE RETURN or LINE FEED<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*05AF</div><div><a href="#04B2H" class="memory-link">CALL 04B2H</a></div><div>GOSUB to 04B2H to move to the start of the line.</div></div>
									<div class="assembly-row-combined model3"><div>*05B2</div><div>PUSH HL</div><div>Save HL (the cursor position) to the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*05B3</div><div><a href="#0504H" class="memory-link">CALL 0504H</a></div><div>GOSUB to 0504H to move the cursor down one line.</div></div>
									<div class="assembly-row-combined model3"><div>*05B6</div><div>LD A,H</div><div>We need to test to see if we just fell off the screen, so load A with the MSB of the cursor location.</div></div>
									<div class="assembly-row-combined model3"><div>*05B7</div><div>CP 40H</div><div>Compare the MSB of the cursor location held in A against 40H (64).</div></div>
									<div class="assembly-row-combined model3"><div>*05B9</div><div><a href="#0588H" class="memory-link">JR Z,0588H</a></div><div>If we fell off the screen the JUMP to 0588H to scroll the screen.</div></div>
									<div class="assembly-row-combined model3"><div>*05BB</div><div>POP DE</div><div>Otherwise restore DE from the STACK to get the old cursor position.</div></div>
								</div>
							</div>

							<br><h2 id="05BCH">*05BC - Cursor Management - CLEAR TO END OF LINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*05BC</div><div>PUSH HL</div><div>Save HL (the cursor position) to the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*05BD</div><div>LD D,H</div><div>We need to test to see if we just fell off the screen, so load A with the MSB of the cursor location.</div></div>
									<div class="assembly-row-combined model3"><div>*05BE</div><div>LD A,L</div><div>We need to test to see if we just fell off the screen, so load A with the MSB of the cursor location.</div></div>
									<div class="assembly-row-combined model3"><div>*05BF</div><div>OR 3FH</div><div>MASK the LSB of the END OF THE LINE with 3F (63).</div></div>
									<div class="assembly-row-combined model3"><div>*05C1</div><div>LD E,A</div><div>Load E with the masked value of the END OF THE LINE.</div></div>
									<div class="assembly-row-combined model3"><div>*05C2</div><div>INC DE</div><div>Bump DE by one so it now points to the start of the next line.</div></div>
									<div class="assembly-row-combined model3"><div>*05C3</div><div><a href="#05C9H" class="memory-link">JR 05C9H</a></div><div>JUMP to 05C9H to clear to the end of the line.</div></div>
								</div>
							</div>

							<br><h2 id="05C5H">*05C5 - Cursor Management - CLEAR TO END OF SCREEN<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*05C5</div><div>PUSH HL</div><div>Save HL (containing the CURSOR POSITION) to the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*05C6</div><div>LD DE,4000H</div><div>Load E with the masked value of the END OF THE LINE.</div></div>
									<div class="assembly-row-combined model3" id="05C9H"><div>+*05C9</div><div>LD (HL),20H</div><div>Put a BLANK into the current cursor position.</div></div>
									<div class="assembly-row-combined model3"><div>|*05CB</div><div>INC HL</div><div>Bump the current cursor position by one.</div></div>
									<div class="assembly-row-combined model3"><div>|*05CC</div><div>RST 18H</div><div>We
 need to check to see if the integer value in HL is greater than or 
equal to DE (which is 1 character off the screen) so we call the COMPARE
 DE:HL routine, which numerically compares DE and HL.   Will not work 
for signed integers (except positive ones). Uses the A-register only. 
The result of the comparison is returned in the status register as:  <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model3"><div>+*05CD</div><div><a href="#05C9H" class="memory-link">JR NZ,05C9H</a></div><div>If that RST 18H call is not zero, then we are not off the screen, so loop back to 05C9H until we are done.</div></div>
									<div class="assembly-row-combined model3"><div>*05CF</div><div>POP HL</div><div>We have cleared the screen so now restore the cursor position back to HL from the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*05D0</div><div>RET</div><div>RETURN.</div></div>
								</div>
							</div>

							<br><h2 class="assembly-section-title nodurda" id="05D1H">*05D1 - These instructions are never called or used.  This was used to hide the name "RON"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<p class="debug-note">Difference between M1 and M3: Rumor has 
it that this is a malicious destruction of the "printer ready" test 
routine found at 05D1H-05D8H in the Model I. In the Model III, the first
 three bytes of the routine are changed from a LD A,(37E8H) instruction 
to 52H, 4FH, and 4EH (LD D,D; LD C,A; and LD C,(HL); or the ASCII 
characters "RON") breaking an otherwise perfectly good routine. An 
equivalent routine that does work (and which would also have fit nicely 
into this space) resides from 044BH to 0451H in the Model III (part of 
the printer driver routine).</p>
									<div class="assembly-row-combined model3 nodurda"><div>*05D1-05D3</div><div>"RON"</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*05D4-05D5</div><div>AND F0H</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*05D6-05D7</div><div>CP 30H</div></div>
									<div class="assembly-row-combined model3 nodurda"><div>*05D8</div><div>RET</div></div>
								</div>
							</div>

							<br><h2 class="assembly-section-title durda" id="05D1H">*05D1 - Message Storage Area<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3 durda"><div>*05D1-05D8</div><div>0EH + "Cass ? + 03H"</div></div>
								</div>
							</div>

							<br><h2 id="05D9H">*05D9-0673 - ACCEPT KEYBOARD INPUT ROUTINE - 
"KLINE" or "LINP1" - WAIT FOR NEXT LINE (take keyboard entry until a 
carriage return, a break, or buffer overrun occurs).<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the most basic of the string input routines and is 
used by the two others (1BB3H and 0361H) as a subroutine. To use it, 
load HL with the required buffer address and the B register with the 
maximum buffer length required. Keyboard input over the specified 
maximum buffer length is ignored, and after pressing the (ENTER) key it 
will return with HL containing the original buffer address and B with 
the string length.<br>A call to this memory location Accepts keyboard 
input and stores each character in a buffer supplied by caller. Input 
continues until either a carriage return or a <kbd>BREAK</kbd> is typed, or until the buffer is full. All edit control codes are recognized, e.g. TAB, BACKSPACE, etc.<br>On
 exit the registers contain: HL=Buffer address, B=Number of characters 
transmitted excluding last, C=Orginal buffer size, A=Last character 
received if a carriage return or <kbd>BREAK</kbd> is typed.  Carry Set 
if break key was terminator, reset otherwise.  If the buffer is full, 
the A register will contain the buffer size.</p>
								<p>To use a ROM call to accept a restricted number of keyboard characters for input (n), use:<br>LD HL,(40A7H)<br>LD B,n<br>CALL 05D9H<br>Up
 to n characters will be accepted, after which the keyboard will simply 
be ignored until the ENTER (or LEFT ARROW, or BREAK, or CLEAR) key is 
pressed. These characters will be stored in consecutive memory cells 
starting at the address contained in 40A7H-40A8H (the keyboard buffer 
area), with a 0DH (carriage return) byte at the end. Upon completion, 
the HL register pair will contain the address of the first character of 
the stored input, and the B register will contain the number of 
characters entered. NOTE: No "?" is displayed as a result of the 
execution of the above program. If the "?" display is desired to prompt 
the typing of the input, precede the above program segment with:<br><span class="code">LD A,3FH<br>CALL 033AH<br>LD A,20H<br>CALL 033AH</span></p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>05D9</div><div>PUSH HL</div><div>Save the start of the input buffer area pointer in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>05DA-05DB</div><div>LD A,0EH</div><div>Load register A with a turn on the cursor character.</div></div>
									<div class="assembly-row-combined model1" id="05DCH"><div>05DC-05DE</div><div><a href="#0033H" class="memory-link">CALL 0033H</a></div><div>Display
 a cursor by calling the DISPLAY A CHARACTER routine at 0033H (which 
puts the character in register A on the video screen).</div></div>
									<div class="assembly-row-combined model1"><div>05DF</div><div>LD C,B</div><div>Load register C with the size of the input buffer in register B.</div></div>
									<div class="assembly-row-combined model1"><div>05E0-05E2</div><div><a href="#0049H" class="memory-link">CALL 0049H</a></div><div>Call the "WAIT FOR KEYBOARD INPUT" routine at 0049H, so as to wait until a key is pressed.</div></div>
									<div class="assembly-row-combined model1"><div>05E3-05E4</div><div>CP 20H</div><div>Check to see if the character is a control character by testing A - 20H.  Results:<ul><li>If A=20H it sets the ZERO FLAG</li><li>If A&lt;20H then the CARRY FLAG will be set</li><li>If A&gt;=20H then the NO CARRY FLAG will be set</li><li>If A is a CONTROL CHARACTER then C will be set.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>05E5-05E6</div><div><a href="#060CH" class="memory-link">JR NC,060CH</a></div><div>JUMP if the key that was pressed in register A is greater than or equal to a <span class="code">SPACE</span>, meaning that it is a printable cahracter.</div></div>
									<div class="assembly-row-combined model1"><div>05E7-05E8</div><div>CP 0DH</div><div>Check to see if the key that was pressed in register A is a <span class="code">CARRIAGE RETURN</span>.</div></div>
									<div class="assembly-row-combined model1"><div>05E9-05EB</div><div><a href="#0662H" class="memory-link">JP Z,0662H</a></div><div>JUMP if the key that was pressed in register A is a <span class="code">CARRIAGE RETURN</span>.</div></div>
									<div class="assembly-row-combined model1"><div>05EC-05ED</div><div>CP 1FH</div><div>Check to see if the key that was pressed in register A is the <span class="code">CLEAR</span> key.</div></div>
									<div class="assembly-row-combined model1"><div>05EE-05EF</div><div><a href="#0619H" class="memory-link">JR Z,0619H</a></div><div>JUMP if the key that was pressed in register A is the <span class="code">CLEAR</span> key.</div></div>
									<div class="assembly-row-combined model1"><div>05F0-05F1</div><div>CP 01H</div><div>Check to see if the key that was pressed in register A is the <kbd>BREAK</kbd> key.</div></div>
									<div class="assembly-row-combined model1"><div>05F2-05F3</div><div><a href="#0661H" class="memory-link">JR Z,0661H</a></div><div>JUMP if the key that was pressed in register A is the <kbd>BREAK</kbd> key.</div></div>
									<div class="assembly-row-combined model1"><div>05F4-05F6</div><div>LD DE,05E0H</div><div>Load register pair DE with the return address of 05E0H.</div></div>
									<div class="assembly-row-combined model1"><div>05F7</div><div>PUSH DE</div><div>Save the return address in register pair DE on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>05F8-05F9</div><div>CP 08H</div><div>Check to see if the key that was pressed in register A is a backspace (which is 08) the cursor and erase character.</div></div>
									<div class="assembly-row-combined model1"><div>05FA-05FB</div><div><a href="#0630H" class="memory-link">JR Z,0630H</a></div><div>JUMP if the key was pressed in register A is a backspace the cursor and erase character.</div></div>
									<div class="assembly-row-combined model1"><div>05FC-05FD</div><div>CP 18H</div><div>Check to see if the key that was pressed in register A is a backspace character.</div></div>
									<div class="assembly-row-combined model1"><div>05FE-05FF</div><div><a href="#062BH" class="memory-link">JR Z,062BH</a></div><div>JUMP if the key that was pressed in register A is a backspace character.</div></div>
									<div class="assembly-row-combined model1"><div>0600-0601</div><div>CP 09H</div><div>Check to see if the key that was pressed in register A is a tab character.</div></div>
									<div class="assembly-row-combined model1"><div>0602-0603</div><div><a href="#0646H" class="memory-link">JR Z,0646H</a></div><div>JUMP if the key that was pressed in register A is a tab character.</div></div>
									<div class="assembly-row-combined model1"><div>0604-0605</div><div>CP 19H</div><div>Check to see if the key that was pressed in register A is a turn on the 32 character per line mode character.</div></div>
									<div class="assembly-row-combined model1"><div>0606-0607</div><div><a href="#0641H" class="memory-link">JR Z,0641H</a></div><div>JUMP if the key that was pressed in register A is a turn on the 32 character per line mode character.</div></div>
									<div class="assembly-row-combined model1"><div>0608-0609</div><div>CP 0AH</div><div>Check to see if the key that was pressed in register A is a line feed character of CHR$(10).</div></div>
									<div class="assembly-row-combined model1"><div>060A</div><div>RET NZ</div><div>Return (to 05E0H) if the key that was pressed in register A isn't a line feed character.</div></div>
									<div class="assembly-row-combined model1"><div>060B</div><div>POP DE</div><div>Get the return address from the STACK and put it in register pair DE (so that it isn't 05E0H anymore).</div></div>
									<div class="assembly-row-combined model1"><div>060C</div><div>LD (HL),A</div><div>We
 now know that the key pressed is a printable character so save the key 
that was pressed in register A at the location of the input buffer 
pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>060D</div><div>LD A,B</div><div>Load register A with the length of the buffer remaining in register B.</div></div>
									<div class="assembly-row-combined model1"><div>060E</div><div>OR A</div><div>Check to see if there is any more of the input buffer remaining (and set status).</div></div>
									<div class="assembly-row-combined model1"><div>060F-0610</div><div><a href="#05E0H" class="memory-link">JR Z,05E0H</a></div><div>JUMP to 05E0H if the end of the input buffer has been reached.</div></div>
									<div class="assembly-row-combined model1"><div>0611</div><div>LD A,(HL)</div><div>Now
 we know the end of the input buffer has not been reached, so load 
register A with the value at the location of the input buffer pointer in
 register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0612</div><div>INC HL</div><div>Increment the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0613-0615</div><div><a href="#0033H" class="memory-link">CALL 0033H</a></div><div>Display
 the character by calling the DISPLAY A CHARACTER routine at 0033H 
(which puts the character in register A on the video screen).</div></div>
									<div class="assembly-row-combined model1"><div>0616</div><div>DEC B</div><div>Decrement the number of bytes remaining in the input buffer area in register B.</div></div>
									<div class="assembly-row-combined model1" id="0617H"><div>0617-0618</div><div><a href="#05E0H" class="memory-link">JR 05E0H</a></div><div>JUMP to 05E0H to get the next character.</div></div>
									<p class="debug-note" id="0619H">Inside the ACCEPT KEYBOARD INPUT ROUTINE.  If we are here, the <span class="code">CLEAR</span> key was hit.</p>
									<div class="assembly-row-combined model1"><div>0619-061B</div><div><a href="#01C9H" class="memory-link">CALL 01C9H</a></div><div>Call the CLEAR SCREEN routine at 01C9H (which clears the screen, changes to 64 characters, and homes the screen).</div></div>
									<div class="assembly-row-combined model1"><div>061C</div><div>LD B,C</div><div>Load register B with the length of the input buffer in register C (which resets the counter of characters transmitted).</div></div>
									<div class="assembly-row-combined model1"><div>061D</div><div>POP HL</div><div>Get
 the starting address for the input buffer area from the STACK and put 
it in register pair HL (which resets the buffer address).</div></div>
									<div class="assembly-row-combined model1"><div>061E</div><div>PUSH HL</div><div>Save the starting address for the input buffer area in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>061F-0621</div><div><a href="#05E0H" class="memory-link">JP 05E0H</a></div><div>JUMP to 05E0H (to get the next character, which is now the first character in the buffer).</div></div>
									<div class="assembly-row-combined model1"><div>0622-0624</div><div><a href="#0630H" class="memory-link">CALL 0630H</a></div><div>GOSUB to wait for the next key and back up the input buffer pointer in register pair HL if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>0625</div><div>DEC HL</div><div>Backup
 to the previous character (the one before the CARRIAGE RETURN) by 
decrementing the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0626</div><div>LD A,(HL)</div><div>Load register A with the character at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0627</div><div>INC HL</div><div>Increment the input buffer pointer in register pair HL to the net availabile position.</div></div>
									<div class="assembly-row-combined model1"><div>0628-0629</div><div>CP 0AH</div><div>Check to see if the character in register A is the line feed character of CHR$(10).</div></div>
									<div class="assembly-row-combined model1"><div>062A</div><div>RET Z</div><div>Return if the character in register A is a line feed character.</div></div>
									<div class="assembly-row-combined model1"><div>062B</div><div>LD A,B</div><div>Now
 we know that character wasn't a line feed, so we need to test for a 
buffer full.  This loads register A with the number of bytes remaining 
in the input buffer area in register B.</div></div>
									<div class="assembly-row-combined model1"><div>062C</div><div>CP C</div><div>Check
 to see if the number of characters remaining in the input buffer area 
in register A is the same as the length of the input buffer area in 
register C.</div></div>
									<div class="assembly-row-combined model1"><div>062D-062E</div><div><a href="#0622H" class="memory-link">JR NZ,0622H</a></div><div>JUMP to 0622H if there is room for more characters.</div></div>
									<div class="assembly-row-combined model1"><div>062F</div><div>RET</div><div>The buffer is full!  Return.</div></div>
								</div>
							</div>

							<br><h2 id="0630H">0630 - This subroutine processes a backspace. 
 On entry, B is the number of characters received, and C is the size of 
the buffer.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0630</div><div>LD A,B</div><div>Load register A with the number of bytes remaining in the input buffer area in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0631</div><div>CP C</div><div>Compare
 the number of bytes remaining in the input buffer (held in Register A) 
against the size of the buffer (held in Register C) to see if the buffer
 is full.</div></div>
									<div class="assembly-row-combined model1"><div>0632</div><div>RET Z</div><div>Return if the input buffer area is full.</div></div>
									<div class="assembly-row-combined model1"><div>0633</div><div>DEC HL</div><div>Decrement the input buffer area pointer in register pair HL to backspace the previous character ...</div></div>
									<div class="assembly-row-combined model1"><div>0634</div><div>LD A,(HL)</div><div>... and then get that character into Register A.</div></div>
									<div class="assembly-row-combined model1"><div>0635-0636</div><div>CP 0AH</div><div>Check to see if the character in register A is the line feed character of CHR$(10).</div></div>
									<div class="assembly-row-combined model1"><div>0637</div><div>INC HL</div><div>Increment the input buffer area pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0638</div><div>RET Z</div><div>Return if the character in register A is a line feed character.</div></div>
									<div class="assembly-row-combined model1"><div>0639</div><div>DEC HL</div><div>Decrement the input buffer area pointer in register pair HL to backspace the previous character in the buffer ...</div></div>
									<div class="assembly-row-combined model1"><div>063A-063B</div><div>LD A,08H</div><div>Load register A with a backspace of CHR$(08) and then ...</div></div>
									<div class="assembly-row-combined model1"><div>063C-063E</div><div><a href="#0033H" class="memory-link">CALL 0033H</a></div><div>Effectuate
 the backspace by calling the DISPLAY A CHARACTER routine at 0033H 
(which puts the character in register A on the video screen).</div></div>
									<div class="assembly-row-combined model1"><div>063F</div><div>INC B</div><div>Increment the number of characters remaining in the input buffer area in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0640</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0641H">0641 - This subroutine sends the position command.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0641-0642</div><div>LD A,17H</div><div>Load register A with 17H (Decimal: 23) so as to turn on the 32 character per line mode character.</div></div>
									<div class="assembly-row-combined model1"><div>0643-0645</div><div><a href="#0033H" class="memory-link">JP 0033H</a></div><div>Call
 the DISPLAY A CHARACTER routine at 0033H (which puts the character in 
register A on the video screen). Since that is the 32 character per line
 mode, that's what happens.</div></div>
									<div class="assembly-row-combined model1"><div>0646-0648</div><div><a href="#0348H" class="memory-link">CALL 0348H</a></div><div>GOSUB to 0348H to get the cursor line position and return with it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0649-064A</div><div>AND 07H</div><div>Mask the cursor line position in register A by ANDing it against 0000 0111, leaving A to be only between 0 and 7.</div></div>
									<div class="assembly-row-combined model1"><div>064B</div><div>CPL</div><div>Invert the value in register A (Binary: 1111 1xxx).</div></div>
									<div class="assembly-row-combined model1"><div>064C</div><div>INC A</div><div>Increment the value in register A so that it is 1 &lt;= A &lt;= 8.</div></div>
									<div class="assembly-row-combined model1"><div>064D-064E</div><div>ADD 08H</div><div>Add
 08H (Binary: 0000 1000) to A to clear the upper bits of the counter 
(because they were all 1's from the invert, so this will push them all 
to zero).</div></div>
									<div class="assembly-row-combined model1"><div>064F</div><div>LD E,A</div><div>Load register E with the number of spaces to be added in register A.</div></div>
									<div class="assembly-row-combined model1"><div>+0650</div><div>LD A,B</div><div>Load register A with the number of bytes remaining in the input buffer area in register B.</div></div>
									<div class="assembly-row-combined model1"><div>|0651</div><div>OR A</div><div>Set the flags to check to see if the buffer is full.</div></div>
									<div class="assembly-row-combined model1"><div>|0652</div><div>RET Z</div><div>Return if the input buffer is full.</div></div>
									<div class="assembly-row-combined model1"><div>|0653-0654</div><div>LD A,20H</div><div>Load register A with a space character.</div></div>
									<div class="assembly-row-combined model1"><div>|0655</div><div>LD (HL),A</div><div>Load register A with a space character.</div></div>
									<div class="assembly-row-combined model1"><div>|0656</div><div>INC HL</div><div>Increment the input buffer area pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>|0657</div><div>PUSH DE</div><div>Save the value in register pair DE on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>|0658-065A</div><div><a href="#0033H" class="memory-link">CALL 0033H</a></div><div>Display
 the space by calling the DISPLAY A CHARACTER routine at 0033H (which 
puts the character in register A on the video screen).</div></div>
									<div class="assembly-row-combined model1"><div>|065B</div><div>POP DE</div><div>Get the value from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>|065C</div><div>DEC B</div><div>Since you just displayed one of the spaces, decrement the number of bytes remaining in the input buffer area in register B ...</div></div>
									<div class="assembly-row-combined model1"><div>|065D</div><div>DEC E</div><div>Since you just displayed one of the spaces, decrement the number of bytes remaining in the input buffer area in register B ...</div></div>
									<div class="assembly-row-combined model1"><div>|065E</div><div>RET Z</div><div>Return if the input buffer is full.</div></div>
									<div class="assembly-row-combined model1"><div>+065F-0660</div><div><a href="#0650H" class="memory-link">JR 0650H</a></div><div>Loop back to 0650H until all the spaces have been added to the input buffer.</div></div>
								</div>
							</div>

							<br><h2 id="0661H">0661 - This subroutine is called when a <kbd>BREAK</kbd> key is hit.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0661</div><div>SCF</div><div>Set the CARRY FLAG.</div></div>
									<p class="debug-note" id="0662H">0662H - Inside the <kbd>BREAK</kbd> KEY routine - Jumps here if an <kbd>ENTER</kbd> was hit, to have the same result, but with the CARRY FLAG untouched.</p>
									<div class="assembly-row-combined model1"><div>0662</div><div>PUSH AF</div><div>Save the value in register pair AF on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0663-0664</div><div>LD A,0DH</div><div>Load register A with a carriage return character.</div></div>
									<div class="assembly-row-combined model1"><div>0665</div><div>LD (HL),A</div><div>Save the carriage return character in register A at the location of the input buffer area pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0666-0668</div><div><a href="#0033H" class="memory-link">CALL 0033H</a></div><div>Display
 the carriage return by calling the DISPLAY A CHARACTER routine at 0033H
 (which puts the character in register A on the video screen).  Since 
that is a CARRIAGE RETURN, that's what happens.</div></div>
									<div class="assembly-row-combined model1"><div>0669-066A</div><div>LD A,0FH</div><div>Load register A with a turn off the cursor character.</div></div>
									<div class="assembly-row-combined model1"><div>066B-066D</div><div><a href="#0033H" class="memory-link">CALL 0033H</a></div><div>Turn
 off the cursor by calling the DISPLAY A CHARACTER routine at 0033H 
(which puts the character in register A on the video screen).</div></div>
									<div class="assembly-row-combined model1"><div>066E</div><div>LD A,C</div><div>Load register A with the length of the input (=buffer size) in register C.</div></div>
									<div class="assembly-row-combined model1"><div>066F</div><div>SUB B</div><div>Subtract
 the number of bytes remaining in the input buffer area in register B 
from the length of the input buffer area in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0670</div><div>LD B,A</div><div>Load register B with the number of characters in the input buffer area in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0671</div><div>POP AF</div><div>Get the value from the STACK and put it in register pair AF.  This also sets the CARRY FLAG if <kbd>BREAK</kbd> and unsets it if CARRIAGE RETURN.</div></div>
									<div class="assembly-row-combined model1"><div>0672</div><div>POP HL</div><div>Get the starting address of the input buffer area from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0673</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0674H">*0674 - KEYBOARD DRIVER ENTRY ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<p class="debug-note">Difference between M1 and M3: In the 
Model I, this is part of the power-up routine and includes the disk 
bootstrap routine (06A1H - 06CBH), the preferred BASIC re-entry routine 
(06CCH-06D1H), and the RST vectors and I/O Device Control Blocks which 
are relocated to RAM on power-up (06D2H-0707H, relocated to 4000H - 
4035H). In the Model III, this area contains the I/O driver entry 
routine (0674H - 0699H) and additional code used by the LIST and LLIST 
commands (069AH - 0707H). Note that a jump to 06CCH will no longer get 
you back into BASIC in the Model III. This might be considered a major 
blunder in the design of the Model III ROM, both because so many 
available programs use this re-entry point to BASIC, and because the ROM
 itself has two jumps to 06CCH (one at 0072H that appears to be unused, 
and one at 02C3H, which is used if the <kbd>BREAK</kbd> key is pressed 
under the SYSTEM command - a bona fide BUG in the Model III ROM). A 
substitute re-entry to BASIC that will work with either model is to LD 
BC,1A18H and then JP 19AEH (this is the code presently found at 06CCH in
 the Model I).</p>
									<div class="assembly-row-combined model3"><div>*0674</div><div>PUSH HL</div><div>Save register pair HL to the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*0675</div><div>PUSH IX</div><div>Save register pair HL to the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*0677</div><div>PUSH DE</div><div>Save register pair HL to the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*0678</div><div>POP IX</div><div>Get the starting address of the device control block from the STACK and put it in Special Index Register IX.</div></div>
									<div class="assembly-row-combined model3"><div>*067A</div><div>PUSH DE</div><div>Save register pair HL to the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*067B</div><div>LD HL,0694H</div><div>Load register pair HL with a return address of 0694H (to restore all registers and RETurn).</div></div>
									<div class="assembly-row-combined model3"><div>*067E</div><div>PUSH HL</div><div>Save register pair HL to the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*067F</div><div>LD C,A</div><div>Load register pair HL with a return address of 0694H (to restore all registers and RETurn).</div></div>
									<div class="assembly-row-combined model3"><div>*0680</div><div>LD A,(DE)</div><div>Load register A with the device type code at the location of the device control block pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model3"><div>*0681</div><div>BIT 7,A</div><div>Test Bit 7 of A, which is the bit for a DISK FILE.</div></div>
									<div class="assembly-row-combined model3"><div>*0683</div><div><a href="#068AH" class="memory-link">JR Z,068AH</a></div><div>If not a disk file, then skip the next 3 instructions and JUMP to 068AH.</div></div>
									<div class="assembly-row-combined model3"><div>*0685</div><div>AND B</div><div>Isolate the device code bits in A by AND'ing with the device codes in B.</div></div>
									<div class="assembly-row-combined model3"><div>*0686</div><div>CP B</div><div>Check to see if the updated device type code in register A is the same as the driver entry code in register B.</div></div>
									<div class="assembly-row-combined model3"><div>*0687</div><div>JP NZ,4033H</div><div>JUMP
 to the DOS exit link at 4033H if the updated device type code in 
register A isn't the same as the driver entry code in register B.</div></div>
									<div class="assembly-row-combined model3" id="068AH"><div>*068A</div><div>AND B</div><div>Isolate the device code bits in A by AND'ing with the device codes in B.</div></div>
									<div class="assembly-row-combined model3"><div>*068B</div><div>CP 02H</div><div>Check to see if the updated device type code in register A is the same as the driver entry code in register B.</div></div>
									<div class="assembly-row-combined model3"><div>*068D</div><div>LD L,(IX+01H)</div><div>Load register A with the device type code at the location of the device control block pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model3"><div>*0690</div><div>LD H,(IX+02H)</div><div>Load
 register H with the MSB of the driver entry address at the location of 
the device control block pointer in Special Index Register IX plus one.</div></div>
									<div class="assembly-row-combined model3"><div>*0693</div><div>JP (HL)</div><div>JUMP to the driver entry address in register pair HL.</div></div>
									<div class="assembly-row-combined model3"><div>*0694</div><div>POP DE</div><div>Get the value from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model3"><div>*0695</div><div>POP IX</div><div>Get the value from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model3"><div>*0697</div><div>POP HL</div><div>Get the value from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model3"><div>*0698</div><div>POP BC</div><div>Get the value from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model3"><div>*0699</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="069AH">069AH - This subroutine CLEARS the DATA FLAG, sets up a buffer of 255 bytes (held in D) and JUMPS to 2B8DH.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*069A</div><div>XOR A</div><div>Clear A and all status flags.</div></div>
									<div class="assembly-row-combined model3"><div>*069B</div><div>LD (409FH),A</div><div>Load
 register H with the MSB of the driver entry address at the location of 
the device control block pointer in Special Index Register IX plus one.</div></div>
									<div class="assembly-row-combined model3"><div>*069E</div><div>LD D,FFH</div><div>Load
 register H with the MSB of the driver entry address at the location of 
the device control block pointer in Special Index Register IX plus one.</div></div>
									<div class="assembly-row-combined model3"><div>*06A0</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2B8DH" class="memory-link">JP 2B8DH</a></div><div>JUMP
 to 2B8DH which is in the middle of the TOKENize routine.  This address 
loads A with the current character at the BASIC line pointer, tests for 
end of line, puts it into the memory location pointed to by BC, and 
exits.</div></div>
									<div class="assembly-row-combined model3" id="06A3H"><div>*06A3</div><div>AND FDH</div><div>Mask A with FDH (1111 1101) to turn off Bit 1.</div></div>
									<div class="assembly-row-combined model3"><div>*06A5</div><div>LD (409FH),A</div><div>Put
 A into the DATA FLAG held in 409FH.  Note: Bit 0 HIGH means inside a 
quote.  Bit 1 HIGH means inside a DATA.  Bit 2 HIGH means inside a REM.</div></div>
									<div class="assembly-row-combined model3"><div>*06A8</div><div>LD A,3AH</div><div>Put
 A into the DATA FLAG held in 409FH.  Note: Bit 0 HIGH means inside a 
quote.  Bit 1 HIGH means inside a DATA.  Bit 2 HIGH means inside a REM.</div></div>
									<div class="assembly-row-combined model3"><div>*06AA</div><div>OR A</div><div>Set the flags, to start a check for a reserved word.</div></div>
									<div class="assembly-row-combined model3"><div>*06AB</div><div><a href="#06E2H" class="memory-link">JP P,06E2H</a></div><div>JUMP
 to 2B8DH which is in the middle of the TOKENize routine.  This address 
loads A with the current character at the BASIC line pointer, tests for 
end of line, puts it into the memory location pointed to by BC, and 
exits.</div></div>
									<div class="assembly-row-combined model3"><div>*06AE</div><div>LD A,(409FH)</div><div>Put
 A into the DATA FLAG held in 409FH.  Note: Bit 0 HIGH means inside a 
quote.  Bit 1 HIGH means inside a DATA.  Bit 2 HIGH means inside a REM.</div></div>
									<div class="assembly-row-combined model3"><div>*06B1</div><div>RRA</div><div>Rotate A right one bit, with the bit that falls off (BIT 0) being moved to the CARRY FLAG, and the CARRY FLAG is moved to BIT 7.</div></div>
									<div class="assembly-row-combined model3"><div>*06B2</div><div><a href="#06E2H" class="memory-link">JR C,06E2H</a></div><div>If
 CARRY is set then we are in quoted string so JUMP to 06E2H which then 
JUMPs to 2B89H which is in the middle of the TOKENize routing.  This 
address bumps BC (the input buffer pointer), reduces D (the buffer 
counter), moves the BASIC line pointer forward, and continues.</div></div>
									<div class="assembly-row-combined model3"><div>*06B4</div><div>RRA</div><div>Rotate A right one bit, with the bit that falls off (BIT 0) being moved to the CARRY FLAG, and the CARRY FLAG is moved to BIT 7.</div></div>
									<div class="assembly-row-combined model3"><div>*06B5</div><div>RRA</div><div>Rotate A right one bit, with the bit that falls off (BIT 0) being moved to the CARRY FLAG, and the CARRY FLAG is moved to BIT 7.</div></div>
									<div class="assembly-row-combined model3"><div>*06B6</div><div><a href="#06F6H" class="memory-link">JR NC,06F6H</a></div><div>If
 CARRY is set then we are in quoted string so JUMP to 06E2H which then 
JUMPs to 2B89H which is in the middle of the TOKENize routing.  This 
address bumps BC (the input buffer pointer), reduces D (the buffer 
counter), moves the BASIC line pointer forward, and continues.</div></div>
									<div class="assembly-row-combined model3"><div>*06B8</div><div>LD A,(HL)</div><div>At this point, we assume this is a TOKEN.  So load A with the contents of HL to get the token.</div></div>
									<div class="assembly-row-combined model3"><div>*06B9</div><div>CP FBH</div><div>Check A against FBH (Binary: 1111 1011) to see if it is a <span class="code">REM</span> TOKEN.</div></div>
									<div class="assembly-row-combined model3"><div>*06BB</div><div>PUSH HL</div><div>Save HL (Position in Text) to the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*06BC</div><div>PUSH BC</div><div>Save HL (Position in Text) to the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*06BD</div><div>LD HL,06DFH</div><div>At this point, we assume this is a TOKEN.  So load A with the contents of HL to get the token.</div></div>
									<div class="assembly-row-combined model3"><div>*06C0</div><div>PUSH HL</div><div>Save HL (the return) to the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*06C1</div><div>RET NZ</div><div>RETURN if this is NOT a <span class="code">REM</span> TOKEN.</div></div>
									<p class="debug-note" id="06C2H">The next set of instructions tests the buffer backwards for <span class="code">M</span>, <span class="code">E</span>, and <span class="code">R</span>, and RETURNS out if those are not found.</p>
									<div class="assembly-row-combined model3"><div>*06C2</div><div>DEC BC</div><div>Decrement the Buffer to back up one character.</div></div>
									<div class="assembly-row-combined model3"><div>*06C3</div><div>LD A,(BC)</div><div>Put the character in the buffer into A.</div></div>
									<div class="assembly-row-combined model3"><div>*06C4</div><div>CP 4DH</div><div>Test A for a 4DH (ASCII: <span class="code">M</span>).</div></div>
									<div class="assembly-row-combined model3"><div>*06C6</div><div>RET NZ</div><div>RETURN if this is NOT a <span class="code">REM</span> TOKEN.</div></div>
									<div class="assembly-row-combined model3"><div>*06C7</div><div>DEC BC</div><div>Decrement the Buffer to back up one character.</div></div>
									<div class="assembly-row-combined model3"><div>*06C8</div><div>LD A,(BC)</div><div>Put the character in the buffer into A.</div></div>
									<div class="assembly-row-combined model3"><div>*06C9</div><div>CP 45H</div><div>Test A for a 4DH (ASCII: <span class="code">M</span>).</div></div>
									<div class="assembly-row-combined model3"><div>*06CB</div><div>RET NZ</div><div>RETURN if this is NOT a <span class="code">REM</span> TOKEN.</div></div>
									<div class="assembly-row-combined model3"><div>*06CC</div><div>DEC BC</div><div>Decrement the Buffer to back up one character.</div></div>
									<div class="assembly-row-combined model3"><div>*06CD</div><div>LD A,(BC)</div><div>Put the character in the buffer into A.</div></div>
									<div class="assembly-row-combined model3"><div>*06CE</div><div>CP 52H</div><div>Test A for a 4DH (ASCII: <span class="code">M</span>).</div></div>
									<div class="assembly-row-combined model3"><div>*06D0</div><div>RET NZ</div><div>If it is not a <span class="code">R</span> then RETURN.</div></div>
									<p class="debug-note" id="06D1H">At this point BC, BC+1, and BC+2 were <span class="code">REM</span>, so check backwards again for a <span class="code">:</span> and if not, RETURN.</p>
									<div class="assembly-row-combined model3"><div>*06D1</div><div>DEC BC</div><div>Decrement the Buffer to back up one character.</div></div>
									<div class="assembly-row-combined model3"><div>*06D2</div><div>LD A,(BC)</div><div>Put the character in the buffer into A.</div></div>
									<div class="assembly-row-combined model3"><div>*06D3</div><div>CP 3AH</div><div>Test A for a <span class="code">:</span>.</div></div>
									<div class="assembly-row-combined model3"><div>*06D5</div><div>RET NZ</div><div>If it is not a <span class="code">R</span> then RETURN.</div></div>
									<p class="debug-note" id="06D1H">At this point BC, BC+1, BC+2, and BC+3 were <span class="code">:REM</span>.</p>
									<div class="assembly-row-combined model3"><div>*06D6</div><div>POP AF</div><div>Restore AF from the STACK (to clear the STACK).</div></div>
									<div class="assembly-row-combined model3"><div>*06D7</div><div>POP AF</div><div>Restore AF from the STACK (to clear the STACK).</div></div>
									<div class="assembly-row-combined model3"><div>*06D8</div><div>POP HL</div><div>Restore AF from the STACK (to clear the STACK).</div></div>
									<div class="assembly-row-combined model3"><div>*06D9</div><div>INC D<br>INC D<br>INC D<br>INC D</div><div>We need to decrease the buffer size by 4.</div></div>
									<div class="assembly-row-combined model3"><div>*06DD</div><div><a href="#0704H" class="memory-link">JR 0704H</a></div><div>JUMP to 0704H to load the next character held in (HL) into A and JUMP to 2BA0H to see if the current token is <span class="code">ELSE</span> and then keep processing.</div></div>
									<div class="assembly-row-combined model3"><div>*06DF</div><div>POP BC</div><div>Restore AF from the STACK (to clear the STACK).</div></div>
									<div class="assembly-row-combined model3"><div>*06E0</div><div>POP HL</div><div>Restore HL (the text position) from the STACK.</div></div>
									<div class="assembly-row-combined model3"><div>*06E1</div><div>LD A,(HL)</div><div>Put the character at the current text position into A.</div></div>
									<div class="assembly-row-combined model3"><div>*06E2</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2B89H" class="memory-link">JP 2B89H</a></div><div>JUMP
 to 2B89H which is in the middle of the TOKENize routing.  This address 
bumps BC (the input buffer pointer), reduces D (the buffer counter), 
moves the BASIC line pointer forward, and continues.</div></div>
								</div>
							</div>

							<br><h2 id="06E5H">06E5H - This subroutine sets the DATA FLAG to "BIT 1 HIGH" to indicate that we are in a <span class="code">DATA</span> command.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*06E5</div><div>LD A,(409FH)</div><div>Put the character at the current text position into A.</div></div>
									<div class="assembly-row-combined model3"><div>*06E8</div><div>OR 02H</div><div>OR A against 02H (0000 0010) to set BIT 1, the DATA bit.</div></div>
									<div class="assembly-row-combined model3"><div>*06EA</div><div>LD (409FH),A</div><div>Put the character at the current text position into A.</div></div>
									<div class="assembly-row-combined model3"><div>*06ED</div><div>XOR A</div><div>Clear A and all flags.</div></div>
									<div class="assembly-row-combined model3"><div>*06EE</div><div>RET</div><div>RETURN.</div></div>
								</div>
							</div>

							<br><h2 id="06EFH">06EFH - This subroutine sets the DATA FLAG to "BIT 2 HIGH" to indicate that we are in a <span class="code">REM</span> command.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model3"><div>*06EF</div><div>LD A,(409FH)</div><div>Put the character at the current text position into A.</div></div>
									<div class="assembly-row-combined model3"><div>*06F2</div><div>OR 04H</div><div>OR A against 04H (Binary: 0000 0100) to turn on Bit 2, the REM bit.</div></div>
									<div class="assembly-row-combined model3"><div>*06F4</div><div><a href="#06EAH" class="memory-link">JR 06EAH</a></div><div>RETURN.</div></div>

									<div class="assembly-row-combined model3" id="06F6H"><div>*06F6</div><div>RLA</div><div>Rotate
 A left one bit, with the bit that falls off (BIT 7) being moved to the 
CARRY FLAG, and the CARRY FLAG is moved to BIT 0.  If this results in 
the CARRY FLAG being set, then we are in a DATA statement.</div></div>
									<div class="assembly-row-combined model3"><div>*06F7</div><div><a href="#06E2H" class="memory-link">JR C,06E2H</a></div><div>RETURN.</div></div>
									<div class="assembly-row-combined model3"><div>*06F9</div><div>LD A,(HL)</div><div>Load the next character into A.</div></div>
									<div class="assembly-row-combined model3"><div>*06FA</div><div>CP 88H</div><div>Compare A to 88H to see if it is <span class="code">DATA</span>.</div></div>
									<div class="assembly-row-combined model3"><div>*06FC</div><div><a href="#06E5H" class="memory-link">CALL Z,06E5H</a></div><div>If it is <span class="code">DATA</span> then GOSUB to 06E5H to set the flag accordingly.</div></div>
									<div class="assembly-row-combined model3"><div>*06FF</div><div>CP 93H</div><div>Compare A to 88H to see if it is <span class="code">DATA</span>.</div></div>
									<div class="assembly-row-combined model3"><div>*0701</div><div><a href="#06EFH" class="memory-link">CALL Z,06EFH</a></div><div>If it is <span class="code">REM</span> then GOSUB to 06EFH to set the DATA FLAG to indicate that we are inside a  <span class="code">REM</span>.</div></div>
									<div class="assembly-row-combined model3"><div>*0704</div><div>LD A,(HL)</div><div>Load the next character into A.</div></div>
									<div class="assembly-row-combined model3"><div>*0705</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#2BA0H" class="memory-link">JP 2BA0H</a></div><div>JUMP to 2BA0H to see if the current token is <span class="code">ELSE</span> and then keep processing.</div></div>
								</div>
							</div>

							<br><h2 id="070BH">070B-070F - SINGLE PRECISION ADDITION, REG 1 = (HL) + REG 1<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Single-precision addition (REG 1=(HL)+ACC) involving a buffer
 pointed to by the HL register pair and REG 1 (see arithmetic section in
 Part 2 of this manual for information on the ACC). This part of the 
program loads the BCDE registers with the value from the buffer, then 
passes control to 716H.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0708-070A</div><div>LD HL,1380H</div><div>Load register pair HL with the starting address of a single precision value stored in ROM at 1380H.</div></div>
									<div class="assembly-row-combined model1"><div>070B-070D</div><div><a href="#09C2H" class="memory-link">CALL 09C2H</a></div><div>GOSUB to 09C2H (which loads a SINGLE PRECISION value pointed to by register pair HL into register pairs BC and DE).</div></div>
									<div class="assembly-row-combined model1"><div>070E-070F</div><div><a href="#0716H" class="memory-link">JR 0716H</a></div><div>JUMP
 to the SINGLE PRECISION ADD routine at 0716H (which adds the single 
precision value in (BC/DE) to the single precision value in REG 1 (i.e.,
 4121H). The sum is left in REG 1).</div></div>
								</div>
							</div>

							<br><h2 id="0710H">0710-0712 - SINGLE PRECISION SUBTRACTION, REG 1 = (HL) - REG 1<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Single-precision subtraction (REG 1=(HL)-REG 1). This loads 
the BCDE registers with the value from (HL), then passes control to 
0713H.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0710-0712</div><div><a href="#09C2H" class="memory-link">CALL 09C2H</a></div><div>GOSUB to 09C2H (which loads a SINGLE PRECISION value pointed to by register pair HL into register pairs BC and DE).</div></div>
								</div>
							</div>

							<br><h2 id="0713H">0713-0715 - SINGLE PRECISION SUBTRACTION, REG 1 = BCDE - REG 1 - "subSP"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Single-precision subtraction (REG 1=BCDE-REG 1). The routine 
actually inverts REG 1 (i.e., 4121H) and adds it to the contents of the 
BCDE registers which, in effect, is a subtraction. The result will be 
stored in the arithmetic work area (REG 1).</p>
								<p>Note: If you wanted to subtract two single precision numbers,
 store the minuend in the BCDE registers and store the subtrahend in 
4121H-4124H and then CALL 0713H.  The result (in single precision 
format) is in 4121H-4124H in approximately 670 microseconds.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0713-0715<span class="origrom2">SSUB</span></div><div><a href="#0982H" class="memory-link">CALL 0982H</a></div><div>Go reverse the sign of the single precision value in register pairs BC and DE.</div></div>
								</div>
							</div>

							<br><h2 id="0716H">0716-0752 - SINGLE PRECISION ADDITION, REG 1 = BCDE + REG 1 - "ADDSP"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Single-precision addition (REG 1=BCDE+ACC). This routine adds
 two single-precision values and stores the result in REG 1 (i.e., 
4121H) area.</p>
								<p>Note: If you wanted to add 2 single precision numbers via a 
ROM call, store one input into BCDE (with the exponent in B and the LSB 
in E) and the other into 4121H-4124H, and then call 0716H.  The single 
precision result will be in 4121H-4124H approximately 1.3 milliseconds 
later.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0716<span class="origrom2">SADD</span></div><div>LD A,B</div><div>Load register A with the exponent of the single precision value in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0717</div><div>OR A</div><div>Check to see if the single precision value in register pairs BC and DE is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0718</div><div>RET Z</div><div>Return if the single precision value in register pairs BC and DE is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0719-071B</div><div>LD A,(4124H)</div><div>Load register A with the exponent of the single precision value in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>071C</div><div>OR A</div><div>Check to see if the single precision value in REG 1 (i.e., 4121H) is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>071D-071F</div><div><a href="#09B4H" class="memory-link">JP Z,09B4H</a></div><div>JUMP
 to 09B4H (which moves the SINGLE PRECISION value in DC/DE into REG 1) 
if the single precision value in REG 1 (i.e., 4121H) is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0720</div><div>SUB B</div><div>Subtract
 the value of the exponent for the single precision value in register B 
from the value of the exponent for the single precision value in REG 1 
(i.e., 4121H) in register A..</div></div>
									<div class="assembly-row-combined model1"><div>0721-0722</div><div><a href="#072FH" class="memory-link">JR NC,072FH</a></div><div>JUMP
 if the single precision value in register pairs BC and DE is smaller 
than the single precision value in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>0723</div><div>CPL</div><div>Adjust the difference in the exponents in register A so that it is positive.</div></div>
									<div class="assembly-row-combined model1"><div>0724</div><div>INC A</div><div>Increment the difference in the exponents in register A so that it will be the correct positive number.</div></div>
									<div class="assembly-row-combined model1"><div>0725</div><div>EX DE,HL</div><div>Load register pair HL with the 16-bit value in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0726-0728</div><div><a href="#09A4H" class="memory-link">CALL 09A4H</a></div><div>Call 09A4 which moves the SINGLE PRECISION value in REG 1 (i.e., 4121H) to the STACK (stored in LSB/MSB/Exponent order).</div></div>
									<div class="assembly-row-combined model1"><div>0729</div><div>EX DE,HL</div><div>Load register pair DE with the 16-bit value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>072A-072C</div><div><a href="#09B4H" class="memory-link">CALL 09B4H</a></div><div>Call 09B4H which moves the SINGLE PRECISION value in DC/DE into REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>072D</div><div>POP BC</div><div>Get the 16-bit value from the STACK and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>072E</div><div>POP DE</div><div>Get the 16-bit value from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>072F-0730</div><div>CP 19H</div><div>Check
 to see if the difference in the exponents in register A is greater than
 24 (because if it is, the numbre cannot be added because of the 
difference in magnitude).</div></div>
									<div class="assembly-row-combined model1"><div>0731</div><div>RET NC</div><div>Return if the difference in the exponents is too great.</div></div>
									<div class="assembly-row-combined model1"><div>0732</div><div>PUSH AF</div><div>Save the difference in the exponents in register A on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0733-0735</div><div><a href="#09DFH" class="memory-link">CALL 09DFH</a></div><div>Set the sign bits for the single precision values and return with the equality of the sign bits in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0736</div><div>LD H,A</div><div>Load register H with the equality of the sign bits in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0737</div><div>POP AF</div><div>Get the difference of the exponents from the STACK and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0738-073A</div><div><a href="#07D7H" class="memory-link">CALL 07D7H</a></div><div>Go
 shift the single precision value in register pairs BC and DE until it 
lines up with the single precision value in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>073B</div><div>OR H</div><div>Check to see if the sign bits are equal.</div></div>
									<div class="assembly-row-combined model1"><div>073C-073E</div><div>LD HL,4121H</div><div>Load register pair HL with the starting address of REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>073F-0741</div><div><a href="#0754H" class="memory-link">JP P,0754H</a></div><div>JUMP if the signs aren't equal.</div></div>
									<div class="assembly-row-combined model1"><div>0742-0744</div><div><a href="#07B7H" class="memory-link">CALL 07B7H</a></div><div>GOSUB to 07B7H to add the single precision value in BCDE to the single precision value in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>0745-0747</div><div><a href="#0796H" class="memory-link">JP NC,0796H</a></div><div>JUMP if the exponent remains unchanged.</div></div>
									<div class="assembly-row-combined model1"><div>0748</div><div>INC HL</div><div>Increment the memory pointer in register pair HL, so that it points to the exponent in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>0749</div><div>INC (HL)</div><div>Increment the exponent in REG 1 (i.e., 4121H) at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>074A-074C</div><div><a href="#07B2H" class="memory-link">JP Z,07B2H</a></div><div>If the exponent in REG 1 (i.e., 4121H) is too large, JUMP to 07B2H to output an OV ERROR message.</div></div>
									<div class="assembly-row-combined model1"><div>074D-074E</div><div>LD L,01H</div><div>Load register L with the number of bits to shift the single precision result in register pairs BC and DE.</div></div>
									<div class="assembly-row-combined model1"><div>074F-0751</div><div><a href="#07EBH" class="memory-link">CALL 07EBH</a></div><div>GOSUB to 07EBH to shift the single precision result in register pairs BC and DE.</div></div>
									<div class="assembly-row-combined model1"><div>0752-0753</div><div><a href="#0796H" class="memory-link">JR 0796H</a></div><div>JUMP to 0796H.</div></div>
								</div>
							</div>

							<br><h2 id="0754H">0754-077C - SINGLE PRECISION MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0754</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>0755</div><div>SUB B</div><div>Subtract the 8-bit value in register B from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0756</div><div>LD B,A</div><div>Load register B with the result in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0757</div><div>LD A,(HL)</div><div>Load register A with the value at the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0758</div><div>SBC A,E</div><div>Subtract the value in register E from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0759</div><div>LD E,A</div><div>Load register E with the result in register A.</div></div>
									<div class="assembly-row-combined model1"><div>075A</div><div>INC HL</div><div>Increment the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>075B</div><div>LD A,(HL)</div><div>Load register A with the value at the location of the memory pointer in register pair HL (to subtract the middle orders).</div></div>
									<div class="assembly-row-combined model1"><div>075C</div><div>SBC A,D</div><div>Subtract the value in register D from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>075D</div><div>LD D,A</div><div>Load register D with the result in register A.</div></div>
									<div class="assembly-row-combined model1"><div>075E</div><div>INC HL</div><div>Increment the memory pointer in register pair HL (to point to the high orders).</div></div>
									<div class="assembly-row-combined model1"><div>075F</div><div>LD A,(HL)</div><div>Load register A with the value at the location of the memory pointer in register pair HL to subtract the high orders.</div></div>
									<div class="assembly-row-combined model1"><div>0760</div><div>SBC A,C</div><div>Subtract the value in register C from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0761</div><div>LD C,A</div><div>Load register C with the result in register A.</div></div>
									<div class="assembly-row-combined model1" id="0762H"><div>0762-0764</div><div><a href="#07C3H" class="memory-link">CALL C,07C3H</a></div><div>Because
 we want a positive mantissa, check if we have to negate the number.  If
 the CARRY FLAG is set, go convert the single precision value to a 
positive number.</div></div>
									<div class="assembly-row-combined model1"><div>0765</div><div>LD L,B</div><div>Load register L with the exponent of the original value in register pairs BC and DE.</div></div>
									<div class="assembly-row-combined model1"><div>0766</div><div>LD H,E</div><div>Load register H with the LSB of the single precision value in register E.</div></div>
									<div class="assembly-row-combined model1"><div>0767</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1" id="0768H"><div>0768</div><div>LD B,A</div><div>Load register B with the new exponent in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0769</div><div>LD A,C</div><div>Load register A with the MSB of the single precision value in register C.</div></div>
									<div class="assembly-row-combined model1"><div>076A</div><div>OR A</div><div>Check to see if the value in register A is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>076B-076C</div><div><a href="#0785H" class="memory-link">JR NZ,0785H</a></div><div>JUMP if the MSB of the single precision value is nonzero.</div></div>
									<div class="assembly-row-combined model1"><div>076D</div><div>LD C,D</div><div>Shift the NMSB into the MSB by loading register C with the value in register D.</div></div>
									<div class="assembly-row-combined model1"><div>076E</div><div>LD D,H</div><div>Shift the LSB into the NMSB by loading register D with the value in register H.</div></div>
									<div class="assembly-row-combined model1"><div>076F</div><div>LD H,L</div><div>Load register H with the value in register L.</div></div>
									<div class="assembly-row-combined model1"><div>0770</div><div>LD L,A</div><div>Load register L with the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0771</div><div>LD A,B</div><div>Load register A with the new exponent counter in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0772-0773</div><div>SUB 08H</div><div>Subtract the number of bits just shifted from the new exponent counter in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0774-0775</div><div>CP E0H</div><div>Compare A against E0H (Binary:1110 0000) to check to see if three bytes have been shifted.</div></div>
									<div class="assembly-row-combined model1"><div>0776-0777</div><div><a href="#0768H" class="memory-link">JR NZ,0768H</a></div><div>Loop back to 0768H until shift is completed.</div></div>
								</div>
							</div>

							<br><h2 id="0778H">0778H - Zero Register 1 (i.e. 4124H)<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0778<span class="origrom2">RSETSA</span></div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>0779-077B</div><div>LD (4124H),A</div><div>Save the value in register A as the exponent of the single precision result in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>077C</div><div>RET</div><div>Return with a single precision value of zero in REG 1 (i.e., 4121H).</div></div>
								</div>
							</div>

							<br><h2 id="077DH">077D-07A7 - SINGLE PRECISION MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>077D</div><div>DEC B</div><div>Decrement the new exponent counter in register B.</div></div>
									<div class="assembly-row-combined model1"><div>077E</div><div>ADD HL,HL</div><div>Shift the 16-bit value in register pair HL left one bit.</div></div>
									<div class="assembly-row-combined model1"><div>077F</div><div>LD A,D</div><div>Load register A with the NMSB in register D.</div></div>
									<div class="assembly-row-combined model1"><div>0780</div><div>RLA</div><div>Shift the NMSB in register A left one bit and shift a bit from register pair HL if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>0781</div><div>LD D,A</div><div>Save the adjusted NMSB in register A into register D.</div></div>
									<div class="assembly-row-combined model1"><div>0782</div><div>LD A,C</div><div>Load register A with the MSB in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0783</div><div>ADC A,A</div><div>Multiply the value in register A by two and add the value of the CARRY FLAG to register A.</div></div>
									<div class="assembly-row-combined model1"><div>0784</div><div>LD C,A</div><div>Load register C with the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1" id="0785H"><div>0785-0787</div><div><a href="#077DH" class="memory-link">JP P,077DH</a></div><div>Loop until the most significant bit of the single precision value is equal to one.</div></div>
									<div class="assembly-row-combined model1"><div>0788</div><div>LD A,B</div><div>Load register A with the new exponent counter in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0789</div><div>LD E,H</div><div>Load register E with the LSB of the single precision value in register H.</div></div>
									<div class="assembly-row-combined model1"><div>078A</div><div>LD B,L</div><div>Load register B with the value in register L.</div></div>
									<div class="assembly-row-combined model1"><div>078B</div><div>OR A</div><div>Check to see if there were any bits shifted.</div></div>
									<div class="assembly-row-combined model1"><div>078C-078D</div><div><a href="#0796H" class="memory-link">JR Z,0796H</a></div><div>JUMP if there weren't any bits shifted.</div></div>
									<div class="assembly-row-combined model1"><div>078E-0790</div><div>LD HL,4124H</div><div>Load register pair HL with the address of the exponent in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>0791</div><div>ADD A,(HL)</div><div>Add
 the value of the original exponent at the location of the memory 
pointer in register pair HL to the number of bits shifted in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0792</div><div>LD (HL),A</div><div>Save the new exponent in register A at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0793-0794</div><div><a href="#0778H" class="memory-link">JR NC,0778H</a></div><div>JUMP if exponent is too small.</div></div>
									<div class="assembly-row-combined model1"><div>0795</div><div>RET Z</div><div>Return if exponent is equal to zero.</div></div>
									<div class="assembly-row-combined model1" id="0796H"><div>0796</div><div>LD A,B</div><div>Load register A with the LSB of the single precision value in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0797-0799</div><div>LD HL,4124H</div><div>Load register pair HL with the address of the exponent in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>079A</div><div>OR A</div><div>Check to see if the most significant bit of the value in register A is set.</div></div>
									<div class="assembly-row-combined model1"><div>079B-079D</div><div><a href="#07A8H" class="memory-link">CALL M,07A8H</a></div><div>Go check for overflow if the most significant bit in the value in register A is set.</div></div>
									<div class="assembly-row-combined model1"><div>079E</div><div>LD B,(HL)</div><div>Load register B with the exponent at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>079F</div><div>INC HL</div><div>Increment the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>07A0</div><div>LD A,(HL)</div><div>Load register A with the value of the sign at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>07A1-07A2</div><div>AND 80H</div><div>Mask the sign bit in register A (1000 0000).</div></div>
									<div class="assembly-row-combined model1"><div>07A3</div><div>XOR C</div><div>Set the sign bit in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07A4</div><div>LD C,A</div><div>Load register C with the adjusted MSB of the single precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07A5-07A7</div><div><a href="#09B4H" class="memory-link">JP 09B4H</a></div><div>JUMP to 09B4H (which moves the SINGLE PRECISION value in DC/DE into REG 1).</div></div>
								</div>
							</div>

							<br><h2 id="07A8H">07A8-07B6 - SINGLE PRECISION MATH ROUTINE - Check for overflow if the most significant bit in the value in register A is set<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>07A8</div><div>INC E</div><div>Increment the LSB of the single precision value in register E.</div></div>
									<div class="assembly-row-combined model1"><div>07A9</div><div>RET NZ</div><div>Return if the adjusted LSB of the single precision value in register E is nonzero.</div></div>
									<div class="assembly-row-combined model1" id="07AAH"><div>07AA</div><div>INC D</div><div>Increment the NMSB of the single precision value in register D.</div></div>
									<div class="assembly-row-combined model1"><div>07AB</div><div>RET NZ</div><div>Return if the adjusted NMSB of the single precision value in register D is nonzero.</div></div>
									<div class="assembly-row-combined model1" id="07ACH"><div>07AC</div><div>INC C</div><div>Increment the MSB of the single precision value in register C.</div></div>
									<div class="assembly-row-combined model1"><div>07AD</div><div>RET NZ</div><div>Return if the adjusted MSB of the single precision value in register C is nonzero.</div></div>
									<div class="assembly-row-combined model1" id="07AEH"><div>07AE-07AF</div><div>LD C,80H</div><div>Adjust the MSB of the single precision value in register C.</div></div>
									<div class="assembly-row-combined model1"><div>07B0</div><div>INC (HL)</div><div>Increment the exponent of the single precision value at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>07B1</div><div>RET NZ</div><div>Return
 if the adjusted exponent of the single precision value at the location 
of the memory pointer in register pair HL is nonzero.</div></div>
									<div class="assembly-row-combined model1" id="07B2H"><div>07B2-07B3</div><div>LD E,0AH</div><div>Load register E with an OV ERROR code.<br><br>This is the OV ERROR entry point.</div></div>
									<div class="assembly-row-combined model1"><div>07B4-07B6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#19A2H" class="memory-link">JP 19A2H</a></div><div>Go to the Level II BASIC error routine and display an OV ERROR message if the value has overflowed.</div></div>
								</div>
							</div>

							<br><h2 id="07B7H">07B7-07C2H SINGLE PRECISION MATH ROUTINE - Add
 the single precision value in BCDE to the single precision value in REG
 1 (i.e., 4121H).<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>07B7</div><div>LD A,(HL)</div><div>Load register A with the LSB of the single precision value at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>07B8</div><div>ADD A,E</div><div>Add the LSB of the single precision value in register E to the LSB of the single precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07B9</div><div>LD E,A</div><div>Load register E with the result in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07BA</div><div>INC HL</div><div>Increment the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>07BB</div><div>LD A,(HL)</div><div>Load
 register A with the NMSB of the single precision value in REG 1 (i.e., 
4121H) at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>07BC</div><div>ADC A,D</div><div>Add the NMSB of the single precision value in register D to the NMSB of the single precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07BD</div><div>LD D,A</div><div>Load register D with the result in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07BE</div><div>INC HL</div><div>Increment the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>07BF</div><div>LD A,(HL)</div><div>Load
 register A with the MSB of the single precision value in REG 1 (i.e., 
4121H) at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>07C0</div><div>ADC A,C</div><div>Add the MSB of the single precision value in register C to the MSB of the single precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07C1</div><div>LD C,A</div><div>Load register C with the result in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07C2</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="07C3H">07C3-07D6 - SINGLE PRECISION MATH ROUTINE - Convert to a single precision number to positive.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>07C3-07C5</div><div>LD HL,4125H</div><div>Load register pair HL with the address of the sign flag storage location.<br><b>NOTE:</b> 4125H-4126H is used by floating point routines.</div></div>
									<div class="assembly-row-combined model1"><div>07C6</div><div>LD A,(HL)</div><div>Load register A with the value of the sign flag at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>07C7</div><div>CPL</div><div>Complement the sign flag in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07C8</div><div>LD (HL),A</div><div>Save the adjusted sign flag in register A at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>07C9</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>07CA</div><div>LD L,A</div><div>Load register L with the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07CB</div><div>SUB B</div><div>Figure the negative value for register B by subtracting the current value in register B from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07CC</div><div>LD B,A</div><div>Save the adjusted value in register A in register B.</div></div>
									<div class="assembly-row-combined model1"><div>07CD</div><div>LD A,L</div><div>Load register A with zero.</div></div>
									<div class="assembly-row-combined model1"><div>07CE</div><div>SBC A,E</div><div>Figure
 the negative LSB of the single precision value in register E by 
subtracting the current LSB of the single precision value in register E 
from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07CF</div><div>LD E,A</div><div>Load register E with the adjusted LSB of the single precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07D0</div><div>LD A,L</div><div>Load register A with zero.</div></div>
									<div class="assembly-row-combined model1"><div>07D1</div><div>SBC A,D</div><div>Figure
 the negative NMSB of the single precision value in register D by 
subtracting the current NMSB of the single precision value in register D
 from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07D2</div><div>LD D,A</div><div>Load register D with the adjusted NMSB of the single precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07D3</div><div>LD A,L</div><div>Load register A with zero.</div></div>
									<div class="assembly-row-combined model1"><div>07D4</div><div>SBC A,C</div><div>Figure
 the negative MSB of the single precision value in register C by 
subtracting the current MSB of the single precision value in register C 
from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07D5</div><div>LD C,A</div><div>Load register C with the adjusted MSB of the single precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07D6</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="07d7-07f7-single">07D7-07F7 - SINGLE PRECISION MATH 
ROUTINE - Shift the single precision value in register pairs BC and DE 
until it lines up with the single precision value in REG 1 (i.e., 
4121H).<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>07D7-07D8</div><div>LD B,00H</div><div>Load register B with zero.</div></div>
									<div class="assembly-row-combined model1"><div>07D9-07DA</div><div>SUB 08H</div><div>Check to see if the shift counter in register A still indicates at least 8 bits have to be shifted.</div></div>
									<div class="assembly-row-combined model1"><div>07DB-07DC</div><div><a href="#07E4H" class="memory-link">JR C,07E4H</a></div><div>JUMP if less than 8 bits are left to be shifted.</div></div>
									<div class="assembly-row-combined model1"><div>07DD</div><div>LD B,E</div><div>Load register B with the LSB of the single precision value in register E.</div></div>
									<div class="assembly-row-combined model1"><div>07DE</div><div>LD E,D</div><div>Load register E with the NMSB of the single precision value in register D.</div></div>
									<div class="assembly-row-combined model1"><div>07DF</div><div>LD D,C</div><div>Load register D with the MSB of the single precision value in register C.</div></div>
									<div class="assembly-row-combined model1"><div>07E0-07E1</div><div>LD C,00H</div><div>Load register C with zero.</div></div>
									<div class="assembly-row-combined model1"><div>07E2-07E3</div><div><a href="#07D9H" class="memory-link">JR 07D9H</a></div><div>Loop until there is less than 8 bits left to be shifted.</div></div>
									<div class="assembly-row-combined model1"><div>07E4-07E5</div><div>ADD 09H</div><div>Adjust the shift counter in register A to its correct value.</div></div>
									<div class="assembly-row-combined model1"><div>07E6</div><div>LD L,A</div><div>Load register L with the shift counter in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07E7</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>07E8</div><div>DEC L</div><div>Decrement the shift counter in register L.</div></div>
									<div class="assembly-row-combined model1"><div>07E9</div><div>RET Z</div><div>Return if there are no more bits to be shifted.</div></div>
									<div class="assembly-row-combined model1" id="07EAH"><div>07EA</div><div>LD A,C</div><div>Load register A with the MSB of the single precision value in register C.</div></div>
									<div class="assembly-row-combined model1" id="07EBH"><div>07EB</div><div>RRA</div><div>Shift the MSB of the single precision value in register A one place to the right.</div></div>
									<div class="assembly-row-combined model1"><div>07EC</div><div>LD C,A</div><div>Load register C with the adjusted MSB of the single precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07ED</div><div>LD A,D</div><div>Load register A with the NMSB of the single precision value in register D.</div></div>
									<div class="assembly-row-combined model1"><div>07EE</div><div>RRA</div><div>Shift the NMSB of the single precision value in register A one place to the right and pick up the value of the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>07EF</div><div>LD D,A</div><div>Load register D with the adjusted NMSB of the single precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07F0</div><div>LD A,E</div><div>Load register A with the LSB of the single precision value in register E.</div></div>
									<div class="assembly-row-combined model1"><div>07F1</div><div>RRA</div><div>Shift the LSB of the single precision value in register A one place to the right and pick up the value of the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>07F2</div><div>LD E,A</div><div>Load register E with the adjusted LSB of the single precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07F3</div><div>LD A,B</div><div>Load register A with the value in register B.</div></div>
									<div class="assembly-row-combined model1"><div>07F4</div><div>RRA</div><div>Shift the value in register A one place to the right and pick up the value of the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>07F5</div><div>LD B,A</div><div>Load register B with the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>07F6-07F7</div><div><a href="#07E7H" class="memory-link">JR 07E7H</a></div><div>Loop until all of the bits have been shifted.</div></div>
								</div>
							</div>

							<br><h2 id="07f8-07fb-single">07F8-07FB - SINGLE PRECISION CONSTANT STORAGE LOCATION<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>07F8-07FB</div><div>00 00 00 81</div><div>A single precision constant equal to 1.0 is stored here.</div></div>
								</div>
							</div>

							<br><h2 id="07FCH">07FC-0808 - SINGLE PRECISION CONSTANTS STORAGE LOCATION2<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>07FC</div><div>03</div><div>The number of single precision constants which follows is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>07FD-0800</div><div>AA 56 19 80</div><div>A single precision constant equal to .598978 is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>0801-0804</div><div>F1 22 76 80</div><div>A single precision constant equal to .961471 is stored here.</div></div>
									<div class="assembly-row-combined model1"><div>0805-0808</div><div>45 AA 38 82</div><div>A single precision constant equal to 2.88539 is stored here.</div></div>
								</div>
							</div>

							<br><h2 id="0809H">0809-0846 - LEVEL II BASIC LOG ROUTINE - <span class="code">LOG</span><button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p> The LOG(n) routine, (REG 1=LOG (REG 1)). This routine finds the LOGarithm of the value in REG 1 (i.e., 4121H) area.<br>A
 call to 0809H computes the natural log (base E) of the single precision
 value in REG 1 (i.e., 4121H). The result is returned as a single 
precision value in REG 1 (i.e., 4121H).</p>
								<p>NOTE: To use a ROM call to find LOG(X), where X is a positive
 single precision variable, store the value of X in 4121H-4124H and then
 CALL 0809H.  The result (in single precision format) is in 
4121H-4124Hin approximately 19 milliseconds.<br><b>NOTE:</b> A fatal error occurs if the value of the input variable is zero or negative.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0809-080B<span class="origrom2">LOG</span></div><div><a href="#0955H" class="memory-link">CALL 0955H</a></div><div>Go
 check the sign of the single precision value in REG 1 (i.e., 4121H).  
On exit, Register A will be 1 if the single preceision value in REG 1 is
 positive.</div></div>
									<div class="assembly-row-combined model1"><div>080C</div><div>OR A</div><div>Check to see if the single precision value in REG 1 (i.e., 4121H) is negative or positive.</div></div>
									<div class="assembly-row-combined model1"><div>080D-080F</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#1E4AH" class="memory-link">JP PE,1E4AH</a></div><div>Go
 the Level II BASIC error routine and display a FC ERROR message if the 
current single precision value in REG 1 (i.e., 4121H) is negative.</div></div>
									<div class="assembly-row-combined model1"><div>0810-0812</div><div>LD HL,4124H</div><div>At this point we know REG 1 is positive.  Load register pair HL with the address of the exponent in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>0813</div><div>LD A,(HL)</div><div>Load Register A with the exponent of the single precision value in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>0814-0816</div><div>LD BC,8035H</div><div>Load register BC with the exponent and the MSB of a single precision constant (which is 32821).</div></div>
									<div class="assembly-row-combined model1"><div>0817-0819</div><div>LD DE,04F3H</div><div>Load
 register DE with the NMSB and the LSB of a single precision constant 
(which is 1267). Register pairs BC and DE are now equal to the single 
precision constant of .707107.</div></div>
									<div class="assembly-row-combined model1"><div>081A</div><div>SUB B</div><div>Subtract the exponent (in Register B) from the exponent of the x-value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>081B</div><div>PUSH AF</div><div>Save the difference between the two exponents in register A to the top of the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>081C</div><div>LD (HL),B</div><div>Save
 the exponent in register B as the exponent of the x-value in REG 1 
(i.e., 4121H) at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>081D</div><div>PUSH DE</div><div>Save the NMSB and the LSB of the single precision value in register pair DE on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>081E</div><div>PUSH BC</div><div>Save the exponent and the MSB of the single value in register pair BC on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>081F-0831</div><div><a href="#0716H" class="memory-link">CALL 0716H</a></div><div>Go
 add the x-value to the single precision constant in register pairs BC 
and DE and return with the result in REG 1 (i.e., 4121H), by calling the
 SINGLE PRECISION ADD routine at 0716H (which adds the single precision 
value in (BC/DE) to the single precision value in REG 1 (i.e., 4121H). 
The sum is left in REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>0822</div><div>POP BC</div><div>Get the exponent and the MSB of the single precision value from the STACK and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>0823</div><div>POP DE</div><div>Get the NMSB and the LSB of the single precision value from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0824</div><div>INC B</div><div>Multiply the single precision value in register pairs BC and DE by two by bumping the exponent in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0825-0827</div><div><a href="#08A2H" class="memory-link">CALL 08A2H</a></div><div>GOSUB
 to 08A2H to divide the single precision value in register pairs BC and 
DE by the x-value in REG 1 (i.e., 4121H) and return with the result in 
REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>0828-082A</div><div>LD HL,07F8H</div><div>Load register pair HL with the starting address of a single precision constant (which is at 2040).</div></div>
									<div class="assembly-row-combined model1"><div>082B-082D</div><div><a href="#0710H" class="memory-link">CALL 0710H</a></div><div>GOSUB
 to 0710H to subtract the x-value in REG 1 (i.e., 4121H) from the single
 precision constant of 1. 0 at the location of the memory pointer in 
register pair HL and return with the result in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>082E-0830</div><div>LD HL,07FCH</div><div>Load
 register pair HL with the starting address of a storage location for 
single precision constants to be used for a series of computations 
(which is at 2044).</div></div>
									<div class="assembly-row-combined model1"><div>0831-0833</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#149AH" class="memory-link">CALL 149AH</a></div><div>Go do a series of computations and return with the result in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>0834-0836</div><div>LD BC,8080H</div><div>Load register BC with the exponent and the MSB of a single precision constant.</div></div>
									<div class="assembly-row-combined model1"><div>0837-0839</div><div>LD DE,0000H</div><div>Load
 register pair DE with the NMSB and the LSB of a single precision. 
Register pairs BC and DE are now equal to a single precision of -0.5.</div></div>
									<div class="assembly-row-combined model1"><div>083A-083C</div><div><a href="#0716H" class="memory-link">CALL 0716H</a></div><div>GOSUB
 to 0716H to add the x-value in REG 1 (i.e., 4121H) to the single 
precision constant in register pairs BC and DE and return with the 
result in REG 1 (i.e., 4121H), by calling the SINGLE PRECISION ADD 
routine at 0716H (which adds the single precision value in (BC/DE) to 
the single precision value in REG 1 (i.e., 4121H). The sum is left in 
REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>083D</div><div>POP AF</div><div>Get the difference between the two original exponents from the STACK and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>083E-0840</div><div><a href="#0F89H" class="memory-link">CALL 0F89H</a></div><div>GOSUB
 to 0F89H to convert the value in register A to a single precision 
number and add it to the x-value in REG 1 (i.e., 4121H).  Return with 
the result in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0841-0843</div><div>LD BC,8031H</div><div>Load register pair BC with the exponent and the MSB of a single precision constant.</div></div>
									<div class="assembly-row-combined model1"><div>0844-0846</div><div>LD DE,7218H</div><div>Load
 register pair DE with the NMSB and the LSB of a single precision 
constant. Register pairs BC and DE are now equal to a single precision 
value of 0.693147.</div></div>
								</div>
							</div>

							<br><h2 id="0847H">0847-0891 - SINGLE PRECISION MULTIPLICATION, REG 1 = BCDE * REG 1 - "MLTSP"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Single-precision multiplication (REG 1=BCDE*ACC).<br>Multiplies the current value in WRAl by the value in (BC/DE). the product is left in WRAl.</p>
								<p>Note: If you wanted to multiply two single precision numbers 
store one operand in the BCDE registers, the other in 4121H-4124H CALL 
0847H.  The result (in single precision format) is in 4121H-4124H in 
approximately 2.2 milliseconds.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0847-0849<span class="origrom2">SMUL</span></div><div><a href="#0955H" class="memory-link">CALL 0955H</a></div><div>Go check to see if the single precision value in REG 1 (i.e., 4121H) is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>084A</div><div>RET Z</div><div>Return if the single precision value in REG 1 (i.e., 4121H) is equal to zero.</div></div>
									<div class="assembly-row-combined model1" id="084BH"><div>084B</div><div>LD L,00H</div><div>Load register L with a bit mask.</div></div>
									<div class="assembly-row-combined model1"><div>084D</div><div><a href="#0914H" class="memory-link">CALL 0914H</a></div><div>Go check for possible overflow and the single precision value in register pairs BC and DE equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0850</div><div>LD A,C</div><div>Load register A with the single precision value's MSB in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0851</div><div>LD (414FH),A</div><div>Save the MSB of the single precision value in register A at memory location 414FH.</div></div>
									<div class="assembly-row-combined model1"><div>0854</div><div>EX DE,HL</div><div>Load register pair HL with the NMSB and the LSB of the single precision value in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0855</div><div>LD (4150H),HL</div><div>Save the NMSB and the LSB of the single precision value in register pair HL at memory locations 4150H and 4151H.</div></div>
									<div class="assembly-row-combined model1"><div>0858</div><div>LD BC,0000H</div><div>Load register pair BC with zero.</div></div>
									<div class="assembly-row-combined model1"><div>085B</div><div>LD D,B</div><div>Load register D with the value in register B.</div></div>
									<div class="assembly-row-combined model1"><div>085C</div><div>LD E,B</div><div>Load register E with the value in register B.</div></div>
									<div class="assembly-row-combined model1"><div>085D</div><div>LD HL,0765H</div><div>Load register pair HL with the return address.</div></div>
									<div class="assembly-row-combined model1"><div>0860</div><div>PUSH HL</div><div>Save the return address in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0861</div><div>LD HL,0869H</div><div>Load register pair HL with the return address.</div></div>
									<div class="assembly-row-combined model1"><div>0864</div><div>PUSH HL</div><div>Save the return address in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0865</div><div>PUSH HL</div><div>Save the return address in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0866</div><div>LD HL,4121H</div><div>Load register pair HL with the starting address of the single precision value in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>0869</div><div>LD A,(HL)</div><div>Load
 register A with the LSB of the single precision value in REG 1 (i.e., 
4121H) at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>085A</div><div>INC HL</div><div>Increment the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>085B</div><div>OR A</div><div>Check to see if the LSB of the single precision value in REG 1 (i.e., 4121H) in register A is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>086C</div><div><a href="#0892H" class="memory-link">JR Z,0892H</a></div><div>JUMP if the LSB of the single precision value in REG 1 (i.e., 4121H) is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>086E</div><div>PUSH HL</div><div>Save the memory pointer in register HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>086F</div><div>LD L,08H</div><div>Load register L with the bit shift counter.</div></div>
									<div class="assembly-row-combined model1"><div>0871</div><div>RRA</div><div>Shift the LSB of the single precision value in REG 1 (i.e., 4121H) in register A one place to the right.</div></div>
									<div class="assembly-row-combined model1"><div>0872</div><div>LD H,A</div><div>Load register H with the adjusted LSB in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0873</div><div>LD A,C</div><div>Load register A with the MSB of the single precision value in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0874</div><div><a href="#0881H" class="memory-link">JR NC,0881H</a></div><div>JUMP forward to 0881H if BIT 0 in the LSB just shifted wasn't set.</div></div>
									<div class="assembly-row-combined model1"><div>0876</div><div>PUSH HL</div><div>Save the value in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0877</div><div>LD HL,(4150H)</div><div>Load register pair HL with the NMSB and the LSB of the original value in register pairs BC and DE.</div></div>
									<div class="assembly-row-combined model1"><div>087A</div><div>ADD HL,DE</div><div>Add
 the NMSB and the LSB of the total figured so far in register pair DE to
 the NMSB and the LSB of the original value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>087B</div><div>EX DE,HL</div><div>Load register pair DE with the adjusted total in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>087C</div><div>POP HL</div><div>Get the value from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>087D</div><div>LD A,(414FH)</div><div>Load register A with the MSB of the original value in register pairs BC and DE.</div></div>
									<div class="assembly-row-combined model1"><div>0880</div><div>ADC A,C</div><div>Add the MSB of the original value in register A to the MSB of the total figured so far in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0881</div><div>RRA</div><div>Shift the adjusted MSB of the total in register A one place to the right.</div></div>
									<div class="assembly-row-combined model1"><div>0882</div><div>LD C,A</div><div>Load register C with the adjusted MSB of the total in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0883</div><div>LD A,D</div><div>Load register A with the NMSB of the total in register D.</div></div>
									<div class="assembly-row-combined model1"><div>0884</div><div>RRA</div><div>Shift the NMSB of the total in register A one place to the right.</div></div>
									<div class="assembly-row-combined model1"><div>0885</div><div>LD D,A</div><div>Load register D with the adjusted NMSB of the total in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0886</div><div>LD A,E</div><div>Load register A with the LSB of the total in register E.</div></div>
									<div class="assembly-row-combined model1"><div>0887</div><div>RRA</div><div>Shift the LSB of the total in register A one place to the right.</div></div>
									<div class="assembly-row-combined model1"><div>0888</div><div>LD E,A</div><div>Load register E with the adjusted LSB of the total in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0889</div><div>LD A,B</div><div>Load register A with the value in register B.</div></div>
									<div class="assembly-row-combined model1"><div>088A</div><div>RRA</div><div>Shift the value in register A one place to the right.</div></div>
									<div class="assembly-row-combined model1"><div>088B</div><div>LD B,A</div><div>Load register B with the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>088C</div><div>DEC L</div><div>Decrement the bit counter in register L.</div></div>
									<div class="assembly-row-combined model1"><div>088D</div><div>LD A,H</div><div>Load register A with the LSB of the current value in register H.</div></div>
									<div class="assembly-row-combined model1"><div>088E</div><div><a href="#0871H" class="memory-link">JR NZ,0871H</a></div><div>Loop until 8 bits have been shifted.</div></div>
									<div class="assembly-row-combined model1"><div>0890</div><div>POP HL</div><div>Get the memory pointer from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0891</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0892H">0892-0896 - SINGLE PRECISION MATH ROUTINE<br>This is accomplished by a circular shift of BC/DE one byte - B is lost, C is replaced by A.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0892</div><div>LD B,E</div><div>Load register B with the LSB of the single precision value in register E.</div></div>
									<div class="assembly-row-combined model1"><div>0893</div><div>LD E,D</div><div>Load register E with the NMSB of the single precision value in register D.</div></div>
									<div class="assembly-row-combined model1"><div>0894</div><div>LD D,C</div><div>Load register D with the MSB of the single precision value in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0895</div><div>LD C,A</div><div>Load register C with the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0896</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0897-08al-single">0897-08Al - SINGLE PRECISION MATH ROUTINE - Divide a single precision number by 10.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0897-0899</div><div><a href="#09A4H" class="memory-link">CALL 09A4H</a></div><div>Call 09A4 which moves the SINGLE PRECISION value in REG 1 (i.e., 4121H) to the STACK (stored in LSB/MSB/Exponent order).</div></div>
									<div class="assembly-row-combined model1"><div>089A-089C</div><div>LD HL,0DD8H</div><div>Load register pair HL with the starting address of a single precision constant equal to 10.</div></div>
									<div class="assembly-row-combined model1"><div>089D-089F</div><div><a href="#09B1H" class="memory-link">CALL 09B1H</a></div><div>Call 09B1H (which moves a SINGLE PRECISION number pointed to by HL to REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>08A0</div><div>POP BC</div><div>Get the exponent and the MSB of the single precision value on the STACK and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>08A1</div><div>POP DE</div><div>Get the NMSB and the LSB of the single precision value from the STACK and put it in register pair DE.</div></div>
								</div>
							</div>

							<br><h2 id="08a2-0903-single">08A2-0903 - SINGLE PRECISION DIVISION, REG 1 = BCDE / REG 1<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>"DIVSP" - Single-precision division (REG 1=BCDE/REG 1). If REG 1=0 a " /0 ERROR " will result.<br>This
 routine will divide the SINGLE PRECISION value in register pairs BC and
 DE by the single precision value in REG 1 (i.e., 4121H).  The result is
 returned in REG 1.</p>
								<p>To use a ROM call to divide two single precision numbers, 
store the dividend in registers BCDE, and the divisor in 4121H-4124H and
 then CALL 08A2H.  The result (in single precision format) is in 
4121H-4124H and then pproximately 4.8 milliseconds.  Overflow or /0 will
 error out and return to Level II.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>08A2<span class="origrom2">SDIV</span></div><div><a href="#0955H" class="memory-link">CALL 0955H</a></div><div>Go check to see if the single precision value in REG 1 (i.e., 4121H) is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>08A5</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#199AH" class="memory-link">JP Z,199AH</a></div><div>Go
 to the Level II BASIC error routine and display an /0 ERROR message if 
the single precision value in REG 1 (i.e., 4121H) is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>08A8</div><div>LD L,FFH</div><div>Load register L with a bit mask.</div></div>
									<div class="assembly-row-combined model1"><div>08AA</div><div><a href="#0914H" class="memory-link">CALL 0914H</a></div><div>Go adjust the exponent in REG 1 (i.e., 4121H) for division.</div></div>
									<div class="assembly-row-combined model1"><div>08AD</div><div>INC (HL)</div><div>Increment
 the value of the exponent for the single precision value in REG 1 
(i.e., 4121H) at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>08AE</div><div>INC (HL)</div><div>Increment
 the value of the exponent for the single precision value in REG 1 
(i.e., 4121H) at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>08AF</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>08B0</div><div>LD A,(HL)</div><div>Load
 register A with the MSB of the single precision value in REG 1 (i.e., 
4121H) at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>08B1</div><div>LD (4089H),A</div><div>Save the MSB of the single precision value in REG 1 (i.e., 4121H) in register A at memory location 4089H.</div></div>
									<div class="assembly-row-combined model1"><div>08B4</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>08B5</div><div>LD A,(HL)</div><div>Load
 register A with the NMSB of the single precision value in REG 1 (i.e., 
4121H) at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>08B6</div><div>LD (4085H),A</div><div>Save the NMSB of the single precision value in REG 1 (i.e., 4121H) in register A at memory location 4085H.</div></div>
									<div class="assembly-row-combined model1"><div>08B9</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>08BA</div><div>LD A,(HL)</div><div>Load
 register A with the LSB of the single precision value in REG 1 (i.e., 
4121H) at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>08BB</div><div>LD (4081H),A</div><div>Save the LSB of the single precision value in REG 1 (i.e., 4121H) in register A at memory location 4081H.</div></div>
									<div class="assembly-row-combined model1"><div>08BE</div><div>LD B,C</div><div>Load register B with the MSB of the single precision value in register C.</div></div>
									<div class="assembly-row-combined model1"><div>08BF</div><div>EX DE,HL</div><div>Load register pair HL with the NMSB and the LSB of the single precision value in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>08C0</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>08C1</div><div>LD C,A</div><div>Zero the MSB of the total by loading register C with the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>08C2</div><div>LD D,A</div><div>Zero the NMSB of the total by loading register D with the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>08C3</div><div>LD E,A</div><div>Zero the LSB of the total by loading register E with the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>08C4</div><div>LD (408CH),A</div><div>Zero memory location 408CH.</div></div>
									<div class="assembly-row-combined model1"><div>08C7</div><div>PUSH HL</div><div>Save the NMSB and LSB of the dividend in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>08C8</div><div>PUSH BC</div><div>Save the MSB of the dividend in register B on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>08C9</div><div>LD A,L</div><div>Load register A with the LSB of the dividend in register L.</div></div>
									<div class="assembly-row-combined model1"><div>08CA</div><div>CALL 4080H</div><div>GOSUB to the Level II BASIC division routine.<br><b>NOTE:</b> 4080H-408DH is a division support routine.</div></div>
									<div class="assembly-row-combined model1"><div>08CD</div><div>SBC 00H</div><div>Adjust the flags.</div></div>
									<div class="assembly-row-combined model1"><div>08CF</div><div>CCF</div><div>Invert the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>08D0</div><div><a href="#08D9H" class="memory-link">JR NC,08D9H</a></div><div>JUMP down to 08D9H (which is a Z-80 trick) if not done.</div></div>
									<div class="assembly-row-combined model1"><div>08D2</div><div>LD (408CH),A</div><div>Save the value in register A at memory location 408CH (a memory location used in the single precision division routine).</div></div>
									<div class="assembly-row-combined model1"><div>08D5</div><div>POP AF</div><div>Get the value from the STACK and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>08D6</div><div>POP AF</div><div>Get the value from the STACK and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>08D7</div><div>SCF</div><div>Set the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>08D8</div><div>D2</div><div>Z-80 Trick - See the note at 0134H for an explanation.</div></div>
									<div class="assembly-row-combined model1"><div>08D9</div><div>POP BC</div><div>Get the value from the STACK and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>08DA</div><div>POP HL</div><div>Get the value from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>08DB</div><div>LD A,C</div><div>Load register A with the MSB of the total in register C.</div></div>
									<div class="assembly-row-combined model1"><div>08DC</div><div>INC A</div><div>Increment the MSB of the total in register A.</div></div>
									<div class="assembly-row-combined model1"><div>08DD</div><div>DEC A</div><div>Decrement the MSB of the total in register A.</div></div>
									<div class="assembly-row-combined model1"><div>08DE</div><div>RRA</div><div>Shift the MSB of the total in register A one place to the right.</div></div>
									<div class="assembly-row-combined model1"><div>08DF-08E1</div><div><a href="#0797H" class="memory-link">JP M,0797H</a></div><div>JUMP back to 0797H if done.</div></div>
									<div class="assembly-row-combined model1"><div>08E2</div><div>RLA</div><div>Reset the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>08E3</div><div>LD A,E</div><div>Load register A with the LSB of the total in register E.</div></div>
									<div class="assembly-row-combined model1"><div>08E4</div><div>RLA</div><div>Multiply the LSB of the total in register A by two.</div></div>
									<div class="assembly-row-combined model1"><div>08E5</div><div>LD E,A</div><div>Load register E with the adjusted LSB of the total in register A.</div></div>
									<div class="assembly-row-combined model1"><div>08E6</div><div>LD A,D</div><div>Load register A with the NMSB of the total in register D.</div></div>
									<div class="assembly-row-combined model1"><div>08E7</div><div>RLA</div><div>Multiply the NMSB of the total in register A by two.</div></div>
									<div class="assembly-row-combined model1"><div>08E8</div><div>LD D,A</div><div>Load register D with the adjusted NMSB of the total in register A.</div></div>
									<div class="assembly-row-combined model1"><div>08E9</div><div>LD A,C</div><div>Load register A with the MSB of the total in register C.</div></div>
									<div class="assembly-row-combined model1"><div>08EA</div><div>RLA</div><div>Multiply the MSB of the total in register A by two.</div></div>
									<div class="assembly-row-combined model1"><div>08EB</div><div>LD C,A</div><div>Load register C with the adjusted MSB of the total in register A.</div></div>
									<div class="assembly-row-combined model1"><div>08EC</div><div>ADD HL,HL</div><div>Multiply the NMSB and the LSB of the dividend in register pair HL by two.</div></div>
									<div class="assembly-row-combined model1"><div>08ED</div><div>LD A,B</div><div>Load register A with the MSB of the dividend in register B.</div></div>
									<div class="assembly-row-combined model1"><div>08EE</div><div>RLA</div><div>Multiply the MSB of the dividend in register A by two.</div></div>
									<div class="assembly-row-combined model1"><div>08EF</div><div>LD B,A</div><div>Load register B with the adjusted MSB of the dividend in register A.</div></div>
									<div class="assembly-row-combined model1"><div>08F0-08F2</div><div>LD A,(408CH)</div><div>Load register A with the value at memory location 408CH.</div></div>
									<div class="assembly-row-combined model1"><div>08F3</div><div>RLA</div><div>Multiply the value in register A by two.</div></div>
									<div class="assembly-row-combined model1"><div>08F4-08F6</div><div>LD (408CH),A</div><div>Save the adjusted value in register A at memory location 408CH.</div></div>
									<div class="assembly-row-combined model1"><div>08F7</div><div>LD A,C</div><div>Load register A with the MSB of the total in register C.</div></div>
									<div class="assembly-row-combined model1"><div>08F8</div><div>OR D</div><div>Combine the NMSB of the total in register D with the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>08F9</div><div>OR E</div><div>Combine the LSB of the total in register E with the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>08FA-08FB</div><div><a href="#08C7H" class="memory-link">JR NZ,08C7H</a></div><div>JUMP back to 08C7H if the total isn't equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>08FC</div><div>PUSH HL</div><div>Save the NMSB and the LSB of the dividend in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>08FD-08FF</div><div>LD HL,4124H</div><div>Load register pair HL with the address of the exponent in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>0900</div><div>DEC (HL)</div><div>Decrement the exponent in REG 1 (i.e., 4121H) at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0901</div><div>POP HL</div><div>Get the NMSB and the LSB of the dividend from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0902-0903</div><div><a href="#08C7H" class="memory-link">JR NZ,08C7H</a></div><div>JUMP back to 08C7H if the exponent in REG 1 (i.e., 4121H) isn't equal to zero.</div></div>
								</div>
							</div>

							<br><h2 id="0904-0906-display">0904-0906 - DISPLAY OV ERROR MESSAGE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0904-0906</div><div><a href="#07B2H" class="memory-link">JP 07B2H</a></div><div>Display an <span class="code">?OV ERROR</span>.</div></div>
								</div>
							</div>

							<br><h2 id="0907H">0907-0913 - DOUBLE PRECISION MATH ROUTINE.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0907-0908</div><div>LD A,FFH</div><div>Load register A with a bit mask of FFH.</div></div>
									<div class="assembly-row-combined model1"><div>0909</div><div>2E</div><div>Z-80 Trick - See the note at 0134H for an explanation.</div></div>
									<div class="assembly-row-combined model1"><div>090A</div><div>XOR A</div><div>Zero A and clear the flags.</div></div>
									<div class="assembly-row-combined model1"><div>090B-090D</div><div>LD HL,412DH</div><div>Load register pair HL with the address of the MSB in REG 2.</div></div>
									<div class="assembly-row-combined model1"><div>090E</div><div>LD C,(HL)</div><div>Load register C with the MSB of the value in REG 2 at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>090F</div><div>INC HL</div><div>Increment the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0910</div><div>XOR (HL)</div><div>Combine
 the value of the exponent in REG 2 at the location of the memory 
pointer in register pair HL with the bit mask in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0911</div><div>LD B,A</div><div>Load register B with the adjusted exponent in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0912-0913</div><div>LD L,00H</div><div>Load register L with a bit mask.</div></div>
								</div>
							</div>

							<br><h2 id="0914H">0914-0930 - SINGLE PRECISION MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0914</div><div>LD A,B</div><div>Load register A with the exponent in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0915</div><div>OR A</div><div>Check to see if the exponent in register A is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0916-0917</div><div><a href="#0937H" class="memory-link">JR Z,0937H</a></div><div>JUMP to 0937H if the exponent in register A is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0918</div><div>LD A,L</div><div>Load register A with the bit mask in register L.</div></div>
									<div class="assembly-row-combined model1"><div>0919-091B</div><div>LD HL,4124H</div><div>Load register pair HL with the address of the exponent in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>091C</div><div>XOR (HL)</div><div>Combine the value of the exponent at the location of  the memory pointer in register pair HL with the bit mask in register A.</div></div>
									<div class="assembly-row-combined model1"><div>091D</div><div>ADD A,B</div><div>Add the value of the exponent in register B to the value of the exponent in register A.</div></div>
									<div class="assembly-row-combined model1"><div>091E</div><div>LD B,A</div><div>Load register B with the combined exponents in register A.</div></div>
									<div class="assembly-row-combined model1"><div>091F</div><div>RRA</div><div>Shift the value of the combined exponents in register A one place to the right.</div></div>
									<div class="assembly-row-combined model1"><div>0920</div><div>XOR B</div><div>Check to see if the CARRY FLAG was set by combining the two exponents.</div></div>
									<div class="assembly-row-combined model1"><div>0921</div><div>LD A,B</div><div>Load register A with the combined exponents value in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0922-0924</div><div><a href="#0936H" class="memory-link">JP P,0936H</a></div><div>JUMP to 0936H if overflow has occurred.</div></div>
									<div class="assembly-row-combined model1"><div>0925-0926</div><div>ADD 80H</div><div>Reload the new exponent into A and turn on bit 8 (80H = Binary 10000000).</div></div>
									<div class="assembly-row-combined model1"><div>0927</div><div>LD (HL),A</div><div>Save
 the value of the combined exponent in register A as the exponent in REG
 1 (i.e., 4121H) at the location of the memory pointer in register pair 
HL.</div></div>
									<div class="assembly-row-combined model1"><div>0928-092A</div><div><a href="#0890H" class="memory-link">JP Z,0890H</a></div><div>JUMP if the combined exponent in register A is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>092B-092D</div><div><a href="#09DFH" class="memory-link">CALL 09DFH</a></div><div>Go turn on the sign bit of the MSB in REG 1 (i.e., 4121H) and register B and save the sign bits.</div></div>
									<div class="assembly-row-combined model1"><div>092E</div><div>LD (HL),A</div><div>Save the value in register A at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>092F</div><div>DEC HL</div><div>Decrement the memory pointer in register pair HL so that it points to the exponent in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>0930</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0931H">0931-093D - SINGLE PRECISION MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0931-0933</div><div><a href="#0955H" class="memory-link">CALL 0955H</a></div><div>GOSUB to 0955H to check the value of the sign bit for the value in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>0934</div><div>CPL</div><div>Reverse the result of the sign bit test in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0935</div><div>POP HL</div><div>Get the value from the STACK and put it in register HL.</div></div>
									<div class="assembly-row-combined model1"><div>0936</div><div>OR A</div><div>Set the flags according to the value of the sign bit test.</div></div>
									<div class="assembly-row-combined model1"><div>0937</div><div>POP HL</div><div>Get the value from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0938</div><div><a href="#0778H" class="memory-link">JP P,0778H</a></div><div>JUMP to 0778H if the value in REG 1 (i.e., 4121H) is negative.</div></div>
									<div class="assembly-row-combined model1"><div>093B</div><div><a href="#07B2H" class="memory-link">JP 07B2H</a></div><div>If its not negative, jump to 07B2H.</div></div>
								</div>
							</div>

							<br><h2 id="093EH">093E-0954 - SINGLE PRECISION MATH ROUTINE - Multiply the current value by 10<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>093E</div><div><a href="#09BFH" class="memory-link">CALL 09BFH</a></div><div>Call 09BF which loads the SINGLE PRECISION value in REG 1 (i.e., 4121H) into register pair BC/DE.</div></div>
									<div class="assembly-row-combined model1"><div>0941</div><div>LD A,B</div><div>Load register A with the value of the exponent in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0942</div><div>OR A</div><div>Check to see if the exponent in register A is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0943</div><div>RET Z</div><div>Return if the single precision value in register pairs BC and DE is equal to zero.</div></div>
									<div class="assembly-row-combined model1" id="0944H"><div>0944-0945</div><div>ADD 02H</div><div>Multiply the value of the exponent in register A by four.</div></div>
									<div class="assembly-row-combined model1"><div>0946</div><div><a href="#07B2H" class="memory-link">JP C,07B2H</a></div><div>Display an <span class="code">?OV ERROR</span> if the adjusted exponent in register A is too large.</div></div>
									<div class="assembly-row-combined model1"><div>0949</div><div>LD B,A</div><div>Load register B with the adjusted exponent in register A.</div></div>
									<div class="assembly-row-combined model1"><div>094A</div><div><a href="#0716H" class="memory-link">CALL 0716H</a></div><div>Go
 add the original value in REG 1 (i.e., 4121H) to the adjusted value in 
register pairs BC and DE and return with the original result in REG 1 
(i.e., 4121H) by calling the SINGLE PRECISION ADD routine at 0716H 
(which adds the single precision value in (BC/DE) to the single 
precision value in REG 1 (i.e., 4121H). The sum is left in REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>094D</div><div>LD HL,4124H</div><div>Load register pair HL with the address of the exponent in REG 1 (i.e., 4121H).</div></div>
									<div class="assembly-row-combined model1"><div>0950</div><div>INC (HL)</div><div>Increment
 the value of the exponent in REG 1 at the location of the memory 
pointer in register pair HL.  REG 1 now holds the original value times 
ten.</div></div>
									<div class="assembly-row-combined model1"><div>0951</div><div>RET NZ</div><div>Return if the new value in REG 1 is in an acceptable range.</div></div>
									<div class="assembly-row-combined model1"><div>0952</div><div><a href="#07B2H" class="memory-link">JP 07B2H</a></div><div>Display an <span class="code">?OV ERROR</span> if the value of the exponent at the location of the memory pointer in register pair HL is too large.</div></div>
								</div>
							</div>

							<br><h2 id="0955H">0955-0963 - SINGLE PRECISION MATH ROUTINE - "SIGN".  Checks the value of the sign bit for the value in REG 1.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0955-0957<span class="origrom2">SIGN</span></div><div>LD A,(4124H)</div><div>Fetch the value held in REG 1 for testing into Register A.</div></div>
									<div class="assembly-row-combined model1"><div>0958</div><div>OR A</div><div>Set the flags for Register A.</div></div>
									<div class="assembly-row-combined model1"><div>0959</div><div>RET Z</div><div>Return if the single precision value in REG 1 is equal to zero.</div></div>
									<div class="assembly-row-combined model1" id="095AH"><div>095A</div><div>LD A,(4123H)</div><div>Since
 the number is not zero, step back 1 memory location and load register A
 with the MSB of the single precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>095E<span class="origrom2">FCOMPS</span></div><div>CPL</div><div>Flip all the bits in A (= Inverse).</div></div>
									<div class="assembly-row-combined model1"><div>095F<span class="origrom2">ICOMS</span></div><div>RLA</div><div>Rotate A left one bit, which puts the value of the sign bit (bit 7) in register A into the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>0960<span class="origrom2">SIGNS</span></div><div>SBC A,A</div><div>Subtract
 A and the CARRY FLAG from A.  This has the effect of making register A 
equal to -1 if the sign bit is negative or a value of 0 if the sign bit 
is positive.</div></div>
									<div class="assembly-row-combined model1"><div>0961</div><div>RET NZ</div><div>Return if the single precision value in REG 1 is negative.</div></div>
									<div class="assembly-row-combined model1" id="0962H"><div>0962</div><div>INC A</div><div>Increment the value in register A so that register A will be equal to 1 if the single precision value in REG 1 is positive.</div></div>
									<div class="assembly-row-combined model1"><div>0963</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0964H">0964-0976 - SINGLE PRECISION MATH ROUTINE - "FLOAT".  Float the signed number in B,A,D,E.  Alters A,B,C,D,E,H,L<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0964-0965<span class="origrom2">FLOAT</span></div><div>LD B,88H</div><div>Load register B with an exponent for an integer value.</div></div>
									<div class="assembly-row-combined model1"><div>0966-0968</div><div>LD DE,0000H</div><div>Load register pair DE with zero.</div></div>
									<div class="assembly-row-combined model1" id="0969H"><div>0969-096B<span class="origrom2">FLOATR</span></div><div>LD HL,4124H</div><div>Load register pair HL with the address of the exponent in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>096C</div><div>LD C,A</div><div>Load register C with the MSB of the integer value.</div></div>
									<div class="assembly-row-combined model1"><div>096D</div><div>LD (HL),B</div><div>Save the exponent in register B in REG 1 at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>096E-096F</div><div>LD B,00H</div><div>Load register B with zero.</div></div>
									<div class="assembly-row-combined model1"><div>0970</div><div>INC HL</div><div>Increment the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0971-0972</div><div>LD (HL),80H</div><div>Save the sign value at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0973</div><div>RLA</div><div>Shift the value of the sign bit for the MSB in register A into the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>0974-0976</div><div><a href="#0762H" class="memory-link">JP 0762H</a></div><div>JUMP to 0762H ("FADFLT").</div></div>
								</div>
							</div>

							<br><h2 id="0977-0989-level-ii">0977-0989 - LEVEL II BASIC MATH ROUTINE<br>"<span class="code">ABS</span>"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p><span class="code">ABS</span> routine (REG 1=ABS(REG 1)) 
input and output can be integer, single-precision or double-precision, 
depending on what is placed in the NTF (NTF=2, 4 or 8).<br>A call to 
0977H converts the value in Working Register Area 1 (WRAl) to its 
positive equivalent. The result is left in REG 1. If a negative integer 
greater than 2** 15 is encountered, it is converted to a single 
precision value. The data type or mode flag (40AFH) will be updated to 
reflect any change in mode.</p>
								<p>NOTE: To use a ROM call to find ABS(X),store the value of X 
in 4121H-4122H (integer), in 4121H-4124H (single precision), or in 411DH
 and then H (double precision), and store the variable type (2, 4, or 8,
 respectively) in 40AFH.  Then CALL 0977H.  The result (in the same 
format as the input variable) is in the same locations in which the 
input variable was stored. If the input was an integer, the result is 
also in the HL register pair.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0977-0979<br>"ABS"</div><div><a href="#0994H" class="memory-link">CALL 0994H</a></div><div>Gosub to 0994H ("VSIGN") to determine the sign of the current value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>097A</div><div>RET P</div><div>Return if the value in REG 1 is positive, since that means we are done.</div></div>
									<p class="debug-note" id="097BH">097BH - Convert the negative value in REG 1 to its positive equivalent.  Alters A,B,C,D,E,H,L</p>
									<div class="assembly-row-combined model1"><div>097B<br>"VNEG"</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>097C-097E</div><div><a href="#0C5BH" class="memory-link">JP M,0C5BH</a></div><div>If that test showed INTEGER, jump to 0C5BH ("INEG")</div></div>
									<div class="assembly-row-combined model1"><div>097F-0981</div><div><a href="#0AF6H" class="memory-link">JP Z,0AF6H</a></div><div>If that test showed STRING, Jump to 0AF6H ("TMERR") to display a <span class="code">?TM ERROR</span> message.</div></div>
									<div class="assembly-row-combined model1"><div>0982-0984<br>"NEG"</div><div>LD HL,4123H</div><div>Load register pair HL with the address of the MSB in REG 1 (which would be the sign).<br><br>NEGATE function for single-precision values (REG 1=-REG 1). Only BC and DE are saved.</div></div>
									<div class="assembly-row-combined model1"><div>0985</div><div>LD A,(HL)</div><div>Load register A with the MSB in REG 1 (the sign) held at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0986-0987</div><div>XOR 80H</div><div>Complement the sign bit.</div></div>
									<div class="assembly-row-combined model1"><div>0988</div><div>LD (HL),A</div><div>Save the adjusted MSB in register A in REG 1 (the sign) at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0989</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="098AH">098A-0993 - LEVEL II BASIC MATH ROUTINE<br>"<span class="code">SGN</span>" - Alters A,H,L<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p><span class="code">SGN</span> function (REG 1=SGN(REG 1)). After execution, NTF=2 and REG 1=-l, 0 or 1 depending on sign and value of ACC before execution.</p>
								<p>NOTE: To use a ROM call to find SGN(X), store the value of X 
in 4121H-4122H (integer), in 4121H-4124H (single precision), or in 4124H
 (double precision) and then store the variable type (2, 4, or 8, 
respectively) in 40AFH and then CALL 098AH.  The result (in integer 
format) is in 4121H-4122H and in the HL register pair.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>098A-098C<br>"SGN"</div><div><a href="#0994H" class="memory-link">CALL 0994H</a></div><div>GOSUB to 0994H ("VSIGN") to test the sign of the current value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>098D<br>"CONIA"</div><div>LD L,A</div><div>Load register L with the result of the sign test in register A.</div></div>
									<div class="assembly-row-combined model1"><div>098E</div><div>RLA</div><div>Shift the sign bit in register A into the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>098F</div><div>SBC A,A</div><div>Adjust
 the value in register A so that it will be equal to zero if the current
 value in REG 1 is positive and equal to -1 if the current value in REG 1
 is negative.</div></div>
									<div class="assembly-row-combined model1"><div>0990</div><div>LD H,A</div><div>Save the adjusted value in register A in register H.</div></div>
									<div class="assembly-row-combined model1"><div>0991-0993</div><div><a href="#0A9AH" class="memory-link">JP 0A9AH</a></div><div>JUMP to 0A9AH ("MAKINT") to return the result and set VALTYP.</div></div>
								</div>
							</div>

							<br><h2 id="0994H">0994-09A3 - LEVEL II BASIC MATH ROUTINE.<br>"<span class="code">VSIGN</span>" - Get the sign of the value in the FAC in A.  Alters A,H,L<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine checks the sign of the ACC. NTF must be set. 
After execution A register=00 if REG 1=0, A=01 if ACC &gt; 0 or A=FFH if
 A &lt; 1. The Flags are also valid.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0994</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>0995-0997</div><div><a href="#0AF6H" class="memory-link">JP Z,0AF6H</a></div><div>If that test showed STRING, JUMP to 0AF6H ("TMERR") to display a <span class="code">?TM ERROR</span> message.</div></div>
									<div class="assembly-row-combined model1"><div>0998-099A</div><div><a href="#0955H" class="memory-link">JP P,0955H</a></div><div>P
 but NZ means single precision, or double precision, so JUMP to 0955H 
("SIGN") if the current value in REG 1 is single precision or double 
precision.</div></div>
									<div class="assembly-row-combined model1"><div>099B-099D</div><div>LD HL,(4121H)</div><div>At this point, we know we have an integer.  Load register pair HL with the integer value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>099E,099F<br>"ISIGN"</div><div>LD A,H<br>OR L</div><div>The
 best way to test a 2 register value against zero is to OR them, because
 the only way the Z flag will get set is if they both were zero.</div></div>
									<div class="assembly-row-combined model1"><div>09A0</div><div>RET Z</div><div>Return if the integer value in REG 1 is equal to zero.</div></div>
									<div class="assembly-row-combined model1" id="09A1H"><div>09A1</div><div>LD A,H</div><div>If it isn't zero, sign is in H so load register A with the MSB of the integer value in register H.</div></div>
									<div class="assembly-row-combined model1"><div>09A2-09A3</div><div><a href="#095FH" class="memory-link">JR 095FH</a></div><div>JUMP to 095FH ("ICOMPS").</div></div>
								</div>
							</div>

							<br><h2 id="09A4H">09A4-09B0 - SINGLE PRECISION MATH ROUTINE<br>"LDSTSA"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Loads Single-precision value from ACC to STACK ((SP)=ACC). To
 retrieve this value, POP BC followed by POP DE. A, BC and HL are 
unchanged by this function.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>09A4<br>"SSTAK"</div><div>EX DE,HL</div><div>We need to save HL, so we load register pair DE with the value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>09A5-09A7</div><div>LD HL,(4121H)</div><div>Load register pair HL with the LSB and the NMSB of the single precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>09A8</div><div>EX (SP),HL</div><div>Exchange the return address on the STACK with the NMSB and the LSB of the single precision value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>09A9</div><div>PUSH HL</div><div>Save the return address in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>09AA-09AC</div><div>LD HL,(4123H)</div><div>Load register pair HL with the exponent and the MSB of the single precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>09AD</div><div>EX (SP),HL</div><div>Exchange the return address on the STACK with the exponent and the MSB of the single precision value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>09AE</div><div>PUSH HL</div><div>Save the return address in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>09AF</div><div>EX DE,HL</div><div>Get the old HL back by swapping register pair HL with  register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>09B0</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="09B1H">09Bl-09BE - SINGLE PRECISION MATH ROUTINE<br>"LDSAHL"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine loads four bytes from the location pointed to by HL, into the ACC. (REG 1=(HL)).</p>
								<p>It moves a number from memory [(HL)] to FAC.  It alters B,C,D,E,H,L.  Upon exit the number is in B,C,D,E and (HL):=(HL)+4</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>09B1-09B3<br>"SCOPY"</div><div><a href="#09C2H" class="memory-link">CALL 09C2H</a></div><div>Call 09C2H (which loads a SINGLE PRECISION value pointed to by register pair HL into register pairs BC and DE).</div></div>
									<div class="assembly-row-combined model1" id="09B4H"><div>09B4<br>"DSTOR"</div><div>EX DE,HL</div><div>Load register pair HL with the NMSB and the LSB of the single precision value in register pair DE.<br><br>This routine loads REG 1 with the contents of the BC and DE register pairs. (REG 1=BCDE). BC and HL remain unaltered.</div></div>
									<div class="assembly-row-combined model1"><div>09B5-09B7</div><div>LD (4121H),HL</div><div>Save the NMSB and the LSB of the single precision value in register pair HL in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>09B8</div><div>LD H,B</div><div>Load register H with the exponent of the single precision value in register B.</div></div>
									<div class="assembly-row-combined model1"><div>09B9</div><div>LD L,C</div><div>Load register L with the MSB of the single precision value in register C.</div></div>
									<div class="assembly-row-combined model1"><div>09BA-09BC</div><div>LD (4123H),HL</div><div>Save the exponent and the MSB of the single precision value in register pair HL in REG 1</div></div>
									<div class="assembly-row-combined model1"><div>09BD</div><div>EX DE,HL</div><div>Load register pair HL with the value in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>09BE</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="09bf-09ca-single">09BF-09CA - SINGLE PRECISION MATH ROUTINE<br>"LDRASA"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine is the opposite of the 09B4H routine. It loads 
four bytes from REG 1 (single-precision) into the BC and DE register 
pairs. (BCDE=ACC). A is unchanged.</p>
								<p>Move FAC to registers (B,C,D,E).  Alters B,C,D,E,H,L</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>09BF-09C1</div><div>LD HL,4121H</div><div>Load register pair HL with the starting address for a single precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>09C2<br>"SGET"</div><div>LD E,(HL)</div><div>Load register E with the LSB of the single precision value in REG 1 at the location of the memory pointer in register pair HL.<br><br>This
 routine will load the BCDE register pairs with four bytes from the 
location pointed to by HL. (BCDE=(HL)),. With these types of data 
movements, the E register is loaded with the LSB and the B register. 
with the MSB.</div></div>
									<div class="assembly-row-combined model1"><div>09C3</div><div>INC HL</div><div>Increment the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>09C4</div><div>LD D,(HL)</div><div>Load register D with the NMSB of the single precision value in REG 1 at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>09C5</div><div>INC HL</div><div>Increment the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>09C6</div><div>LD C,(HL)</div><div>Load register C with the MSB of the single precision value in REG 1 at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>09C7</div><div>INC HL</div><div>Increment the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>09C8</div><div>LD B,(HL)</div><div>Load
 register B with the exponent of the single precision value in REG 1 at 
the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>09C9</div><div>INC HL</div><div>Increment the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>09CA</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="09CBH">09CB-09Dl - SINGLE PRECISION MATH ROUTINE<br>"LDHLSA"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine is the opposite of the 9B1H routine. It loads 
four bytes from REG 1 to the memory location pointed to by HL. 
((HL)=ACC).</p>
								<p>Move number from FAC to memory [(HL)].  Alters A,B,C,D,E,H,L</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>09CB-09CD</div><div>LD DE,4121H</div><div>Load register pair DE with the starting address for a single precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>09CE-09CF</div><div>LD B,04H</div><div>Load register B with the number of bytes to be moved for a single precision value.<br><br>Data move routine. This moves four bytes from the location pointed to by DE into the location pointed to by HL. ((HL)=(DE)).</div></div>
									<div class="assembly-row-combined model1"><div>09D0-09D1</div><div><a href="#09D7H" class="memory-link">JR 09D7H</a></div><div>JUMP
 to 09D7H (which is the GENERAL PURPOSE MOVE routine and moves the 
contents of the B Register bytes from the address in DE to the address 
in HL).</div></div>
								</div>
							</div>

							<br><h2 id="09D2H">09D2-09DE - MOVE VALUE POINTED TO BY HL TO THE LOCATION POINTED TO BY DE<br>"LDDEHL"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the VARIABLE MOVE Routine which moves the number of 
bytes specified in the type flag (40AFH) from the address in DE to the 
address in HL.  Uses A, DE and HL.</p>
								<p>Move number from (DE) to (HL).  Alters A,B,C,D,E,H,L.  Exits with (DE):=(DE)+4 : (HL):=(HL)+4</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>09D2</div><div>EX DE,HL</div><div>Exchange the value in register pair HL with the value in register pair DE.<br><br>Data
 move routine. The location pointed to by DE is loaded with bytes from 
the location pointed to by HL. The number of bytes moved is determined 
by the value in the NTF. ((DE)=(HL)).</div></div>
									<div class="assembly-row-combined model1"><div>09D3-09D5<br>"LDHLDE"</div><div>LD A,(40AFH)</div><div>Load register A with the current value of the number type flag (which is in 40AFH).<br><br>This routine is similar to 9D2H above. The only difference is that it moves data in the opposite direction. ((HL) = (DE)).<br><b>Note:</b> 40AFH holds the current number's type flag as follows:<ul><li>2: Integer</li><li>3: String</li><li>4: Single precision</li><li>8: Double precision</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>09D6<br>"MOVEA"</div><div>LD B,A</div><div>Load register B with the number of bytes to be moved in register A.<br><br>This routine is the same as 9D3H except that the number of bytes moved depends on the value in the A register ((HL) = (DE)).</div></div>
									<div class="assembly-row-combined model1"><div>09D7<br>"MOVEB"</div><div>LD A,(DE)</div><div>Load register A with the value at the location of the memory pointer in register pair DE.<br><br>This
 routine is the same as 9D6H except that the number of bytes shifted is 
determined by the value in the B register ((HL)=(DE)).<br>This is the 
GENERAL PURPOSE MOVE routine and moves the contents of the B Register 
bytes from the address in DE to the address in HL).</div></div>
									<div class="assembly-row-combined model1"><div>09D8</div><div>LD (HL),A</div><div>Save the value in register A at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>09D9</div><div>INC DE</div><div>Increment the value of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>09DA</div><div>INC HL</div><div>Increment the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>09DB</div><div>DEC B</div><div>Decrement the value of the byte counter in register B.</div></div>
									<div class="assembly-row-combined model1"><div>09DC-09DD</div><div><a href="#09D7H" class="memory-link">JR NZ,09D7H</a></div><div>Loop until all of the bytes have been moved.</div></div>
									<div class="assembly-row-combined model1"><div>09DE</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="09DFH">09DF-09F3 - SINGLE PRECISION MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Unpack the FAC and the registers.  Alters A,C,H,L.  When the 
number in the FAC is unpacked, the assumed one in the mantissa is 
restored, and the complement of the sign is placed in FAC+1.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>09DF-09E1</div><div>LD HL,4123H</div><div>Load register pair HL with the address of the MSB of the value in REG 1 (which would be the high order number and the sign).</div></div>
									<div class="assembly-row-combined model1"><div>09E2</div><div>LD A,(HL)</div><div>Load register A with the MSB of the value in REG 1 at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>09E3</div><div>RLCA</div><div>Move the value of the sign bit in register A into the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>09E4</div><div>SCF</div><div>Set the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>09E5</div><div>RRA</div><div>Turn
 off the sign bit in register A by moving the value of the CARRY FLAG 
into register A and moving the previous value of the sign bit from BIT 0
 of register A into the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>09E6</div><div>LD (HL),A</div><div>Save the adjusted MSB in register A in REG 1 at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>09E7</div><div>CCF</div><div>Invert the value of the sign bit in the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>09E8</div><div>RRA</div><div>Move the inverted sign bit from the CARRY FLAG into register A.</div></div>
									<div class="assembly-row-combined model1"><div>09E9</div><div>INC HL</div><div>Increment the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>09EA</div><div>INC HL</div><div>Increment the value of the memory pointer in register pair HL.  This sets up for a temporary sign byte.</div></div>
									<div class="assembly-row-combined model1"><div>09EB</div><div>LD (HL),A</div><div>Save the value in register A (the complemented sign) at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>09EC</div><div>LD A,C</div><div>Load register A with the MSB of the single precision value in register C (which is the high order number and the sign).</div></div>
									<div class="assembly-row-combined model1"><div>09ED</div><div>RLCA</div><div>Move the value of the sign bit in register A into the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>09EE</div><div>SCF</div><div>Set the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>09EF</div><div>RRA</div><div>Turn
 on the sign bit in register A by moving the value of the CARRY FLAG 
into register A and moving the previous value of the sign bit from BIT 0
 of register A into the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>09F0</div><div>LD C,A</div><div>Load register C with the adjusted MSB in register A to save it.</div></div>
									<div class="assembly-row-combined model1"><div>09F1</div><div>RRA</div><div>Move the value of the sign bit from the CARRY FLAG back into register A.</div></div>
									<div class="assembly-row-combined model1"><div>09F2</div><div>XOR (HL)</div><div>Combine
 the value of the sign bit for the single precision value in register A 
with the value of the sign bit for the single precision value at the 
location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>09F3</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="09F4H">09F4-09FB - LEVEL II BASIC MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine is used by the double-precision logic. It moves a
 number of bytes (the number depending on the value stored in the NTF) 
from the AACC into the ACC. ((REG 1)=(AACC)).</p>
								<p>Move any type value from memory [(HL)] to FAC.  Alters A,B,D,E,H,L</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>09F4-09F6</div><div>LD HL,4127H</div><div>Load register pair HL with the starting address of REG 2.<br><b>NOTE:</b> 4127H-412EH holds REG 2 with 412EH being the exponent.</div></div>
									<div class="assembly-row-combined model1"><div>09F7-09F9<br>"MVSAHL"</div><div>LD DE,09D2H</div><div>Load register pair DE with the return address.</div></div>
									<div class="assembly-row-combined model1"><div>09FA-09FB</div><div><a href="#0A02H" class="memory-link">JR 0A02H</a></div><div>JUMP down a few instructions to 0A02H.</div></div>
								</div>
							</div>

							<br><h2 id="09FCH">09FC-0A0B - LEVEL II BASIC MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This is the opposite of 9F4H. ((AACC)=(REG 1)).</p>
								<p>Move any type value from FAC to memory [(HL)].  Alters A,B,D,E,H,L.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>09FC-09FE<br>"MVALT"</div><div>LD HL,4127H</div><div>Load register pair HL with the starting address of REG 2.<br><b>NOTE:</b> 4127H-412EH holds REG 2 with 412EH being the exponent.</div></div>
									<div class="assembly-row-combined model1"><div>09FF-0A01</div><div>LD DE,09D3H</div><div>Load register pair DE with the return address (which is the address of the move subroutine).</div></div>
									<div class="assembly-row-combined model1" id="0A02H"><div>0A02</div><div>PUSH DE</div><div>Save
 the return address in register pair DE on the STACK.  So long as that 
value remains at the top of the stack, a RET will jump to it.</div></div>
									<div class="assembly-row-combined model1"><div>0A03-0A05</div><div>LD DE,4121H</div><div>Load register pair HL with the starting address for a single precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0A06</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>0A07</div><div>RET C</div><div>If that test is anything other than double precision, return out of this subroutine.</div></div>
									<div class="assembly-row-combined model1" id="0A08H"><div>0A08-0A0A</div><div>LD DE,411DH</div><div>Load register pair DE with the starting address of REG 1.<br><b>NOTE:</b> 411DH-4124H holds REG l.</div></div>
									<div class="assembly-row-combined model1"><div>0A0B</div><div>RET</div><div>Return (to the move routine).</div></div>
								</div>
							</div>

							<br><h2 id="0A0CH">0A0C-0A25 - SINGLE PRECISION COMPARE<br>"CPSP"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Single-precision compare. Compares REG 1 with the contents of
 BCDE registers. After execution of this routine, the A register will 
contain: A=0 if REG 1=BCDE, A=1 if ACC&gt;BCDE or A=FFH if ACC&lt;BCDE.</p>
								<p>NOTE: To use a ROM call to compare two single precision 
numbers, store the first input in registers BCDE, the second input in 
4121H-4124H and then CALL 0A0CH.  If the numbers are equal, the Z (zero)
 flag will be set. If they are not equal, the Z flag will be turned off.
 If the first input number is the smaller, the S (sign) and C (carry) 
flags will also be turned off. If the second input number is the 
smaller, the S and C flags will both be set.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0A0C</div><div>LD A,B</div><div>First we need to check to see if A is 0, so load register A with the value of the exponent in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0A0D</div><div>OR A</div><div>Set the flags.</div></div>
									<div class="assembly-row-combined model1"><div>0A0E-0A10</div><div><a href="#0955H" class="memory-link">JP Z,0955H</a></div><div>JUMP to 0955H if the exponent in register A is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0A11-0A13</div><div>LD HL,095EH</div><div>The exponent in register A is NOT equal to zero, so load register pair HL with a return address to "FCOMPS".</div></div>
									<div class="assembly-row-combined model1"><div>0A14</div><div>PUSH HL</div><div>Save the return address in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0A15-0A17</div><div><a href="#0955H" class="memory-link">CALL 0955H</a></div><div>GOSUB to 0955H to check the sign of the single precision numbers.</div></div>
									<div class="assembly-row-combined model1"><div>0A18</div><div>LD A,C</div><div>Load register A with the MSB of the single precision value in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0A19</div><div>RET Z</div><div>Return if the signs of the single precision values aren't equal.</div></div>
									<div class="assembly-row-combined model1" id="0A10H"><div>0A10-0A1C</div><div>LD HL,4123H</div><div>Load register pair HL with the address of the MSB in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0A1D</div><div>XOR (HL)</div><div>Test
 to see if the signs are different.  Combine the MSB in REG 1 at the 
location of the memory pointer in register pair HL with the MSB in 
register A.</div></div>
									<div class="assembly-row-combined model1"><div>0A1E</div><div>LD A,C</div><div>Load register A with the MSB in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0A1F</div><div>RET M</div><div>Return if the MSBs don't match.</div></div>
									<div class="assembly-row-combined model1"><div>0A20-0A22</div><div><a href="#0A26H" class="memory-link">CALL 0A26H</a></div><div>Go compare the single precision values.</div></div>
									<div class="assembly-row-combined model1"><div>0A23</div><div>RRA</div><div>Move the value of the CARRY FLAG from the comparison into register A.</div></div>
									<div class="assembly-row-combined model1"><div>0A24</div><div>XOR C</div><div>Combine the value of the MSB of the single precision value in register C with the value in register A.</div></div>
									<div class="assembly-row-combined model1" id="0A25H"><div>0A25</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0A26H">0A26-0A38 - SINGLE PRECISION COMPARISON ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0A26</div><div>INC HL</div><div>Increment the value of the memory pointer in register pair HL so that it points to the exponent in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0A27</div><div>LD A,B</div><div>Load register A with the value of the exponent for the single precision value in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0A28</div><div>CP (HL)</div><div>Check
 to see if the exponent for the single precision value in REG 1 at the 
location of the memory pointer in register pair HL is the same as the 
value of the exponent for the single precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0A29</div><div>RET NZ</div><div>Return if the value of the exponent in REG 1 isn't the same as the value of the exponent in register A.</div></div>
									<div class="assembly-row-combined model1" id="0A2AH"><div>0A2A</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL to point to the MSB.</div></div>
									<div class="assembly-row-combined model1"><div>0A2B</div><div>LD A,C</div><div>Load register A with the MSB for the single precision value in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0A2C</div><div>CP (HL)</div><div>Check
 to see if the MSB for the single precision value in REG 1 at the 
location of the memory pointer in register pair HL is the same as the 
value of the MSB for the single precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0A2D</div><div>RET NZ</div><div>Return if the value of the MSB in REG 1 isn't the same as the value of the MSB in register A.</div></div>
									<div class="assembly-row-combined model1" id="0A2EH"><div>0A2E</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0A2F</div><div>LD A,D</div><div>Load register A with the NMSB of the single precision value in register D.</div></div>
									<div class="assembly-row-combined model1"><div>0A30</div><div>CP (HL)</div><div>Check
 to see if the NMSB for the single precision value in REG 1 at the 
location of the memory pointer in register pair HL is the same as the 
value of the NMSB for the single precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0A31</div><div>RET NZ</div><div>Return if the value of the NMSB in REG 1 isn't the same as the value of the NMSB in register A.</div></div>
									<div class="assembly-row-combined model1" id="0A32H"><div>0A32</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0A33</div><div>LD A,E</div><div>Load register A with the LSB of the single precision value in register E.</div></div>
									<div class="assembly-row-combined model1"><div>0A34</div><div>SUB (HL)</div><div>Check
 to see if the LSB for the single precision value in REG 1 at the 
location of the memory pointer in register pair HL is the same as the 
value of the LSB for the single precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0A35</div><div>RET NZ</div><div>Return if the value of the LSB in REG 1 isn't the same as the value of the LSB in register A.</div></div>
									<div class="assembly-row-combined model1" id="0A36H"><div>0A36</div><div>POP HL</div><div>Get the value from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0A37</div><div>POP HL</div><div>Get the value from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0A3B</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0A39H">0A39-0A48 - INTEGER COMPARE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Integer compare. Compares HL with DE. After execution, A=0 if
 HL=DE, A=1 if HL&gt;DE or A=FFH if HL&lt;DE. The S and Z flags are 
valid.</p>
								<p>NOTE: To use a ROM call to compare two integers, store the 
first input in DE, the second in HL and then CALL 0A39H.  If the numbers
 are equal, the Z (zero) flag will be set. If they are not equal, the Z 
flag will be turned off. If the first input number is the smaller, the S
 (sign) and C (carry) flags will also be turned off. If the second input
 number is the smaller, the S and C flags will both be set.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0A39</div><div>LD A,D</div><div>Load register A with the MSB of the integer value in register D.</div></div>
									<div class="assembly-row-combined model1"><div>0A3A</div><div>XOR H</div><div>Check
 to see if the sign bit for the MSB of the integer value in register H 
is the same as the sign bit for the MSB for the integer value in 
register A.</div></div>
									<div class="assembly-row-combined model1"><div>0A3B</div><div>LD A,H</div><div>If
 the signs are not the same, then the answer is the sign of HL so load 
register A with the MSB of the integer value in register H.</div></div>
									<div class="assembly-row-combined model1"><div>0A3C-0A3E</div><div><a href="#095FH" class="memory-link">JP M,095FH</a></div><div>If
 M is set, then the above test created a NEGATIVE number, meaning that 
the sign bits for the integer values aren't equal.  So JUMP to 095FH.</div></div>
									<div class="assembly-row-combined model1"><div>0A3F</div><div>CP D</div><div>Check to see if the MSB for the integer value in register D is the same as the MSB for the integer value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0A40-0A42</div><div><a href="#0960H" class="memory-link">JP NZ,0960H</a></div><div>JUMP to 0960H if the MSB for the integer value in register D isn't the same as the MSB for the integer value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0A33</div><div>LD A,L</div><div>Load register A with the LSB of the single precision value in register E.</div></div>
									<div class="assembly-row-combined model1"><div>0A44</div><div>SUB E</div><div>Check to see if the LSB for the integer value in register E is the same as the LSB for the integer value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0A45-0A47</div><div><a href="#0960H" class="memory-link">JP NZ,0960H</a></div><div>JUMP if the LSB for the integer value in register E isn't the same as the LSB for the integer value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0A48</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0A49H">0A49-0A77 - DOUBLE PRECISION COMPARE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Double-precision compare. Compares REG 1 with the AACC. After
 execution the A register will contain: A=0 if REG 1=AACC, A=1 if ACC 
&gt; AACC or A=FFH if ACC &lt; AACC. S and Z flags are valid.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0A49-0A4B</div><div>LD HL,4127H</div><div>Load register pair HL with the starting address of REG 2.<br><b>NOTE:</b> 4127H-412EH holds REG 2 with 412EH being the exponent.</div></div>
									<div class="assembly-row-combined model1"><div>0A4C-0A4E</div><div><a href="#09D3H" class="memory-link">CALL 09D3H</a></div><div>GOSUB to 09D3H to move the double precision value pointed to by register pair DE to REG 2.</div></div>
									<div class="assembly-row-combined model1"><div>0A4F-0A51</div><div>LD DE,412EH</div><div>Load register pair DE with the address of the exponent in REG 2.</div></div>
									<div class="assembly-row-combined model1"><div>0A52</div><div>LD A,(DE)</div><div>Load
 register A with the exponent for the double precision value in REG 2 at
 the location of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0A53</div><div>OR A</div><div>Check to see if the double precision value in REG 2 is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0A54-0A56</div><div><a href="#0955H" class="memory-link">JP Z,0955H</a></div><div>JUMP if the double precision value in REG 2 is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0A57-0A59</div><div>LD HL,095EH</div><div>Load register pair HL with the return address.</div></div>
									<div class="assembly-row-combined model1"><div>0A5A</div><div>PUSH HL</div><div>Save the return address in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0A5B-0A5D</div><div><a href="#0955H" class="memory-link">CALL 0955H</a></div><div>GOSUB to 0955H to check to see if the double precision value in REG 1 is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0A5E</div><div>DEC DE</div><div>Decrement the value of the memory pointer in register pair DE to point to the sign.</div></div>
									<div class="assembly-row-combined model1"><div>0A5F</div><div>LD A,(DE)</div><div>Load register A with the MSB of the double precision value in REG 2 at the location of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0A60</div><div>LD C,A</div><div>Load register C with the MSB of the double precision value in REG 2 in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0A61</div><div>RET Z</div><div>Return if the double precision value in REG 1 is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0A62-0A64</div><div>LD HL,4123H</div><div>Load register pair HL with the address of the MSB of the double precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0A65</div><div>XOR (HL)</div><div>Check
 to see if the sign bit for the MSB of the double precision value in REG
 1 at the location of the memory pointer in register pair HL is the same
 as the sign bit for the MSB of the double precision value in REG 2 in 
register A.</div></div>
									<div class="assembly-row-combined model1"><div>0A66</div><div>LD A,C</div><div>Load register A with the MSB of the double precision value in REG 2 in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0A67</div><div>RET M</div><div>Return if the sign bits for the double precision values in REG 1 and REG 2 aren't the same.</div></div>
									<div class="assembly-row-combined model1" id="0A68H"><div>0A68</div><div>INC DE</div><div>Increment the value of the memory pointer in register pair DE to point back to the exponent of REG 2.</div></div>
									<div class="assembly-row-combined model1"><div>0A69</div><div>INC HL</div><div>Increment the value of the memory pointer in register pair HL to point back to the exponent of REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0A6AH-OA6B</div><div>LD B,08H</div><div>Load register B with 8 (i.e., the number of bytes to be compared).</div></div>
									<div class="assembly-row-combined model1"><div>0A6C</div><div>LD A,(DE)</div><div>Load register A with the value at the location of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0A6D</div><div>SUB (HL)</div><div>Check to see if the value in register A is the same as the value at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0A6E-0A70</div><div><a href="#0A23H" class="memory-link">JP NZ,0A23H</a></div><div>JUMP
 back to 0A23H if the value in register A isn't the same as the value at
 the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0A71</div><div>DEC DE</div><div>Decrement the value of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0A72</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0A73</div><div>DEC B</div><div>Decrement the number of bytes remaining to be compared in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0A74-0A75</div><div><a href="#0A6CH" class="memory-link">JR NZ,0A6CH</a></div><div>Loop until all of the bytes have been compared.</div></div>
									<div class="assembly-row-combined model1"><div>0A76</div><div>POP BC</div><div>Get the value from the STACK and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>0A77</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0A78H">0A78-0A7E - DOUBLE PRECISION COMPARE<br>"CPDP"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Double-precision compare. This compare is the opposite of the
 A4FH compare. It compares the AACC with the ACC. (Remember that a 
compare is actually a subtraction that is never executed therefore a 
compare can be done in two ways with the same values. (A-B and B-A)). 
The results are the same as the A4FH routine.</p>
								<p>NOTE: To use a ROM call to compare two double precision 
number, store the first input in 411DH-4124H, and store the second input
 in 4127H-412EH and then CALL 0A78H.  If the numbers are equal, the Z 
(zero) flag will be set. If they are not equal, the Z flag will be 
turned off. If the first input number is the smaller, the S (sign) and C
 (carry) flags will also be turned off. If the second input number is 
the smaller, the S and C flags will both be set.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0A78-0A7A</div><div><a href="#0A4FH" class="memory-link">CALL 0A4FH</a></div><div>Go compare the double precision value in REG 2 to the double precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0A7B-0A7D</div><div><a href="#095EH" class="memory-link">JP NZ,095EH</a></div><div>JUMP if the double precision value in REG 1 and the double precision value in REG 2 aren't the same.</div></div>
									<div class="assembly-row-combined model1"><div>0A7E</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0a7f-0ab0-level-ii">0A7F-0AB0 - LEVEL II BASIC <span class="code">CINT</span> ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p><span class="code">CINT</span> routine. Takes a value from 
ACC, converts it to an integer value and puts it back into the ACC. On 
completion, the HL register pair contains the LSB of the integer value, 
and the NTF contains 2 (Integer=2). If NTF=3 (string) a TM ERROR will be
 generated and control will be passed to BASIC.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0A7F<br>"CINT"</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>0A80-0A82</div><div>LD HL,(4121H)</div><div>Load register pair HL with the integer value in REG 1</div></div>
									<div class="assembly-row-combined model1"><div>0A83</div><div>RET M</div><div>If that test showed we have an INTEGER, then return out of this subroutine.</div></div>
									<div class="assembly-row-combined model1"><div>0A84-0A86</div><div><a href="#0AF6H" class="memory-link">JP Z,0AF6H</a></div><div>If that test showed we have a STRING, Display a <span class="code">?TM ERROR</span> message.</div></div>
									<p class="debug-note">NOTE: To use a ROM call to call the <span class="code">CINT</span>
 routine, store the single precision input variable in 4121H-4124H and 
then call to 0A8AH and bypass all the foregoing.  After the call, the 
integer result would be in 4121H-4122H and in the HL register pair.  Too
 big a number will generate a <span class="code">?OV Error</span>.</p>
									<div class="assembly-row-combined model1"><div>0A87-0A89</div><div><a href="#0AB9H" class="memory-link">CALL NC,0AB9H</a></div><div>If that test shows we have DOUBLE PRECISION, call 0AB9H to convert the number to single precision.</div></div>
									<div class="assembly-row-combined model1"><div>0A8A-0A8C</div><div>LD HL,07B2H</div><div>Load register pair HL with the return address.</div></div>
									<div class="assembly-row-combined model1"><div>0A8D</div><div>PUSH HL</div><div>Save the return address in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0A8E-0A90</div><div>LD A,(4124H)</div><div>Load register A with the exponent for the single precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0A91-0A92</div><div>CP 90H</div><div>Check to see if the exponent for the single precision value in REG 1 in register A indicates more than 16 bits of precision.</div></div>
									<div class="assembly-row-combined model1"><div>0A93-0A94</div><div><a href="#0AA3H" class="memory-link">JR NC,0AA3H</a></div><div>JUMP to 0AA3H if the exponent for the single precision value in REG 1 in register A indicates more than 16 bits of precision.</div></div>
									<div class="assembly-row-combined model1"><div>0A95-0A97</div><div><a href="#0AFBH" class="memory-link">CALL 0AFBH</a></div><div>Its
 not too large, so GOSUB to 0AFBH to convert the single precision value 
in REG 1 to an integer and return with the integer value in register 
pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0A98</div><div>EX DE,HL</div><div>Swap DE and HL.</div></div>
									<div class="assembly-row-combined model1"><div>0A99</div><div>POP DE</div><div>Get the error address from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1" id="0A9AH"><div>0A9A-0A9C<br>"ISTOR"</div><div>LD (4121H),HL</div><div>Save the integer value in register pair HL as the current value in REG 1.<br><br>This
 is the routine that returns the value in the HL register pair to the 
BASIC program that called it. In effect it moves the content of HL into 
REG 1 (ACC = HL).</div></div>
									<div class="assembly-row-combined model1"><div>0A9D-0A9E<br>"FLAGIN"</div><div>LD A,02H</div><div>Load register A with an integer number type flag (which is a 2).</div></div>
									<div class="assembly-row-combined model1"><div>0A9F-0AA1</div><div>LD (40AFH),A</div><div>Save the integer number type flag in register A as the current value of the number type flag.<br><b>Note:</b> 40AFH holds the current number's type flag as follows:<ul><li>2: Integer</li><li>3: String</li><li>4: Single precision</li><li>8: Double precision</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>0AA2</div><div>RET</div><div>Return.</div></div>
									<div class="assembly-row-combined model1"><div>0AA3-0AA5</div><div>LD BC,9080H</div><div>Load register pair BC with the exponent and the MSB of a single precision value (i.e., -32768).</div></div>
									<div class="assembly-row-combined model1"><div>0AA6-0AA8</div><div>LD DE,0000H</div><div>Load
 register pair DE with the NMSB and the LSB of a single precision value.
 Register pairs BC and DE now hold a single precision value equal to 
-32768.</div></div>
									<div class="assembly-row-combined model1"><div>0AA9-0AAB</div><div><a href="#0A0CH" class="memory-link">CALL 0A0CH</a></div><div>Compare them by GOSUB to the SINGLE PRECISION COMPARISON routine at 0A0CH.<br><br><span class="nobottomborder bold">NOTE:</span>  The routine at 0A0CH algebraically compares the single precision value in BC/DE to the single precision value REG 1.<br>The results are stored in A as follows:<ul><li>A=0 if REG 1 = BCDE</li><li>A=1 if REG 1&gt;BCDE; and </li><li>A=FFH if REG 1&lt;BCDE.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>0AAC</div><div>RET NZ</div><div>Display an <span class="code">?OV ERROR</span> if the value in REG 1 isn't equal to -32768.</div></div>
									<div class="assembly-row-combined model1"><div>0AAD</div><div>LD H,C</div><div>Put -32768 into HL by first loading register H with the MSB of the single precision value in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0AAE</div><div>LD L,D</div><div>and then loading  register L with the NMSB of the single precision value in register D.</div></div>
									<div class="assembly-row-combined model1"><div>0AAF-0AB0</div><div><a href="#0A99H" class="memory-link">JR 0A99H</a></div><div>JUMP to 0A99H to store it in REG 1 and set the variable type flag.</div></div>
								</div>
							</div>

							<br><h2 id="0ab1-0acb-level-ii">0AB1-0ACB - LEVEL II BASIC <span class="code">CSNG</span> ROUTINE<br>"CSASP"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p><span class="code">CSNG</span> routine. Takes value from ACC and converts it to single-precision. The result is put in ACC and NTF contains 4.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0AB1<br>"CSNG"</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>0AB2</div><div>RET PO</div><div>If that test shows we have SINGLE PRECISION, return out of this subroutine.</div></div>
									<div class="assembly-row-combined model1"><div>0AB3-0AB5</div><div><a href="#0ACCH" class="memory-link">JP M,0ACCH</a></div><div>If that test shows we have an INTEGER, jump to 0ACCH.</div></div>
									<div class="assembly-row-combined model1"><div>0AB6-0AB8</div><div><a href="#0AF6H" class="memory-link">JP Z,0AF6H</a></div><div>If that test shows we have a STRING, display a <span class="code">?TM ERROR</span> .</div></div>
									<div class="assembly-row-combined model1"><div>0AB9-0ABB</div><div><a href="#09BFH" class="memory-link">CALL 09BFH</a></div><div>At
 this point, we have a DOUBLE PRECISION number, so call 09BF which loads
 the SINGLE PRECISION value in REG 1 (which is currently the most 
significant four bytes of the double precision value in REG 1) into 
register pair BC/DE.</div></div>
									<div class="assembly-row-combined model1"><div>0ABC-0ABE</div><div><a href="#0AEFH" class="memory-link">CALL 0AEFH</a></div><div>Go set the current number type flag to single precision.</div></div>
									<div class="assembly-row-combined model1"><div>0ABF</div><div>LD A,B</div><div>Load register A with the exponent of the double precision value in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0AC0</div><div>OR A</div><div>Check to see if the double precision value in REG 1 is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0AC1</div><div>RET Z</div><div>Return if the double precision value in REG 1 is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0AC2-0AC4</div><div><a href="#09DFH" class="memory-link">CALL 09DFH</a></div><div>GOSUB to 09DFH to unpack the number ... turn on the most significant bit of the single precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0AC5-0AC7</div><div>LD HL,4120H</div><div>Load register pair HL with the address of the most significant byte chopped off the double precision value.</div></div>
									<div class="assembly-row-combined model1"><div>0AC8</div><div>LD B,(HL)</div><div>Loaded
 register B with the most significant byte chopped off the double 
precision value at the location of the memory pointer in register pair 
HL.</div></div>
									<div class="assembly-row-combined model1"><div>0AC9-0ACB</div><div><a href="#0796H" class="memory-link">JP 0796H</a></div><div>JUMP to 0796H to round the double number up.</div></div>
								</div>
							</div>

							<br><h2 id="0ACCH">0ACC-0ADA - LEVEL II BASIC MATH ROUTINE<br>"CHGIS"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Convert Integer to Single Precision.  Alters: A,B,C,D,E,H,L.</p>
								<p>Note: If you wanted to convert integer to single precision 
via a ROM call, you would store the integer input variable in 
4121H-4122H and then call to 0ACCH.  The result (as a single precision 
number) will be in 4121H-4124H.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0ACC-0ACE</div><div>LD HL,(4121H)</div><div>Load register pair HL with the integer value at the location of an integer storage in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0ACF-0AD1</div><div><a href="#0AEFH" class="memory-link">CALL 0AEFH</a></div><div>GOSUB to 0AEF to set the current number type flag to single precision.</div></div>
									<div class="assembly-row-combined model1"><div>0AD2</div><div>LD A,H</div><div>Now
 we need to prepare the registers for the routine at 0969H ... Load 
register A with the MSB of the integer value in register H.</div></div>
									<div class="assembly-row-combined model1"><div>0AD3</div><div>LD D,L</div><div>Load register D with the LSB of the integer value in register L.</div></div>
									<div class="assembly-row-combined model1"><div>0AD4-0AD5</div><div>LD E,00H</div><div>Zero register E.</div></div>
									<div class="assembly-row-combined model1"><div>0AD6-0AD7</div><div>LD B,90H</div><div>Load register B with 90H (Decimal: 144) as the initial maximum exponent.</div></div>
									<div class="assembly-row-combined model1"><div>0AD8-0ADA</div><div><a href="#0969H" class="memory-link">JP 0969H</a></div><div>JUMP to 0969H.</div></div>
								</div>
							</div>

							<br><h2 id="0ADBH">0ADB-0AED - LEVEL II BASIC CDBL ROUTINE<br>"CSADP"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p><span class="code">CDBL</span> routine. Takes a value from ACC and converts it to double-precision. The result will be in ACC and NTF will be 8.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0ADB<br>"CDBL"</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>0ADC</div><div>RET NC</div><div>If that test shows we have a DOUBLE PRECISION number, return out of the subroutine.</div></div>
									<div class="assembly-row-combined model1"><div>0ADD-0ADF</div><div><a href="#0AF6H" class="memory-link">JP Z,0AF6H</a></div><div>If that test shows we have a STRING, Display a TM ERROR message.</div></div>
									<div class="assembly-row-combined model1"><div>0AE0-0AE2</div><div><a href="#0ACCH" class="memory-link">CALL M,0ACCH</a></div><div>If that test shows we have an INTEGER, then GOSUB to 0ACCH to convert it to SINGLE PRECISION..</div></div>
									<div class="assembly-row-combined model1"><div>0AE3-0AE5</div><div>LD HL,0000H</div><div>So now we know we have a SINGLE PRECISION value.  Load register pair HL with zero.</div></div>
									<div class="assembly-row-combined model1"><div>0AE6-0AE8</div><div>LD (411DH),HL</div><div>Clear the next 4 bytes ... Save the value in register pair HL as the first and second bytes of REG 1.<br><b>NOTE:</b> 411DH-4124H holds REG l.</div></div>
									<div class="assembly-row-combined model1"><div>0AE9-0AEB</div><div>LD (411FH),HL</div><div>and save the value in register pair HL as the third and fourth bytes of REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0AEC-0AED<br>"FLAGDP"</div><div>LD A,08H</div><div>Load register A with a double precision number type flag.</div></div>
								</div>
							</div>

							<br><h2 id="0AEEH">0AEE-0AF3 - LEVEL II BASIC MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0AEE</div><div>01</div><div>Z-80 Trick - See the note at 0134H for an explanation.</div></div>
									<div class="assembly-row-combined model1"><div>0AEF-0AF0<br>"FLAGSP"</div><div>LD A,04H</div><div>Load register A with a single precision number type flag (of 4).</div></div>
									<div class="assembly-row-combined model1"><div>0AF1-0AF3</div><div><a href="#0A9FH" class="memory-link">JP 0A9FH</a></div><div>JUMP away to 0A9FH to save the value in register A as the current number type flag.</div></div>
								</div>
							</div>

							<br><h2 id="0AF4H">0AF4-0AFA - LEVEL II BASIC MATH ROUTINE - Force REG1 to be a STRING<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine calls 20H (RST 20H) and returns if NTF=3 
(string) else if NTF is not 3 then it generates a TM ERROR. BC, DE, and 
HL are saved.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0AF4</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>0AF5</div><div>RET Z</div><div>If that test shows we have a STRING, return out of the subroutine.</div></div>
									<div class="assembly-row-combined model1"><div>0AF6-0AF7</div><div>LD E,18H</div><div>Load register E with a TM ERROR code.<br><br>This is the entry point for the TM ERROR.</div></div>
									<div class="assembly-row-combined model1"><div>0AF8-0AFA</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#19A2H" class="memory-link">JP 19A2H</a></div><div>Display a TM ERROR message if the current value in REG 1 isn't a string.</div></div>
								</div>
							</div>

							<br><h2 id="0AFBH">0AFB-0B1E - LEVEL II BASIC MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine will reset the BC and DE register pairs if the A register contains 0. (XOR A before calling this routine).</p>
								<p>Greatest integer function.  Leaves INT(REG1) in C,D,E 
(signed).  Assumes REG1 &lt; 2^23 = 8388608.  Assumes the exponent of 
REG1 is in A.  Alters A,B,C,D,E</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0AFB</div><div>LD B,A</div><div>Load register B with the exponent of the single precision number in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0AFC</div><div>LD C,A</div><div>Load register C with the exponent of the single precision number in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0AFD</div><div>LD D,A</div><div>Load register D with the exponent of the single precision number in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0AFE</div><div>LD E,A</div><div>Load register E with the exponent of the single precision number in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0AFF</div><div>OR A</div><div>Check to see if the single precision number in REG 1 is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0B00</div><div>RET Z</div><div>Return if the single precision value in REG 1 is equal to zero.</div></div>
									<p class="debug-note">The hard case is QINT is negative 
non-integers.  To handle this if the number is negative, we regard the 
3-byte mantissa as a 3 byte integer and subtract one.  Then all the 
fractional bits are shifted out by shifting the mantissa right.  Then, 
if the number was negative, we add one.  So if we had a negative 
integer, all the bits to the right of the binary point were zero.  So 
the net effect is we have the original number in C,D,E.  If the number 
was a negative non-integer, there is at least one non-zero bit to the 
right of the binary point. So the net effect is that we get the absolute
 value of INT(REG1) in C,D,E.  C,D,E is then negated if the original 
number was negative so the result will be signed.	</p>
									<div class="assembly-row-combined model1"><div>0B01</div><div>PUSH HL</div><div>Save the value in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0B02-0B04</div><div><a href="#09BFH" class="memory-link">CALL 09BFH</a></div><div>GOSUB to 09BFH which loads the SINGLE PRECISION value in REG 1 into register pair BC/DE.</div></div>
									<div class="assembly-row-combined model1"><div>0B05-0B07</div><div><a href="#09DFH" class="memory-link">CALL 09DFH</a></div><div>GOSUB to 09DFH to to turn on the sign bit of the single precision value in register pairs BC and DE.</div></div>
									<div class="assembly-row-combined model1"><div>0B08</div><div>XOR (HL)</div><div>Set the sign bit according to the sign of the value at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0B09</div><div>LD H,A</div><div>Load register H with the value of the sign in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0B0A-0B0C</div><div><a href="#0B1FH" class="memory-link">CALL M,0B1FH</a></div><div>Go decrement the single precision value in register pairs BC and DE if the sign of the value is negative.</div></div>
									<div class="assembly-row-combined model1"><div>0B0D-0B0E</div><div>LD A,98H</div><div>Load register A with the maximum exponent of 98H (Decimal: 152).</div></div>
									<div class="assembly-row-combined model1"><div>0B0F</div><div>SUB B</div><div>Figure the number of bits to be shifted by subtracting the exponent in register B from the exponent in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0B10-0B12</div><div><a href="#07D7H" class="memory-link">CALL 07D7H</a></div><div>GOSUB to 07D7H to shift the single precision value in register pairs BC and DE (to get rid of the fractional bits).</div></div>
									<div class="assembly-row-combined model1"><div>0B13</div><div>LD A,H</div><div>Load register A with the value of the sign in register H.</div></div>
									<div class="assembly-row-combined model1"><div>0B14</div><div>RLA</div><div>Put the sign bit into the CARRY FLAG so it won't be changed.</div></div>
									<div class="assembly-row-combined model1"><div>0B15-0B17</div><div><a href="#07A8H" class="memory-link">CALL C,07A8H</a></div><div>Go bump the value in register pairs BC and DE if the original number was negative.</div></div>
									<div class="assembly-row-combined model1"><div>0B18-0B19</div><div>LD B,00H</div><div>Load register B with zero to forget the bits which were shifted out.</div></div>
									<div class="assembly-row-combined model1"><div>0B1A-0B1C</div><div><a href="#07C3H" class="memory-link">CALL C,07C3H</a></div><div>Go
 make the integer negative if the original number was negative because 
we want a signed mantissa. Return with the integer value in register 
pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0B1D</div><div>POP HL</div><div>Get the old HL value from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0B1E</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0BlFH">0B1F-0B25 - LEVEL II BASIC MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0B1F</div><div>DEC DE</div><div>Decrement the NMSB and the LSB of the single precision value in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0B20</div><div>LD A,D</div><div>Load register A with the value of the NMSB for the single precision value in register D.</div></div>
									<div class="assembly-row-combined model1"><div>0B21</div><div>AND E</div><div>Combine the LSB of the single precision value in register E with the NMSB of the single precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0B22</div><div>INC A</div><div>Increment the combined value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0B23</div><div>RET NZ</div><div>Return if the NMSB and the LSB of the single precision value in register pair DE isn't equal to FFFFH.</div></div>
									<div class="assembly-row-combined model1"><div>0B24</div><div>DEC BC</div><div>Decrement the value of the exponent and the MSB of the single precision value in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>0B25</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0b26-0b58-level-ii">0B26-0B58 - LEVEL II BASIC <span class="code">FIX</span> ROUTINE - "FIX"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p><span class="code">FIX</span> routine. Takes a value from ACC
 and converts it to an integer value. The result will be in ACC. NTF 
will be 2 if value is smaller than 32767 else it will be 4. An error 
will be generated if NTF=3 (string).<br>A call to 0B26H unconditionally 
truncates the fractional part of a floating point number in REG 1. The 
result is stored in WRAl and the type flag is set to integer.</p>
								<p>Note: If you wanted to call the <span class="code">FIX</span>
 routine via a ROM call, you would store the single-precision input 
variable in 4121H-4124H, then put a 4 into 40AFH to flag as single 
precision, and then call to 0B26H.  If the result can be an integer, it 
will be in 4121H-4122H and in the HL register pair.  If single 
precision, the result will be in 4121H-4124H.  If double precision, in 
411DH-4124H.  In all cases 40AFH will have the data mode flag as 2, 4, 
or 8, accordingly.</p>
								<p>The routine is FIX(X)=SGN(X)*INT(ABS(X))</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0B26<span class="origrom2">FIX</span></div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>0B27</div><div>RET M</div><div>If that test shows we have an INTEGER, return out of the subroutine.</div></div>
									<div class="assembly-row-combined model1"><div>0B28-0B2A</div><div><a href="#0955H" class="memory-link">CALL 0955H</a></div><div>GOSUB to 0955H to check the sign of the current value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0B2B-0B2D</div><div><a href="#0B37H" class="memory-link">JP P,0B37H</a></div><div>If
 the current value in REG 1 is positive, jump to the RETURN INTEGER 
(INT[N]) routine at 0B37H (which returns the integer portion of a 
floating point number. If the value is positive, the integer portion is 
returned. If the value is negative with a fractional part, it is rounded
 up before truncation. The integer portion is left in REG 1. The mode 
flag is updated.).</div></div>
									<div class="assembly-row-combined model1"><div>0B2E-0B30</div><div><a href="#0982H" class="memory-link">CALL 0982H</a></div><div>GOSUB to 0982H to convert the current value in REG 1 to positive.</div></div>
									<div class="assembly-row-combined model1"><div>0B31-0B33</div><div><a href="#0B37H" class="memory-link">CALL 0B37H</a></div><div>Now
 that REG 1 is positive, call the RETURN INTEGER (INT[N]) routine at 
0B37H (which returns the integer portion of a floating point number. If 
the value is positive, the integer portion is returned. If the value is 
negative with a fractional part, it is rounded up before truncation. The
 integer portion is left in REG 1. The mode flag is updated.).</div></div>
									<div class="assembly-row-combined model1"><div>0B34-0B36</div><div><a href="#097BH" class="memory-link">JP 097BH</a></div><div>JUMP back to 097BH (which is in the middle of the <span class="code">ABS(x)</span> routine.</div></div>

								</div>
							</div>

							<br><h2 id="0b37-level-ii-basic">0B37 - LEVEL II BASIC <span class="code">INT(</span> ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>A call to 0B37H returns the integer portion of a floating 
point number. If the value is positive, the integer portion is returned.
 If the value is negative with a fractional part, it is rounded up 
before truncation. The integer portion is left in REG 1.  The mode flag 
is updated.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0B37<span class="origrom2">INT</span></div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>0B38</div><div>RET M</div><div>If that test shows we have an INTEGER, return out of this subroutine.</div></div>
									<div class="assembly-row-combined model1"><div>0B39-0B3A</div><div><a href="#0B59H" class="memory-link">JR NC,0B59H</a></div><div>JUMP if the current value in REG 1 is double precision.</div></div>
									<div class="assembly-row-combined model1"><div>0B3B-0B3C</div><div><a href="#0AF6H" class="memory-link">JR Z,0AF6H</a></div><div>Display a <span class="code">?TM ERROR</span> if the current value in REG 1 isa string.</div></div>
									<p class="debug-note">Note: If you wanted to call the <span class="code">INT</span>
 routine via a ROM call, you would store the single precision input 
variable in 4121H-4124H, put a 4 into 40AFH (to flag as single 
precision), and then call 0B3DH and bypass all the foregoing.  After the
 call, the integer result would be in 4121H-4122H and in the HL register
 pair IF the absolute value of the input did not exceed 32767.  
Otherwise it will be in 4121H-4124H in single precision format, and 40AF
 will be a 2 for integer or 4 for single precision..</p>
									<div class="assembly-row-combined model1"><div>0B3D-0B3F</div><div><a href="#0A8EH" class="memory-link">CALL 0A8EH</a></div><div>Go convert the single precision value in REG 1 to an integer.</div></div>
									<div class="assembly-row-combined model1"><div>0B40-0B42</div><div>LD HL,4124H</div><div>Load register pair HL with the address of the exponent in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0B43</div><div>LD A,(HL)</div><div>Load register A with the value of the exponent in REG 1 at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0B44-0B45</div><div>CP 98H</div><div>Check to see if there is more than 24 bits of precision used by the current value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0B46-0B48</div><div>LD A,(4121H)</div><div>Load register A with the LSB of the single precision number in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0B49</div><div>RET NC</div><div>Return if more than 24 bits of precision is used by the single precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0B4A</div><div>LD A,(HL)</div><div>Load register A with the exponent of the single precision number in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0B4B-0B4D</div><div><a href="#0AFBH" class="memory-link">CALL 0AFBH</a></div><div>GOSUB to 0AFBH to convert the single precision number in REG 1 to an integer.</div></div>
									<div class="assembly-row-combined model1"><div>0B4E-0B4F</div><div>LD (HL),98H</div><div>Save an exponent in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0B50</div><div>LD A,E</div><div>Load register A with the LSB of the integer value in register E.</div></div>
									<div class="assembly-row-combined model1"><div>0B51</div><div>PUSH AF</div><div>Save the LSB of the integer value in register A on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0B52</div><div>LD A,C</div><div>Load register A with the value in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0B53</div><div>RLA</div><div>Move the sign bit in register A into the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>0B54-0B56</div><div><a href="#0762H" class="memory-link">CALL 0762H</a></div><div>Go make the number in REG 1 single precision.</div></div>
									<div class="assembly-row-combined model1"><div>0B57</div><div>POP AF</div><div>Get the LSB of the single precision value from the STACK and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0B58</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0B59H">0B59-0B9D - LEVEL II BASIC MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0B59-0B5B</div><div>LD HL,4124H</div><div>Load register pair HL with the address of the exponent in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0B5C</div><div>LD A,(HL)</div><div>Load
 register A with the value of the exponent for the double precision 
number in REG 1 at the location of the memory pointer in register pair 
HL.</div></div>
									<div class="assembly-row-combined model1"><div>0B5D-0B5E</div><div>CP 90H</div><div>Check
 to see if the double precision number in REG 1 uses more or less than 
16 bits of precision by checking A against 90H.  This has the effect of 
checking A-90H, so if A &lt; 90H (16 Bits of Precision) then the CARRY 
will be set and if A &gt;= 90H (16 Bits of Precision) then the NO CARRY 
will be set.</div></div>
									<div class="assembly-row-combined model1"><div>0B5F-0B61</div><div><a href="#0A7FH" class="memory-link">JP C,0A7FH</a></div><div>If
 the double precision value in REG 1 uses less than 16 bits of 
precision, jump to the CONVERT TO INTEGER routine at 0A7F (where the 
contents of REG 1 are converted from single or double precision to 
integer and stored in HL).</div></div>
									<div class="assembly-row-combined model1"><div>0B62-0B63</div><div><a href="#0B78H" class="memory-link">JR NZ,0B78H</a></div><div>JUMP forward to 0B78H if the double precision number in REG 1 uses more than 16 bits of precision.</div></div>
									<div class="assembly-row-combined model1"><div>0B64</div><div>LD C,A</div><div>Load register C with the exponent for the double precision number in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0B65</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0B66</div><div>LD A,(HL)</div><div>Load register A with the MSB of the double precision value in REG 1 at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0B67-0B68</div><div>XOR 80H</div><div>Complement the value of the sign bit in register A (which is 1000 0000).</div></div>
									<div class="assembly-row-combined model1"><div>0B69-0B6A</div><div>LD B,06H</div><div>Load register B with the number of bytes to be checked.</div></div>
									<div class="assembly-row-combined model1"><div>0B6B</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0B6C</div><div>OR (HL)</div><div>Combine the value at the location of the memory pointer in register HL with the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0B6D</div><div>DEC B</div><div>Decrement the byte counter in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0B6E-0B6F</div><div><a href="#0B6BH" class="memory-link">JR NZ,0B6BH</a></div><div>Loop until all of the bytes have been checked.</div></div>
									<div class="assembly-row-combined model1"><div>0B70</div><div>OR A</div><div>Check to see if the double precision value in REG 1 is equal to a -32768.</div></div>
									<div class="assembly-row-combined model1"><div>0B71-0B73</div><div>LD HL,8000H</div><div>Load register pair HL with a negative zero.</div></div>
									<div class="assembly-row-combined model1"><div>0B74-0B76</div><div><a href="#0A9AH" class="memory-link">JP Z,0A9AH</a></div><div>JUMP back to 0A9AH if the double precision value in REG 1 is a -32768.</div></div>
									<div class="assembly-row-combined model1"><div>0B77</div><div>LD A,C</div><div>Load register A with the exponent for the double precision value in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0B78-0B79</div><div>CP B8H</div><div>Check to see if more than 56 bits of precision has been used for the double precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0B7A</div><div>RET NC</div><div>Return if more than 56 bits of precision have been used for the double precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0B7B</div><div>PUSH AF</div><div>Save the exponent in register A on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0B7C-0B7E</div><div><a href="#09BFH" class="memory-link">CALL 09BFH</a></div><div>GOSUB to 09BF which loads most significant four bytes of the double precision value in REG 1 into register pair BC/DE.</div></div>
									<div class="assembly-row-combined model1"><div>0B7F-0B81</div><div><a href="#09DFH" class="memory-link">CALL 09DFH</a></div><div>GOSUB to 09DFH to turn on the sign bit and return with the value of the sign.</div></div>
									<div class="assembly-row-combined model1"><div>0B82</div><div>XOR (HL)</div><div>Set
 the sign bit by combining the value at the location of the memory 
pointer in register pair HL with the result of the sign test in register
 A.</div></div>
									<div class="assembly-row-combined model1"><div>0B83</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0B84-0B85</div><div>LD (HL),B8H</div><div>Save an exponent at the location of the memory pointer in register HL.</div></div>
									<div class="assembly-row-combined model1"><div>0B86</div><div>PUSH AF</div><div>Save the value of the sign test in register A on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0B87-0B89</div><div><a href="#0BA0H" class="memory-link">CALL M,0BA0H</a></div><div>GOSUB to 0BA0H to adjust the number in REG 1 if it's negative.</div></div>
									<div class="assembly-row-combined model1"><div>0B8A-0B8C</div><div>LD HL,4123H</div><div>Load register pair HL with the address of the MSB in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0B8D-0B8E</div><div>LD A,B8H</div><div>Load register A with the maximum value of an exponent.</div></div>
									<div class="assembly-row-combined model1"><div>0B8F</div><div>SUB B</div><div>Subtract the value of the exponent at the location of the memory pointer in register pair HL from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0B90-0B92</div><div><a href="#0D69H" class="memory-link">CALL 0D69H</a></div><div>Go adjust the value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0B93</div><div>POP AF</div><div>Get the value of the sign test from the STACK and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0B94-0B96</div><div><a href="#0D20H" class="memory-link">CALL M,0D20H</a></div><div>If REG 1 is negative, then COSUB to 0D20H to adjust the value.</div></div>
									<div class="assembly-row-combined model1"><div>0B97</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>0B98-0B9A</div><div>LD (411CH),A</div><div>Zero memory location 411CH.<br><b>NOTE:</b> 411CH is used by floating point routines.</div></div>
									<div class="assembly-row-combined model1"><div>0B9B</div><div>POP AF</div><div>Get the value of the original exponent test from the STACK and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>0B9C</div><div>RET NC</div><div>Return if more than 56 bits are used by the double precision number.</div></div>
									<div class="assembly-row-combined model1"><div>0B9D-0B9F</div><div><a href="#0CD8H" class="memory-link">JP 0CD8H</a></div><div>JUMP to 0CD8H.</div></div>
								</div>
							</div>

							<br><h2 id="0BA0H">0BA0-0BA9 - LEVEL II BASIC MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0BA0-0BA2</div><div>LD HL,411DH</div><div>Load register pair HL with the starting address of REG 1.<br><b>NOTE:</b> 411DH-4124H holds REG l.</div></div>
									<div class="assembly-row-combined model1"><div>0BA3</div><div>LD A,(HL)</div><div>Load register A with the value at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0BA4</div><div>DEC (HL)</div><div>Decrement the value at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0BA5</div><div>OR A</div><div>Check to see if the value in register A is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0BA6</div><div>INC HL</div><div>Increment the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0BA7-0BA8</div><div><a href="#0BA3H" class="memory-link">JR Z,0BA3H</a></div><div>Loop until the value at the location of the memory pointer in register pair HL is equal to a nonzero value.</div></div>
									<div class="assembly-row-combined model1"><div>0BA9</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0BAAH">0BAA-0BC6 - LEVEL II BASIC MATH ROUTINE - 
Integer Multiply for Multiply Dimensioned Arrays.  DF = BC * DE.  
Overflow will cause a <span class="code">BS ERROR</span>.  Alters A, B, C, D, and E<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0BAA</div><div>PUSH HL</div><div>Save the value in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0BAB-0BAD</div><div>LD HL,0000H</div><div>Load register pair HL with zero to zero the product registers.</div></div>
									<div class="assembly-row-combined model1"><div>0BAE-0BAF</div><div>LD A,B<br>OR C</div><div>Test
 for BC=0.  The easiest way to test a 2 byte register for zero is to 
load the MSB into A and then OR it with the LSB.  If the MSB was 0 and 
the LSB was 0, then A will be 0.</div></div>
									<div class="assembly-row-combined model1"><div>0BB0-0BB1</div><div><a href="#0BC4H" class="memory-link">JR Z,0BC4H</a></div><div>JUMP to 0BC4H if BC = 0 (which is really just for speed).</div></div>
									<div class="assembly-row-combined model1"><div>0BB2-0BB3</div><div>LD A,10H</div><div>Load register A with the counter value (which is 16).</div></div>
									<div class="assembly-row-combined model1"><div>0BB4</div><div>ADD HL,HL</div><div>HL = HL + HL.  This will set the CARRY flag if it overflows.</div></div>
									<div class="assembly-row-combined model1"><div>0BB5-0BB7</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#273DH" class="memory-link">JP C,273DH</a></div><div>Display a <span class="code">?BS ERROR</span> message if the result in register pair HL has overflowed.</div></div>
									<div class="assembly-row-combined model1"><div>0BB8</div><div>EX DE,HL</div><div>We
 need to do a DE = DE + DE, but that doesn't exist, so we need to use 
HL.  First, exchange the integer value in register pair DE with the 
result in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0BB9</div><div>ADD HL,HL</div><div>... then HL = HL + HL.</div></div>
									<div class="assembly-row-combined model1"><div>0BBA</div><div>EX DE,HL</div><div>... then exchange the result in register pair DE with the integer value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0BBB-0BBC</div><div><a href="#0BC1H" class="memory-link">JR NC,0BC1H</a></div><div>JUMP to 0BC1H if the most significant bit in the integer value in register DE wasn't set.</div></div>
									<div class="assembly-row-combined model1"><div>0BBD</div><div>ADD HL,BC</div><div>Add the integer value in register pair BC to the result in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0BBE-0BC0</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#273DH" class="memory-link">JP C,273DH</a></div><div>Display a BS ERROR message if the result in register pair HL has overflowed.</div></div>
									<div class="assembly-row-combined model1"><div>0BC1</div><div>DEC A</div><div>Decrement the counter in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0BC2-0BCJ</div><div><a href="#0BB4H" class="memory-link">JR NZ,0BB4H</a></div><div>Loop until the multiplication has been completed.</div></div>
									<div class="assembly-row-combined model1"><div>0BC4</div><div>EX DE,HL</div><div>Load register pair DE with the result in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0BC5</div><div>POP HL</div><div>Get the value from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0BC6</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0BC7H">0BC7-0BD1 - INTEGER SUBTRACTION<br>"subINT"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Integer subtract. (REG 1=DE-HL) The result is returned in both REG 1 and the HL register pair.<br>Subtracts
 the value in DE from the value in HL. The difference is left in the HL 
register pair. DE is preserved. In the event of underflow, both values 
are converted to single precision and the subtraction is repeated. The 
result is left in REG 1 and the mode flag is updated accordingly.</p>
								<p>Note: If you wanted to subtract 2 integers via a ROM call, 
store one into DE and the subtrahend in HL (i.e., to do 26-17, DE gets 
26), and then call 0BC7H.  The integer result will be stored in 
4121H-4122H approximately 210 microseconds later, and 40AFH will be set 
to 2 (to flag it as an integer).  If there is an overflow, it will be 
converted to single precision (with 40AFH being a 4 in that case) and 
will be stored in 4121H-4124H.</p>
								<p>(HL):=(DE)-(HL). Alters: A,B,C,D,E,H,L</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0BC7<span class="origrom2">ISUB</span></div><div>LD A,H</div><div>Load register A with the MSB of the integer value in register H.</div></div>
									<div class="assembly-row-combined model1"><div>0BC8</div><div>RLA</div><div>Put the value of the sign bit into the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>0BC9</div><div>SBC A,A</div><div>Adjust register A according to the value of the sign bit.</div></div>
									<div class="assembly-row-combined model1"><div>0BCA</div><div>LD B,A</div><div>Load register B with the result of the sign test.</div></div>
									<div class="assembly-row-combined model1"><div>0BCB-0BCD</div><div><a href="#0C51H" class="memory-link">CALL 0C51H</a></div><div>GOSUB to 0C51H to complement the value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0BCE</div><div>LD A,C</div><div>Load register A with zero.</div></div>
									<div class="assembly-row-combined model1"><div>0BCF</div><div>SBC A,B</div><div>Adjust the value of the sign test.</div></div>
									<div class="assembly-row-combined model1"><div>0BD0-0BD1</div><div><a href="#0BD5H" class="memory-link">JR 0BD5H</a></div><div>JUMP to 0BD5H.</div></div>
								</div>
							</div>

							<br><h2 id="0BD2H">0BD2-0BF1 - INTEGER ADDITION<br>"ADDINT"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Integer addition (REG 1=DE+HL). After execution NTF=2, or 4 
if overflow has occurred, in which case the result in REG 1 will be 
single-precision. The result is returned in both REG 1 and the HL 
register pair.<br>Adds the integer value in DE to the integer in HL. The
 sum is left in HL and the orginal contents of DE are preserved. If 
overflow occurs (sum exceeds 2**15), both values are converted to single
 precision and then added. The result would be left in Reg 1 and the 
mode flag would be updated.</p>
								<p>Note: If you wanted to add 2 integers via a ROM call, store 
one input into DE and the other into HL, and then call 0BD2H.  The 
result will be in 4121H-4122H and in HL, with a 2 in 40AFH, and will 
take about 130 microseconds.  If there is an overflow, the result will 
be converted to Single Precision and put into 4121H-4124H (with a 4 in 
40AFH).</p>
								<p>(HL):=(DE)+(HL).  Alters: A,B,C,D,E,H,L</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0BD2</div><div>LD A,H</div><div>Load register A with the MSB of the integer value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0BD3</div><div>RLA</div><div>Put the value of the sign bit into the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>0BD4</div><div>SBC A,A</div><div>Adjust register A according to the value of the sign bit.</div></div>
									<div class="assembly-row-combined model1"><div>0BD5</div><div>LD B,A</div><div>Load register B with the result of the sign test to save the sign.</div></div>
									<div class="assembly-row-combined model1"><div>0BD6</div><div>PUSH HL</div><div>Save the integer value in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0BD7</div><div>LD A,D</div><div>Load register A with the MSB of the integer value in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0BD8</div><div>RLA</div><div>Put the value of the sign bit into the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>0BD9</div><div>SBC A,A</div><div>Adjust register A according to the value of the sign bit.</div></div>
									<div class="assembly-row-combined model1"><div>0BDA</div><div>ADD HL,DE</div><div>Add the integer value in register pair DE to the integer value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0BDB</div><div>ADC A,B</div><div>Add
 the CARRY FLAG and the value from the sign test for the integer value 
in register pair HL in register B to the value of the sign test for the 
integer value in register pair DE in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0BDC</div><div>RRCA</div><div>This
 instruction and the next basically test to see if the LSB of A is 
different from the MSB of H, in which cas an overflow will occur.  So 
first, put the value of the CARRY FLAG in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0BDD</div><div>XOR H</div><div>Then combine the value of the sign bit for the result in register H with the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0BDE-0BE0</div><div><a href="#0A99H" class="memory-link">JP P,0A99H</a></div><div>JUMP unless overflow has occurred.</div></div>
									<div class="assembly-row-combined model1"><div>0BE1</div><div>PUSH BC</div><div>Save the value of the sign test in register B on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0BE2</div><div>EX DE,HL</div><div>Load register pair HL with the integer value in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0BE3-0BE5</div><div><a href="#0ACFH" class="memory-link">CALL 0ACFH</a></div><div>Go convert the register value in register pair HL to single precision and return with the result in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0BE6</div><div>POP AF</div><div>Get the value of the sign test from the STACK and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0BE7</div><div>POP HL</div><div>Get the integer value from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0BE8-0BEA</div><div><a href="#09A4H" class="memory-link">CALL 09A4H</a></div><div>Call 09A4 which moves the SINGLE PRECISION value in REG 1 to the STACK (stored in LSB/MSB/Exponent order).</div></div>
									<div class="assembly-row-combined model1"><div>0BEB</div><div>EX DE,HL</div><div>Load register pair DE with the integer value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0BEC-0BEE</div><div><a href="#0C6BH" class="memory-link">CALL 0C6BH</a></div><div>Go convert the integer value in register pair DE to single precision and return with the result in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0BEF-0BF1</div><div><a href="#0F8FH" class="memory-link">JP 0F8FH</a></div><div>Go perform single precision addition.</div></div>
								</div>
							</div>

							<br><h2 id="0bf2-0cle-integer">0BF2-0ClE - INTEGER MULTIPLICATION<br>"MLTINT"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Integer multiply. (REG 1=DE*HL).  Multiplies HL by DE. The 
product is left in HL and DE is preserved. If overflow occurs, both 
values are converted to single precision and the operation is restarted.
 The product would be left in REG 1.</p>
								<p>Note: If you wanted to multiply two integers, store one input
 in DE, the other in HL CALL 0BF2H.  The result is in 4121H-4122H and in
 HL, with a 2 in 40AFH (but in an overflow the result is converted to 
single precision format and stored in 4121H-4124H, with a 4 in 40AFH. 
Process takes approximately 900 microseconds.</p>
								<p>Alters A,B,C,D,E,H,L</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0BF2,0BF3<span class="origrom2">IMUL</span></div><div>LD A,H<br>OR L</div><div>We
 need to check if HL is zero, so first load register A with the MSB of 
the integer value in register H and then combine the LSB of the integer 
value in register L with the MSB of the integer value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0BF4-0BF6</div><div><a href="#0A9AH" class="memory-link">JP Z,0A9AH</a></div><div>JUMP if the integer value in register pair HL is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0BF7</div><div>PUSH HL</div><div>Save the integer value in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0BF8</div><div>PUSH DE</div><div>Save the integer value in register pair DE on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0BF9-0BFB</div><div><a href="#0C45H" class="memory-link">CALL 0C45H</a></div><div>Go convert any negative integer values to positive and return with register B set according to the value of the sign bits.</div></div>
									<div class="assembly-row-combined model1"><div>0BFC</div><div>PUSH BC</div><div>Save the value of the sign bit test in register B on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0BFD</div><div>LD B,H</div><div>Load register B with the MSB of the integer value in register H.</div></div>
									<div class="assembly-row-combined model1"><div>0BFE</div><div>LD C,L</div><div>Load register C with the LSB of the integer value in register L.</div></div>
									<div class="assembly-row-combined model1"><div>0BFF-0C01</div><div>LD HL,0000H</div><div>The product is going to go into HL so load register pair HL with zero.</div></div>
									<div class="assembly-row-combined model1"><div>0C02-0C03</div><div>LD A,10H</div><div>Load register A with the counter value (which is 16).</div></div>
									<div class="assembly-row-combined model1"><div>0C04</div><div>ADD HL,HL</div><div>Multiply the result in register pair HL by two.</div></div>
									<div class="assembly-row-combined model1"><div>0C05-0C06</div><div><a href="#0C26H" class="memory-link">JR C,0C26H</a></div><div>JUMP to 0C26H if the result in register pair HL has overflowed.</div></div>
									<div class="assembly-row-combined model1"><div>0C07</div><div>EX DE,HL</div><div>We
 need to multiply the result in register pair DE by two, but there's no 
command for that, so we need to have HL do it.  First, exchange the 
integer value in register pair DE with the integer result in register 
pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0C08</div><div>ADD HL,HL</div><div>... then multiply the integer value in register pair HL by two.</div></div>
									<div class="assembly-row-combined model1"><div>0C09</div><div>EX DE,HL</div><div>... then exchange the integer result in register pair DE with the integer value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0C0A-0C0B</div><div><a href="#0C10H" class="memory-link">JR NC,0C10H</a></div><div>JUMP to 0C10H if the most significant bit of the integer register pair DE wasn't set.</div></div>
									<div class="assembly-row-combined model1"><div>0C0C</div><div>ADD HL,BC</div><div>Add the integer value in register pair BC to the integer result in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0C0D-0C0F</div><div><a href="#0C26H" class="memory-link">JP C,0C26H</a></div><div>JUMP to 0C26H if the result in register pair HL has overflowed.</div></div>
									<div class="assembly-row-combined model1"><div>0C10</div><div>DEC A</div><div>Decrement the value of the counter in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0C11-0C12</div><div><a href="#0C04H" class="memory-link">JR NZ,0C04H</a></div><div>Loop until the multiplication has been completed.</div></div>
									<div class="assembly-row-combined model1"><div>0C13</div><div>POP BC</div><div>Get the value of the sign test from the STACK and put it in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0C14</div><div>POP DE</div><div>Get the integer value from the STACK and put it in register pair DE.</div></div>
									<p class="debug-note">This is an entry point from IDIV and is to test to see if the rsult is greater than 32767.</p>
									<div class="assembly-row-combined model1"><div>0C15</div><div>LD A,H</div><div>Load register A with the MSB of the result in register H.</div></div>
									<div class="assembly-row-combined model1"><div>0C16</div><div>OR A</div><div>Check to see if the sign bit in the MSB of the integer result in register A is set.</div></div>
									<div class="assembly-row-combined model1"><div>0C17-0C19</div><div><a href="#0C1FH" class="memory-link">JP M,0C1FH</a></div><div>JUMP to 0C1FH if the integer result in register pair HL is negative.  This jump is to check for a special case of -32768.</div></div>
									<div class="assembly-row-combined model1"><div>0C1A</div><div>POP DE</div><div>Get the integer value from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0C1B</div><div>LD A,B</div><div>Load register A with the value of the sign test in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0C1C-0C1E</div><div><a href="#0C4DH" class="memory-link">JP 0C4DH</a></div><div>JUMP to 0C4DH to negate the result, if necessary.</div></div>
								</div>
							</div>

							<br><h2 id="0ClFH">0ClF-0C34 - LEVEL II BASIC MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0C1F-0C20</div><div>XOR 80H</div><div>Clear
 the sign bit for the MSB of the integer value in register A which is 
1000 0000.  This is a way to check to specifically check for 32768.</div></div>
									<div class="assembly-row-combined model1"><div>0C21</div><div>OR L</div><div>Combine the value of the LSB for the integer value in register L with the adjusted MSB of the integer value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0C22-0C23</div><div><a href="#0C37H" class="memory-link">JR Z,0C37H</a></div><div>JUMP to 0C37H if the result is equal to zero (meaning it was 32768).</div></div>
									<div class="assembly-row-combined model1"><div>0C24</div><div>EX DE,HL</div><div>At
 this point, it was greater than 32768, so its an overflow situation.  
Load register pair HL with the integer value in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0C25-0C28</div><div>LD BC,E1C1H</div><div>Z-80 Trick - See the note at 0134H for an explanation.</div></div>
									<div class="assembly-row-combined model1"><div>0C26</div><div>POP BC</div><div>Get the value of the sign test from the STACK and put it in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0C27</div><div>POP HL</div><div>Get the integer value from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0C28-0C2A</div><div><a href="#0ACFH" class="memory-link">CALL 0ACFH</a></div><div>GOSUB to 0ACFH to convert the integer value in register pair HL to single precision and return with the result in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0C2B</div><div>POP HL</div><div>Get the integer value from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0C2C-0C2E</div><div><a href="#09A4H" class="memory-link">CALL 09A4H</a></div><div>GOSUB to 09A4H to move the SINGLE PRECISION value in REG 1 to the STACK (stored in LSB/MSB/Exponent order).</div></div>
									<div class="assembly-row-combined model1"><div>0C2F-0C31</div><div><a href="#0ACFH" class="memory-link">CALL 0ACFH</a></div><div>GOSUB to 0ACFH to convert the integer value in register pair HL to single precision and return with the result in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0C32</div><div>POP BC</div><div>Get the exponent and the MSB of the single precision value from the STACK and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>0C33</div><div>POP DE</div><div>Get the NMSB and the LSB of the single precision value from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0C34-0C36</div><div><a href="#0847H" class="memory-link">JP 0847H</a></div><div>JUMP
 to the SINGLE PRECISION MULTIPLY routine at 0847H (which multiplies the
 current value in REG 1 by the value in (BC/DE). The product is left in 
REG 1.</div></div>
								</div>
							</div>

							<br><h2 id="0C37H">0C37-0C44 - LEVEL II BASIC MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0C37</div><div>LD A,B</div><div>Load register A with the result of the sign test in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0C38</div><div>OR A</div><div>Check to see if the result is supposed to be negative.</div></div>
									<div class="assembly-row-combined model1"><div>0C39</div><div>POP BC</div><div>Get the value from the STACK and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>0C3A-0CJC</div><div><a href="#0A9AH" class="memory-link">JP M,0A9AH</a></div><div>JUMP if the result is supposed to be negative.</div></div>
									<div class="assembly-row-combined model1"><div>0C3D</div><div>PUSH DE</div><div>Save the integer value in register pair DE on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0C3E-0C40</div><div><a href="#0ACFH" class="memory-link">CALL 0ACFH</a></div><div>Go convert the integer result in register pair HL to single precision and return with the result in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0C41</div><div>POP DE</div><div>Get the integer value from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0C42-0C44</div><div><a href="#0982H" class="memory-link">JP 0982H</a></div><div>JUMP to 0982H.</div></div>
								</div>
							</div>

							<br><h2 id="0C45H">0C45-0C5A - LEVEL II BASIC MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0C45</div><div>LD A,H</div><div>Load register A with the MSB of the integer value in register H.</div></div>
									<div class="assembly-row-combined model1"><div>0c46</div><div>XOR D</div><div>Combine the MSB of the integer value in register D with the MSB of the integer value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0C47</div><div>LD B,A</div><div>Save the result of the combined signs in register A into register B.</div></div>
									<div class="assembly-row-combined model1"><div>0C48-0C4A</div><div><a href="#0C4CH" class="memory-link">CALL 0C4CH</a></div><div>GOSUB to 0C4CH to convert a negative integer value in register pair HL to positive.</div></div>
									<div class="assembly-row-combined model1"><div>0C4B</div><div>EX DE,HL</div><div>Exchange the integer value in register pair DE with the integer value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0C4C</div><div>LD A,H</div><div>Load register A with the MSB of the integer value in register H.</div></div>
									<div class="assembly-row-combined model1"><div>0C4D</div><div>OR A</div><div>Check the value of the sign for the MSB of the integer value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0C4E-0C50</div><div><a href="#0A9AH" class="memory-link">JP P,0A9AH</a></div><div>JUMP if the integer value in register pair HL is positive.</div></div>
									<div class="assembly-row-combined model1"><div>0C51</div><div>XOR A</div><div>Zero register A.<br>Negate
 HL routine. This routine changes the sign of the HL register pair and 
stores it in the ACC. (HL=REG 1=-HL) The result is returned in both the 
HL register pair and the ACC.</div></div>
									<div class="assembly-row-combined model1"><div>0C52</div><div>LD C,A</div><div>Load register C with the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0C53</div><div>SUB L</div><div>Subtract the LSB of the integer value in register L from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0C54</div><div>LD L,A</div><div>Save the adjusted value in register A in register L.</div></div>
									<div class="assembly-row-combined model1"><div>0C55</div><div>LD A,C</div><div>Load register A with the value in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0C56</div><div>SBC A,H</div><div>Subtract the MSB of the integer value in register H from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0C57</div><div>LD H,A</div><div>Save the adjusted value in register A into register H.</div></div>
									<div class="assembly-row-combined model1"><div>0C58-0C5A</div><div><a href="#0A9AH" class="memory-link">JP 0A9AH</a></div><div>JUMP to 0A9AH.</div></div>
								</div>
							</div>

							<br><h2 id="0C5BH">0C5B-0C6F - LEVEL II BASIC MATH ROUTINE - Integer Negation.  Alters A,B,C,D,E,H,L.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0C5B-0C5D</div><div>LD HL,(4121H)</div><div>Load register pair HL with the integer value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0C5E-0C60</div><div><a href="#0C51H" class="memory-link">CALL 0C51H</a></div><div>GOSUB to 0C51H to convert the integer value in register pair HL to positive if it's negative.</div></div>
									<div class="assembly-row-combined model1"><div>0C61</div><div>LD A,H</div><div>Load register A with the MSB of the integer value in register H.</div></div>
									<div class="assembly-row-combined model1"><div>0C62-0C63</div><div>XOR 80H</div><div>XOR A with 80H (Binary: 1000 0000).  This will invert the value of the sign bit in register A.  It checks for 32768.</div></div>
									<div class="assembly-row-combined model1"><div>0C64</div><div>OR L</div><div>Combine the LSB of the integer value in register L with the adjusted MSB of the integer value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0C65</div><div>RET NZ</div><div>Return if the integer value in REG 1 isn't equal to -32768.</div></div>
									<div class="assembly-row-combined model1"><div>0C66</div><div>EX DE,HL</div><div>Load register pair DE with the integer value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0C67-0C69</div><div><a href="#0AEFH" class="memory-link">CALL 0AEFH</a></div><div>Go set the number type flag to single precision.</div></div>
									<div class="assembly-row-combined model1"><div>0C6A</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>0C6B-0C6C</div><div>LD B,98H</div><div>Load register B with an exponent.</div></div>
									<div class="assembly-row-combined model1"><div>0C6D-0C6F</div><div><a href="#0969H" class="memory-link">JP 0969H</a></div><div>JUMP to 0969H.</div></div>

								</div>
							</div>

							<br><h2 id="0C70H">0C70-0C76 - DOUBLE PRECISION SUBTRACTION<br>"subDP"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Double-precision subtraction (REG 1=ACC-AACC).<br>Subtracts the double precision value in REG 2 from the value in REG 1. The difference is left in REG 1.</p>
								<p>Note: If you wanted to subtract two double precision numbers,
 store the minuend in 411DH-4124H and the subtrahend in 4127H-412EH, and
 CALL 0C70H.  The result (in double precision format) is in 411DH-4124H 
in approximately 1.3 milliseconds.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0C70-0C72<span class="origrom2">DSUB</span></div><div>LD HL,412DH</div><div>Load register pair HL with the address of the MSB in REG 2.</div></div>
									<div class="assembly-row-combined model1"><div>0C73</div><div>LD A,(HL)</div><div>Load register A with the MSB of the double precision value in REG 2 at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0C74-0C75</div><div>XOR 80H</div><div>Invert the value of the sign bit for the MSB of the double precision value in register A which is 1000 0000.</div></div>
									<div class="assembly-row-combined model1"><div>0C76</div><div>LD (HL),A</div><div>Save
 the adjusted MSB of the double precision value in register A in REG 2 
at the location of the memory pointer in register pair HL.</div></div>
								</div>
							</div>

							<br><h2 id="0C77H">0C77-0CCEH -DOUBLE PRECISION ADDITION<br>"ADDDP"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Double-precision addition (REG 1=ACC+AACC).<br>Adds the double precision value in REG 2 to the value in REG 1. Sum is left in REG 1.</p>
								<p>Note: If you wanted to add 2 double precision numbers via a 
ROM call, store one input into 411DH-4124H and the other in 4127H-412EH.
  Then call 0C77H.  The double precision result will be stored in 
411DH-4124H approximately 1.3 milliseconds later.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0C77-0C79<span class="origrom2">DADD</span></div><div>LD HL,412EH</div><div>Load register pair HL with the address of the exponent in REG 2.</div></div>
									<div class="assembly-row-combined model1"><div>0C7A</div><div>LD A,(HL)</div><div>Load
 register A with the exponent of the double precision value in REG 2 at 
the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0C7B</div><div>OR A</div><div>Check to see if the double precision value in REG 2 is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0C7C</div><div>RET Z</div><div>Return if the double precision value in REG 2 is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0C7D</div><div>LD B,A</div><div>Load register B with the value of the exponent for the double precision value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0C7E</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0C7F</div><div>LD C,(HL)</div><div>Load
 register C with the value of the MSB of the double precision value in 
REG 2 at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0C80-0C82</div><div>LD DE,4124H</div><div>Load register pair DE with the address of the exponent in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0C83</div><div>LD A,(DE)</div><div>Load
 register A with the value of the exponent of the double precision value
 in REG 1 at the location of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0C84</div><div>OR A</div><div>Check to see if the double precision value in REG 1 is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0C85-0C87</div><div><a href="#09F4H" class="memory-link">JP Z,09F4H</a></div><div>JUMP if the double precision value in REG 1 is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0C88</div><div>SUB B</div><div>Subtract
 the value of the exponent for the double precision value in REG 2 in 
register B from the value of the exponent for the double precision value
 in REG 1 in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0C89-0C8A</div><div><a href="#0CA1H" class="memory-link">JR NC,0CA1H</a></div><div>JUMP if the double precision value in REG 1 is greater than or equal to the double precision value in REG 2.</div></div>
									<div class="assembly-row-combined model1"><div>0C8B</div><div>CPL</div><div>Complement the difference between the two exponents in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0C8C</div><div>INC A</div><div>Increment the value of the difference for the exponents in register A so that register A will hold the positive difference.</div></div>
									<div class="assembly-row-combined model1"><div>0C8D</div><div>PUSH AF</div><div>Save the difference for the exponents in register A on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0C8E-0C8F</div><div>LD C,08H</div><div>Load register C with the counter value which is 8.</div></div>
									<div class="assembly-row-combined model1"><div>0C90</div><div>INC HL</div><div>Increment
 the value of the memory pointer in register pair HL so that it will be 
pointing to the exponent of the double precision value in REG 2.</div></div>
									<div class="assembly-row-combined model1"><div>0C91</div><div>PUSH HL</div><div>Save the value of the memory pointer in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0C92</div><div>LD A,(DE)</div><div>Load register A with the value at the location of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0C93</div><div>LD B,(HL)</div><div>Load register B with the value at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0C94</div><div>LD (HL),A</div><div>Save the value in register A at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0C95</div><div>LD A,B</div><div>Load register A with the value in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0C96</div><div>LD (DE),A</div><div>Save the value in register A at the location of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0C97</div><div>DEC DE</div><div>Decrement the value of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0C98</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0C99</div><div>DEC C</div><div>Decrement the value of the counter in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0C9A-0C9B</div><div><a href="#0C92H" class="memory-link">JR NZ,0C92H</a></div><div>Loop until the double precision values in REG 1 and REG 2 have been exchanged.</div></div>
									<div class="assembly-row-combined model1"><div>0C9C</div><div>POP HL</div><div>Get the value of the memory pointer from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0C9D</div><div>LD B,(HL)</div><div>Load
 register B with the value of the exponent for the double precision 
value in REG 2 at the location of the memory pointer in register pair 
HL.</div></div>
									<div class="assembly-row-combined model1"><div>0C9E</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0C9F</div><div>LD C,(HL)</div><div>Load
 register C with the value of the MSB for the double precision value in 
REG 2 at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0CA0</div><div>POP AF</div><div>Get the difference for the exponents from the STACK and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0CA1-0CA2</div><div>CP 39H</div><div>Check
 to see if the difference between the two exponents is greater than 56 
bits.  To do this we test A against 39H (A - 39H).  If A&lt;39H then the
 CARRY FLAG will be set and if A&gt;=39H then the NO CARRY FLAG will be 
set.</div></div>
									<div class="assembly-row-combined model1"><div>0CA3</div><div>RET NC</div><div>Return if the difference between the two exponents is greater than 56 bits.</div></div>
									<div class="assembly-row-combined model1"><div>0CA4</div><div>PUSH AF</div><div>Save the difference for the exponents in register A on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0CA5-0CA7</div><div><a href="#09DFH" class="memory-link">CALL 09DFH</a></div><div>Go turn on the sign bits for the double precision numbers.</div></div>
									<div class="assembly-row-combined model1"><div>0CA8</div><div>INC HL</div><div>Increment the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0CA9-0CAA</div><div>LD (HL),00H</div><div>Zero the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0CAB</div><div>LD B,A</div><div>Save the result of the sign test in register A in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0CAC</div><div>POP AF</div><div>Get the difference for the exponents from the STACK and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0CAD-0CAF</div><div>LD HL,412DH</div><div>Load register pair HL with the address of the MSB in REG 2.</div></div>
									<div class="assembly-row-combined model1"><div>0CB0-0CB2</div><div><a href="#0D69H" class="memory-link">CALL 0D69H</a></div><div>Go shift the double precision value in REG 2 until it lines up with the double precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0CB3-0CB5</div><div>LD A,(4126H)</div><div>Get the bits shifted out of the double precision value in REG2 and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0CB6-0CB8</div><div>LD (411CH),A</div><div>Save the value in register A.<br><b>NOTE:</b> 411CH is used by floating point routines.</div></div>
									<div class="assembly-row-combined model1"><div>0CB9</div><div>LD A,B</div><div>Load register A with the value of the sign test in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0CBA</div><div>OR A</div><div>Check to see if the signs are equal.</div></div>
									<div class="assembly-row-combined model1"><div>0CBB-0CBD</div><div><a href="#0CCFH" class="memory-link">JP P,0CCFH</a></div><div>Go subtract the values if the signs aren't equal.</div></div>
									<div class="assembly-row-combined model1"><div>0CBE-0CC0</div><div><a href="#0D33H" class="memory-link">CALL 0D33H</a></div><div>Go add the values.</div></div>
									<div class="assembly-row-combined model1"><div>0CC1-0CC3</div><div><a href="#0D0EH" class="memory-link">JP NC,0D0EH</a></div><div>JUMP if the CARRY FLAG isn't set.</div></div>
									<div class="assembly-row-combined model1"><div>0CC4</div><div>EX DE,HL</div><div>Load register pair HL with the value of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0CC5</div><div>INC (HL)</div><div>Increment the value of the exponent at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0CC6-0CC8</div><div><a href="#07B2H" class="memory-link">JP Z,07B2H</a></div><div>Display an <span class="code">?OV ERROR</span> if the exponent for the double precision result in REG 1 is too large.</div></div>
									<div class="assembly-row-combined model1"><div>0CC9-0CCB</div><div><a href="#0D90H" class="memory-link">CALL 0D90H</a></div><div>GOSUB to 0D90H to adjust the double precision result in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0CCC-0CCE</div><div><a href="#0D0EH" class="memory-link">JP 0D0EH</a></div><div>JUMP to 0D0EH.</div></div>
								</div>
							</div>

							<br><h2 id="0CCFH">0CCF-0DlF - DOUBLE PRECISION MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0CCF-0CD1</div><div><a href="#0D45H" class="memory-link">CALL 0D45H</a></div><div>Go subtract the double precision values.</div></div>
									<div class="assembly-row-combined model1"><div>0CD2-0CD4</div><div>LD HL,4125H</div><div>Load register pair HL with the address of the sign for the result.<br><b>NOTE:</b> 4125H-4126H is used by floating point routines.</div></div>
									<div class="assembly-row-combined model1"><div>0CD5-0CD7</div><div><a href="#0D57H" class="memory-link">CALL C,0D57H</a></div><div>Go complement the result in REG 1 if the CARRY FLAG is set.</div></div>
									<div class="assembly-row-combined model1"><div>0CD8</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>0CD9</div><div>LD B,A</div><div>Load register B with the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0CDA-0CDC</div><div>LD A,(4123H)</div><div>Load register A with the value of the MSB of the double precision result in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0CDD</div><div>OR A</div><div>Check to see if the MSB of the double precision result is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0CDE-0CDF</div><div><a href="#0CFEH" class="memory-link">JR NZ,0CFEH</a></div><div>JUMP forward to 0CFEH if the MSB of the double precision value is nonzero.</div></div>
									<div class="assembly-row-combined model1"><div>0CE0-0CE2</div><div>LD HL,411CH</div><div>Load register pair HL with the starting address of REG 1 minus one.<br><b>NOTE:</b> 411CH is used by floating point routines.</div></div>
									<div class="assembly-row-combined model1"><div>0CE3-0CE4</div><div>LD C,08H</div><div>Load register C with the number of bytes to be shifted.</div></div>
									<div class="assembly-row-combined model1"><div>0CE5</div><div>LD D,(HL)</div><div>Load register D with the value at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0CE6</div><div>LD (HL),A</div><div>Save the value in register A at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0CE7</div><div>LD A,D</div><div>Load register A with the value in register D.</div></div>
									<div class="assembly-row-combined model1"><div>0CE8</div><div>INC HL</div><div>Increment the value of the memory pointer in registerpair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0CE9</div><div>DEC C</div><div>Decrement the number of bytes to be shifted in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0CEA-0CEB</div><div><a href="#0CE5H" class="memory-link">JR NZ,0CE5H</a></div><div>Loop until all of the bytes in the double precision value have been shifted.</div></div>
									<div class="assembly-row-combined model1"><div>0CEC</div><div>LD A,B</div><div>Load register A with the number of bits shifted in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0CED-0CEE</div><div>SUB 08H</div><div>Subtract the number of bits just shifted from the shift counter in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0CEF-0CF0</div><div>CP C0H</div><div>Check to see if the whole of the double precision value has been shifted.</div></div>
									<div class="assembly-row-combined model1"><div>0CF1-0CF2</div><div><a href="#0CD9H" class="memory-link">JR NZ,0CD9H</a></div><div>JUMP to 0CD9H if the whole of the double precision value hasn't been shifted.</div></div>
									<div class="assembly-row-combined model1"><div>0CF3-0CF5</div><div><a href="#0778H" class="memory-link">JP 0778H</a></div><div>JUMP to 0778H to make the double precision value equal to zero if the whole of the double precision value has been shifted.</div></div>
									<div class="assembly-row-combined model1" id="0CF6H"><div>0CF6</div><div>DEC B</div><div>Decrement the shift counter in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0CF7-0CF9</div><div>LD HL,411CH</div><div>Load register pair HL with the starting address of REG 1 minus one.<br><b>NOTE:</b> 411CH is used by floating point routines.</div></div>
									<div class="assembly-row-combined model1"><div>0CFA-0CFC</div><div><a href="#0D97H" class="memory-link">CALL 0D97H</a></div><div>GOSUB to shift the double precision value in REG 1 once.</div></div>
									<div class="assembly-row-combined model1"><div>0CFD</div><div>OR A</div><div>Check to see if the sign bit of the MSB of the double precision value in register A is set.</div></div>
									<div class="assembly-row-combined model1"><div>0CFE-0D00</div><div><a href="#0CF6H" class="memory-link">JP P,0CF6H</a></div><div>Loop until the sign bit is set.</div></div>
									<div class="assembly-row-combined model1"><div>0D01</div><div>LD A,B</div><div>Load register A with the value of the shift counter in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0D02</div><div>OR A</div><div>Check to see if the shift counter in register A is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0D03-0D04</div><div><a href="#0D0EH" class="memory-link">JR Z,0D0EH</a></div><div>JUMP if the value in REG 1 wasn't shifted at all.</div></div>
									<div class="assembly-row-combined model1"><div>0D05-0D07</div><div>LD HL,4124H</div><div>Load register pair HL with the address of the exponent in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0D08</div><div>ADD A,(HL)</div><div>Add
 the value of the exponent for the double preci?sion value in REG 1 at 
the location of the memory pointer in register pair HL to the value of 
the shift counter in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0D09</div><div>LD (HL),A</div><div>Save
 the adjusted exponent for the double precision value in register A at 
the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D0A-0D0C</div><div><a href="#0778H" class="memory-link">JP NC,0778H</a></div><div>JUMP if overflow didn't occur.</div></div>
									<div class="assembly-row-combined model1"><div>0D0D</div><div>RET Z</div><div>Return if the double precision value is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0D0E-0D10</div><div>LD A,(411CH)</div><div>Load register A with the value of the rounding byte at the location of the starting address of REG 1 minus one.<br><b>NOTE:</b> 411CH is used by floating point routines.</div></div>
									<div class="assembly-row-combined model1"><div>0D11</div><div>OR A</div><div>Check to see if there is a bit to be shifted into the double precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0D12-0D14</div><div><a href="#0D20H" class="memory-link">CALL M,0D20H</a></div><div>Go move the bit into the double precision value if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>0D15-0D17</div><div>LD HL,4125H</div><div>Load register pair HL with the address of the sign for the result.<br><b>NOTE:</b> 4125H-4126H is used by floating point routines.</div></div>
									<div class="assembly-row-combined model1"><div>0D18</div><div>LD A,(HL)</div><div>Load register A with the value of the sign for the result at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D19-0D1A</div><div>AND 80H</div><div>Mask A against 80H (1000 0000), to turn off all bits other than Bit 7 (the sign).</div></div>
									<div class="assembly-row-combined model1"><div>0D1B</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL so that it points to the exponent in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0D1C</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL so that it points to the MSB in REG 1</div></div>
									<div class="assembly-row-combined model1"><div>0D1D</div><div>XOR (HL)</div><div>Combine
 the value of the MSB of the double preci?sion value in REG 1 at the 
location of the memory pointer in register pair HL with the value of the
 sign for the result in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0D1E</div><div>LD (HL),A</div><div>Save the adjusted MSB of the double precision value in register A at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D1F</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0D20H">0D20-0D32 - DOUBLE PRECISION MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0D20-0D22</div><div>LD HL,411DH</div><div>Load register pair HL with the starting address in REG 1.<br><b>NOTE:</b> 411DH-4124H holds REG l.</div></div>
									<div class="assembly-row-combined model1"><div>0D23-0D24</div><div>LD B,07H</div><div>Load register B with the number of bytes to be bumped for the double precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0D25</div><div>INC (HL)</div><div>Increment the value at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D26</div><div>RET NZ</div><div>Return if the value at the location of the memory pointer in register pair HL isn't equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0D27</div><div>INC HL</div><div>Increment the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D28</div><div>DEC B</div><div>Decrement the value of the byte counter in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0D29-0D2A</div><div><a href="#0D25H" class="memory-link">JR NZ,0D25H</a></div><div>Loop until all of the necessary bytes have been bumped.</div></div>
									<div class="assembly-row-combined model1"><div>0D2B</div><div>INC (HL)</div><div>Increment the value of the exponent at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D2C-0D2E</div><div><a href="#07B2H" class="memory-link">JP Z,07B2H</a></div><div>Go
 to the Level II BASIC error routine and display an OV ERROR message if 
the exponent for the double precision value in REG 1 is too large.</div></div>
									<div class="assembly-row-combined model1"><div>0D2F</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D30-0D31</div><div>LD (HL),80H</div><div>Save a new MSB at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D32</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0D33H">0D33-0D44 - DOUBLE PRECISION MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0D33-0D35</div><div>LD HL,4127H</div><div>Load register pair HL with the starting address of REG 2.<br><b>NOTE:</b> 4127H-412EH holds REG 2 with 412EH being the exponent.</div></div>
									<div class="assembly-row-combined model1"><div>0D36-0D38</div><div>LD DE,411DH</div><div>Load register pair DE with the starting address of REG 1.<br><b>NOTE:</b> 411DH-4124H holds REG l.</div></div>
									<div class="assembly-row-combined model1"><div>0D39-0D3A</div><div>LD C,07H</div><div>Load register C with the number of bytes to be added.</div></div>
									<div class="assembly-row-combined model1"><div>0D3B</div><div>XOR A</div><div>Clear the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>0D3C</div><div>LD A,(DE)</div><div>Load register A with the value in REG 1 at the location of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0D3D</div><div>ADC A,(HL)</div><div>Add the value in REG 2 at the location of the memory value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0D3E</div><div>LD (DE),A</div><div>Save the result in register A in REGI at the location of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0D3F</div><div>INC DE</div><div>Increment the value of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0D40</div><div>INC HL</div><div>Increment the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D41</div><div>DEC C</div><div>Decrement the number of bytes to be added in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0D42-0D43</div><div><a href="#0D3CH" class="memory-link">JR NZ,0D3CH</a></div><div>Loop until all of the bytes for the double precision values have been added.</div></div>
									<div class="assembly-row-combined model1"><div>0D44</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0D45H">0D45-0D56 - DOUBLE PRECISION MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0D45-0D47</div><div>LD HL,4127H</div><div>Load register pair HL with the starting address of REG 2.<br><b>NOTE:</b> 4127H-412EH holds REG 2 with 412EH being the exponent.</div></div>
									<div class="assembly-row-combined model1"><div>0D48-0D4A</div><div>LD DE,411DH</div><div>Load register pair DE with the starting address of REG 1.<br><b>NOTE:</b> 411DH-4124H holds REG l.</div></div>
									<div class="assembly-row-combined model1"><div>0D4B-0D4C</div><div>LD C,07H</div><div>Load register C with the number of bytes to be subtracted.</div></div>
									<div class="assembly-row-combined model1"><div>0D4D</div><div>XOR A</div><div>Clear the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">+-</span>0D4E</div><div>LD A,(DE)</div><div>Load register A with the value in REG 1 at the location of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">|</span> 0D4F</div><div>SBC A,(HL)</div><div>Subtract the value in REG 2 at the location of the memory pointer in register pair HL from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">|</span> 0D50</div><div>LD (DE),A</div><div>Save the result in register A in REG 1 at the location of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">|</span> 0D51</div><div>INC DE</div><div>Increment the value of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">|</span> 0D52</div><div>INC HL</div><div>Increment the value of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">|</span> 0D53</div><div>DEC C</div><div>Decrement the number of bytes to be subtracted for the double precision values in register C.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">+-</span>0D54-0D55</div><div><a href="#0D4EH" class="memory-link">JR NZ,0D4EH</a></div><div>Loop until all of the bytes for the double precision values have been subtracted.</div></div>
									<div class="assembly-row-combined model1"><div>0D56</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0D57H">0D57-0D68 - DOUBLE PRECISION MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0D57</div><div>LD A,(HL)</div><div>Load register A with the value of the sign at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D58</div><div>CPL</div><div>Complement the value of the sign in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0D59</div><div>LD (HL),A</div><div>Save the value of the sign in register A at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D5A-0D5C</div><div>LD HL,411CH</div><div>Load register pair HL with the starting address of REG 1 minus one.<br><b>NOTE:</b> 411CH is used by floating point routines.</div></div>
									<div class="assembly-row-combined model1"><div>0D5D-0D5E</div><div>LD B,08H</div><div>Load register B with the number of bytes to be reversed.</div></div>
									<div class="assembly-row-combined model1"><div>0D5F</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>0D60</div><div>LD C,A</div><div>Load register C with the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">+-</span>0D61</div><div>LD A,C</div><div>Load register A with the value in REG 1 at the location of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">|</span> 0D62</div><div>SBC A,(HL)</div><div>Subtract the value in REG 2 at the location of the memory pointer in register pair HL from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">|</span> 0D63</div><div>LD (HL),A</div><div>Save the result in register A in REG 1 at the location of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">|</span> 0D64</div><div>INC HL</div><div>Increment the value of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">|</span> 0D65</div><div>DEC B</div><div>Decrement the number of bytes to be subtracted for the double precision values in register C.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">+-</span>0D66-0D67</div><div><a href="#0D61H" class="memory-link">JR NZ,0D61H</a></div><div>Loop until all of the bytes for the double precision values have been subtracted.</div></div>
									<div class="assembly-row-combined model1"><div>0D68</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0D69H">0D69-0D8F - DOUBLE PRECISION MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0D69</div><div>LD (HL),C</div><div>Save the MSB of the double precision value in register C at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D6A</div><div>PUSH HL</div><div>Save the value of the memory pointer in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0D6B-0D6C</div><div>SUB 08H</div><div>Subtract 8 from the number of bits to be shifted from the number of bits to be shifted in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0D6D-0D6E</div><div><a href="#0D7DH" class="memory-link">JR C,0D7DH</a></div><div>JUMP if there are less than 8 bits to be shifted.</div></div>
									<div class="assembly-row-combined model1"><div>0D6F</div><div>POP HL</div><div>Get the value of the memory pointer from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D70</div><div>PUSH HL</div><div>Save the value of the memory pointer in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0D71-0D73</div><div>LD DE,0800H</div><div>Load
 register pair DE with the number of bytes to be shifted (which is 2048)
 and the value to be shifted into the double precision value.</div></div>
									<div class="assembly-row-combined model1"><div>0D74</div><div>LD C,(HL)</div><div>Load register C with the value at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D75</div><div>LD (HL),E</div><div>Save the value in register E at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D76</div><div>LD E,C</div><div>Load register E with the value in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0D77</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D78</div><div>DEC D</div><div>Decrement the number of bytes shifted in register D.</div></div>
									<div class="assembly-row-combined model1"><div>0D79-0D7A</div><div><a href="#0D74H" class="memory-link">JR NZ,0D74H</a></div><div>Loop until all of the bytes have been shifted.</div></div>
									<div class="assembly-row-combined model1"><div>0D7B-0D7C</div><div><a href="#0D6BH" class="memory-link">JR 0D6BH</a></div><div>Loop until there are less than 8 bits to be shifted.</div></div>
									<div class="assembly-row-combined model1"><div>0D7D-0D7E</div><div>ADD 09H</div><div>Adjust the number of bits to be shifted in register A so that it holds the correct value (adjustment against 0000 1001).</div></div>
									<div class="assembly-row-combined model1"><div>0D7F</div><div>LD D,A</div><div>Load register D with the number of bits to be shifted in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0D80</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>0D81</div><div>POP HL</div><div>Get the value of the memory pointer from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D82</div><div>DEC D</div><div>Decrement the number of bits to be shifted in register D.</div></div>
									<div class="assembly-row-combined model1"><div>0D83</div><div>RET Z</div><div>Return if all of the bits have been shifted.</div></div>
									<div class="assembly-row-combined model1" id="0D84H"><div>0D84</div><div>PUSH HL</div><div>Save the value of the memory pointer in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0D85-0D86</div><div>LD E,08H</div><div>Load register E with the number of bytes to be shifted.</div></div>
									<div class="assembly-row-combined model1"><div>0D87</div><div>LD A,(HL)</div><div>Load register A with the value at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D88</div><div>RRA</div><div>Rotate the bits in register A right, copying Bit 0 to the CARRY FLAG, and the CARRY FLAG to bit 7.</div></div>
									<div class="assembly-row-combined model1"><div>0D89</div><div>LD (HL),A</div><div>Save the adjusted value in register A at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D8A</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0D8B</div><div>DEC E</div><div>Decrement the number of bytes to be shifted in register E.</div></div>
									<div class="assembly-row-combined model1"><div>0D8C-0D8D</div><div><a href="#0D87H" class="memory-link">JR NZ,0D87H</a></div><div>Loop until all of the bytes have been shifted.</div></div>
									<div class="assembly-row-combined model1"><div>0D8E-0D8F</div><div><a href="#0D80H" class="memory-link">JR 0D80H</a></div><div>Loop until all of the bits have been shifted.</div></div>
								</div>
							</div>

							<br><h2 id="0D90H">0D90-0D96 - DOUBLE PRECISION MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0D90-0D92</div><div>LD HL,4123H</div><div>Load register pair HL with the address of the MSB of the double precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0D93-0D94</div><div>LD D,01H</div><div>Load register D with the number of bits to be shifted.</div></div>
									<div class="assembly-row-combined model1"><div>0D95-0D96</div><div><a href="#0D84H" class="memory-link">JR 0D84H</a></div><div>JUMP to 0D84H.</div></div>
								</div>
							</div>

							<br><h2 id="0D97H">0D97-0DA0 - DOUBLE PRECISION MATH ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0D97-0D98</div><div>LD C,08H</div><div>Load register C with the number of bytes to be shifted.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">+-</span>0D99</div><div>LD A,(HL)</div><div>Load register A with the value in REG 1 at the location of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">|</span> 0D9A</div><div>RLA</div><div>Shift the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">|</span> 0D9B</div><div>LD (HL),A</div><div>Save the result in register A in REG 1 at the location of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">|</span> 0D9C</div><div>INC HL</div><div>Increment the value of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">|</span> 0D9D</div><div>DEC C</div><div>Decrement the number of bytes to be subtracted for the double precision values in register C.</div></div>
									<div class="assembly-row-combined model1"><div><span class="red">+-</span>0D9E-0D9F</div><div><a href="#0D99H" class="memory-link">JR NZ,0D99H</a></div><div>Loop until all of the bytes for the double precision values have been subtracted.</div></div>
									<div class="assembly-row-combined model1"><div>0DA0</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0DA1H">0DA1-0DD3 - DOUBLE PRECISION MULTIPLICATION<br>"MLTDP"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Double-precision multiplication (REG 1=ACC*AACC).<br>Multiplies the double precision value in REG 1 by the value in REG 2. The product is left in REG 1.</p>
								<p>Note: If you wanted to multiply two double precision numbers 
store one operand in 411DH-4124H, and store the other in 4127H-412EH and
 then CALL 0DA1H.  The result (in double precision format) is in 
411DH-4124H in approximately 22 milliseconds.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0DA1-0DA3<span class="origrom2">DMUL</span></div><div><a href="#0955H" class="memory-link">CALL 0955H</a></div><div>Go check to see if the value in REG 1 is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0DA4</div><div>RET Z</div><div>Return if the double precision value in REG 1 is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0DA5-0DA7</div><div><a href="#090AH" class="memory-link">CALL 090AH</a></div><div>Go figure the new exponent.</div></div>
									<div class="assembly-row-combined model1"><div>0DA8-0DAA</div><div><a href="#0E39H" class="memory-link">CALL 0E39H</a></div><div>Go move the double precision value in REG 1 to a temporary work area.</div></div>
									<div class="assembly-row-combined model1"><div>0DAB</div><div>LD (HL),C</div><div>Zero the location at the current value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0DAC</div><div>INC DE</div><div>Increment register pair DE so that it points to the LSB of the double precision value in the temporary work area.</div></div>
									<div class="assembly-row-combined model1"><div>0DAD-0DAE</div><div>LD B,07H</div><div>Load register B with the number of bytes to be figured.</div></div>
									<div class="assembly-row-combined model1"><div>0DAF</div><div>LD A,(DE)</div><div>Load register A with the value at the location of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0DB0</div><div>INC DE</div><div>Increment the value of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0DB1</div><div>OR A</div><div>Check to see if the value in register A is equal to zero.</div></div>
								</div>
							</div>

							<br><h2 id="0DB2H">0DB2 - INTEGER ADD routine - "IADD"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Adds the integer value in DE to the integer in HL. The sum is
 left in HL and the orginal contents of DE are preserved. If overflow 
occurs (sum exceeds 2**15), both values are converted to single 
precision and then added. The result would be left in REG 1 and the mode
 flag would be updated.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0DB2</div><div>PUSH DE</div><div>Save the value of the memory pointer in register pair DE on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0DB3-0DB4</div><div><a href="#0DCCH" class="memory-link">JR Z,0DCCH</a></div><div>JUMP if the value in register A is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0DB5-0DB6</div><div>LD C,08H</div><div>Load register C with the numberofbits to be shifted.</div></div>
									<div class="assembly-row-combined model1"><div>0DB7</div><div>PUSH BC</div><div>Save the value in register pair BC on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0DB8</div><div>RRA</div><div>Shift the value in register A one place to the right.</div></div>
									<div class="assembly-row-combined model1"><div>0DB9</div><div>LD B,A</div><div>Load register B with the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0DBA-0DBC</div><div><a href="#0D33H" class="memory-link">CALL C,0D33H</a></div><div>Go add the value in REG 2 to the total in REG 1 if bit zero of register A was set.</div></div>
									<div class="assembly-row-combined model1"><div>0DBD-0DBF</div><div><a href="#0D90H" class="memory-link">CALL 0D90H</a></div><div>Go shift the value of the total in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0DC0</div><div>LD A,B</div><div>Load register A with the adjusted value in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0DC1</div><div>POP BC</div><div>Get the value from the STACK and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>0DC2</div><div>DEC C</div><div>Decrement the number of bits to be shifted in regis?ter C.</div></div>
									<div class="assembly-row-combined model1"><div>0DC3-0DC4</div><div><a href="#0DB7H" class="memory-link">JR NZ,0DB7H</a></div><div>Loop back to 0DB7H until all of the bits have been shifted.</div></div>
									<div class="assembly-row-combined model1"><div>0DC5</div><div>POP DE</div><div>Get the value from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0DC6</div><div>DEC B</div><div>Decrement the number of bytes to be figured in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0DC7-0DC8</div><div><a href="#0DAFH" class="memory-link">JR NZ,0DAFH</a></div><div>Loop back to 0DAFH until all of the bytes have been figured.</div></div>
									<div class="assembly-row-combined model1"><div>0DC9-0DCB</div><div><a href="#0CD8H" class="memory-link">JP 0CD8H</a></div><div>JUMP to 0CD8H.</div></div>
									<div class="assembly-row-combined model1"><div>0DCC-0DCE</div><div>LD HL,4123H</div><div>Load register pair HL with the address of the MSB in REG 1</div></div>
									<div class="assembly-row-combined model1"><div>0DCF-0DD1</div><div><a href="#0D70H" class="memory-link">CALL 0D70H</a></div><div>Go shift the double precision total in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0DD2-0DD3</div><div><a href="#0DC5H" class="memory-link">JR 0DC5H</a></div><div>JUMP to 0DC5H.</div></div>
								</div>
							</div>

							<br><h2 id="0DD4H">0DD4-0DDB - DOUBLE PRECISION CONSTANT STORAGE AREA<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0DD4-0DDB</div><div>00 00 00 00 00 00 20 84</div><div>A double precision constant equal to 10.0 is stored here.</div></div>
								</div>
							</div>

							<br><h2 id="0DDCH">0DDC-0DE4 - DOUBLE PRECISION MATH ROUTINE -  - Divide a double precision number by 10.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0DDC-0DDE</div><div>LD DE,0DD4H</div><div>Load register pair DE with the starting address of the double precision constant stored above.</div></div>
									<div class="assembly-row-combined model1"><div>0DDF-0DE1</div><div>LD HL,4127H</div><div>Load register pair HL with the starting address of REG 2.<br><b>NOTE:</b> 4127H-412EH holds REG 2 with 412EH being the exponent.</div></div>
									<div class="assembly-row-combined model1"><div>0DE2-0DE4</div><div><a href="#09D3H" class="memory-link">CALL 09D3H</a></div><div>Go move the double precision constant into REG 2.</div></div>
								</div>
							</div>

							<br><h2 id="0de5-0e38-double">0DE5-0E38 - DOUBLE PRECISION DIVISION<br>"DIVDP"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Double-precision division (REG 1=ACC / AACC).<br>Divides the double precision value in WRAl by the value in REG 2. The quotient is left in REG 1.</p>
								<p>To use a ROM call to divide two double precision numbers, 
store the dividend in 411DH-4124H, and the divisor in 4127H-412EH and 
then  CALL 0DE5H.  The result (in double precision format) is in 
411DH-4124H and then pproximately 42 milliseconds.  Overflow or /0 will 
error out and return to Level II.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0DE5-0DE7<span class="origrom2">DDIV</span></div><div>LD A,(412EH)</div><div>Load register A with the value of the exponent for the double precision value in REG 2.</div></div>
									<div class="assembly-row-combined model1"><div>0DE8</div><div>OR A</div><div>Check to see if the double precision value in REG 2 is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0DE9-0DEB</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#199AH" class="memory-link">JP Z,199AH</a></div><div>Display a /0 ERROR message if the double precision value in REG 2 is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0DEC-0DEE</div><div><a href="#0907H" class="memory-link">CALL 0907H</a></div><div>Go figure the value of the new exponent.</div></div>
									<div class="assembly-row-combined model1"><div>0DEF</div><div>INC (HL)</div><div>Increment the value of the exponent in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0DF0</div><div>INC (HL)</div><div>Increment the value of the exponent in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0DF1-0DF3</div><div><a href="#0E39H" class="memory-link">CALL 0E39H</a></div><div>Go move the double precision value from REG 1 into the temporary work area.</div></div>
									<div class="assembly-row-combined model1"><div>0DF4-0DF6</div><div>LD HL,4151H</div><div>Load register pair HL with the address of the exponent in the temporary work area.</div></div>
									<div class="assembly-row-combined model1"><div>0DF7</div><div>LD (HL),C</div><div>Zero the value of the exponent in the temporary work area at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0DF8</div><div>LD B,C</div><div>Zero register B.</div></div>
									<div class="assembly-row-combined model1"><div>0DF9-0DFB</div><div>LD DE,414AH</div><div>Load register pair DE with the starting address of the double precision value in the temporary work area.<br><b>NOTE:</b> 414AH-4151H is used by floating pointer routines.</div></div>
									<div class="assembly-row-combined model1"><div>0DFC-0DFE</div><div>LD HL,4127H</div><div>Load register pair HL with the starting address of the double precision value in REG 2.<br><b>NOTE:</b> 4127H-412EH holds REG 2 with 412EH being the exponent.</div></div>
									<div class="assembly-row-combined model1"><div>0DFF-0E01</div><div><a href="#0D4BH" class="memory-link">CALL 0D4BH</a></div><div>Go subtract the double precision value in REG 2 from the double precision value in the temporary work area.</div></div>
									<div class="assembly-row-combined model1"><div>0E02</div><div>LD A,(DE)</div><div>Load register A with the value at the location of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0E03</div><div>SBC A,C</div><div>Subtract the value in register C from the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0E04</div><div>CCF</div><div>Complement the value of the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>0E05-0E06</div><div><a href="#0E12H" class="memory-link">JR C,0E12H</a></div><div>JUMP if the double precision value in REG 2 is greater than the double precision value in the temporary work area.</div></div>
									<div class="assembly-row-combined model1"><div>0E07-0E09</div><div>LD DE,414AH</div><div>Load register pair DE with the starting address of the double precision value in the temporary work area.<br><b>NOTE:</b> 414AH-4151H is used by floating pointer routines.</div></div>
									<div class="assembly-row-combined model1"><div>0E0A-0E0C</div><div>LD HL,4127H</div><div>Load register pair HL with the starting address of tht double precision value in REG 2.<br><b>NOTE:</b> 4127H-412EH holds REG 2 with 412EH being the exponent.</div></div>
									<div class="assembly-row-combined model1"><div>0E0D-0E0F</div><div><a href="#0D39H" class="memory-link">CALL 0D39H</a></div><div>Go add the double precision value in REG 2 to the double precision value in the temporary work area.</div></div>
									<div class="assembly-row-combined model1"><div>0E10</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>0E11-0E13</div><div><a href="#0412H" class="memory-link">JP C,0412H</a></div><div>If the CARRY FLAG is set, JUMP to 0412H.</div></div>
									<div class="assembly-row-combined model1"><div>0E14-0E16</div><div>LD A,(4123H)</div><div>Load register A with the value of the MSB of the total in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0E17</div><div>INC A</div><div>Increment the value of the MSB for the double precision result in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0E18</div><div>DEC A</div><div>Decrement the value of the MSB for the double precision result in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0E19</div><div>RRA</div><div>Rotate
 A right one bit, putting the old BIT 0 into the CARRY FLAG, and putting
 the old CARRY FLAG into BIT 7, which is the SIGN bit.</div></div>
									<div class="assembly-row-combined model1"><div>0E1A-0E1C</div><div><a href="#0D11H" class="memory-link">JP M,0D11H</a></div><div>If the NEGATIVE FLAG is set by the prior rotation, then JUMP to 0D11H.</div></div>
									<div class="assembly-row-combined model1"><div>0E1D</div><div>RLA</div><div>Put the sign bit in register A back into the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>0E1E-0E20</div><div>LD HL,411DH</div><div>Load register pair HL with the starting address of the double precision result in REG 1.<br><b>NOTE:</b> 411DH-4124H holds REG l.</div></div>
									<div class="assembly-row-combined model1"><div>0E21-0E22</div><div>LD C,07H</div><div>Load register C with the number of bytes to be shifted.</div></div>
									<div class="assembly-row-combined model1"><div>0E23-0E25</div><div><a href="#0D99H" class="memory-link">CALL 0D99H</a></div><div>Go shift the double precision result in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0E26-0E28</div><div>LD HL,414AH</div><div>Load register pair HL with the starting address of  the double precision value in the temporary work area.<br><b>NOTE:</b> 414AH-4151H is used by floating pointer routines.</div></div>
									<div class="assembly-row-combined model1"><div>0E29R-0E2B</div><div><a href="#0D97H" class="memory-link">CALL 0D97H</a></div><div>Go shift the double precision value in the temporary work area.</div></div>
									<div class="assembly-row-combined model1"><div>0E2C</div><div>LD A,B</div><div>Load register A with the value of the counter in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0E2D</div><div>OR A</div><div>Check to see if the value of the counter in register A is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0E2E-0E2F</div><div><a href="#0DF9H" class="memory-link">JR NZ,0DF9H</a></div><div>Loop until done if the value of the counter in register A isn't equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0E30-0E32</div><div>LD HL,4124H</div><div>Load register pair HL with the address of the exponent for the double precision result in REG 1 (which is 16676).</div></div>
									<div class="assembly-row-combined model1"><div>0E33</div><div>DEC (HL)</div><div>Decrement
 the value of the exponent for the double precision result in REG 1 at 
the location of the mem?ory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0E34-0E35</div><div><a href="#0DF9H" class="memory-link">JR NZ,0DF9H</a></div><div>Loop until done if overflow didn't occur.</div></div>
									<div class="assembly-row-combined model1"><div>0E36-0E38</div><div><a href="#07B2H" class="memory-link">JP 07B2H</a></div><div>Display an <span class="code">?OV ERROR</span> if the exponent for the result in REG 1 is too small.</div></div>
								</div>
							</div>

							<br><h2 id="0E39H">0E39-0E4C - DOUBLE PRECISION MATH ROUTINE - Move the double precision value in REG 1 to a temporary work area.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0E39</div><div>LD A,C</div><div>Load register A with the MSB of the double precision value in REG 2 in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0E3A-0E3C</div><div>LD (412DH),A</div><div>Save the MSB of the double precision value in REG 2 in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0E3D</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0E3E-0E40</div><div>LD DE,4150H</div><div>Load register pair DE with the starting address of the temporary work area.</div></div>
									<div class="assembly-row-combined model1"><div>0E41-0E43</div><div>LD BC,0700H</div><div>Load register B with the number of bytes to be moved (which is 1792) and zero register C.</div></div>
									<div class="assembly-row-combined model1"><div>0E44</div><div>LD A,(HL)</div><div>Load register A with the value at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0E45</div><div>LD (DE),A</div><div>Save the value in register A at the location of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0E46</div><div>LD (HL),C</div><div>Zero the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0E47</div><div>DEC DE</div><div>Decrement the value of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0E48</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0E49</div><div>DEC B</div><div>Decrement the value of the byte counter in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0E4A-0E4B</div><div><a href="#0E44H" class="memory-link">JR NZ,0E44H</a></div><div>Loop until the double precision value has been moved to the temporary work area.</div></div>
									<div class="assembly-row-combined model1"><div>0E4C</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0E4DH">0E4D-0E64 - LEVEL II BASIC MATH ROUTINE - Multiply the current double precision value by 10<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine multiplies the current DP value by 2 by adding 
it to itself.  First the current value is moved to a saved location, and
 then DP add routine adds the current value to that saved value.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0E4D-0E4F</div><div><a href="#09FCH" class="memory-link">CALL 09FCH</a></div><div>Go move the value in REG 1 to REG 2.</div></div>
									<div class="assembly-row-combined model1"><div>0E50</div><div>EX DE,HL</div><div>Load register pair HL with the value of the memory pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0E51</div><div>DEC HL</div><div>Decrement the value of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0E52</div><div>LD A,(HL)</div><div>Load register A with the value of the exponent in REG 1 at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0E53</div><div>OR A</div><div>Check to see if the value in REG 1 is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0E54</div><div>RET Z</div><div>Return if the value in REG 1 is equal to zero.</div></div>
									<div class="assembly-row-combined model1"><div>0E55-0E56</div><div>ADD 02H</div><div>Adjust the exponent for the following addition.</div></div>
									<div class="assembly-row-combined model1"><div>0E57-0E59</div><div><a href="#07B2H" class="memory-link">JP C,07B2H</a></div><div>Display an <span class="code">?OV ERROR</span> if the adjusted exponent in register A is too large.</div></div>
									<div class="assembly-row-combined model1"><div>0E5A</div><div>LD (HL),A</div><div>Save the adjusted exponent in register A in REG 1 at the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0E5B</div><div>PUSH HL</div><div>Save the value of the memory pointer in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0E5C-0E5E</div><div><a href="#0C77H" class="memory-link">CALL 0C77H</a></div><div>Call
 the DOUBLE PRECISION ADD function (which adds the double precision 
value in REG 2 to the value in REG 1.  Result is left in REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>0E5F</div><div>POP HL</div><div>Get the value of the memory pointer from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0E60</div><div>INC (HL)</div><div>Increment
 the value of the exponent for the double preci?sion value in REG 1 at 
the location of the memory pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0E61</div><div>RET NZ</div><div>Return if overflow didn't occur.</div></div>
									<div class="assembly-row-combined model1"><div>0E62-0E64</div><div><a href="#07B2H" class="memory-link">JP 07B2H</a></div><div>Display an <span class="code">?OV ERROR</span> if the exponent in REG 1 at the location of the memory pointer in register pair HL is too large.</div></div>
								</div>
							</div>

							<br><h2 id="0E65H">0E65-0F88 - ASCII TO DOUBLE PRECISION<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine converts an ASCII string (pointed to by HL) to a
 double-precision value and stores it in the ACC. The NTF is fixed 
accordingly. The string must be terminated with a <span class="code">,</span>
 or zero byte. Note that the AACC is destroyed in the process and that 
HL will point to the delimiter at the end of the string. The string 
formats must follow the same rules as in BASIC.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0E65-0E67</div><div><a href="#0778H" class="memory-link">CALL 0778H</a></div><div>Go zero the exponent in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0E68-0E6A</div><div><a href="#0AECH" class="memory-link">CALL 0AECH</a></div><div>Go set the current number type flag to double precision.</div></div>
								</div>
							</div>

							<br><h2 id="0E6CH">0E6C - ASCII to Binary Converter<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>A call to 0E6CH converts the ASCII string pointed to by HL to
 binary. If the value is less than 2** 16 and does not contain a decimal
 point or an E or D descriptor (exponent), the string will be converted 
to its integer equivalent. If the string contains a decimal point or an 
E, or D descriptor or if it exceeds 2** 16 it will be converted to 
single or double precision. The binary value will be left in REG 1 and 
the mode flag will be to the proper value.</p>
								<p>Note: If you wanted to do this conversion via a ROM call, 
first have the characters assembled in consecutive memory locations, 
with either a comma or a 00H at the end.  Load HL with the address of 
the first character.  Call 0E6CH.  If the output can be an integer, it 
will be in 4121H-4122H (with 40AFH being a 2).  If the output has to be 
single precision, it will be in 4121H-4124H (with 40AFH being a 4).  If 
the output has to be double precision, it will be in 411DH-4124H (with 
40AFH being an 8).</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0E6C<span class="origrom2">ASTOR</span></div><div>OR AFH</div><div>Zero register A (by issuing an OR against 1010 1111).<br>This routine is the same as E65H above, except that it fixes REG 1 and NTF to the smallest possible number type.</div></div>
									<div class="assembly-row-combined model1"><div>0E6D</div><div>EX DE,HL</div><div>Load register pair DE with the current input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0E6E-0E70</div><div>LD BC,00FFH</div><div>Load register pair BC with a zero and a negative one.</div></div>
									<div class="assembly-row-combined model1"><div>0E71</div><div>LD H,B</div><div>Load register H with zero.</div></div>
									<div class="assembly-row-combined model1"><div>0E72</div><div>LD L,B</div><div>Load register L with zero.</div></div>
									<div class="assembly-row-combined model1"><div>0E73-0E75</div><div><a href="#0A9AH" class="memory-link">CALL Z,0A9AH</a></div><div>Go set the current number type flag to integer if the routine was entered from OE6CH.</div></div>
									<div class="assembly-row-combined model1"><div>0E76</div><div>EX DE,HL</div><div>Load register pair HL with the input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0E77</div><div>LD A,(HL)</div><div>Load register A with the character at the location of the current input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0E78-0E79</div><div>CP 2DH</div><div>Check to see if the character at the location of the current input buffer pointer in register A is a minus sign(-).</div></div>
									<div class="assembly-row-combined model1"><div>0E7A</div><div>PUSH AF</div><div>Save the value in register pair AF on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0E7B-0E7D</div><div><a href="#0E83H" class="memory-link">JP Z,0E83H</a></div><div>JUMP if the character at the location of the current input buffer pointer in register A is a minus sign (-).</div></div>
									<div class="assembly-row-combined model1"><div>0E7E-0E7F</div><div>CP 2BH</div><div>Check to see if the character at the location of the current input buffer pointer in register A is a plus sign(+).</div></div>
									<div class="assembly-row-combined model1"><div>0E80-0E81</div><div><a href="#0E83H" class="memory-link">JR Z,0E83H</a></div><div>JUMP if the character at the location of the current input buffer pointer in register A is a plus sign ( +).</div></div>
									<div class="assembly-row-combined model1"><div>0E82</div><div>DEC HL</div><div>Decrement the value of the current input buffer pointer in register pair HL.</div></div>
									<p class="debug-note" id="0E83H">0E83H - Process a <span class="code">+</span> or <span class="code">-</span> at the location of the current input buffer.</p>
									<div class="assembly-row-combined model1"><div>0E83</div><div>RST 10H</div><div>Since
 we need to bump the current input buffer pointer in register pair HL 
until it points to the next character, call the EXAMINE NEXT SYMBOL 
routine at RST 10H (which Loads the next character from the string 
pointed to by the HL register set into the A-register and clears the 
CARRY FLAG if it is alphabetic, or sets it if is alphanumeric. Blanks 
and control codes 09 and OB are ignored causing the following character 
to be loaded and tested. The HL register will be incremented before 
loading any character therfore on the first call the HL register should 
contain the string address minus one. The string must be terminated by a
 byte of zeros).</div></div>
									<div class="assembly-row-combined model1"><div>0E84-0E86</div><div><a href="#0F29H" class="memory-link">JP C,0F29H</a></div><div>JUMP if the character at the location of the current input buffer pointer in register A is numeric.</div></div>
									<div class="assembly-row-combined model1"><div>0E87-0E88</div><div>CP 2EH</div><div>Check to see if the character at the location of the current input buffer pointer in register A is a decimal point (.).</div></div>
									<div class="assembly-row-combined model1"><div>0E89-0E8B</div><div><a href="#0EE4H" class="memory-link">JP Z,0EE4H</a></div><div>JUMP if the character at the location of the current input buffer pointer in register A is a decimal point (.).</div></div>
									<div class="assembly-row-combined model1"><div>0ESC-0E8D</div><div>CP 45H</div><div>Check to see if the character at the location of the current input buffer pointer in register A is an E.</div></div>
									<div class="assembly-row-combined model1"><div>0E8E-0E8F</div><div><a href="#0EA4H" class="memory-link">JR Z,0EA4H</a></div><div>JUMP if the character at the location of the current input buffer pointer in register A is an E.</div></div>
									<div class="assembly-row-combined model1"><div>0E90-0E91</div><div>CP 25H</div><div>Check to see if the character at the location of the current input buffer pointer in register A is a %.</div></div>
									<div class="assembly-row-combined model1"><div>0E92-0E94</div><div><a href="#0EEEH" class="memory-link">JP Z,0EEEH</a></div><div>JUMP if the character at the location of the current input buffer pointer in register A is a %.</div></div>
									<div class="assembly-row-combined model1"><div>0E95-0E96</div><div>CP 23H</div><div>Check to see if the character at the location of the current input buffer pointer in register A is a #.</div></div>
									<div class="assembly-row-combined model1"><div>0E97-0E99</div><div><a href="#0EF5H" class="memory-link">JP Z,0EF5H</a></div><div>JUMP if the character at the location of the current input buffer pointer in register A is a #.</div></div>
									<div class="assembly-row-combined model1"><div>0E9A-0E9B</div><div>CP 21H</div><div>Check to see if the character at the location of the current input buffer pointer in register A is an ! .</div></div>
									<div class="assembly-row-combined model1"><div>0E9C-0E9E</div><div><a href="#0EF6H" class="memory-link">JP Z,0EF6H</a></div><div>JUMP if the character at the location of the current input buffer pointer in register A is an ! .</div></div>
									<div class="assembly-row-combined model1"><div>0E9F-0EA0</div><div>CP 44H</div><div>Check to see if the character at the location of the current input buffer pointer in register A is a D.</div></div>
									<div class="assembly-row-combined model1"><div>0EA1-0EA2</div><div><a href="#0EC7H" class="memory-link">JR NZ,0EC7H</a></div><div>JUMP if the character at the location of the current input buffer pointer in register A isn't a D.</div></div>
									<div class="assembly-row-combined model1"><div>0EA3</div><div>OR A</div><div>Set the flags according to the value of the character at the location of the current input buffer pointer in register A.</div></div>
									<p class="debug-note" id="0EA4H">0EA4H - Inside the ASCII TO BINARY CONVERTER routine.  Process a <span class="code">E</span> at the location of the current input buffer.</p>
									<div class="assembly-row-combined model1"><div>0EA4-0EA6</div><div><a href="#0EFBH" class="memory-link">CALL 0EFBH</a></div><div>GOSUB
 to 0EFBH to convert the current value in REG 1 to either single 
precision (if Z is set) or double precision (if NZ is set).</div></div>
									<div class="assembly-row-combined model1"><div>0EA7</div><div>PUSH HL</div><div>Save the current input buffer pointer in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0EA8-0EAA</div><div>LD HL,0EBDH</div><div>Load register pair HL with the return address (which is 3773).</div></div>
									<div class="assembly-row-combined model1"><div>0EAB</div><div>EX (SP),HL</div><div>Exchange the return address in register pair HL with the value of the current input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0EAC</div><div>RST 10H</div><div>Since
 we need to bump the current input buffer pointer in register pair HL 
until it points to the next character, call the EXAMINE NEXT SYMBOL 
routine at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>0EAD</div><div>DEC D</div><div>Decrement the value in register D.</div></div>
									<div class="assembly-row-combined model1"><div>0EAE-0EAF</div><div>CP CEH</div><div>Check to see if the character at the location of the current input buffer pointer in register A is a minus sign token ( CEH).</div></div>
									<div class="assembly-row-combined model1"><div>0EB0</div><div>RET Z</div><div>Return if the character at the location of the current input buffer pointer in register A is a minus sign token (CEH).</div></div>
									<div class="assembly-row-combined model1"><div>0EB1-0EB2</div><div>CP 2DH</div><div>Check to see if the character at the location of the current input buffer pointer in register A is a minus sign(-).</div></div>
									<div class="assembly-row-combined model1"><div>0EB3</div><div>RET Z</div><div>Return if the character at the location of the current input buffer pointer in register A is a minus sign (-).</div></div>
									<div class="assembly-row-combined model1"><div>0EB4</div><div>INC D</div><div>Increment the value in register D.</div></div>
									<div class="assembly-row-combined model1"><div>0EB5-0EB6</div><div>CP CDH</div><div>Check to see if the character at the location of the current input buffer pointer in register A is a plus sign token (CDH.)</div></div>
									<div class="assembly-row-combined model1"><div>0EB7</div><div>RET Z</div><div>Return if the character at the location of the current input buffer pointer in register A is a plus sign token (CDH).</div></div>
									<div class="assembly-row-combined model1"><div>0EB8-0EB9</div><div>CP 2BH</div><div>Check to see if the character at the location of the current input buffer pointer in register A is a plus sign ( +).</div></div>
									<div class="assembly-row-combined model1"><div>0EBB</div><div>RET Z</div><div>Return if the character at the location of the current input buffer pointer in register A is a plus sign ( +).</div></div>
									<div class="assembly-row-combined model1"><div>0EBA</div><div>DEC HL</div><div>Decrement the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0EBC</div><div>POP AF</div><div>Get the value from the STACK and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1" id="0EBDH"><div>0EBD</div><div>RST 10H</div><div>Since
 we need to bump the current input buffer pointer in register pair HL 
until it points to the next character, call the EXAMINE NEXT SYMBOL 
routine at RST 10H.<br><span class="nobottomborder bold">NOTE:</span><ul><li>The
 RST 10H routine loads the next character from the string pointed to by 
the HL register into the A-register and clears the CARRY FLAG if it is 
alphabetic, or sets it if is alphanumeric.</li><li>Blanks and control codes 09H and 0BH are ignored causing the following character to be loaded and tested.</li><li>The
 HL register will be incremented before loading any character therfore 
on the first call the HL register should contain the string address 
minus one.</li><li>The string must be terminated by a byte of zeros.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>0EBE-0EC0</div><div><a href="#0F94H" class="memory-link">JP C,0F94H</a></div><div>JUMP if the character at the location of the input buffer pointer in register A is numeric.</div></div>
									<div class="assembly-row-combined model1"><div>0EC1</div><div>INC D</div><div>Increment the value in register D.</div></div>
									<div class="assembly-row-combined model1"><div>0EC2-0EC3</div><div><a href="#0EC7H" class="memory-link">JR NZ,0EC7H</a></div><div>JUMP if the exponent is positive.</div></div>
									<div class="assembly-row-combined model1"><div>0EC4</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>0EC5</div><div>SUB E</div><div>Subtract the value of the exponent in register E from register A.</div></div>
									<div class="assembly-row-combined model1"><div>0EC6</div><div>LD E,A</div><div>Load register E with the value of the exponent in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0EC7</div><div>PUSH HL</div><div>Save the current input buffer pointer in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0EC8</div><div>LD A,E</div><div>Load register A with the value of the exponent in register E.</div></div>
									<div class="assembly-row-combined model1"><div>0EC9</div><div>SUB B</div><div>Subtract the value in register B from the exponent in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0ECA-0ECC</div><div><a href="#0F0AH" class="memory-link">CALL P,0F0AH</a></div><div>Go multiply the current value by ten if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>0ECD-0ECF</div><div><a href="#0F18H" class="memory-link">CALL M,0F18H</a></div><div>Go divide the current value by ten if necessary.</div></div>
									<div class="assembly-row-combined model1"><div>0ED0-0ED1</div><div><a href="#0ECAH" class="memory-link">JR NZ,0ECAH</a></div><div>Loop until the value is adjusted correctly.</div></div>
									<div class="assembly-row-combined model1"><div>0ED2</div><div>POP HL</div><div>Get the value of the current input buffer pointer from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0ED3</div><div>POP AF</div><div>Get the value from the STACK and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>0ED4</div><div>PUSH HL</div><div>Save the value of the current input buffer pointer in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0ED5-0ED7</div><div><a href="#097BH" class="memory-link">CALL Z,097BH</a></div><div>GOSUB to 097BH to convert the negative value in REG 1 to its positive equivalent.</div></div>
									<div class="assembly-row-combined model1"><div>0ED8</div><div>POP HL</div><div>Get the value of the current input buffer pointer from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0ED9</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>0EDA</div><div>RET PE</div><div>If that test shows we have anything other than a SINGLE PRECISION number, return out of the subroutine.</div></div>
									<div class="assembly-row-combined model1"><div>0EDB</div><div>PUSH HL</div><div>Save the current value of the input buffer pointer in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0EDC-0EDE</div><div>LD HL,0890H</div><div>Load register pair HL with the return address of 2192.</div></div>
									<div class="assembly-row-combined model1"><div>0EDF</div><div>PUSH HL</div><div>Save the value of the return address in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0EE0-0EE2</div><div><a href="#0AA3H" class="memory-link">CALL 0AA3H</a></div><div>Go convert the current value in REG 1 to an integer if possible.</div></div>
									<div class="assembly-row-combined model1"><div>0EE3</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0EE4H">0EE4H - Inside the ASCII TO BINARY CONVERTER routine.  Process a <span class="code">.</span> at the location of the current input buffer.  JUMPed to from 0E89H.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0EE4</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>0EE5</div><div>INC C</div><div>Increment the value in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0EE6-0EE7</div><div><a href="#0EC7H" class="memory-link">JR NZ,0EC7H</a></div><div>If that test shows we have a number, jump to 0EC7H since there is no need to convert the current value.</div></div>
									<div class="assembly-row-combined model1"><div>0EE8-0EEA</div><div><a href="#0EFBH" class="memory-link">CALL C,0EFBH</a></div><div>If
 that test shows we have anything other than DOUBLE PRECISION, GOSUB to 
0EFBH to convert the current value in REG 1 to either single precision 
(if Z is set) or double precision (if NZ is set).</div></div>
									<div class="assembly-row-combined model1"><div>0EEB-0EED</div><div><a href="#0E83H" class="memory-link">JP 0E83H</a></div><div>JUMP to 0E83H.</div></div>
								</div>
							</div>

							<br><h2 id="0EEEH">0EEEH - Inside the ASCII TO BINARY CONVERTER routine.  Process a <span class="code">%</span> at the location of the current input buffer.  JUMPed to from 0E92H.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0EEE</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>0EEF-0EF1</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#1997H" class="memory-link">JP P,1997H</a></div><div>If that test shows anything butn an INTEGER, jump to the Level II BASIC error routine and display a SN ERROR message.</div></div>
									<div class="assembly-row-combined model1"><div>0EF2</div><div>INC HL</div><div>Increment the value of the current input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0EF3-0EF4</div><div><a href="#0EC7H" class="memory-link">JR 0EC7H</a></div><div>JUMP to 0EC7H.</div></div>
									<div class="assembly-row-combined model1"><div>0EF5</div><div>OR A</div><div>Set the flags according to the character at the location of the current input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0EF6-0EF8</div><div><a href="#0EFBH" class="memory-link">CALL 0EFBH</a></div><div>GOSUB
 to 0EFBH to convert the current value in REG 1 to either single 
precision (if Z is set) or double precision (if NZ is set).</div></div>
									<div class="assembly-row-combined model1"><div>0EF9-0EFA</div><div><a href="#0EF2H" class="memory-link">JR 0EF2H</a></div><div>JUMP to 0EF2H.</div></div>
								</div>
							</div>

							<br><h2 id="0EFBH">0EFBH - Inside the ASCII TO BINARY CONVERTER 
routine.  Convert the current value in REG 1 to either single precision 
or double precision based on the Z FLAG.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0EFB</div><div>PUSH HL</div><div>Save the value in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0EFC</div><div>PUSH DE</div><div>Save the value in register pair DE on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0EFD</div><div>PUSH BC</div><div>Save the value in register pair BC on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0EFE</div><div>PUSH AF</div><div>Save the value in register pair AF on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0EFF-0F01</div><div><a href="#0AB1H" class="memory-link">CALL Z,0AB1H</a></div><div>Call
 the CONVERT TO SINGLE PRECISION routine at 0AB1H (which converts the 
contents of REG 1 from integer or double precision into single 
precision).</div></div>
									<div class="assembly-row-combined model1"><div>0F02</div><div>POP AF</div><div>Get the value from the STACK and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>0F03-0F05</div><div><a href="#0ADBH" class="memory-link">CALL NZ,0ADBH</a></div><div>Call
 the CONVERT TO DOUBLE PRECISION routine at 0ADBH (where the contents of
 REG 1 are converted from integer or single precision to double 
precision).</div></div>
									<div class="assembly-row-combined model1"><div>0F06</div><div>POP BC</div><div>Get the value from the STACK and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>0F07</div><div>POP DE</div><div>Get the value from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0F08</div><div>POP HL</div><div>Get the value from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0F09</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0F0AH">0F0AH - Multiply the current value by 10 Part 1 - Jumps to Part 2 based on number type.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0F0A</div><div>RET Z</div><div>Return if the current value is an integer.</div></div>
									<div class="assembly-row-combined model1"><div>0F0B</div><div>PUSH AF</div><div>Save the value in register pair AF on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0F0C</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>0F0D</div><div>PUSH AF</div><div>Save the value in register pair AF on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0F0E-0F10</div><div><a href="#093EH" class="memory-link">CALL PO,093EH</a></div><div>If that test shows SINGLE PRECISION, go to 093EH to multiply the current value in REG 1 by ten.</div></div>
									<div class="assembly-row-combined model1"><div>0F11</div><div>POP AF</div><div>Get the value from the STACK and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>0F12-0F14</div><div><a href="#0E4DH" class="memory-link">CALL PE,0E4DH</a></div><div>If that test shows DOUBLE PRECISION, go to 0E4DH to multiply the current value in REG 1 by ten.</div></div>
									<div class="assembly-row-combined model1"><div>0F15</div><div>POP AF</div><div>Get the value from the STACK and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>0F16</div><div>DEC A</div><div>Decrement the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0F17</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0F18H">0F18H - Divide the current value by 10 Part 1 - Jumps to Part 2 based on number type.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0F18</div><div>PUSH DE</div><div>Save the value in register pair DE on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0F19</div><div>PUSH HL</div><div>Save the value in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0F1A</div><div>PUSH AF</div><div>Save the value in register pair AF on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0F1B</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>0F1C</div><div>PUSH AF</div><div>Save the value in register pair AF on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0F1D-0F1F</div><div><a href="#0897H" class="memory-link">CALL PO,0897H</a></div><div>If that test shows SINGLE PRECISION, go to 0897H to divide the current value in REG 1 by ten.</div></div>
									<div class="assembly-row-combined model1"><div>0F20</div><div>POP AF</div><div>Get the value from the STACK and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>0F21-0F23</div><div><a href="#0DDCH" class="memory-link">CALL PE,0DDCH</a></div><div>If that test shows DOUBLE PRECISION, go to 0DDCH to divide the current value in REG 1 by ten.</div></div>
									<div class="assembly-row-combined model1"><div>0F24</div><div>POP AF</div><div>Get the value from the STACK and put it in register pair AF.</div></div>
									<div class="assembly-row-combined model1"><div>0F25</div><div>POP HL</div><div>Get the value from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0F26</div><div>POP DE</div><div>Get the value from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0F27</div><div>INC A</div><div>Increment the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0F28</div><div>RET</div><div>Return.</div></div>
								</div>
							</div>

							<br><h2 id="0F29H">0F29H - Inside the ASCII TO BINARY CONVERTER 
routine.  Process a number at the location of the current input buffer. 
 JUMPed to from 0E84H.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0F29</div><div>PUSH DE</div><div>Save the value in register pair DE on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0F2A</div><div>LD A,B</div><div>Load register A with the value in register B.</div></div>
									<div class="assembly-row-combined model1"><div>0F2B</div><div>ADC A,C</div><div>Add the value in register C to the value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0F2C</div><div>LD B,A</div><div>Load register B with the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0F2D</div><div>PUSH BC</div><div>Save the value in register pair BC on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0F2E</div><div>PUSH HL</div><div>Save the value in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0F2F</div><div>LD A,(HL)</div><div>Load register A with the character at the location of the current input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0F30-0F31</div><div>SUB 30H</div><div>Convert the adjusted value in register A to it?s binary equivalent (which is subtracting 0011 0000)</div></div>
									<div class="assembly-row-combined model1"><div>0F32</div><div>PUSH AF</div><div>Save the adjusted value in register A on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0F33</div><div>RST 20H</div><div>We need to check the value of the current number type flag, so we call the TEST DATA MODE routine at RST 20H.<br><span class="nobottomborder bold">NOTE:</span>
  The RST 20H routine determines the type of the current value in REG 1 
and returns a combination of STATUS flags and unique numeric values in 
the A Register according to the data mode flag (40AFH).<br><br>The results are returned as follows:<table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">If the Variable Type is ...</td><td style="border: 1px solid black; padding: 8px;">and the Flags<br>are set ...</td><td style="border: 1px solid black; padding: 8px;">... then Register<br>A will be set ...</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Integer</td><td style="border: 1px solid black; padding: 8px;">NZ/C/M/E</td><td style="border: 1px solid black; padding: 8px;">-1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">String</td><td style="border: 1px solid black; padding: 8px;">Z/C/P/E</td><td style="border: 1px solid black; padding: 8px;">0</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Single Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/C/P/O</td><td style="border: 1px solid black; padding: 8px;">1</td></tr><tr><td style="border: 1px solid black; padding: 8px;">Double Precision</td><td style="border: 1px solid black; padding: 8px;">NZ/NC/P/E</td><td style="border: 1px solid black; padding: 8px;">5</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>0F34-0F36</div><div><a href="#0F5DH" class="memory-link">JP P,0F5DH</a></div><div>If that test shows we have anything but an INTEGER, jump to 0F5DH.</div></div>
									<div class="assembly-row-combined model1"><div>0F37-0F39</div><div>LD HL,(4121H)</div><div>Now that we know we have an integer, load register pair HL with the integer value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0F3A-0F3C</div><div>LD DE,0CCDH</div><div>Load register pair DE with 0CCDH.</div></div>
									<div class="assembly-row-combined model1"><div>0F3D</div><div>RST 18H</div><div>Now
 we need to check to see if the integer value in HL is greater than or 
equal to 0CCDH (in DE), so we call the COMPARE DE:HL routine, which 
numerically compares DE and HL. Will not work for signed integers 
(except positive ones). Uses the A-register only. The result of the 
comparison is returned in the status register as:  <table style="border-collapse: collapse; border: 1px solid black;"><tbody><tr style="background-color: #f0f0f0;"><td style="border: 1px solid black; padding: 8px;">Condition</td><td style="border: 1px solid black; padding: 8px;">Flag</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &lt; DE</td><td style="border: 1px solid black; padding: 8px;">CARRY SET</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL &gt; DE</td><td style="border: 1px solid black; padding: 8px;">NO CARRY</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL ‚â† DE</td><td style="border: 1px solid black; padding: 8px;">NZ</td></tr><tr><td style="border: 1px solid black; padding: 8px;">If HL = DE</td><td style="border: 1px solid black; padding: 8px;">Z</td></tr></tbody></table></div></div>
									<div class="assembly-row-combined model1"><div>0F3E-0F3F</div><div><a href="#0F59H" class="memory-link">JR NC,0F59H</a></div><div>JUMP to 0F59 if the integer value in register pair HL is greater than or equal to 0CCDH.</div></div>
									<div class="assembly-row-combined model1"><div>0F40</div><div>LD D,H</div><div>Load register D with the MSB of the integer value in register H.</div></div>
									<div class="assembly-row-combined model1"><div>0F41</div><div>LD E,L</div><div>Load register E with the LSB of the integer value in register L.</div></div>
									<div class="assembly-row-combined model1"><div>0F42</div><div>ADD HL,HL</div><div>Multiply the integer value in register pair HL by two.</div></div>
									<div class="assembly-row-combined model1"><div>0F43</div><div>ADD HL,HL</div><div>Multiply the integer value in register pair HL by two. Register pair HL now holds the original integer value times four.</div></div>
									<div class="assembly-row-combined model1"><div>0F44</div><div>ADD HL,DE</div><div>Add
 the original integer value in register pair DE to the integer value in 
register pair HL. Register pair HL now holds the original integer value 
times five.</div></div>
									<div class="assembly-row-combined model1"><div>0F45</div><div>ADD HL,HL</div><div>Multiply the integer value in register pair HL by two. Register pair HL now holds the origmal integer value times ten.</div></div>
									<div class="assembly-row-combined model1"><div>0F46</div><div>POP AF</div><div>Get the binary value for the next character from the STACK and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0F47</div><div>LD C,A</div><div>Load register C with the value of the character in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0F48</div><div>ADD HL,BC</div><div>Add the value of the character in register pair BC to the integer value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0F49,0F4A</div><div>LD A,H<br>OR A</div><div>The easiest way to check flags for a 2-byte register is to OR the bytes together.</div></div>
									<div class="assembly-row-combined model1"><div>0F4B-0F4D</div><div><a href="#0F57H" class="memory-link">JP M,0F57H</a></div><div>JUMP if the sign bit is set in the integer value in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0F4E-0F50</div><div>LD (4121H),HL</div><div>Save the integer value in register pair HL as the current integer value in REG 1.</div></div>
									<div class="assembly-row-combined model1" id="0F51H"><div>0F51</div><div>POP HL</div><div>Get the value from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0F52</div><div>POP BC</div><div>Get the value from the STACK and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>0F53</div><div>POP DE</div><div>Get the value from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0F54-0F56</div><div><a href="#0E83H" class="memory-link">JP 0E83H</a></div><div>JUMP to 0E83H.</div></div>
								</div>
							</div>

							<br><h2 id="0F57H">0F57H - Inside the ASCII TO BINARY CONVERTER routine.  At this point, the integer value in HL has the sign bit HIGH.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0F57</div><div>LD A,C</div><div>Load register A with the binary value of the character in register C.</div></div>
									<div class="assembly-row-combined model1"><div>0F58</div><div>PUSH AF</div><div>Save the value in register A on the STACK.</div></div>
									<div class="assembly-row-combined model1" id="0F59H"><div>0F59-0F5B</div><div><a href="#0ACCH" class="memory-link">CALL 0ACCH</a></div><div>GOSUB to 0ACCH to convert the current value in REG 1 to single precision.</div></div>
									<div class="assembly-row-combined model1"><div>0F5C</div><div>SCF</div><div>Set the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>0F5D-0F5E</div><div><a href="#0F77H" class="memory-link">JR NC,0F77H</a></div><div>JUMP if the current value in REG 1 is double precision.</div></div>
									<div class="assembly-row-combined model1"><div>0F5F-0F61</div><div>LD BC,9474H</div><div>Load register pair BC with the exponent and the MSB of a single precision constant.</div></div>
									<div class="assembly-row-combined model1"><div>0F62-0F64</div><div>LD DE,2400H</div><div>Load
 register pair DE with the NMSB and the LSB of a single precision 
constant. Register pairs BC and DE now hold a single precision constant 
equal to 1E6.</div></div>
									<div class="assembly-row-combined model1"><div>0F65-0F67</div><div><a href="#0A0CH" class="memory-link">CALL 0A0CH</a></div><div>GOSUB to the SINGLE PRECISION COMPARISON routine at 0A0CH.<br><br><span class="nobottomborder bold">NOTE:</span>  The routine at 0A0CH algebraically compares the single precision value in BC/DE to the single precision value REG 1.<br>The results are stored in A as follows:<ul><li>A=0 if REG 1 = BCDE</li><li>A=1 if REG 1&gt;BCDE; and </li><li>A=FFH if REG 1&lt;BCDE.</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>0F68-0F6A</div><div><a href="#0F74H" class="memory-link">JP P,0F74H</a></div><div>JUMP to 0F74H if the single precision value in REG 1 is greater than or equal to 1E6.</div></div>
									<div class="assembly-row-combined model1"><div>0F6B-0F6D</div><div><a href="#093EH" class="memory-link">CALL 093EH</a></div><div>Go multiply the single precision value in REG 1 by 10.</div></div>
									<div class="assembly-row-combined model1"><div>0F6E</div><div>POP AF</div><div>Get the binary value of the character from the STACK and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0F6F-0F71</div><div><a href="#0F89H" class="memory-link">CALL 0F89H</a></div><div>Go add the value in register A to the single precision value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0F72-0F33</div><div><a href="#0F51H" class="memory-link">JR 0F51H</a></div><div>JUMP to 0F51H.</div></div>
									<div class="assembly-row-combined model1"><div>0F74-0F76</div><div><a href="#0AE3H" class="memory-link">CALL 0AE3H</a></div><div>Go convert the single precision value in REG 1 to double precision.</div></div>
								</div>
							</div>

							<br><h2 id="0F77H">0F77H - Inside the ASCII TO BINARY CONVERTER routine.  At this point, the number in REG 1 is double precision.<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0F77-0F79</div><div><a href="#0E4DH" class="memory-link">CALL 0E4DH</a></div><div>Go multiply the double precision value in REG 1 by ten.</div></div>
									<div class="assembly-row-combined model1"><div>0F7A-0F7C</div><div><a href="#09FCH" class="memory-link">CALL 09FCH</a></div><div>Go move the double precision value in REG 1 to REG 2.</div></div>
									<div class="assembly-row-combined model1"><div>0F7D</div><div>POP AF</div><div>Get the binary value for the character from the STACK and put it in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0F7E-0F80</div><div><a href="#0964H" class="memory-link">CALL 0964H</a></div><div>Go convert the binary value in register A to single precision.</div></div>
									<div class="assembly-row-combined model1"><div>0F81-0F83</div><div><a href="#0AE3H" class="memory-link">CALL 0AE3H</a></div><div>Go convert the single precision value in REG 1 to double precision.</div></div>
									<div class="assembly-row-combined model1"><div>0F84-0F86</div><div><a href="#0C77H" class="memory-link">CALL 0C77H</a></div><div>Call
 the DOUBLE PRECISION ADD function (which adds the double precision 
value in REG 2 to the value in REG 1.  Result is left in REG 1).</div></div>
									<div class="assembly-row-combined model1"><div>0F87-0F88</div><div><a href="#0F51H" class="memory-link">JR 0F51H</a></div><div>JUMP to 0F51H.</div></div>
								</div>
							</div>

							<br><h2 id="0F89H">0F89-0F93 - SINGLE PRECISION MATH ROUTINE - Subroutine to add the value in register A to the single precision value in REG 1<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0F89-0F8B</div><div><a href="#09A4H" class="memory-link">CALL 09A4H</a></div><div>Call 09A4 which moves the SINGLE PRECISION value in REG 1 to the STACK (stored in LSB/MSB/Exponent order).</div></div>
									<div class="assembly-row-combined model1"><div>0F8C-0F8E</div><div><a href="#0964H" class="memory-link">CALL 0964H</a></div><div>Go convert the value in register Ato single precision and return with the result in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0F8F</div><div>POP BC</div><div>Get the exponent and the MSB for the single preci?sion value from the STACK and put it in register pair BC.</div></div>
									<div class="assembly-row-combined model1"><div>0F90</div><div>POP DE</div><div>Get the NMSB and the LSB of the single precision value from the STACK and put it in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0F91-0F93</div><div><a href="#0716H" class="memory-link">JP 0716H</a></div><div>JUMP
 to the SINGLE PRECISION ADD routine at 0716H (which adds the single 
precision value in (BC/DE) to the single precision value in REG 1. The 
sum is left in REG 1).</div></div>
								</div>
							</div>

							<br><h2 id="0F94H">0F94-0FA6 - LEVEL II BASIC MATH ROUTINE - Part
 of the ASCII TO BINARY CONVERSION routine.  JUMPs here if the character
 at the location of the input buffer pointer in register A is numeric<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0F94</div><div>LD A,E</div><div>Load register A with the value of the exponent in register E.</div></div>
									<div class="assembly-row-combined model1"><div>0F95-0F96</div><div>CP 0AH</div><div>We
 need to check to see if the value of the exponent in register A is 
greater than or equal to 10, by testing A - 0AH.  If A=0AH it sets the 
ZERO FLAG.  If A&lt;0AH then the CARRY FLAG will be set and if A&gt;=0AH
 then the NO CARRY FLAG will be set.</div></div>
									<div class="assembly-row-combined model1"><div>0F97-0F98</div><div><a href="#0FA2H" class="memory-link">JR NC,0FA2H</a></div><div>JUMP if the value of the exponent in register A is greater than or equal to 10.</div></div>
									<div class="assembly-row-combined model1"><div>0F99</div><div>RLCA</div><div>Multiply the value in register A by two.</div></div>
									<div class="assembly-row-combined model1"><div>0F9A</div><div>RLCA</div><div>Multiply the value in register A by two. Register A now holds the original value of the exponent times four.</div></div>
									<div class="assembly-row-combined model1"><div>0F9B</div><div>ADD A,E</div><div>Add the original value of the exponent in register E to the adjusted value of the exponent in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0F9C</div><div>RLCA</div><div>Multiply the value in register A by two. Register A now holds the original value of the exponent times ten.</div></div>
									<div class="assembly-row-combined model1"><div>0F9D</div><div>ADD A,(HL)</div><div>Add
 the value of the current character at the memory location of the input 
buffer pointer in register pair HL to the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0F9E-0F9F</div><div>SUB 30H</div><div>Convert the adjusted value in register A to its binary equivalent (which is subtracting 0011 0000).</div></div>
									<div class="assembly-row-combined model1"><div>0FA0</div><div>LD E,A</div><div>Load register E with the adjusted value in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0FA2-0FA3</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-4.htm#321EH" class="memory-link">JP M,321EH</a></div><div>Load register E with the maximum exponent.</div></div>
									<div class="assembly-row-combined model1"><div>0FA4-0FA6</div><div><a href="#0EBDH" class="memory-link">JP 0EBDH</a></div><div>JUMP to 0EBDH.</div></div>
								</div>
							</div>

							<br><h2 id="0FA7H">0FA7-0FAE - DISPLAY MESSAGE ROUTINE<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0FA7</div><div>PUSH HL</div><div>Save the value in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0FA8-0FAA</div><div>LD HL,1924H</div><div>Load register pair HL with the starting address of the IN message (which is 1924H).</div></div>
									<div class="assembly-row-combined model1"><div>0FAB-0FAD</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#28A7H" class="memory-link">CALL 28A7H</a></div><div>Call the WRITE MESSAGE routine at 28A7H..<br><span class="bold">NOTE:</span><br><ul><li>The routine at 28A7 displays the message pointed to by HL on current system output device (usually video).</li><li>The string to be displayed must be terminated by a byte of machine zeros or a carriage return code 0D.</li><li>If terminated with a carriage return, control is returned to the caller after taking the DOS exit at 41D0H (JP 5B99H).</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>0FAE</div><div>POP HL</div><div>Get the value from the STACK and put it in register pair HL.</div></div>
								</div>
							</div>

							<br><h2 id="0FAFH">0FAF-0FBC - CONVERT BINARY TO ASCII AND 
DISPLAY RESULT.  This is also the continuation of the DISPLAY MESSAGE 
routine above because it is showing an error "IN xxxx" where xxxx would 
be the ASCII of xxxx (the line number).<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine converts the value in the HL register pair 
(which is assumed to be an integer) to ASCII and display it at the 
current cursor position on the video screen.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0FAF-0FB1</div><div><a href="#0A9AH" class="memory-link">CALL 0A9AH</a></div><div>Go save the value in register pair HL as the current value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0FB2</div><div>XOR A</div><div>Zero register A.</div></div>
									<div class="assembly-row-combined model1"><div>0FB3-0FB5</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#1034H" class="memory-link">CALL 1034H</a></div><div>Go initialize the input buffer for the ASCII conversion.</div></div>
									<div class="assembly-row-combined model1"><div>0FB6</div><div>OR (HL)</div><div>Set the flags.</div></div>
									<div class="assembly-row-combined model1"><div>0FB7-0FB9</div><div><a href="#0FD9H" class="memory-link">CALL 0FD9H</a></div><div>Go convert the integer value in REG 1 to an ASCII string. Return with register pair HL pointing to the result.</div></div>
									<div class="assembly-row-combined model1"><div>0FBA-0FBC</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-3.htm#28A6H" class="memory-link">JP 28A6H</a></div><div>Go display the message pointed to by register pair HL.</div></div>
								</div>
							</div>

							<br><h2 id="0FBDH">0FBDH - BINARY TO ASCII CONVERSION ROUTINE - "CSAASC"<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>Conversion routine. Converts the value from REG 1 to an ASCII
 string delimited with a zero byte. The number type can be any of 
Integer, single or double-precision. After execution HL will be pointing
 to the start of the string. REG 1 and AACC are destroyed by the 
process.</p>
								<p>To use a ROM call to convert a number to a string of digits, 
and to display the latter on the video screen starting at the current 
cursor position, store the number in 4121H-4122H (if it's an integer), 
or in 4121H-4124H (if it's single precision), or in 411DH-4124H (if it's
 double precision).  Then store the variable type (2, 4, or 8, 
respectively) in 40AFH.  Call 0FBDH and then call the WRITE MESSAGE 
routine at 28A7H.
								</p><p>NOTE 1: The routine at 0FBDH is the conversion routine 
described in Section 3.3 (a). The subroutine at 28A7H is a general 
program for displaying a string of characters and updating the cursor 
position. The string to be displayed must be terminated by a zero byte, 
and the HL register pair must contain the address of the first character
 of the string before 28A7H is called. (The routine at 0FBDH effects 
this setup automatically.)</p>
								<p>NOTE 2: Many of the ROM routines described in this book 
require a numeric input (or inputs). For most of these, the instructions
 given for calling them have not included the storage of the variable 
type flag in 40AFH. The reason is that, wherever possible, the variable 
type flag storage has been finessed by the choice of the subroutine 
entry point. In the routine of this section, that has not been possible,
 nor was it possible for the INT, the FIX, the Number to Numeric String,
 the SGN, or the ABS routines. Storing a 2, 4, or 8 in 40AFH takes only 5
 bytes of machine code, but there are subroutines in the Level II ROM 
that can reduce the required code to 3 bytes. CALL 0A9DH will store a 2 
in 40AFH. CALL 0AEFH will store a 4 in 40AFH. And, finally, CALL 0AECH 
will store an 8 in 40AFH; this last subroutine, however, destroys the 
contents of the BC register pair. DISK SYSTEM CAUTION: The subroutine at
 28A7H has two exits to DISK BASIC, with RAM transfer points at 41C1H 
and 41D0H. To use this routine safely, either be certain that DISK BASIC
 is in place or have your assembly language program fill locations 41C1H
 and 41D0H with RET's (C9H), before calling the routine.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0FBD<br>"NEDIT"</div><div>XOR A</div><div>Zero register A.</div></div>
								</div>
							</div>

							<br><h2 id="0FBEH">0FBE-0FC0 - FLOATING to ASCII Conversion Routine<button class="clipboard-copy-button" title="Copy link to this section">üìã</button></h2>
							<div class="card-item">
								<p>This routine converts a single or double precision number in 
REG 1 to its ASCII equivalent.  The ASCII value is stored at the buffer 
pointed to by the HL register pair. As the value is converted from 
binary to ASCII, it is formatted as it would be if a PRINT USING 
statement had been invoked. The format modes that can be specified are 
selected by loading the following values into the A, B, and C registers 
as follows:
								</p><p>A=0 means do not edit; this is a binary to ASCII conversion</p>
								<p>A=X means edit as follows:  Bit 7=1 means edit the value, Bit
 6=Print commas every third digit, Bit 5=Include leading asterisks, Bit 
4=Print a leading $, Bit 3=Sign Follows Value, and Bit 1=Exponential 
Notation</p>
								<p>B = The number of digits to the left of the decimal point.</p>
								<p>C = The number of digits after the decimal point.</p>
								<p>Note: If you wanted to convert any integer/single/double into
 its character string, store the variable in 4121H-4122H for integer, 
4121H-4124H for single, or in 411DH-4124H for double.  Then load 40AFH 
with a 2, 4, or 8 depending on whether that variable was integer, 
single, or double.  Then call 0FBDH.  Upon return, the character string 
is stored in 4130H and on, ending with a 00H.</p>
								<div class="assembly-table">
									<div class="assembly-row-combined model1"><div>0FBE-0FC0</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#1034H" class="memory-link">CALL 1034H</a></div><div>Initialize
 the input buffer for the ASCII conversion by calling 1034H (which puts 
the EDIT flag into A, loads HL with the starting address of the input 
buffer, and inserts a space).</div></div>
									<div class="assembly-row-combined model1"><div>0FC1-0FC2</div><div>AND 08H</div><div>Mask
 A against 08H (Binary: 0000 1000) to help check the value of the edit 
flag in register A to see if the sign is to be included.</div></div>
									<div class="assembly-row-combined model1"><div>0FC3-0FC4</div><div><a href="#0FC7H" class="memory-link">JR Z,0FC7H</a></div><div>Skip the next instruction (i.e., JUMP to 0FC7H) if the sign isn't to be included in the ASCII string.</div></div>
									<div class="assembly-row-combined model1"><div>0FC5-0FC6</div><div>LD (HL),2BH</div><div>Save a <span class="code">+</span> at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1" id="0FC7H"><div>0FC7</div><div>EX DE,HL</div><div>Load register pair DE with the value of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0FC8-0FCA</div><div><a href="#0994H" class="memory-link">CALL 0994H</a></div><div>Go determine the value of the sign for the current value in REG 1.</div></div>
									<div class="assembly-row-combined model1"><div>0FCB</div><div>EX DE,HL</div><div>Load register pair HL with the input buffer pointer in register pair DE.</div></div>
									<div class="assembly-row-combined model1"><div>0FCC-0FCE</div><div><a href="#0FD9H" class="memory-link">JP P,0FD9H</a></div><div>JUMP down to 0FD9H if the current value in REG 1 is positive.</div></div>
									<div class="assembly-row-combined model1"><div>0FCF-0FD0</div><div>LD (HL),2DH</div><div>Save a <span class="code">-</span> at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0FD1</div><div>PUSH BC</div><div>Save the value in register pair BC on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0FD2</div><div>PUSH HL</div><div>Save the value in register pair HL on the STACK.</div></div>
									<div class="assembly-row-combined model1"><div>0FD3-0FD5</div><div><a href="#097BH" class="memory-link">CALL 097BH</a></div><div>GOSUB to 097BH to convert the negative value in REG 1 to its positive equivalent.</div></div>
									<div class="assembly-row-combined model1"><div>0FD6</div><div>POP HL</div><div>Get the value from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0FD7</div><div>POP BC</div><div>Get the value from the STACK and put it in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0FD8</div><div>OR H</div><div>Set the flags.</div></div>
									<p class="debug-note">0FD9H is a routine which will convert the
 integer value in REG 1 (i.e., 4124H) to an ASCII string.   Returns with
 register pair HL pointing to the result.</p>
									<div class="assembly-row-combined model1" id="0FD9H"><div>0FD9</div><div>INC HL</div><div>Increment the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0FDA-0FDB</div><div>LD (HL),30H</div><div>Save a <span class="code">0</span> at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0FDC-0FDE</div><div>LD A,(40D8H)</div><div>Load register A with the value of the edit flag (stored at 40D8H).<br><b>NOTE:</b> 40D8H-40D9H holds the temporary storage location.</div></div>
									<div class="assembly-row-combined model1"><div>0FDF</div><div>LD D,A</div><div>Load register D with the value of the edit flag in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0FE0</div><div>RLA</div><div>Move the edit on/off bit in register A into the CARRY FLAG.</div></div>
									<div class="assembly-row-combined model1"><div>0FE1-0FE3</div><div>LD A,(40AFH)</div><div>Load register A with the value of the current number type flag.<br><b>Note:</b> 40AFH holds the current number's type flag as follows:<ul><li>2: Integer</li><li>3: String</li><li>4: Single precision</li><li>8: Double precision</li></ul></div></div>
									<div class="assembly-row-combined model1"><div>0FE4-0FE6</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#109AH" class="memory-link">JP C,109AH</a></div><div>JUMP to 109AH if value is to be edited.</div></div>
									<div class="assembly-row-combined model1"><div>0FE7-0FE9</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#1092H" class="memory-link">JP Z,1092H</a></div><div>JUMP to 1092H if no edit.</div></div>
									<div class="assembly-row-combined model1"><div>0FEA-0FEB</div><div>CP 04H</div><div>Check
 to see if the current value in REG 1 is single or double precision by 
testing A - 04H.  If A=04H it sets the ZERO FLAG.  If A&lt;04H then the 
CARRY FLAG will be set and if A&gt;=04H then the NO CARRY FLAG will be 
set.</div></div>
									<div class="assembly-row-combined model1"><div>0FEC-0FEE</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#103DH" class="memory-link">JP NC,103DH</a></div><div>JUMP if the current value in REG 1 is single or double precision.</div></div>
									<div class="assembly-row-combined model1"><div>0FEF-0FF1</div><div>LD BC,0000H</div><div>Load register pair BC with zero.</div></div>
									<div class="assembly-row-combined model1"><div>0FF2-0FF4</div><div><a href="https://www.trs-80.com/sub-disassem-rom-m3-part-2.htm#132FH" class="memory-link">CALL 132FH</a></div><div>Call
 the INTEGER TO ASCII routine at 1232F (which converts the integer in 
REG 1 to ASCII and stores the ASCII string in the buffer pointed to in 
HL).</div></div>
									<div class="assembly-row-combined model1"><div>0FF5-0FF7</div><div>LD HL,4130H</div><div>Load register pair HL with the starting address of the input buffer, which is at 16688.<br><b>NOTE:</b> 4130H-4149H holds Internal print buffer.</div></div>
									<div class="assembly-row-combined model1"><div>0FF8</div><div>LD B,(HL)</div><div>Load register B with the character at the location of the input buffer pointer in register pair HL.</div></div>
									<div class="assembly-row-combined model1"><div>0FF9-0FFA</div><div>LD C,20H</div><div>Load register C with a space character.</div></div>
									<div class="assembly-row-combined model1"><div>0FFB-0FFD</div><div>LD A,(40D8H)</div><div>Load register A with the value of the edit flag (which is stored in 40D8H).<br><b>NOTE:</b> 40D8H-40D9H holds the temporary storage location.</div></div>
									<div class="assembly-row-combined model1"><div>0FFE</div><div>LD E,A</div><div>Load register E with the value of the edit flag in register A.</div></div>
									<div class="assembly-row-combined model1"><div>0FFF-1000</div><div>AND 20H</div><div>Check the value of the edit flag in register A (by AND againt 0010 0000) to see if leading * are to be printed.</div></div>
								</div>
							</div>
						</div>
					</div>
				</div>
			</main>
		</div>
	</div>
	<!-- Fancybox JavaScript -->
	<script src="Model%20III%20ROM%20Explained%20-%20Part%201_files/fancybox.umd.js"></script>
	<!-- Initialize Fancybox -->
	<script>
		Fancybox.bind("[data-fancybox]", {
			Toolbar: {
				display: {
					left: ["infobar"],
					middle: [],
					right: ["slideshow", "thumbs", "close"],
				},
			},
			Thumbs: {
				autoStart: false,
			},
		});
	</script>
	<!-- Last Modified Date -->
	<script>
		document.write("<p style='text-align:right; padding: 10px 20px; font-style: italic; font-size: 0.85em; color: #666;'>Last edited: " + document.lastModified + "</p>");
	</script><p style="text-align:right; padding: 10px 20px; font-style: italic; font-size: 0.85em; color: #666;">Last edited: 02/06/2026 21:26:12</p>

<div id="mobile-overlay" class="mobile-menu-overlay"></div></body></html>